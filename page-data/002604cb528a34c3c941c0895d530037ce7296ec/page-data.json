{"componentChunkName":"component---src-templates-blog-post-js","path":"/002604cb528a34c3c941c0895d530037ce7296ec","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"002604cb528a34c3c941c0895d530037ce7296ec","text":"# 프로그래머스 모의고사 Javascript\n\n- Title : 프로그래머스 모의고사 Javascript\n- Date : 2019-11-28\n- Category: 알고리즘 풀이\n\n# 문제 설명\n\n수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.\n\n1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...  \n2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...  \n3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...\n\n1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.\n\n# 제한 조건\n\n- 시험은 최대 10,000 문제로 구성되어있습니다.\n- 문제의 정답은 1, 2, 3, 4, 5중 하나입니다.\n- 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.\n\n# 풀이\n\n```javascript\nfunction solution(answers) {\n  const person_ans = [\n    [1, 2, 3, 4, 5],\n    [2, 1, 2, 3, 2, 4, 2, 5],\n    [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]\n  ];\n\n  const scores = Array(3).fill(0);\n\n  for (let i = 0; i < answers.length; i++) {\n    if (person_ans[0][i % 5] === answers[i]) scores[0]++;\n    if (person_ans[1][i % 8] === answers[i]) scores[1]++;\n    if (person_ans[2][i % 10] === answers[i]) scores[2]++;\n  }\n\n  let max = Math.max(...scores);\n\n  let answer = [];\n\n  scores.forEach((element, index) => {\n    if (max == element) answer.push(index + 1);\n  });\n\n  return answer;\n}\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"a232821a5f7761c1362d349bea69e0660876cc43","text":"# 프로그래머스 2016년 Javascript\n\n- Title : 프로그래머스 2016년 Javascript\n- Date : 2019-11-29\n- Category: 알고리즘 풀이\n\n# 문제 설명\n\n2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT 입니다.\n\n를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 TUE를 반환하세요.\n\n# 제한 조건\n\n- 2016년은 윤년입니다.\n- 2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)\n\n# 풀이\n\n```javascript\nfunction solution(a, b) {\n  const month = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const day = [\"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\"];\n\n  let answer = b - 1;\n  for (let i = 1; i < a; i++) answer += month[i];\n\n  return day[answer % 7];\n}\n```\n\n쉬운 문제여서 금방 풀었지만, 뭔가 자바스크립트스럽지않아서 탐탁지않았다.  \n그래서 자바스크립트의 **reduce** 와 **slice** 메서드를 이용해서 다시 풀어보았다.\n\n```javascript\nfunction solution(a, b) {\n  const month = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const day = [\"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\"];\n\n  let answer = b - 1;\n  if (a > 1) {\n    answer += month.slice(1, a).reduce((accumlator, currentValue) => {\n      return accumlator + currentValue;\n    });\n  }\n\n  return day[answer % 7];\n}\n```\n\n# Array.prototype.reduce()\n\nreduce() 메서드는 배열의 각 요소에 reducer 함수를 실행하여 계산의 누적 결과값을 반환한다.\n\n```javascript\narr.reduce((accumulator, currentValue[,currentIndex, array][,initialValue]) => {\n //\n return //\n});\n```\n\n리듀서 함수 인수\n\n- accumulator : 콜백(리듀서함수)의 반환값 누적\n- currentValue : 처리할 현재 요소\n- 옵션 currentIndex : 처리할 현재 요소의 인덱스로 initialValue가 있으면 0, 아니면 1부터 시작\n- 옵션 array : reduce()를 호출한 배열\n\n- initialValue : 리듀서 함수 최초 호출에서 첫번째 인수로 제공할 값, 제공안하면 배열의 첫번째 요소를 사용한다. 만약 빈 배열에서 초기값 없이 reduce() 호출하면 에러난다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"75b2859bd64143393ac340b0b9c506a3ac7bbcba","text":"# 프로그래머스 조이스틱 Javascript\n\n- Title : 프로그래머스 조이스틱 Javascript\n- Date : 2019-11-28\n- Category: 알고리즘 풀이\n\n# 문제 설명\n\n조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.  \nex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA\n\n조이스틱을 각 방향으로 움직이면 아래와 같습니다.  \n▲ - 다음 알파벳  \n▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)  \n◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)  \n▶ - 커서를 오른쪽으로 이동\n\n예를 들어 아래의 방법으로 JAZ를 만들 수 있습니다.\n\n- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.\n- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.\n- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.\n\n따라서 11번 이동시켜 \"JAZ\"를 만들 수 있고, 이때가 최소 이동입니다.\n\n만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.\n\n# 제한 사항\n\n- name은 알파벳 대문자로만 이루어져 있습니다.\n- name의 길이는 1 이상 20 이하입니다.\n\n# 풀이\n\n```javascript\nfunction solution(name) {\n  var arrName = Array(name.length).fill(\"A\"); // 초기값 'A...'로 셋팅해서 name과 같을 때까지 반복 돌림\n  var index = 0; // 조작할 인덱스\n  var answer = 0; // 조작 횟수\n  while (arrName.join(\"\") !== name) {\n    // 현재 인덱스의 알파벳 변경\n    arrName[index] = name[index];\n    // 알파벳 조작 횟수\n    answer += alpha(name[index]);\n    // 다음에 조작할 인덱스 찾기\n    let obj = findPos(index, name, arrName);\n    if (obj !== null) {\n      answer += obj.diff;\n      index = obj.index;\n    }\n  }\n  return answer;\n}\n\nfunction findPos(index, name, arrName) {\n  var nextRightIndex = (index + 1) % name.length;\n  var nextLeftIndex = (index - 1 + name.length) % name.length;\n  var moveSize = 1;\n\n  // 최소값을 찾는 거니깐 or로 해서 동시 탐색\n  // 'A'가 아니면서 이미 변경처리한 알파벳이 아닌 인덱스 찾기\n  while (nextRightIndex != index || nextLeftIndex != index) {\n    if (\n      name[nextRightIndex] !== \"A\" &&\n      arrName[nextRightIndex] !== name[nextRightIndex]\n    ) {\n      return {\n        index: nextRightIndex,\n        diff: moveSize\n      };\n    }\n    if (\n      name[nextLeftIndex] !== \"A\" &&\n      arrName[nextLeftIndex] !== name[nextLeftIndex]\n    ) {\n      return {\n        index: nextLeftIndex,\n        diff: moveSize\n      };\n    }\n    nextRightIndex = ++nextRightIndex % name.length;\n    nextLeftIndex = (--nextLeftIndex + name.length) % name.length;\n    moveSize++;\n  }\n  return null;\n}\n\nfunction alpha(n) {\n  return Math.min(\n    n.charCodeAt(0) - \"A\".charCodeAt(0),\n    \"Z\".charCodeAt(0) - n.charCodeAt(0) + 1\n  );\n}\n```\n"}}}},"pageContext":{"id":"002604cb528a34c3c941c0895d530037ce7296ec","previousPostId":"a232821a5f7761c1362d349bea69e0660876cc43","nextPostId":"75b2859bd64143393ac340b0b9c506a3ac7bbcba"}},"staticQueryHashes":["2685952063","2841359383"]}