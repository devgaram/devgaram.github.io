{"componentChunkName":"component---src-templates-blog-post-js","path":"/d91ddb038b5151998966588eea19cf150c69cd32","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d91ddb038b5151998966588eea19cf150c69cd32","text":"# 함수 컴포넌트에서 ref를 사용하려면?\n\n- Title : 함수 컴포넌트에서 ref를 사용하려면?\n- Date : 2020-09-02\n- Category: React\n\n# Key Point 💥\n\n부모 컴포넌트에서 `useRef` 훅으로 생성한 ref를 자식 컴포넌트에 전달하고 싶다면? **forwardRef**를 사용하자!\n함수 컴포넌트에는 인스턴스가 없기 때문에 함수 컴포넌트에 ref 어트리뷰트를 사용할 수 없다.\n\n함수 컴포넌트에 ref를 사용할 수 있게 하려면!\n\n- [forwardRef](https://ko.reactjs.org/docs/forwarding-refs.html) 또는 forwardRef + [useImperativeHandle](https://ko.reactjs.org/docs/hooks-reference.html#useimperativehandle) 를 사용\n- 클래스 컴포넌트로 변경\n\n단, DOM 엘리먼트나 클래스 컴포넌트의 인스턴스에 접근하기 위해 `ref` ****어트리뷰트를 함수 컴포넌트에서 사용할 수 있다.\n\n# 삽질기 ⛏️\n\n현재의 Copy 컴포넌트에서 Overlay의 target 속성이 Copy 컴포넌트 내부에서 useRef로 생성한 ref 값을 전달한다. 내가 구현하고 싶었던 건 부모 컴포넌트에서 ref를 받아서 부모 컴포넌트의 특정 DOM 위에 overlay를 보여주는 거다. 부모 컴포넌트에서 useRef로 만든 값을 props로 전달했지만 Copy 자체가 동작하지 않았다. 휴 계속 삽질을 했지만 답은 공식 문서에 있었다. 문서를 열심히 읽자!! 😆\n\n수정 전 Copy.jsx\n\n```jsx\nimport React, { useState, useEffect, useRef } from 'react';\nimport { CopyToClipboard } from 'react-copy-to-clipboard';\nimport { Overlay, Tooltip } from 'react-bootstrap';\n\nconst Copy = ({ children, text, placement, copiedMsg }) => {\n  const [isShowCopied, setIsShowCopied] = useState(false);\n  const target = useRef(null);\n\n  useEffect(() => {\n    if (!isShowCopied) return;\n\n    setTimeout(() => {\n      setIsShowCopied(false);\n    }, 2000);\n  }, [isShowCopied]);\n\n  return (\n    <>\n      <CopyToClipboard\n        text={text}\n        onCopy={() => {\n          setIsShowCopied(true);\n        }}\n      >\n        {React.cloneElement(children, { ref: target })}\n      </CopyToClipboard>\n      <Overlay target={target.current} show={isShowCopied} placement={placement}>\n        <Tooltip>{copiedMsg}</Tooltip>\n      </Overlay>\n    </>\n  );\n};\n\nexport default Copy;\n```\n\n수정 후 Copy.jsx\n\n```jsx\nimport React, { useState, useEffect, useRef, forwardRef } from 'react';\nimport { CopyToClipboard } from 'react-copy-to-clipboard';\nimport { Overlay, Tooltip } from 'react-bootstrap';\n\nconst Copy = forwardRef(({ children, text, placement, copiedMsg }, ref) => {\n  const [isShowCopied, setIsShowCopied] = useState(false);\n  const target = useRef(null);\n\n  useEffect(() => {\n    if (!isShowCopied) return;\n\n    setTimeout(() => {\n      setIsShowCopied(false);\n    }, 2000);\n  }, [isShowCopied]);\n\n  return (\n    <>\n      <CopyToClipboard\n        text={text}\n        onCopy={() => {\n          setIsShowCopied(true);\n        }}\n      >\n        {React.cloneElement(children, { ref: target })}\n      </CopyToClipboard>\n      <Overlay target={(ref && ref.current) || target.current} show={isShowCopied} placement={placement}>\n        <Tooltip>{copiedMsg}</Tooltip>\n      </Overlay>\n    </>\n  );\n});\n\nexport default Copy;\n```"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e1d231567cddc9de8b345729cc86853dff9718ce","text":"# DOM API\n\n- Title : DOM API\n- Date : 2020-09-05\n- Category : 프론트\n\n# DOM(Document Object Model)\n\n- 문서 객체 모델은 HTML 또는 XML과 상호작용을 위한 일종의 API\n- 브라우저에 로드 되며 DOM tree 형태로 문서를 만듬 (노드로 트리를 구성, element, text string, coment)\n- 스크립트 또는 프로그래밍 언어를 웹 페이지에서 사용할 수 있게 연결 시킴\n- 자바 스크립트를 이용해 DOM을 수정할 수 있음\n- 웹 페이지를 객체 지향적으로 표현한 것\n- Dom Tree: 트리 구조 형태의 노드들이 문서를 만듬\n\n    ![DOM%20API%2045dcb9dfa98b4ca7969268d9de5e8451/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Front/images/2020-09-05-img/Untitled.png)\n\n    ![DOM%20API%2045dcb9dfa98b4ca7969268d9de5e8451/Untitled%201.png](https://raw.githubusercontent.com/devgaram/TIL/master/Front/images/2020-09-05-img/Untitled1.png)\n\n    예시)\n\n    HTMLElement ← HTMLMediaElement ← HMLTAudioElement ← <audio>\n\n    HTMLElement ← HTMLMediaElement ← HMLTVideoElement ← <video>\n\n# DOM API\n\n[Web API](https://developer.mozilla.org/ko/docs/Web/API)\n\n- DOM의 각 노드와 상호작용을 위한 인터페이스\n- 노드 생성, 이동, 수정\n- 노드에 이벤트 리스너 추가\n- 폼 데이터 조작\n- `<canvas>`, `2D 이미지`와 상호작용\n- media 관리 `<audio>` `<video>`\n- 웹페이지 컨텐츠 `드래그 앤 드랍`\n- 브라우저의 세션 기록에 접근 `History API`\n- `Web Components`, `Web Storage`, `Web Workers`, `WebSocket`, and `Server-sent events`."}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"966ea5b2cd8e89dbab1723a18bec85539cbfa10a","text":"# SPA, SSR vs CSR\n- Title : SSR vs CSR vs SPA\n- Date : 2020-08-22\n- Category : 프론트\n# SPA(Single Page Application)\n\n- 앱에 필요한 모든 정적 리소스를 **최초 한번만** 받아 오고 이후에는 동적으로 DOM을 구성하여 렌더링 되는 화면만 바꾼다.\n- 페이지가 한번 로딩된 이후 데이터를 수정하거나 조회할 때, 페이지가 새로 고침되거나 다른 페이지로 넘어가지 않는다.\n- 클라이언트 렌더링 방식을 채택\n\n**장점**\n- 전체적인 트래픽을 감소시킨다.\n- 새로고침이 발생하지 않아 네이티브 앱과 유사한 사용자 경험을 제공한다. -> **모바일 퍼스트** 전략에 적합\n\n**단점**\n- 모든 정적 리소스를 최초에 한번 다운로드하기 때문에 초기 구동 속도가 상대적으로 느리다. -> 최초 첫 페이지(어느 정도 그려진)를 서버로부터 받는 SSR을 진행하여 속도를 개선할 수 있다.\n- SEO(검색엔진 최적화) 문제 -> SPA 프레임워크(앵귤러, 리액트..)에서 SSR을 지원하여 SEO에 대응할 수 있다.\n\n**전통적 Link Tag와 차이**\n- Link tag는 새로운 페이지를 요청할 때마다 정적 리소스를 다운 받고 전체 페이지를 다시 렌더링한다.   \n- 새로고침이 매번 발생되어 사용성이 좋지 않고 변경이 필요 없는 부분을 포함하여 전체 페이지를 갱식하므로 비효율적이다.\n\n# SSR(Server Side Rendering)\n**서버**가 사용자에게 보여줄 페이지를 모두 구성하여 사용자에게 페이지를 보여주는 방식이다.\n\n1. 브라우저가 서버에 페이지 요청한다.\n2. 서버는 DB에서 데이터를 가져오든 뭐든, 필요한 데이터를 모두 매핑시킨 HTML을 만들어 브라우저에 응답한다.\n3. 브라우저는 응답 받은 페이지를 렌더링한다. 이 때부터 **사용자는 페이지를 볼 수 있다.** 동시에 브라우저는 필요한 JS 파일들을 다운 받는다. [Viewable]\n4. 브라우저가 React를 실행한다.\n5. 드디어 페이지가 사용자와 상호 작용 할 수 있게 된다. [Interactable]\n\n# CSR(Client Side Rendering)\n데이터 없는 빈 HTML 파일을 받아오고 데이터는 문서와 여러 static 파일들이 로드된 후에 요청해서 받아오는 방식\n\n1. 서버가 아래와 같은 빈 HTML을 보내준다.\n\n```html\n<html>\n  <head>\n    <script src=\"client-side-framework.js\"></script>\n    <script src=\"app.js\"></script>\n  </head>\n  <body>\n    <div class=\"container\"></div>\n  </body>\n</html>\n```\n\n2. 브라우저는 JS 파일을 다운로드 받는다.\n3. 브라우저가 리액트를 실행한다.\n4. 드디어 사용자가 페이지를 볼 수 있고 상호 작용할 수 있다. [Viewable & Interactable]\n"}}}},"pageContext":{"id":"d91ddb038b5151998966588eea19cf150c69cd32","previousPostId":"e1d231567cddc9de8b345729cc86853dff9718ce","nextPostId":"966ea5b2cd8e89dbab1723a18bec85539cbfa10a"}},"staticQueryHashes":["2685952063","2841359383"]}