{"componentChunkName":"component---src-templates-blog-post-js","path":"/d91ddb038b5151998966588eea19cf150c69cd32","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d91ddb038b5151998966588eea19cf150c69cd32","text":"# 함수 컴포넌트에서 ref를 사용하려면?\n\n- Title : 함수 컴포넌트에서 ref를 사용하려면?\n- Date : 2020-09-02\n- Category: React\n\n# Key Point 💥\n\n부모 컴포넌트에서 `useRef` 훅으로 생성한 ref를 자식 컴포넌트에 전달하고 싶다면? **forwardRef**를 사용하자!\n함수 컴포넌트에는 인스턴스가 없기 때문에 함수 컴포넌트에 ref 어트리뷰트를 사용할 수 없다.\n\n함수 컴포넌트에 ref를 사용할 수 있게 하려면!\n\n- [forwardRef](https://ko.reactjs.org/docs/forwarding-refs.html) 또는 forwardRef + [useImperativeHandle](https://ko.reactjs.org/docs/hooks-reference.html#useimperativehandle) 를 사용\n- 클래스 컴포넌트로 변경\n\n단, DOM 엘리먼트나 클래스 컴포넌트의 인스턴스에 접근하기 위해 `ref` ****어트리뷰트를 함수 컴포넌트에서 사용할 수 있다.\n\n# 삽질기 ⛏️\n\n현재의 Copy 컴포넌트에서 Overlay의 target 속성이 Copy 컴포넌트 내부에서 useRef로 생성한 ref 값을 전달한다. 내가 구현하고 싶었던 건 부모 컴포넌트에서 ref를 받아서 부모 컴포넌트의 특정 DOM 위에 overlay를 보여주는 거다. 부모 컴포넌트에서 useRef로 만든 값을 props로 전달했지만 Copy 자체가 동작하지 않았다. 휴 계속 삽질을 했지만 답은 공식 문서에 있었다. 문서를 열심히 읽자!! 😆\n\n수정 전 Copy.jsx\n\n```jsx\nimport React, { useState, useEffect, useRef } from 'react';\nimport { CopyToClipboard } from 'react-copy-to-clipboard';\nimport { Overlay, Tooltip } from 'react-bootstrap';\n\nconst Copy = ({ children, text, placement, copiedMsg }) => {\n  const [isShowCopied, setIsShowCopied] = useState(false);\n  const target = useRef(null);\n\n  useEffect(() => {\n    if (!isShowCopied) return;\n\n    setTimeout(() => {\n      setIsShowCopied(false);\n    }, 2000);\n  }, [isShowCopied]);\n\n  return (\n    <>\n      <CopyToClipboard\n        text={text}\n        onCopy={() => {\n          setIsShowCopied(true);\n        }}\n      >\n        {React.cloneElement(children, { ref: target })}\n      </CopyToClipboard>\n      <Overlay target={target.current} show={isShowCopied} placement={placement}>\n        <Tooltip>{copiedMsg}</Tooltip>\n      </Overlay>\n    </>\n  );\n};\n\nexport default Copy;\n```\n\n수정 후 Copy.jsx\n\n```jsx\nimport React, { useState, useEffect, useRef, forwardRef } from 'react';\nimport { CopyToClipboard } from 'react-copy-to-clipboard';\nimport { Overlay, Tooltip } from 'react-bootstrap';\n\nconst Copy = forwardRef(({ children, text, placement, copiedMsg }, ref) => {\n  const [isShowCopied, setIsShowCopied] = useState(false);\n  const target = useRef(null);\n\n  useEffect(() => {\n    if (!isShowCopied) return;\n\n    setTimeout(() => {\n      setIsShowCopied(false);\n    }, 2000);\n  }, [isShowCopied]);\n\n  return (\n    <>\n      <CopyToClipboard\n        text={text}\n        onCopy={() => {\n          setIsShowCopied(true);\n        }}\n      >\n        {React.cloneElement(children, { ref: target })}\n      </CopyToClipboard>\n      <Overlay target={(ref && ref.current) || target.current} show={isShowCopied} placement={placement}>\n        <Tooltip>{copiedMsg}</Tooltip>\n      </Overlay>\n    </>\n  );\n});\n\nexport default Copy;\n```"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"8d51608bb77f280a336bf3cc627ad5b9d0383e29","text":"# HTTP 커넥션(part 1)\n- Title : HTTP 커넥션\n- Date : 2020-12-14\n- Category : Network\n\n## `http://www.github.com:80/devgaram` URL을 입력받은 브라우저가 하는 일\n> 전 세계 HTTP 통신은 컴퓨터와 네트워크 장비에서 널리 쓰이고 있는 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이루어진다.\n> 세계 어디서든 클라이언트 애플리케이션은 서버 애플리케이션으로 TCP/IP 커넥션을 맺을 수 있다.\n\n1. 브라우저가 `www.github.com`라는 호스트 명을 추출한다.\n2. 브라우저가 호스트 명에 대한 IP 주소, 192.30.252.153를 찾는다.\n3. 브라우저가 포트 번호, 80을 얻는다.\n4. 브라우저가 192.30.252.153의 80포트로 TCP 커넥션을 생성한다.\n5. 브라우저가 서버로 HTTP GET 요청 메시지를 보낸다.\n6. 브라우저가 서버에서 온 HTTP 응답 메시지를 읽는다.\n7. 브라우저가 커넥션을 끊는다.\n\n## TCP 커넥션\n> HTTP 커넥션은 몇몇 사용 규칙을 제외하고는 TCP 커넥션에 불과하며 TCP는 HTTP에게 신뢰할 만한 통신 방식을 제공한다.\n\n- TCP 커넥션은 **<발신지 IP주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>** , 이 네가지 값으로 생성되며, 네가지가 모두 동일한 커넥션은 존재할 수 없다.\n- IP 주소가 컴퓨터, 포트 번호가 애플리케이션으로 생각하면 된다.\n\n### 프로토콜 스택\nHTTP - 애플리케이션 계층 | TCP - 전송 계층 | IP - 네트워크 계층 | Network Interfaces - 데이터링크 계층\n\n**HTTP**\n\n|HTTP 프로토콜|\n|:---:|\n|HTTP|\n|TCP|\n|IP|\n|Network Interfaces|\n\n**HTTPS**    \nHTTP에 보안 기능을 더한 것으로 SSL 또는 TLS라고 불리기도 하며 HTTP와 TCP 사이에 있는 암호화 계층이다.\n\n|HTTPS 프로토콜|\n|---|\n|HTTP| \n|TLS 또는 SSL|\n|TCP|\n|IP|\n|Network Interfaces|\n\n### 전송 과정\n\n1. HTTP가 메시지를 전송하고자 현재 연결되어 있는 TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보낸다.\n2. TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나눈다. 각 세그먼트를 IP 패킷(혹은 IP 데이터그램)에 담아서 하나의 IP 주소에서 다른 IP 주소로 전달한다.\n\n### IP 패킷에 포함되는 정보\n- IP 패킷 헤더(20byte): 발신지와 목적지의 IP 주소, 크기, 기타 플래그 가짐\n- TCP 세그먼트 헤더(20byte): TCP 포트 번호, TCP 제어 플래그, 데이터 순서와 무결성을 검사하기 위해 사용하는 숫자 값 가짐\n- TCP 데이터 조각(0혹은 그 이상의 바이트)\n\n## TCP 소켓 프로그래밍\n\n소켓 API를 사용하면 TCP 종단(endpoint) 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.\nTCP API는 기본적인 네트워크 프로토콜의 핸드셰이킹, 그리고 TCP 데이터 스트림과 IP 패킷 간의 분할 및 재조립에 대한 모든 세부사항을 외부로부터 숨긴다.\n\n### 클라이언트와 서버가 TCP 소켓 인터페이스를 사용하여 상호작용 하는 방법\n\n|클라이언트|서버|\n|---|---|\n|| 1. 새로운 소켓을 만든다|\n||2. 80 포트로 소켓을 묶는다|\n||3. 소켓 커넥션을 허가한다(listen)|\n||4. 커넥션을 기다린다(accept)|\n|1. IP 주소와 포트를 얻는다.||\n|2. 새로운 소켓을 생성한다.||\n|3. 서버의 IP포트로 연결한다(connect)||\n||5. 애플리케이션에 커넥션 통지|\n|4. 성공적으로 연결 |6. 요청을 읽기 시작한다(read)|\n|5. HTTP 요청을 보낸다(write)|7. HTTP 요청 메시지를 처리한다.|\n|6. HTTP 응답을 기다린다(read)||\n||8. HTTP 응답을 보낸다(write)|\n|7. HTTP 응답을 처리한다||\n|8. 커넥션을 닫는다(close)|\n||9. 커넥션을 닫는다(close)|\n\n\n참고 책 - HTTP 완벽 가이드\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"a21d94a6b96cfbfbce523c164d6e7bd377c5c4b7","text":"# 자바스크립트의 실행 컨텍스트\n\nDate: Jul 11, 2020\n\n- Title : 실행 컨텍스트\n- Date : 2020-07-11\n- Category : Javascript\n\n이 글은 코어 자바스크립트 책의 실행 컨텍스트 부분을 정리한 내용입니다.\n\n# 실행 컨텍스트\n\n- 실행할 코드에 제공할 환경 정보들을 모아 놓은 객체다.\n- 자바 스크립트는 동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하여 콜 스택에 올린다. 가장 위에 쌓인 컨텍스트와 관련 코드를 실행하는 방법을 통해 전체 코드의 환경과 순서를 보장한다.\n- 실행 컨텍스트를 구성하는 방법은 `전역 공간`, `eval() 함수`, `함수` 등이 있다. `전역 공간`은 자동으로 생성되고 `eval()` 함수는 악마로 취급 되므로 **컨텍스트를 구성하기 위해 함수를 실행하는 방법을 흔히 사용**한다.\n\n## 실행 컨텍스트를 코드로 이해하기\n\n```jsx\n// (1)\nvar a = 1;\nfunction outer() {\n  function inner() {\n\t  console.log(a); // undefined\n\t  var a = 3;\n  }\n  inner(); // (2)\n  console.log(a); // 1\n}\nouter(); // (3)\nconsole.log(a); // 1\n```\n\n1. 처음 자바 스크립트 코드가 실행하는 순간(1) 전역 컨텍스트가 콜 스택에 담긴다.\n\n    참고로 전역 컨텍스트는 일반 실행 컨텍스트와 달리 함수가 아닌 전역 공간이기 때문에 arguments가 없고 전역 공간을 둘러싼 외부 스코프가 존재할 수 없기 때문에 스코프 체인 상에는 전역 스코프 하나만 존재한다.\n\n2. 콜 스택에 전역 컨텍스트 외에 다른 프레임이 없으므로 전역 컨텐스트와 관련된 코드들을 순차로 진행하다가 (3)에서 outer 함수를 호출하면 엔진은 outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성한 후 콜 스택에 담는다.\n3. 콜 스택의 맨 위에 outer 실행 컨텍스트가 놓인 상태이므로 전역 컨텍스트와 관련된 코드 실행을 일시 중단하고 outer 실행 컨텍스트와 관련된 코드(outer 함수 내부 코드)를 순차로 실행한다.\n4. (2)에서 inner 함수의 실행 컨텍스트가 콜 스택 가장 위에 담기면 outer 컨텍스트와 관련된 코드 실행을 중단하고 inner 함수 내부의 코드를 순서대로 실행한다.\n5. inner 함수의 실행이 종료되면 inner 실행 컨텍스트가 콜 스택에서 제거된다.\n6. outer 실행 컨텍스트가 콜 스택에 맨 위에 존재하게 되므로 중단했던 (2)의 다음 줄부터 이어서 실행한다.\n7. outer 함수의 실행이 종료되어 콜 스택에서 제거되면 전역 컨텍스트의 코드들을 실행하게 된다. 더 이상 실행할 코드가 남아 있지 않으면 전역 컨텍스트도 제거되어 콜 스택에는 아무 것도 남지 않은 상태로 종료된다.\n\n# 실행 컨텍스트에 담기는 정보들\n\n- VariableEnvironment: 현재 컨텍스트 내의 식별자에 대한 정보 + 외부 환경 정보, 선언 시점의 LexicalEnvironment의 스냅샷으로 변경 사항은 반영되지 않음\n- LexicalEnvironment: 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨\n- ThisBinding: this 식별자가 바라봐야 할 대상 객체\n\n## VariableEnvironment\n\nLexicalEnvironment에 담기는 내용과 같지만 VariableEnvironment는 **최초 실행 시의 스냅샷을 유지**한다는 점이 다르다. 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음 이를 그대로 복사해서 LexicalEnvironment를 만들고 이후에는 LexicalEnvironment를 주로 활용하게 된다.\n\n## LexicalEnvironment\n\n내부 구성\n\n- environmentRecode: 매개 변수의 이름, 함수 선언, 변수명 등이 담김\n- outerEnvironmentReference: 바로 직전 컨텍스트의 LexicalEnvironment 정보를 참조\n\n### environmentRecode\n\n컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어 나가며 순서대로 현재 컨텍스트와 관련된 코드의 식별자 정보들을 저장한다. 매개변수 식별자, 선언한 함수가 있을 경우 그 함수 자체(함수 선언문), var로 선언된 변수의 식별자가 식별자 정보에 해당된다.\n\n코드가 실행되기 전임에도 자바스크립트 엔진은 해당 컨텍스트에 속한 변수 명들을 모두 알고 있다. 즉, 자바스크립트 엔진은 **식별자들을 최 상단으로 끌어 올려 놓은 다음 실제 코드를 실행한다**라고 생각해도 된다. 여기서 호이스팅의 개념이 등장한다.\n\n자바 스크립트 엔진은 변수 선언과 값 할당이 동시에 이뤄진 문장은 **선언부**만을 호이스팅하고 할당 과정은 원래 자리에 둔다. 따라서 함수 선언문은 함수 전체가 호이스팅 되지만 함수 표현식은 변수 선언부만 호이스팅 된다.\n\n### outerEnvironmentReference\n\nouterEnvironmentReference는 **현재 호출된 함수가 선언될 당시**의 LexicalEnvironment를 참조하기 때문에 우리는 스코프 체인을 할 수 있다. \n\n코드 상에서 어떤 변수에 접근하려고 하면 현재 컨텍스트의 LexicalEnvironment를 탐색한다. 변수 값을 발견하면 그 값을 반환 하지만 발견하지 못하면 outerEnvironmentReference에 담긴 LexicalEnvironment를 탐색하는 과정을 거친다. 전역 컨텍스트의 LexicalEnvironment까지 탐색 해도 해당 변수를 찾지 못하면 undefined를 반환한다.\n\n> 스코프는 식별자에 대한 유효 범위로, 어떤 경계 A의 외부에서 선언한 변수는 A의 외부 뿐 아니라 A의 내부에서도 접근이 가능하지만, A의 내부에서 선언한 변수는 오직 A 내부에서만 접근할 수 있다는 개념으로 이해하면 된다. 이러한 식별자 유효 범위를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라고 한다.\n\n"}}}},"pageContext":{"id":"d91ddb038b5151998966588eea19cf150c69cd32","previousPostId":"8d51608bb77f280a336bf3cc627ad5b9d0383e29","nextPostId":"a21d94a6b96cfbfbce523c164d6e7bd377c5c4b7"}},"staticQueryHashes":["2841359383"]}