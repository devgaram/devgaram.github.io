{"componentChunkName":"component---src-templates-blog-post-js","path":"/77ee51be00a66cb386e84663fe372b319859e4f3","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"77ee51be00a66cb386e84663fe372b319859e4f3","text":"# 알고리즘 개념 잡자 - 그래프\n\n- Title : 알고리즘 개념 잡자 - 그래프\n- Date : 2020-02-01\n- Category: Algorithm\n\n> 참고서적\n>\n> - [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539)\n\n<br/>\n\n# 1. 그래프(graph)란\n\n- 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조다.\n- 정점(vertex)과 간선(edge)들의 집합으로 구성된다 => G = (V, E)\n- 정점 == 객체 == 노드, 간선 == 관계 == 노드\n- 그래프로 표현할 수 있는 것들) 도로, 영역 간 인접 관계, 선수 과목\n- 간선의 종류에 따라 무방향 그래프와 방향 그래프로 구분된다.\n\n> **오일러 경로**\n>\n> - 모든 간선을 한번만 통과하면서 처음 정점으로 되돌아오는 경로다.\n> - 그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 오일러 경로가 존재한다.\n\n# 2. 그래프 용어정리\n\n- 가중치 그래프(네트워크) : 간선에 비용이나 가중치가 할당된 그래프\n- 차수(degree) : 정점이 가지고 있는 인접 링크의 수\n- 인접 정점(adjacent vertex) : 간선에 의해 직접 연결된 정점\n  - 무방향 그래프에서 정점의 차수(degree)는 인접 정점의 수다.\n  - 무방향 그래프에 존재하는 정점의 모든 차수를 합하면 그래프의 간선 수의 2배가 된다.\n- 방향 그래프 : 간선에 방향성이 존재하는 그래프\n  - 집입 차수(in-degree) : 외부에서 오는 간선 수\n  - 진출 차수(out-degree) : 외부로 향하는 간선 수\n  - 정점의 진입 차수와 진출 차수의 합은 방향 그래프의 간선의 수가 된다.\n- 경로 길이(path length) : 경로를 구성하는 데 사용된 간선의 수\n  - 단순 경로(simple path) : 경로 중에서 반복되는 간선이 없는 경우\n  - 사이클(cycle) : 단순 경로의 시작 정점과 종료 정점이 동일한 경우\n- 연결 그래프(connected graph) : 무방향 그래프에 있는 모든 정점에 대해 항상 경로가 존재하면 그래프는 연결되어 있다고 한다.\n  - 그래프의 어느 두 정점을 선택해도 그 사이에 경로가 존재하면 연결 그래프다.\n  - 트리는 그래프의 특수한 형태로 사이클을 가지지 않는 연결 그래프이다.\n- 완전 그래프(complete graph) : 그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프\n  - 무방향 완전 그래프의 정점 수가 n이면 하나의 정점은 n-1개의 다른 정점으로 연결되므로 간선의 수는 n x (n-1)/2가 된다.\n\n# 3. 그래프의 구현\n\n## 1) 인접 행렬(adjacency matrix)\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-23-img/1.png)<br/>\n\n- 2차원 배열로 표현\n- n개의 정점을 가지는 그래프를 표현하기 위해서는 n<sup>2</sup>의 메모리 공간이 필요해서 간선이 많이 존재하는 밀집 그래프를 표현하는 경우에 적합하다.\n- 간선 수가 적은 최소 그래프의 경우에는 메모리의 낭비가 크므로 부적합하다.\n- 두 정점을 연결하는 간선의 존재 여부를 O(1) 시간 안에 알 수 있다.\n- 정점의 차수는 인접 행렬의 행이나 열을 조사하면 알 수 있으므로 O(n)의 연산에 알 수 있다.\n- 정점 i에 대한 차수는 인접 행렬의 i번째 행에 있는 값을 모두 더하면 된다.\n- 그래프에 존재하는 모든 간선의 수를 알아내려면 인접 행렬 전체를 조사해야하므로 O(n<sup>2</sup>)의 시간이 요구된다.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n  int n, m; // n: 정점개수, m: 간선 개수\n  int v1, v2, d, c; // v1: 정점1, v2: 정점2, d: 0(무방향) 1(v1->v2), c: 간선 가중치 (1이상)\n  scanf(\"%d %d\", &n, &m);\n\n  int graph[n+1][n+1] = {0}; // 0으로 초기화\n\n  for (int i=0; i<m+1; i++) {\n    scanf(\"%d %d %d %d\", &v1, &v2, &d, &c);\n    if (d == 0) {\n      graph[v1][v2] = graph[v2][v1] = c;\n    } else {\n      graph[v1][v2] = c;\n    }\n  }\n\n  return 0;\n}\n```\n\n## 2) 인접 리스트(adjacency list)\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-23-img/2.png)<br/>\n\n- 각 정점에 인접한 정점들을 연결리스트로 표현\n- 각 연결 리스트들은 헤드 포인터를 가지고 있고 이 헤드 포인터들은 하나의 배열로 구성되어 있어 정점의 번호만 알면 이 번호를 배열의 인덱스로 하여 각 정점의 연결리스트에 쉽게 접근할 수 있다.\n- 정점의 수가 n개고 간선의 수가 e개인 무방향 그래프를 표시하기 위해서는 n개의 연결 리스트가 필요하고 n개의 헤드 포인터와 2e개의 노드가 필요하다.\n- 간선의 개수가 적은 희소 그래프의 표현에 적합하다.\n- 간선의 존재 여부나 정점 i의 차수를 알기 위해서는 정점 i의 연결리스트를 탐색해야 하므로 연결리스트에 있는 노드의 수만큼(정점 차수만큼)의 시간이 필요하다.\n- n개의 정점, e개의 간선을 가진 그래프의 전체 간선 수를 알아내려면 O(n+e)의 연산이 요구된다.\n\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main() {\n  int n, m;\n  int v1, v2, d, c;\n  scanf(\"%d %d\", &n, &m);\n\n  vector<pair<int, int> > graph[n+1];\n\n  for (int i=0; i<m+1; i++) {\n    scanf(\"%d %d %d %d\", &v1, &v2, &d, &c);\n    if (d == 0) { // 무방향\n      graph[v1].push_back(make_pair(v2, c));\n      graph[v2].push_back(make_pair(v1, c));\n    } else {\n      graph[v1].push_back(make_pair(v2, c));\n    }\n  }\n}\n```\n\n# 4. 그래프 탐색\n\n- 그래프에서 모든 노드를 방문하고 싶다면?\n  - DFS, BFS 중 아무거나 사용해도 상관없으나 DFS가 좀 더 간단하긴 하다.\n- 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶다면?\n  - BFS가 일반적으로 더 낫다.\n  - DFS는 경로를 찾을 수는 있겠지만 모든 노드를 탐색해야할지도 모르고 최단 경로가 아닐 수도 있다.\n\n## 1) 깊이 우선 탐색(DFS)\n\n> 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 가다가 더 이상 갈 수 없게 되면 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색을 진행하는 방법과 유사하다.\n\n- 순환 호출이나 명시적 스택을 사용한다.\n- 전위 순회를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류다.\n- 그래프 탐색의 경우는 어떤 노드를 방문했었는지 여부를 반드시 검사해야한다. 이를 검사하지 않으면 무한 루프에 빠질 위험이 있다.\n- 정점의 수가 n, 간선의 수가 e인 그래프를 깊이 우선 탐색하는 시간은? (힌트 : 모든 간선을 조사한다.)\n  - 인접리스트 : O(n+e)\n  - 인접행렬 : O(n<sup>2</sup>)\n\n**인접 행렬로 표현된 무방향 그래프 DFS**\n\n```cpp\n#include <iostream>\n#define MAX_V 20; // 정점 최대 값\nusing namespace std;\n\nint n; // 입력받은 정점의 수\n\nvoid dfs(int graph[][MAX_V], int visited[], int v) {\n  visited[v] = true;\n  printf(\"%d\", v);\n  for (int i=0; i<n+1; i++) {\n    if (graph[v][i] == 1 && !visited[i]) dfs(graph, visited, i);\n  }\n}\n```\n\n## 2) 너비 우선 탐색(BFS)\n\n- 큐를 사용한다.\n- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.\n\n**인접 행렬로 표현된 무방향 그래프 BFS**\n\n```cpp\n#include <iostream>\n#include <queue>\n#define MAX_V 20; // 정점 최대 값\nusing namespace std;\n\nint n; // 입력받은 정점의 수\n\nvoid bfs(int graph[][MAX_V], int visited[], int v) {\n  visited[v] = true;\n  queue<int> q;\n  q.push(v);\n\n  while(!q.empty()) {\n    int top = q.front();\n    q.pop();\n    printf(\"%d\", top);\n\n    for (int i=0; i<n+1; i++) {\n      if (graph[v][i] == 1 && !visited[i]) {\n        q.push(i);\n        visited[i] = true;\n      }\n    }\n  }\n\n}\n\n```\n\n## 3) 양방향 탐색\n\n- 출발지와 도착지 사이에 최단 경로를 찾을 때 사용한다.\n- 출발지, 도착지 두 노드에서 동시에 너비 우선 탐색을 수행한 뒤, 두 탐색 지점이 충돌하는 경우에 경로를 찾는 방법이다.\n- 두 탐색 알고리즘이 대략 d/2 단계(s와 t 사이의 중간 지점)에서 충돌하여 각 출발지와 도착지 노드의 방문 노드의 개수는 대략 k<sup>d/2</sup>가 된다. (k : 각 노드의 인접 노드의 개수)\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"baf3d7f1d92d3ddf097652b4412ef8feb523af76","text":"# 완전 초보를 위한 가상화 개념\n\n- Title : 완전 초보를 위한 가상화 개념\n- Date : 2020-02-19\n- Category: Infra\n\n이 포스팅은 완전 초보를 위한 글로 \"무슨 이거까지 설명해?\" 라는 생각이 들 수 있어요. 초보가 정리한 거라 오류가 있을 수도 있으니 발견하시면 코멘트 주세요! 😊\n\n> Windows 운영체제 위에서 Linux를 사용하기 위해 가상머신을 설치해본 적이 있나요? 주로 VM웨어사가 만든 하이퍼바이저 기반 가상머신 소프트웨어인 VM웨어 워크스테이션을 사용했을 거예요. 이처럼 하이퍼바이저(hypervisor)는 호스트 컴퓨터(여기선 윈도우 환경)에서 리눅스와 같은 다수의 운영체제를 동시에 실행할 수 있는 플랫폼을 제공해줘요.\n\n위 글에서 언급된 **가상화**, **가상머신**, **하이퍼바이저**를 설명할 수 있나요? 있다면, 고수네요. 부럽..🤣 초보인 저와 또 다른 초보를 위해 차근차근 정리해볼게요.\n\n<br/>\n\n---\n\n<br/>\n\n## 1. 가상화(virtualization)\n\n가상화는 컴퓨팅 리소스(서버, 데이터베이스, 스토리지, 애플리케이션 등)를 **추상화**하여 다수의 운영 체제 또는 애플리케이션 이미지를 하나의 물리적 서버에서 공유할 수 있도록 하는 프로세스예요. 물리적 컴퓨터 수를 줄일 수 있어 **비용 절감**에 효과적인데요. 대부분의 서버는 단지 용량의 10~15%만 사용하는 데 가상화를 통해 서버 효용률을 70% 이상으로 올릴 수 있기 때문이죠.\n\n## 2. 가상 머신(virtual machine, VM)\n\n**가상머신**은 컴퓨팅 환경을 소프트웨어로 구현한 것으로 컴퓨터를 **에뮬레이션**하는 소프트웨어예요.\n에뮬레이터 역할을 하는 거죠. 가상 머신은 CPU를 포함한 모든 하드웨어를 가상화하여 가상머신상에서 운영체제나 응용 프로그램을 설치하고 실행할 수 있게 해요.\n\n<span class=\"clr-grey\">에뮬레이션은 한 시스템을 복제하여 그 시스템을 흉내 내는 것으로 가상화 구현에서는 CPU를 포함한 모든 하드웨어를 가상화하는 것을 말해요. 즉, 옵코드가 달라도 실행 가능하죠. PC에서 실행되는 수많은 게임 에뮬레이터도 이런 가상화 기술 중 하나예요. 느리다는 단점이 있긴 하죠.</span>\n\n## 3. 하이퍼바이저(hypervisor)\n\n호스트 컴퓨터에서 다수의 게스트 OS를 동시에 실행할 수 있게 하는 소프트웨어로 가상화 머신 모니터 또는 가상화 머신 매니저라고 불러요. 하이퍼바이저는 아래와 같이 2가지 타입으로 나눠져요.\n<br/><br/>\n\n<div style=\"text-align:center\">\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-19-img/Hyperviseur.png)\n<br/>\n<span class=\"clr-grey\">위키피디아 하이퍼바이저</span>\n\n</div>\n<br/>\n\n### 타입 2 (호스트형)\n\n일반 프로그램과 같이 하이퍼바이저는 호스트 OS 위에서 실행돼요. VM 내부에서 동작되는 게스트 OS는 하드웨어에서 3번째 수준으로 실행되는 거죠. 타입1에 비해 오버헤드가 크지만, 게스트 OS 종류에 대한 제약이 없고 데스크탑, 노트북에서도 운영할 수 있어요.\n\n<BR/>\n\n### 타입 1 (native 또는 bare-metal)\n\n타입2와 달리 **호스트 OS 없이** 하드웨어 위에 하이퍼바이저가 바로 위치해요. 별도의 호스트 OS가 없기에 오버헤드가 적고 하드웨어를 직접 제어하기 때문에 효율적으로 리소스를 사용할 수 있어요. 하지만 여러 하드웨어 드라이버를 세팅해야 하므로 설치가 어려워요. VM 내부의 게스트 OS는 하드웨어 위에서 2번째 수준으로 실행되는 거죠.\n\n<span class=\"clr-grey\">네이티브형 하이퍼바이저는 전가상화, 반가상화 방식으로 세분화할 수 있어요. 하이퍼바이저를 통해 가상 머신 내의 게스트 OS가 호스트 시스템을 활용한다는 점을 같지만, 하드웨어와 인터랙션하는 방식에 차이가 있어요.</span>\n\n**1) 전가상화(Full-virtualization, Native-virtualization)**\n\n동일한 아키텍처에서 실행되는 게스트 OS를 **수정없이** 그대로 띄워주는데 필요한 하드웨어를 모두 에뮬레이션 하는 형식으로 가상화해요.\n\n- 게스트 OS는 하드웨어에 직접 액세스 하는 것으로 인식해요. 사실 이 하드웨어는 하이퍼 바이저가 하드웨어를 에뮬레이션한 복제품이죠. 그래서 게스트 OS는 하드웨어를 자신이 소유하고 있는 걸로 인식해요.\n- 하이퍼바이저는 게스트 OS가 하드웨어에 주는 명령을 감시해 \"하드웨어를 독점\"하는 명령이 발생하면 별도로 핸들링 해줘야 해요. 즉, 하이퍼바이저가 게스트 OS와 하드웨어 사이의 **중재자** 역할을 하죠. 그 전에 모든 게스트 OS는 \"DOM 0\"이라는 관리 머신을 거쳐 하이퍼바이저와 통신해요\n- 매번 하이퍼바이저와 통신하므로 CPU와 RAM처럼 I/O가 잦은 자원을 컨트롤 하기에는 번거롭기에 아래의 반가상화 방식이 출현했어요.\n\n**2) 반가상화(Para-virtualization)**\n\n하드웨어 에뮬레이션 없이 하이퍼바이저를 통해 하이퍼바이저가 제공하는 API를 이용한 OS를 실행할 수 있는 가상화해요. **게스트 OS를 하이퍼바이저의 API를 이용할 수 있도록 수정**해야해요. 게스트 OS를 수정해야 하므로 좀 번거롭죠.\n\n- 게스트 OS는 하드웨어에 하이퍼바이저가 제공한 API를 통해서 엑세스할 수 있어요.\n- 게스트 OS 입장에선 하드웨어를 소유하고 있지 않다는 것을 알고 있으므로 하드웨어를 독점하는 명령을 하지 않아요.\n- 각각의 게스트 OS는 필요한 자원을 직접 API를 통해 요청할 수 있으므로 모든 요청을 \"DOM 0\"가 한꺼번에 처리하여 하드웨어를 제어하는 전가상화 방식에 비해 성능이 좋아요.\n\n## 4. 컨테이너 기반의 가상화(도커) - 추후 추가예정\n\nOS레벨 가상화(OperatingSystem-level virtualization)는 OS상에서 같은 OS를 하나 더 사용하는것 처럼 꾸며주는 가상화로 가상화로 인한 속도저하가 없다고 생각해도 무방해요. 특히 OS레벨 가상화는 요즘 가장 핫한 방식인데, Container 를 사용해 SaaS, PaaS를 제공하는 Docker 와, 수많은 Container 관리를 용이하게 해주는 Kubernetes가 그 중심에 있다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"71b6232e760cb058f53c92719edc32233daa262c","text":"# c++로 알고리즘 풀 때 팁들\n\n- Title : c++로 알고리즘 풀 때 팁들\n- Date : 2020-01-28\n- Category: Algorithm\n\n# # 입출력\n\ncin, cout은 느려서 scanf, printf를 사용하는 걸 추천한다.\n\n```cpp\nint N, M, K;\nscanf(\"%d %d %d\", &N, &M, &K);\n```\n\n# # 2차원 배열\n\n1 2 3 4 5 <br/>\n2 3 4 5 6 <br/>\n... 방식의 입력을 받고 싶다면?\n\n```cpp\n#define MAX 10\nint A[MAX][MAX];\n\nint main() {\n\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n    }\n  }\n  return 0;\n}\n```\n\n## 2차원 deque 입력, 정렬\n\n```cpp\n#define MAX 10\ndeque<int> T[MAX][MAX];\n// ...\nint main() {\n  int x, y, age;\n\n  // 입력\n  for (int i=0; i<M; i++) {\n    scanf(\"%d %d %d\", &x, &y, &age);\n    T[--x][--y].push_back(age);\n  }\n\n  // 정렬 오름차순\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      if (T[i][j].size() > 1)\n        sort(T[i][j].begin(), T[i][j].end());\n\n    }\n  }\n\n  // 순회\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      deque<int> &tmp = T[i][j]; // 참조로 받기(수정하려면)\n      for(auto iter=tmp.begin(); iter != tmp.end();) {\n        int &t = *iter;\n        if () //삭제X\n          iter++;\n        else //삭제 O\n          iter = tmp.erase(iter); //다음 iter 받음\n\n      }\n    }\n  }\n  return 0;\n}\n```\n\n# 포인터와 참조\n\n```cpp\n// 새로운게임2 에서..\nstruct Horse {\n  int row, col, dir;\n};\n\n// 참조 변수 : 대상을 직접 할당\n// 선언과 동시에 초기화해야한다!\n// NULL 불가\nHorse &h = horse[0];\nh = horse[1]; // 에러!! (대상 변경 불가)\nprintf(\"%d\", h.row);\n\n// 포인터 변수 : 주소값 할당\nHorse *h = &horse[0];\nh = &horse[1];  // 대상 변경 가능!\nHorse *h = NULL; // NULL 가능\n\nif (h) printf(\"%d\", h->row);\n// 또는\nif (h) printf(\"%d\", (*h).row);\n```\n\n# 배열 초기화할 때, memset 함수 쓰자!\n\n- for문보다 더 빠른 속도가 나올 수 있다.\n- 특정 범위에 있는 **연속된 메모리**에 값을 지정하고 싶을 때 쓰자!\n- cstring 헤더\n\n```cpp\nvoid* memset(void *ptr, int value, size_t num);\n/*\nptr : 메모리 시작 포인터(주소) => 배열 이름\nvalue: 채울 값 => 값\nnum: 채우고자 하는 바이트 수(메모리 크기) => sizeof(배열이름)\n*/\n```\n\n```cpp\n#include <cstring>\nusing namespace std;\nint main() {\n  int C[21][21];\n  memset(C, 0, sizeof(C));\n  return 0;\n}\n```\n\n# 구조체 멤버 내용 복사하고 싶으면? memcpy를 쓰자\n\n```cpp\n#include <cstring>\nusing namespace std;\n\nstruct Horse {\n  int row, col, dir;\n};\n\nint main() {\n  Horse h1, h2;\n  h1.row = 1;\n  h1.col = 2;\n  h1.dir = 3\n\n  memcpy(&h2, &h1, sizeof(Horse)); // Horse 구조체 크기만큼 h1 내용을 h2에 복사\n  return 0;\n}\n```\n\n## 동적 할당된 경우는?\n\n```cpp\n#include <cstring>\nusing namespace std;\n\nstruct Horse {\n  int row, col, dir;\n};\n\nint main() {\n  Horse *h1 = malloc(sizeof(Horse));\n  Horse *h2= malloc(sizeof(Horse));\n  h1->row = 1;\n  h1->col = 2;\n  h1->dir = 3\n\n  memcpy(h2, h1, sizeof(Horse)); // Horse 구조체 크기만큼 h1 내용을 h2에 복사\n  return 0;\n}\n```\n\n## 또 다른 예\n\n```cpp\nHorse h1;\nHorse *h2= malloc(sizeof(Horse));\n\nmemcpy(h2, &h1, sizeof(Horse));    // 구조체 변수에서 동적 메모리로 복사\n```\n\n# 자료형\n\n정수 자료형 int는 4바이트 정보를 기록할 수 있는 자료형으로, signed int(부호가 있는 정수)를 기준으로 기록할 수 있는 양의 정수 범위는 0 ~ 2,147,483,647 (16진수로 7FFFFFFF)이다.\n\n## int 범위를 벗어나는 경우 자료형은 무엇을 쓸까?\n\n8바이트 크기를 가지는 정수 자료형 long long을 쓰는 게 좋다. signed long long을 기준으로 하면 최대 계산할 수 있는 양의 정수 범위는 0 ~ 9,223,372,036,854,775,807(16진수로 7FFFFFFFFFFFFFFF)다.\n\nlong long으로도 불가능하다면 BigInteger를 사용하면 된다.\n\n```cpp\ntypedef long long ll;\nll large, small;\n\n```\n\n# 순열관련 함수\n\nprev_permutation\n"}}}},"pageContext":{"id":"77ee51be00a66cb386e84663fe372b319859e4f3","previousPostId":"baf3d7f1d92d3ddf097652b4412ef8feb523af76","nextPostId":"71b6232e760cb058f53c92719edc32233daa262c"}},"staticQueryHashes":["2841359383"]}