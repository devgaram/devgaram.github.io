{"componentChunkName":"component---src-templates-blog-post-js","path":"/f9911ac03613c935962bb92b556860145926df9d","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f9911ac03613c935962bb92b556860145926df9d","text":"# 최단 경로 알고리즘 - Floyd\n\n- Title : 최단 경로 알고리즘 - Floyd\n- Date : 2020-03-04\n- Category: Algorithm\n\n## Why?\n\n## Floyd 알고리즘\n\n그래프에 존재하는 **모든** 정점 사이의 최단 경로를 한 번에 **모두** 찾아주는 알고리즘이다. 다익스트라는 모든 정점 사이의 최단 경로를 구하려면 정점의 수만큼 다익스트라 알고리즘을 반복 실행한다.\n\n- 2차원 배열 weight를 이용하여 3중 반복으로 구성되어 있다.\n- 초기 배열 weight에서 i==j 면 weight[i][j] = 0, i j 사이의 직접 간선 없으면 weight[i][j]=INF, i j 사이 간선 있으면 weight[i][j] = 가중치값\n- 정점 0부터 n까지 반복을 돌린다. 정점 0을 거치는 경우..1을 거치는 경우..\n- weight[i][j] = min(weight[i][j], weight[i][k] + weight[k][j])\n\n![Floyd/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-04-img/Untitled.png)\n\n## 백준 문제 풀이\n\n11404번 플로이드\n\n[11404번: 플로이드](https://www.acmicpc.net/problem/11404)\n\n```cpp\n    #include <iostream>\n    #include <algorithm>\n    using namespace std;\n\n    int main() {\n    \tint n, m;\n    \tcin >> n >> m;\n\n    \tint graph[n+1][n+1];\n    \tfill(&graph[1][1], &graph[n][n], 10000001);\n    \tfor (int i=1; i<n+1; i++)\n    \t\tgraph[i][i] = 0;\n\n    \tint a, b, c;\n    \twhile (m--) {\n    \t\tcin >> a >> b >> c;\n    \t\tgraph[a][b] = min(graph[a][b], c);\n    \t}\n\n    \tfor (int k=1; k<n+1; k++) {\n    \t\tfor (int i=1; i<n+1; i++) {\n    \t\t\tif (k == i) continue;\n    \t\t\tfor (int j=1; j<n+1; j++) {\n    \t\t\t\tif (k == j) continue;\n    \t\t\t\tgraph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \tfor (int i=1; i<n+1; i++) {\n    \t\tfor (int j=1; j<n+1; j++) {\n    \t\t\tif (graph[i][j] == 10000001) cout << 0 << \" \";\n    \t\t\telse cout << graph[i][j] << \" \";\n    \t\t}\n\n    \t\tcout << \"\\n\";\n    \t}\n\n    \treturn 0;\n    }\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"cb0f5b74980d5a8d75a84ffc8c6e5bcbd54a7dfe","text":"# 최단 경로 알고리즘 - Bellman-Ford\n\n- Title : 최단 경로 알고리즘 - Bellman-Ford\n- Date : 2020-03-06\n- Category: Algorithm\n\n## Why?\n\n[11657번: 타임머신](https://www.acmicpc.net/problem/11657)\n\n다익스트라가 통하지 않았다...😫**음수 가중치** 가 있으면 벨만-포드 알고리즘을 써야한다네...?\n\n## 음수 가중치가 있을 때, 다익스트라가 통하지 않는다. 왜?\n\n다익스트라는 선택된 정점의 집합 S에 없는 정점 중 가중치 값이 가장 작은 정점을 뽑는다. 단 아래의 상황이 만족되는 경우에 적용이 가능하다.\n\n![Bellman%20Ford/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-06-img/Untitled.png)\n\n- 다익스트라에 따르면, 선택된 정점의 집합 S = {1} 일 때, 선택되지않은 정점 {2, 3, 4} ( int[] distance = [0, 5, INF, 6] )중 가장 가중치가 적은 2를 선택한다. 1 → 2는 1→ 4 → 2, 1→ 4 → 3 → 2 보다 적은 가중치를 갖는 것이 증명되기 때문이다.\n\n**그러나, 음수 가중치가 있다면?**\n\n![Bellman%20Ford/Untitled%201.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-06-img/Untitled%201.png)\n\n- 다익스트라에 따르면, 집합 S = {1} 이고 distance가 [0, 5, INF, 6] 이므로 정점 2를 선택한다. 그러나, 1 → 2 가 1 → 4 → 2, 1 → 4 → 3 → 2 보다 적은 가중치를 가지나? **NO!** 음수 가중치에 의해 1에서 2의 최단 경로는 1 → 4 → 3 → 2 가 된다.\n\n그럼 새로운 거리 가중치가 현재의 distance 보다 작으면 바꿀 수 있게 **집합 S에 속한 경우도 탐색하면 되지 않을까?**\n\n- S = {1} , distance = [~~0~~, **5**, INF, 6]\n- S = {1, 2}, distance = [~~0~~, **5**, 9, 6] —> 또 정점 2가 선택되어 **무한루프**를 타버린다.\n\n그러면 **선택된 정점의 현재 distance가 이전에 선택되었을 때의 distance 값과 동일하다면 제외하면 되지 않을까?**\n\n- S = {1, 2}, distance = [~~0~~, 5, 9, **6**] —> 정점 2는 이전에 선택되었을 때와 distance가 같아서 제외하고 그 다음으로 정점 4를 선택\n- S = {1, 2, 4}, distance = [~~0~~, **2**, 4, 6] —> 이전 distance 5보다 적은 가중치이므로 정점 2를 선택\n- S = {1, 2, 4}, distance = [~~0~~, 2, **4**, 6] —> 정점 2는 이전 distance와 같으니깐 정점 3 선택\n- S = {1, 2, 3, 4}, distance = [~~0~~, **1**, 4, 6] —> 정점 2 선택\n- S = {1, 2, 3, 4}, distance = [~~0~~, 1, 4, 6] —> 모두 이전 distance와 같은 상태..\n\n기존 다익스트라보다 복잡하다. **음수 가중치**가 있으면 벨만 포드 알고리즘을 써서 좀 더 간단하게 풀자!\n\n## 벨만 포드 알고리즘\n\n정점 u, v 사이의 최단 경로를 구할 때 그래프 내 **모든 간선에 대해 간선 경감(Edge Relaxation)을 수행**한다. u, v 사이의 최단 경로는 u → v 직접 간선일 수도 있고 u → v를 제외한 모든 노드 → v 일 수도 있다. 따라서 모든 간선에 대해 간선 경감을 **|V| - 1** 회 수행한다. (V : 정점 개수)\n\n![Bellman%20Ford/Untitled%202.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-06-img/Untitled%202.png)\n\n1. **초기화 작업** : 시작 정점을 제외한 모든 정점을 INF 값으로 초기화한다.\n\n![Bellman%20Ford/Untitled%203.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-06-img/Untitled%203.png)\n\n2.  **간선 경감 수행** : 정점 개수 - 1 만큼 간선 경감을 수행한다.\n\n![Bellman%20Ford/Untitled%204.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-06-img/Untitled%204.png)\n\n3.  **사이클 검사**: 음의 가중치가 포함된 사이클이 있는 지 검사한다. 존재하면 false, 존재하지 않으면 true를 반환\n\n> 벨만-포드는 음수 가중치가 사이클을 이루고 있으면 적용할 수 없다. 사이클을 돌면 돌수록 거리 가중치 값이 작아져 최단 경로를 구하는 의미가 없어지기 때문이다. 따라서 2번 과정 수행 후 마지막으로 그래프 모든 엣지에 대해 간선 경감을 1번 수행하여 값이 업데이트하는 지 확인해야한다. 업데이트가 된다면 음수 가중치 사이클이 존재한다는 의미로 결과를 구할 수 없다는 false를 반환하면 된다.\n\n**시간복잡도**\n\n- 시작 정점을 제외한 나머지 정점의 개수(|V| - 1)만큼 간선 경감을 반복한 후 음수 사이클 검사를 위해 그래프의 모든 간선에 대한 탐석을 1번 더 수행한다. O(|V|\\*|E|)\n- 최악(Dense Graph)의 경우 다익스트라는 O(|V|²)의 시간 복잡도를 가지며 벨만-포드는 O(|V|³)의 시간 복잡도를 가진다.\n\n### 백준 문제 풀이\n\n11657 타임머신\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #define INF 2e9\n    using namespace std;\n    vector<pair<int, int> > w[501];\n    int d[501];\n    int n, m;\n\n    bool solve() {\n    \tbool cycle = false;\n    \tfor (int i=1; i<=n+1; i++) {\n    \t\tfor (int j=1; j<n+1; j++) {\n    \t\t\tfor (int k=0; k<w[j].size(); k++) {\n    \t\t\t\tif (d[j] == INF) continue;\n    \t\t\t\tif (d[j] + w[j][k].first < d[w[j][k].second]) {\n    \t\t\t\t\td[w[j][k].second] = d[j] + w[j][k].first;\n    \t\t\t\t\tif (i == n+1) {\n    \t\t\t\t\t\treturn true;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn cycle;\n    }\n    int main() {\n    \tint a, b, c;\n    \tcin >> n >> m;\n\n    \tfill(&d[1], &d[501], INF);\n    \td[1] = 0;\n    \tfor (int i=0; i<m; i++) {\n    \t\tcin >> a >> b >> c;\n    \t\tw[a].push_back({c, b});\n    \t}\n    \tif (solve()) {\n    \t\tcout << \"-1\";\n    \t} else {\n    \t\tfor (int i=2; i<n+1; i++) {\n    \t\t\tif (d[i] == INF) cout << \"-1\" << \"\\n\";\n    \t\t\telse cout << d[i] << \"\\n\";\n    \t\t}\n    \t}\n\n    \treturn 0;\n    }\n```\n\n**참고**\n\n[벨만-포드 알고리즘](https://ratsgo.github.io/data%20structure&algorithm/2017/11/27/bellmanford/)\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"5219daaeb39e005c6bc68059ba819110107f2daf","text":"# 최단 경로 알고리즘 - Dijkstra\n\n- Title : 최단 경로 알고리즘 - Dijkstra\n- Date : 2020-03-01\n- Category: Algorithm\n\n## Why?\n\n[1753번: 최단경로](https://www.acmicpc.net/problem/1753)\n\n> 최단 경로 문제는 네트워크에서 정점 u와 정점 v를 연결하는 경로 중에서 간선들의 가중치 합이 최소가 되는 경로를 찾는 문제다.\n\n## Dijkstra의 최단 경로 알고리즘\n\n네트워크에서 **하나의** 시작 정점으로부터 **모든** 다른 정점까지의 최단 경로를 찾는 알고리즘이다. 최단 경로는 경로의 길이순으로 구해진다.\n\n- 집합 S는 정점 v로부터의 최단 경로가 이미 발견된 정점들의 집합이다.\n- distance[]는 시작 정점에서 집합 S에 있는 정점을 거쳐서 다른 정점으로 가는 최단 거리를 기록한 배열이다.\n- distance 배열의 초깃값은 시작 정점이 v라면 distance[v] = 0 이고 다른 정점에 대한 distance 값은 v와 해당 정점 간의 가중치가 된다. 정점 v와 w와 직접 간선이 없다면 무한대 값을 저장한다.\n- 알고리즘 매 단계에서 집합 S에 없는 정점 중 가장 distance 값이 작은 정점을 S에 추가한다. 왜냐하면 현재 정점 u에서 x, y, z 중 y의 가중치가 최소라면 u → y가 u → x → y 또는 u → y → x 등 어떤 정점을 거쳐서 y로 가든 u → y 가 최단 경로이기 때문이다.\n- 새로운 정점 x가 S에 추가되면 S에 있지 않은 다른 정점들의 distance 값을 수정한다. 새로 추가된 정점 x를 거쳐 다른 정점까지 가는 거리와 기존의 거리를 비교하여 더 작은 거리로 distance 값을 수정한다. **distance[w] = min(distance[w], distance[x] + weight[x][w])** 식과 같다.\n\n![Dijkstra/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-01-img/Untitled.png)\n\n네트워크에 n개의 정점이 있다면, 다익스트라 최단 경로 알고리즘은 주 반복문을 n번 반복하고 내부 반복문을 2n번 반복하므로 **O(n²)** 의 복잡도를 가진다. distance를 배열이 아닌 **우선순위 큐**를 사용하면 더 빠르게 수행할 수 있다.\n\n### 백준 문제 풀이\n\n**1753번 최단경로**\n\n[1753번: 최단경로](https://www.acmicpc.net/problem/1753)\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #include <queue>\n    #define MAX_W 98765432\n    using namespace std;\n\n    vector<pair<int, int> > graph[20001];\n\n    vector<int> dijkstra (int s, int cv) {\n    \tvector<int> dis(cv, MAX_W);\n    \tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n    \tpq.push(make_pair(0, s));\n    \tdis[s] = 0;\n\n    \twhile (!pq.empty()) {\n    \t\tint cost = pq.top().first;\n    \t\tint v = pq.top().second;\n    \t\tpq.pop();\n    \t\tif (dis[v] < cost) continue;\n\n    \t\tfor (int i=0; i<graph[v].size(); i++) {\n    \t\t\tif (dis[graph[v][i].second] >= cost + graph[v][i].first) {\n    \t\t\t\tpq.push(make_pair(cost + graph[v][i].first, graph[v][i].second));\n    \t\t\t\tdis[graph[v][i].second] = cost + graph[v][i].first;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn dis;\n    }\n    int main() {\n    \tint v, e, s;\n    \tint a, b, c;\n\n    \tscanf(\"%d %d\", &v, &e);\n    \tscanf(\"%d\", &s);\n\n    \twhile (e--) {\n    \t\tscanf(\"%d %d %d\", &a, &b, &c);\n    \t\tgraph[a].push_back(make_pair(c, b));\n    \t}\n\n    \tvector<int> dis = dijkstra(s, v + 1);\n\n    \tfor (int i=1; i<v+1; i++) {\n    \t\tif (dis[i] == MAX_W)\n    \t\t\tprintf(\"INF\\n\");\n    \t\telse\n    \t\t\tprintf(\"%d\\n\", dis[i]);\n    \t}\n\n    \treturn 0;\n    }\n```\n\n**참고**\n\n[C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539)\n"}}}},"pageContext":{"id":"f9911ac03613c935962bb92b556860145926df9d","previousPostId":"cb0f5b74980d5a8d75a84ffc8c6e5bcbd54a7dfe","nextPostId":"5219daaeb39e005c6bc68059ba819110107f2daf"}},"staticQueryHashes":["2841359383"]}