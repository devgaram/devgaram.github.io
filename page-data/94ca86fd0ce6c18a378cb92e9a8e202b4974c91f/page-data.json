{"componentChunkName":"component---src-templates-blog-post-js","path":"/94ca86fd0ce6c18a378cb92e9a8e202b4974c91f","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"94ca86fd0ce6c18a378cb92e9a8e202b4974c91f","text":"# GraphQL 알아보기\n\n- Title : GraphQL 알아보기\n- Date : 2020-03-17\n- Category : 프론트\n\n# Why?\n\nTIL 레파지토리의 문서들을 얻기 위해 Github Content API를 이용했다. 루트 폴더들, 각 폴더의 문서들, 문서의 내용 등을 REST API를 사용하여 얻었는 데 아무래도 엔드 포인트가 많다 보니 코드가 복잡해졌다. 또 내가 원하는 데이터만 받고 싶은 데 응답 구조가 정해져있다보니 응답 데이터를 직접 가공하는 수 밖에 없었다. 휴 불편하네~ 😥 불편하다. 생각하던 중 Github이 GraphQL API를 제공한다는 것을 발견했다. 예전에 잠깐 공부했을 때는 REST API보다 왜 편한지 이해를 못했는 데 역시 사람은 몸소 겪어봐야 아나보다. 직접 사용해보니 너무 너무 편했다. 그래서 오늘의 TIL은 GraphQL에 대해 정리해보려한다. \n\n# ✨ GraphQL 이란?\n\nGraphQL(gql)는 API를 위한 쿼리 언어로 API 서버에서 원하는 데이터를 효율적으로 가져올 수 있다. GraphQL을 사용하는 앱은 느린 모바일 네트워크 연결에서도 빠르게 수행할 수 있다고 한다. \n\nGraphQL API 서버는 gql로 작성된 쿼리를 입력으로 받고 쿼리를 처리한 결과를 클라이언트에게 돌려준다. HTTP API 처럼 gql도 특정 데이터베이스나 플랫폼에 종속적이지않다.\n\n네트워크 방식에도 종속적이지 않다. 일반적으로 gql의 인터페이스간 송수신은 네트워크 레이어 L7의 HTTP POST 메서드와 웹 소켓 프로토콜을 활용한다. 필요에 따라서는 L4의 TCP/UDP나 L2의 이더넷 프레임을 활용할 수 있다.\n\n## REST API와 차이점?\n\n- REST API가 여러 URL에서 데이터를 얻는 것과 달리 GraphQL은 모든 데이터를 하나의 엔드 포인트를 통해 가져올 수 있다.\n- REST API는 각 엔드포인트마다 데이터베이스 SQL 쿼리가 달라지고 gql API는 gql 스키마 타입마다 데이터베이스 SQL 쿼리가 달라진다.\n- REST API는 리소스를 URL로 표현하고 GraphQL은 Query로 표현한다고 할 수 있다.\n\n# GraphQL 구조\n\n## 📌 Query\n\nHTTP Method의 `GET` 과 비슷\n\n### **Fields**\n\n    {\n    \tplayers {\n    \t\tname\n    \t}\n    }\n\n    {\n    \t\"data\": {\n    \t\t\"players\": [\n    \t\t\t{\n    \t\t\t   \"name\": \"Pogba\"\n    \t\t\t },\n    \t\t\t {\n    \t\t\t   \"name\": \"Lukaku\"\n    \t\t\t },\n    \t\t\t {\n    \t\t\t   \"name\": \"Rashford\"\n    \t\t\t },\n    \t\t\t {\n    \t\t\t   \"name\": \"Marshal\"\n    \t\t\t }\n    \t\t]\n    \t}\n    }\n\n- 객체에서 원하는 필드만 리턴 받을 수 있다.\n- 쿼리는 한번의 요청으로 객체나 필드를 순회하여 관련된 데이터들도 가져올 수 있다. 이런 작업을 REST API에서 하려면 API 호출을 여러 번 해야한다.\n\n### **Arguments**\n\n    {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \t\"data\": {\n    \t\t\"players\": {\n    \t\t\t\"name\": \"Pogba\",\n    \t\t\t\"kit\": [\n    \t\t\t\t{\n    \t\t\t\t\t\"shirtSize\": \"large\",\n               \"shoeSize\": \"medium\"\n    \t\t\t\t}\t\t\t\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n\n- arguments를 쿼리의 필드 및 중첩된 객체들에 전달하여 원하는 데이터만 얻을 수 있다\n- REST API에서 ?name=Pogba 또는 /Pogba (/:name 형식일 때) 와 같은 목적으로 사용한다.\n\n### Aliases\n\n    {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    \tplayer(id: \"Lukaku\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \tplayer1: player(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    \tplayer2: player(id: \"Lukaku\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \t\"data\": {\n    \t\t\"player1\": {\n    \t\t\t\"name\": \"Pogba\",\n    \t\t\t\"kit\": [\n    \t\t\t\t{\n    \t\t\t\t\t\"shirtSize\": \"large\",\n               \"shoeSize\": \"medium\"\n    \t\t\t\t}\t\t\t\n    \t\t\t]\n    \t\t}\n    \t\t\"player2\": {\n    \t\t\t\"name\": \"Lukaku\",\n    \t\t\t\"kit\": [\n    \t\t\t\t{\n    \t\t\t\t\t\"shirtSize\": \"extralarge\",\n               \"shoeSize\": \"large\"\n    \t\t\t\t}\t\t\t\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n\n- 필드 이름을 겹쳐서 사용할 수는 없기에 왼쪽처럼 할 수 없다. 오른쪽 처럼 별칭을 써서 사용하면 된다.\n\n### Operation name\n\n    query PlayerDetails {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n- Operation Type: query, mutation과 같은 키워드\n- Operation Name: 이 작업이 무슨 일을 하는 지(메소드 명처럼..?)\n\n### Variables\n\n    query PlayerDetails($id: String) {\n    \tplayer(id: $id) {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n- arguments를 동적으로 받고 싶을 때 사용한다.\n- Operation Name 옆에 변수를 $변수이름: 타입 형태로 정의한다. 만약  `String!` 형태로 정의했다면 id는 **반드시** String이어야 한다.\n- 실제 argument로 사용하려면 필드명: $변수이름 형태로 사용하면 된다.\n- 전달된 변수가 없으면 디폴트로 사용할 값을 정의할 수도 있다. `$id: String = \"Pogba\"` 형태로 쓰면 된다.\n\n### Fragments\n\n    {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    \tplayer(id: \"Lukaku\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \tplayer1: player(id: \"Pogba\") {\n    \t\t...playerKit\n    \t}\n    \tplayer2: player(id: \"Lukaku\") {\n    \t\t...playerKit\n    \t}\n    }\n    \n    fragment playerKit on player {\n    \tname,\n    \tkit {\n    \t\tshirtSize,\n    \t\tshoeSize\n    \t}\n    }\n\n- 왼쪽을 보면 name과 kit이 반복된다. 이처럼 동일한 구조의 필드를 가져올 때 fragment 를 이용하면 오른쪽처럼 간편하게 쓸 수 있다.\n\n### Inline Fragments\n\n    query HeroForEpisode($ep: Episode!) {\n      hero(episode: $ep) {\n        name\n        ... on Droid {\n          primaryFunction\n        }\n        ... on Human {\n          height\n        }\n      }\n    }\n\n    {\n      \"data\": {\n        \"hero\": {\n          \"name\": \"R2-D2\",\n          \"primaryFunction\": \"Astromech\"\n        }\n      }\n    }\n\n- 위 쿼리에서 hero 필드는 $ep 인수에 따라 Human 또는 Droid 타입인 Character 인터페이스를 리턴한다.\n- 위 쿼리의 name 필드는 Character 인터페이스에 있는 값이다.\n- Fragment의 타입 질의 기능을 이용하면 Human 타입일 때, Droid 타입일 때 가져올 데이터를 정의할 수 있다.\n- 어떤 필드가 Interface나 union 타입으로 리턴된다면 inline fragment로 원하는 데이터만 받을 수 있다.\n\n    interface Character {\n      id: ID!\n      name: String!\n      friends: [Character]\n      appearsIn: [Episode]!\n    }\n    \n    type Human implements Character {\n      id: ID!\n      name: String!\n      friends: [Character]\n      appearsIn: [Episode]!\n      starships: [Starship]\n      totalCredits: Int\n    }\n    \n    type Droid implements Character {\n      id: ID!\n      name: String!\n      friends: [Character]\n      appearsIn: [Episode]!\n      primaryFunction: String\n    }\n\n### Directives\n\n    query PlayerDetails ($playerShirtDirective: Boolean!){\n        player(id: \"Pogba\") {\n            name,\n            kit {\n                shirtSize @skip(if: $playerShirtDirective)\n                bootSize\n            }\n        }\n    }\n\n- 특정 필드를 포함할 지, 스킵할 지를 정할 수 있다.\n- @skip : true면 스킵\n- @include : true면 포함\n\n## 📌 Mutation\n\nHTTP Method의 `POST` `PATCH` `DELETE` 와 비슷\n\n    mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n      createReview(episode: $ep, review: $review) {\n        stars\n        commentary\n      }\n    }\n\n    {\n      \"ep\": \"JEDI\",\n      \"review\": {\n        \"stars\": 5,\n        \"commentary\": \"This is a great movie!\"\n      }\n    }\n\n    {\n      \"data\": {\n        \"createReview\": {\n          \"stars\": 5,\n          \"commentary\": \"This is a great movie!\"\n        }\n      }\n    }\n\n**참고**\n\n[GraphQL 개념잡기](https://tech.kakao.com/2019/08/01/graphql-basic/)\n\n[Understanding Queries in GraphQL | DigitalOcean](https://www.digitalocean.com/community/tutorials/understanding-queries-in-graphql)"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"aca141df670b8b9c9474fa873d833730c6d80a8f","text":"# [자바스크립트] 이벤트 위임(Event delegation)\n\n- Title : [자바스크립트] 이벤트 위임(event delegation)\n- Date : 2020-03-20\n- Category : Javascript\n\n# Why?\n\n웹 개발자라면 이벤트 핸들러를 등록할 때 **캡처링**과 **버블링**을 적절하게 선택할 수 있어야 하지 않을까?\n```javascript\n    // 이벤트 캡처\n    element1.addEventListener('click',doSomething2,true)\n    // 이벤트 버블링\n    element2.addEventListener('click',doSomething,false)\n```\n> 🔊 익명함수로 이벤트 핸들러를 정의할 수 있는 데 이 때 화살표 함수의 this 컨텍스트는 event.currentTarget이 아님을 알고 있어야 한다. function (e) {} 형태로 정의해야 this 컨텍스트가 event.currentTarget이 된다.\n\n# addEventListener 동작 방식\n\naddEventListener() 메서드의 마지막 argument의 값으로 이벤트 전파 방식을 지정할 수 있다. true면 캡쳐, false(기본값)면 버블링으로 이벤트가 전파된다. 아래 예시로 이해를 어떤식으로 전파되는 지 이해해보자.\n```html\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <meta charset=\"utf-8\">\n      <meta name=\"viewport\" content=\"width=device-width\">\n      <title>JS Bin</title>\n    </head>\n    <body>\n      <div id=\"element1\">\n        element1\n        <div id=\"element2\">\n           element2\n          <div id=\"element3\">element3</div\n        </div>\n      </div>\n    </body>\n    </html>\n```\n```javascript\n    var element1 = document.getElementById(\"element1\");\n    var element2 = document.getElementById(\"element2\");\n    var element3 = document.getElementById(\"element3\");\n    function doSomething1(){\n      console.log(\"doSomething1\");\n    }\n    function doSomething2(){\n      console.log(\"doSomething2\");\n    }\n    function doSomething3(){\n      console.log(\"doSomething3\");\n    }\n```\n🎈 3개의 element가 버블링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,false)\n    element3.addEventListener('click',doSomething3,false)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething2`→ `doSomething1`\n- element3 클릭시 출력 :  `doSomething3`→ `doSomething2` -> `doSomething1`\n\n🎈 3개의 element가 캡처링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,true)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,true)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething1`→ `doSomething2`\n- element3 클릭시 출력 :  `doSomething1`→ `doSomething2` -> `doSomething3`\n\n🎈 맨 밖의 엘리먼트는 버블링 내부 엘리먼트는 캡처링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,true)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething2`→ `doSomething1`\n- element3 클릭시 출력 :  `doSomething2`→ `doSomething3` -> `doSomething1`\n\n🎈 섞여있으면..?\n```javascript\n    document.body.addEventListener('click',doSomething0,true)\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,false)\n```\nelement3 클릭시 출력 :  `doSomething0`→ `doSomething2` -> `doSomething3` → `doSomething1`\n\n### 테스트 결과\n\n- 이벤트 타켓에 이벤트가 발생하면 이벤트가 다른 이벤트 타켓(이벤트 핸들러가 등록된)으로 전파된다.\n- 이벤트 캡처는 이벤트 타켓의 최상위 요소(단, 이벤트 핸들러가 등록된)부터 이벤트 타켓까지 이벤트 핸들러를 처리한다.\n- 이벤트 버블링은 캡처와 반대로 이벤트 타켓부터 최상위 요소까지 이벤트 핸들러를 처리한다.\n- 섞여있으면 캡처링 우선인 이벤트 타켓부터 처리한 후 버블링을 수행한\n\n# 이벤트 버블링과 캡쳐\n\n아래 사진은 DOM 트리에서 일어나는 이벤트 전파 방법이다.\n\n[UI Events](https://www.w3.org/TR/DOM-Level-3-Events/#event-flow)\n\n![Event%20delegation/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/Untitled.png)\n\n캡처와 버블링은 두 요소(엘리먼트)가 해당 이벤트에 대한 핸들(함수)를 등록한 경우, 다른 요소 내에 중첩된 요소에서 발생하는 이벤트를 전파하는 방법이다. 이벤트 전파 모드로 요소가 이벤트를 수신하는 순서를 판별한다.\n\n## 이벤트 전파..? 신경쓰기 싫어!\n\n현재 이벤트 이후의 이벤트 전파(캡처링, 버블링)를 막고 싶다면 **`event.stopPropagation()`** 메서드를 사용하면 된다.\n\n## 이벤트는 취소하고 전파는 하고 싶어!\n\n**`event.preventDefault()`** 는 이벤트를 취소하지만 이벤트 전파를 막지 않는다. 전파를 막으려면 `event.stopPropagation()`을 사용해야한다.  주로 `a` 태그나 `submit` 태그 등 고유의 동작을 막고 원하는 이벤트 핸들러를 실행할 때 사용한다.\n\n## 메모리 이슈\n\n루프의 각 반복마다 새로운 익명 행들러 함수가 생성되는 방식으로 이벤트를 등록하지 말자. 따로 이벤트 핸들러를 생성한 후 등록하는 방식을 사용해야 메모리 소비가 줄고 `removeEventListener()`를 호출할 수 있다. 익명 함수는 참조가 유지되지않기에 이벤트 리스너를 제거할 수 없다.\n\n# 이벤트 위임(Event delegation)\n\n이벤트 발생 시 document 레벨까지 버블링 되어 올라가는 것을 활용하는 것으로 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식이다.\n\n- 동적인 엘리먼트에 대한 이벤트 처리 수월\n- 하위 엘리먼트는 자유롭게 추가 삭제 가능\n- 동일한 이벤트를 한 곳에서 관리할 수 있고 이벤트 핸들러 관리 쉽다.\n- 생성되는 이벤트 핸들러 함수가 줄어 메모리 사용량이 줄고 메모리 누수 가능성이 감소된다.\n\n참조\n\n[왜 이벤트 위임(delegation)을 해야 하는가?](https://ui.toast.com/weekly-pick/ko_20160826/)\n\n[EventTarget.addEventListener()](https://developer.mozilla.org/ko/docs/Web/API/EventTarget/addEventListener)"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"cf3a7b61b8bfe799d47adca29daf2b3c341d13a4","text":"# REST API에 대해\n\n- Title : REST API에 대해\n- Date : 2020-03-16\n- Category: Web\n\n## ✨ REST API 란?\n\nREST(Representational State Transfer)는 웹처럼 HTTP 기반의 시스템에 필요한 자원(리소스, DBMS 데이터, 이미지, 동영상, 서비스..등)에 접근하는 방식을 정해놓은 아키텍쳐다.\n\n### REST 구성\n\n- 자원(RESOURCE) - URI\n  - 리소스명은 동사보다는 명사를 사용\n- 행위(Verb) - HTTP METHOD(GET, POST, PUT, DELETE)\n- 표현(Representations)\n\n### REST 특징\n\n- **클라이언트/서버 구조** : REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로 간 의존성이 줄어든다.\n- **무상태성(Stateless)** : 클라이언트 컨텍스트(세션, 쿠키)는 서버에 저장되어서는 안 된다. API 서버는 단순히 들어오는 요청만을 처리한다.\n- **캐시 처리 가능(Cacheable)** : HTTP가 가진 캐싱 기능 적용이 가능하다. 클라이언트 응답을 캐싱할 수 있어야 한다.\n- **계층화(Layered System)** : REST 서버는 다중 계층으로 구성될 수 있다. 하지만 클라이언트는 REST 서버에 직접 연결되었는지, 또는 중간 서버를 통해 연결되었는 지를 알 수 없게 해야한다. 중간 서버는 로드 밸런싱 기능이나 공유 캐시 기능을 제공함으로써 시스템 규모 확장성을 향상시키는 데 유용하다.\n- **유니폼 인터페이스(Uniform)** : URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말한다.\n\n### URI 설계 시 주의할 점\n\n- 슬래시 구분자(/)는 계층 관계를 나타내는 데 사용한다.\n- URI 마지막 문자로 슬래시(/)를 포함하지 않는다.\n- 하이픈(-)은 URI 가독성을 높이는데 사용한다.\n- 밑줄(\\_)은 URI에 사용하지 않는다.\n- URI 경로에는 소문자가 적합하다.\n- 파일 확장자는 URI에 포함시키지 않는다.\n\n### 리소스 간의 관계 표현하는 방법\n\n사용자가 좋아하는 디바이스 목록 가져오기\n\n    GET : /users/{userid}/likes/devices\n\n### 자원을 표현하는 Collection과 Document\n\n- Collection: 문서들의 집합, 객체들의 집합\n- Document: 문서, 객체\n\n예시로 이해하기\n\n- sports, players: 컬렉션\n- soccer, 13: 다큐먼트\n\n  http:// restapi.example.com/sports/soccer/players/13\n\n**참고 99.9%**\n\n[REST API 제대로 알고 사용하기 : TOAST Meetup](https://meetup.toast.com/posts/92)\n"}}}},"pageContext":{"id":"94ca86fd0ce6c18a378cb92e9a8e202b4974c91f","previousPostId":"aca141df670b8b9c9474fa873d833730c6d80a8f","nextPostId":"cf3a7b61b8bfe799d47adca29daf2b3c341d13a4"}},"staticQueryHashes":["2685952063","2841359383"]}