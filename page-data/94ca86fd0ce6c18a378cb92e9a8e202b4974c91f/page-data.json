{"componentChunkName":"component---src-templates-blog-post-js","path":"/94ca86fd0ce6c18a378cb92e9a8e202b4974c91f","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"94ca86fd0ce6c18a378cb92e9a8e202b4974c91f","text":"# GraphQL 알아보기\n\n- Title : GraphQL 알아보기\n- Date : 2020-03-17\n- Category : 프론트\n\n# Why?\n\nTIL 레파지토리의 문서들을 얻기 위해 Github Content API를 이용했다. 루트 폴더들, 각 폴더의 문서들, 문서의 내용 등을 REST API를 사용하여 얻었는 데 아무래도 엔드 포인트가 많다 보니 코드가 복잡해졌다. 또 내가 원하는 데이터만 받고 싶은 데 응답 구조가 정해져있다보니 응답 데이터를 직접 가공하는 수 밖에 없었다. 휴 불편하네~ 😥 불편하다. 생각하던 중 Github이 GraphQL API를 제공한다는 것을 발견했다. 예전에 잠깐 공부했을 때는 REST API보다 왜 편한지 이해를 못했는 데 역시 사람은 몸소 겪어봐야 아나보다. 직접 사용해보니 너무 너무 편했다. 그래서 오늘의 TIL은 GraphQL에 대해 정리해보려한다. \n\n# ✨ GraphQL 이란?\n\nGraphQL(gql)는 API를 위한 쿼리 언어로 API 서버에서 원하는 데이터를 효율적으로 가져올 수 있다. GraphQL을 사용하는 앱은 느린 모바일 네트워크 연결에서도 빠르게 수행할 수 있다고 한다. \n\nGraphQL API 서버는 gql로 작성된 쿼리를 입력으로 받고 쿼리를 처리한 결과를 클라이언트에게 돌려준다. HTTP API 처럼 gql도 특정 데이터베이스나 플랫폼에 종속적이지않다.\n\n네트워크 방식에도 종속적이지 않다. 일반적으로 gql의 인터페이스간 송수신은 네트워크 레이어 L7의 HTTP POST 메서드와 웹 소켓 프로토콜을 활용한다. 필요에 따라서는 L4의 TCP/UDP나 L2의 이더넷 프레임을 활용할 수 있다.\n\n## REST API와 차이점?\n\n- REST API가 여러 URL에서 데이터를 얻는 것과 달리 GraphQL은 모든 데이터를 하나의 엔드 포인트를 통해 가져올 수 있다.\n- REST API는 각 엔드포인트마다 데이터베이스 SQL 쿼리가 달라지고 gql API는 gql 스키마 타입마다 데이터베이스 SQL 쿼리가 달라진다.\n- REST API는 리소스를 URL로 표현하고 GraphQL은 Query로 표현한다고 할 수 있다.\n\n# GraphQL 구조\n\n## 📌 Query\n\nHTTP Method의 `GET` 과 비슷\n\n### **Fields**\n\n    {\n    \tplayers {\n    \t\tname\n    \t}\n    }\n\n    {\n    \t\"data\": {\n    \t\t\"players\": [\n    \t\t\t{\n    \t\t\t   \"name\": \"Pogba\"\n    \t\t\t },\n    \t\t\t {\n    \t\t\t   \"name\": \"Lukaku\"\n    \t\t\t },\n    \t\t\t {\n    \t\t\t   \"name\": \"Rashford\"\n    \t\t\t },\n    \t\t\t {\n    \t\t\t   \"name\": \"Marshal\"\n    \t\t\t }\n    \t\t]\n    \t}\n    }\n\n- 객체에서 원하는 필드만 리턴 받을 수 있다.\n- 쿼리는 한번의 요청으로 객체나 필드를 순회하여 관련된 데이터들도 가져올 수 있다. 이런 작업을 REST API에서 하려면 API 호출을 여러 번 해야한다.\n\n### **Arguments**\n\n    {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \t\"data\": {\n    \t\t\"players\": {\n    \t\t\t\"name\": \"Pogba\",\n    \t\t\t\"kit\": [\n    \t\t\t\t{\n    \t\t\t\t\t\"shirtSize\": \"large\",\n               \"shoeSize\": \"medium\"\n    \t\t\t\t}\t\t\t\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n\n- arguments를 쿼리의 필드 및 중첩된 객체들에 전달하여 원하는 데이터만 얻을 수 있다\n- REST API에서 ?name=Pogba 또는 /Pogba (/:name 형식일 때) 와 같은 목적으로 사용한다.\n\n### Aliases\n\n    {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    \tplayer(id: \"Lukaku\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \tplayer1: player(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    \tplayer2: player(id: \"Lukaku\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \t\"data\": {\n    \t\t\"player1\": {\n    \t\t\t\"name\": \"Pogba\",\n    \t\t\t\"kit\": [\n    \t\t\t\t{\n    \t\t\t\t\t\"shirtSize\": \"large\",\n               \"shoeSize\": \"medium\"\n    \t\t\t\t}\t\t\t\n    \t\t\t]\n    \t\t}\n    \t\t\"player2\": {\n    \t\t\t\"name\": \"Lukaku\",\n    \t\t\t\"kit\": [\n    \t\t\t\t{\n    \t\t\t\t\t\"shirtSize\": \"extralarge\",\n               \"shoeSize\": \"large\"\n    \t\t\t\t}\t\t\t\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n\n- 필드 이름을 겹쳐서 사용할 수는 없기에 왼쪽처럼 할 수 없다. 오른쪽 처럼 별칭을 써서 사용하면 된다.\n\n### Operation name\n\n    query PlayerDetails {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n- Operation Type: query, mutation과 같은 키워드\n- Operation Name: 이 작업이 무슨 일을 하는 지(메소드 명처럼..?)\n\n### Variables\n\n    query PlayerDetails($id: String) {\n    \tplayer(id: $id) {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n- arguments를 동적으로 받고 싶을 때 사용한다.\n- Operation Name 옆에 변수를 $변수이름: 타입 형태로 정의한다. 만약  `String!` 형태로 정의했다면 id는 **반드시** String이어야 한다.\n- 실제 argument로 사용하려면 필드명: $변수이름 형태로 사용하면 된다.\n- 전달된 변수가 없으면 디폴트로 사용할 값을 정의할 수도 있다. `$id: String = \"Pogba\"` 형태로 쓰면 된다.\n\n### Fragments\n\n    {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    \tplayer(id: \"Lukaku\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \tplayer1: player(id: \"Pogba\") {\n    \t\t...playerKit\n    \t}\n    \tplayer2: player(id: \"Lukaku\") {\n    \t\t...playerKit\n    \t}\n    }\n    \n    fragment playerKit on player {\n    \tname,\n    \tkit {\n    \t\tshirtSize,\n    \t\tshoeSize\n    \t}\n    }\n\n- 왼쪽을 보면 name과 kit이 반복된다. 이처럼 동일한 구조의 필드를 가져올 때 fragment 를 이용하면 오른쪽처럼 간편하게 쓸 수 있다.\n\n### Inline Fragments\n\n    query HeroForEpisode($ep: Episode!) {\n      hero(episode: $ep) {\n        name\n        ... on Droid {\n          primaryFunction\n        }\n        ... on Human {\n          height\n        }\n      }\n    }\n\n    {\n      \"data\": {\n        \"hero\": {\n          \"name\": \"R2-D2\",\n          \"primaryFunction\": \"Astromech\"\n        }\n      }\n    }\n\n- 위 쿼리에서 hero 필드는 $ep 인수에 따라 Human 또는 Droid 타입인 Character 인터페이스를 리턴한다.\n- 위 쿼리의 name 필드는 Character 인터페이스에 있는 값이다.\n- Fragment의 타입 질의 기능을 이용하면 Human 타입일 때, Droid 타입일 때 가져올 데이터를 정의할 수 있다.\n- 어떤 필드가 Interface나 union 타입으로 리턴된다면 inline fragment로 원하는 데이터만 받을 수 있다.\n\n    interface Character {\n      id: ID!\n      name: String!\n      friends: [Character]\n      appearsIn: [Episode]!\n    }\n    \n    type Human implements Character {\n      id: ID!\n      name: String!\n      friends: [Character]\n      appearsIn: [Episode]!\n      starships: [Starship]\n      totalCredits: Int\n    }\n    \n    type Droid implements Character {\n      id: ID!\n      name: String!\n      friends: [Character]\n      appearsIn: [Episode]!\n      primaryFunction: String\n    }\n\n### Directives\n\n    query PlayerDetails ($playerShirtDirective: Boolean!){\n        player(id: \"Pogba\") {\n            name,\n            kit {\n                shirtSize @skip(if: $playerShirtDirective)\n                bootSize\n            }\n        }\n    }\n\n- 특정 필드를 포함할 지, 스킵할 지를 정할 수 있다.\n- @skip : true면 스킵\n- @include : true면 포함\n\n## 📌 Mutation\n\nHTTP Method의 `POST` `PATCH` `DELETE` 와 비슷\n\n    mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n      createReview(episode: $ep, review: $review) {\n        stars\n        commentary\n      }\n    }\n\n    {\n      \"ep\": \"JEDI\",\n      \"review\": {\n        \"stars\": 5,\n        \"commentary\": \"This is a great movie!\"\n      }\n    }\n\n    {\n      \"data\": {\n        \"createReview\": {\n          \"stars\": 5,\n          \"commentary\": \"This is a great movie!\"\n        }\n      }\n    }\n\n**참고**\n\n[GraphQL 개념잡기](https://tech.kakao.com/2019/08/01/graphql-basic/)\n\n[Understanding Queries in GraphQL | DigitalOcean](https://www.digitalocean.com/community/tutorials/understanding-queries-in-graphql)"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"4f925fc92243abb58588445af492b3fed43f4848","text":"# 가깝고도 먼 HTML 1탄\n\n- Title : 가깝고도 먼 HTML 1탄\n- Date : 2020-03-28\n- Category : 프론트\n\n# WHY?\n\nHTML, 잘 알고 있다고 생각했으나 지식이 구멍이 뻥뻥 뚫려있었다. 그래서 시작한 **가깝고도 먼 HTML!** 오늘부터 GO GO!\n\n# `< !DOCTYPE>` 을 왜 선언할까?\n\n> HTML 문서를 작성할 때 항상 DOCTYPE을 문서의 맨 위에 선언한다. ... 왜 선언할까?\n\n`<html>` 태그 전에 선언되야하며 `<!DOCTYPE>` 을 통해 브라우저가 해당 웹 문서가 어떤 타입(HTML5, HTML, XHTML)의 문서인지 파악할 수 있다. 웹 브라우저에게 HTML 버전을 알려주는 역할을 한다. HTML2 ~ HTML4는 SGML(Standard Generalized Markup Language, HTML 할아버지)에 기반을 두어 만들어져서 `<!DOCTYPE>` 을 통한 DTD 참조가 필요하다. 반면에 HTML5는 SGML에 기반을 두지 않아서 DTD 참조가 필요 없고 표준 모드로 작동되게 하는 역할만 하면 되서`<!DOCTYPE html>` 으로 간단하게 선언할 수 있다. \n\nDTD(Document Type Definition: 문서형 정의)는 마크업 언어를 위한 규칙으로 HTML5, XHTML, HTML 등의 문서 형식을 정의할 수 있다. `<!DOCTYPE>` 과 같은 문법을 사용한다. 기술한 유형에 따라 **마크업 문서의 요소와 속성등을 처리하며 유효성 검사 에 이용**된다. DTD를 생략하는 경우 웹 브라우저가 표준 모드가 아니라 비 표준 모드로 렌더링되어 크로스 브라우징에 어려움을 겪는다.\n\n# head 태그에는 무엇이 있을까? 메타가 있죠.\n\n> 보통 에디터의 자동 완성으로 HTML5 기본 형태를 작성한 후 `<body>` 부터 태그를 작성했다. `<body>` 앞은 신경쓰지도 않았다. 물론 예전에 일할 때 페이지 공유 기능을 위해 메타 태그를 설정한 적이 있었지만, 가물가물하니 다시 정리해보았다.\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <meta charset='utf-8'>\n      <meta http-equiv='X-UA-Compatible' content='IE=edge'>\n      <title>Page Title</title>\n      <meta name='viewport' content='width=device-width, initial-scale=1'>\n      <link rel='stylesheet' type='text/css' media='screen' href='main.css'>\n      <script src='main.js'></script>\n    </head>\n    <body>\n      \n    </body>\n    </html>\n\n## HTML head란?\n\nhead는 페이지를 열 때 브라우저에 표시되지는 않는다. head는 `<title>`, `CSS 링크`, `favicon`(사이트 아이콘), `메타 데이터`(작성자, 중요한 키워드 같은 HTML에 대한 내용)를 포함한다.\n\n## 메타데이터 `<meta>` 요소들\n\n### `<meta charset='utf-8'>`\n\n문서에서 허용하는 encoding에 대해 표시\n\n### Viewport\n\n모바일 브라우저들은 뷰포트로 알려진 가상 window 상에 페이지를 렌더링한다. 데스크탑의 뷰포트는 브라우저 창(visible area)의 뷰포트와 같고 사용자가 창의 크기를 조절하면 뷰포트의 크기도 조절된다. 웹 페이지가 뷰포트보다 크면 스크롤 하여 나머지 영역을 볼 수 있다. 반면에 모바일 뷰포트는 웹 브라우저 창보다 크거나 작을 수 있고 상하좌우로 움직이거나, 더블 탭, 줌인, 줌아웃을 통해 뷰포트의 배율을 변경할 수 있다. \n\n뷰포트를 설정안하면 기본 뷰포트가 980px라 페이지가 작게 보인다. ~~아.. 그래서 예전에 작게 보였었구나..~~\n\n기본 사용법\n\n`<meta name='viewport' content='width=device-width, initial-scale=1'>`\n\n- width : viewport의 가로 크기를 조정한다. 숫자가 들어갈 수도 있다. device-width는 100% 스케일에서 css 픽셀들로 계산된 화면의 폭을 의미한다. 즉 기기의 가로 크기에 맞게 설정된다.\n- initial-scale : 페이지가 처음 로딩될 때 줌 레벨을 조정한다. 값이 1이면 CSS 픽셀과 기기 종속적인 픽셀 간의 1:1 관계를 형성한다.\n\n> 미디어 쿼리(@media) 에서 선언된 width 범위에 따라 css를 적용하는 반응형 웹을 만드려면 `width=device-width`를 설정해야한다.\n\n### IE 문서 모드\n\n같은 웹문서를 IE 버전에 따라 마크업과 CSS를 다르게 렌더링하는 경우가 있다. 이 문제를 해결하기 위해 MS는 호환성 보기(쿼크 모드 == 비표준모드) 기능을 제공한다. 하지만 모든 사용자가 직접 호환성 보기를 설정하는 것은 불가능한 일이라 아래 메타태그가 등장했다.\n\n`<meta http-equiv='X-UA-Compatible' content='IE=edge'>` \n\n`content='IE=edge'` 이 메타 태그를 넣으면 자동으로 호환성 보기 기능이 활성화 된다. IE=edge로 선언하면 IE 버전 중 가장 최신 모드를 기준으로 보여지도록 하겠다는 의미다. 이 때, DOCTYPE 선언과 함께 사용해야 유효하다.\n\n# HTML에 CSS와 Javascript 적용하기\n\n## `<link>` 의 위치\n\n`<link>` 는 현재 문서와 외부 리소스의 관계를 명시할 때 사용한다. 스타일 시트를 연결할 때 제일 많이 사용하지만, 사이트 아이콘 연결 등 여러 가지로 쓰일 수 있다. 항상 문서의 **head** 부분에 위치하며 ret=\"stylesheet\" 와 href=\"경로\" 속성을 가진다. head에 놓아야 화면이 여러번 렌더링되는 것을 줄일 수 있다.\n\n## `<script>` 의 위치\n\n`<script>` 요소는 실행 가능한 코드를 문서에 포함하거나 참조할 때 사용한다. head에 들어갈 필요는 없고 `</body>` 태그 바로 앞, 문서 본문의 맨 끝에 넣는 것이 좋다. 자바스크립트를 적용하기 전에 브라우저가 모든 HTML 내용을 읽었는지 확인하여 자바스크립트가 아직 존재하지 않은 요소에 접근하는 경우를 방지해야 한다.\n\n# `<script>` 요소의 defer, async 속성의 차이점\n\n브라우저는 구문 분석을 진행하다 인라인 스크립트(`<script>` 내부에 코드 작성하는 방식) 또는 `async`, `defer`, `type=\"module\"` 속성이 없는 스크립트에 도달하면 스크립트를 가져온 후 실행하기 전까지 분석을 중단한다. HTML이 화면에 출력되는 시간이 길어져 사용자의 불편을 유발한다.\n\n## async\n\nasync 속성이 있으면 HTML 구문 분석 중에도 스크립트를 비동기적으로 가져올 수 있고 사용이 가능해지는 즉시 수행한다. 실행 순서가 다운로드 완료 시점이므로 실행 순서가 중요한 스크립트들에 async를 사용할 때는 유의해야 한다.\n\n## defer\n\nasync과 마찬가지로 브라우저가 HTML 구문 분석을 수행 중에도 스크립트를 다운로드 할 수 있다. 하지만 구문 분석이 완료된 후, **DOMContentLoaded** 발생 이전에 스크립트가 실행된다. defer 속성을 가진 스크립트는 문서 상의 순서를 따라 실행된다.\n\n> `DOMContentLoaded` 이벤트는 초기 HTML 문서를 완전히 불러오고 분석했을 때 발생한다. 스타일 시트, 이미지, 하위 프레임의 로딩은 기다리지 않는다.\n\n# HTML5의 섹셔닝 요소들\n\n> div로 뼈대를 만들던 시대는 지나갔다. HTML5부터 등장한 구조를 위한 태그들.. 잘 알고 잘 사용하고 있을까?\n\nHTML5 에서는 `<header>` `<nav>` `<aside>` `<article>` `<section>` `<footer>` 등의 섹셔닝 요소가 생겨 좀 더 시멘틱한(의미 있는) 마크업 작업을 할 수 있고 여기에 h1 ~ h6 로 섹션의 제목을 작성하면 좋다. 휴. 이제 `<div>` 로 레이아웃을 만들지 않아도 된다. \n\n![HTML%201/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Front/images/2020-03-28-img/Untitled.png)\n\n[https://www.w3schools.com/html/html5_semantic_elements.asp](https://www.w3schools.com/html/html5_semantic_elements.asp)\n\n### SECTION\n\n`<section>` 은 테마별로 연관된 컨텐츠를 묶어 더 큰 **논리적**인 단위를 형성할 수 있게 돕는다. 하나의 페이지 안에서 **주제가 다른 영역을 구분 짓거나 하나의 글을 부분으로 나누기도 한다.** 주로 heading 요소들과 함께 사용한다. 스타일링이나 스크립트를 위해서 엘리먼트들을 감싸는 요소가 필요하다면 `<section>` 을 사용하지 말고 문서 구조상 특별한 의미가 없는 `<div>` 를 사용해야 한다.\n\n- 예) 홈페이지의 뉴스, 긴 글의 세부 사항과 같은 관련 컨텐츠의 묶음\n\n### ARTICLE\n\n`<article>` 은 문서, 페이지, 애플리케이션, 사이트 안에 들어가는 **독립적**으로 구성할 수 있는 컴포넌트로 별도로 배포하거나 재사용하기 위한 구조다. `<article>` 은 완전히 떼어내 다른 사이트에 붙여도 그 의미를 사용자가 알 수 있는 컨텐츠를 담으면 된다. article 요소 안에 article이 들어간 경우, 밖의 article 요소의 내용과 안쪽의 article 요소의 내용이 관련있다는 것을 의미한다. article 중첩 사용은 피하는 게 좋고 대신 논리적인 부분들을 section 요소로 사용하면 된다.\n\n- 예) 블로그에서 글, 포럼에서 포스팅, 코멘트 등\n\n### NAV\n\n`<nav>`는 사이트 네비게이션(다른 페이지로의 이동) 또는 같은 페이지에서 섹션 이동을 위한 네비게이션 링크 목록을 담는 섹션이다.  페이지 안의 모든 링크 그룹이 nav로 기술될 필요는 없다.\n\n    <nav>\n    \t<h1>메인 내비게이션</h1>\n    \t<ul>\n    \t\t<li>메뉴1</li>\n    \t\t<li>메뉴2</li>\n    \t</ul>\n    </nav>\n\n### ASIDE\n\n`<aside>`  본문 컨텐츠 흐름과 분리되지만 약간의 관련성이 있는 컨텐츠에 사용한다.\n\n- 예) 관련 사이트 링크나 광고, nav 요소의 그룹, 메인 콘텐츠와 별도의 내용이라고 생각되는 것, 사이드바, 글의 발췌, 각주 부분, 글에 대한 정보, 여백을 메우는 추가 정보, 코멘트 세션\n\n### HEADER\n\n`<header>` 는 소개나 내비게이션 기능들의 묶음을 나타낸다. 보통 문서나 section의 최상단에 나타나지만, 꼭 그래야 할 필요는 없으며 여러번 사용 가능하다. 한 섹션의 목차나 검색폼, 관련 로고 등을 감싸는 용도로 사용할 수 있다.\n\n### FOOTER\n\n`<footer>` 는 페이지를 만든 사람, 저작권 정보, 연관된 컨텐츠에 대한 링크, 블로그 포스트 작성자, 발행일시 등에 쓰인다. 이 요소는 가장 가까운 섹션의 푸터를 의미한다. 작성자의 연락처는 footer 안의 `<address>` 로 표현, 저작권은 `<small>`로 표현한다.\n\n### FIGURE\n\n`<figure>` 요소는 이미지와 캡션을 그룹화하여 독립적인 컨텐츠를 표현할 때 사용한다. `<figurecaption>` 요소를 사용해 설명을 붙일 수 있다. \n\n    <figure>\n        <img src=\"/media/examples/elephant-660-480.jpg\"\n             alt=\"Elephant at sunset\">\n        <figcaption>An elephant at sunset</figcaption>\n    </figure>\n\n### MAIN\n\n`<main>` 말 그대로 문서의 메인 컨텐츠를 표현할 때 사용하며 `<main>` 안의 내용은 문서에서 유일해야한다. 여러 문서에서 반복적으로 사용되는 사이드바, 네비게이션, 로고, 검색 폼 등을 포함해서는 안되며 문서에 `<main>`은 한 개 여야 한다.\n\n# `<ul>` `<ol>` `<dl>` 의 차이점\n\n> HTML에서 목록을 표현하는 요소는? 각 요소의 차이점은?\n\n### ul(Unordered List)\n\n순서가 없는 목록을 표현할 때 사용하며 목록 앞에 점이나 사각형 등의 도형이 붙는다. 목록의 내용은 `<li>` 로 만든다.\n\n### ol(Ordered List)\n\n순서가 있는 목록을 표현할 때 사용하며 1, 2, 3... 처럼 차례대로 증가하는 번호가 붙는다. 목록의 내용은 `<li>` 로 만든다.\n\n### dl(Definition List)\n\n용어와 그 뜻을 나열할 때 사용한다. 용어는 `<dt>` , 뜻은 `<dd>` 로 만든다.\n\n참조\n\n[[HTML5] 4-1장 구조를 위한 태그](https://webdir.tistory.com/86?category=607030)"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d4a60dea091fb5b6e0163278ddd1345bb5131c7c","text":"# Pattern Searching - KMP Algorithm\n\n- Title : Pattern Searching - KMP Algorithm\n- Date : 2020-03-11\n- Category: Algorithm\n\n## KMP\n\nkmp 알고리즘은 Pattern Searching - Naive Alogorithm(TIL 알고리즘 파트에서 내용을 볼 수 있음)과 비슷하나 0~N(탐색문자길이) 탐색 중 적절하게 문자를 건너뛴다. 아래 예시로 이해해보자.\n\n- txt[] = ABABCAAA\n- pat[] = ABABD\n\n첫번째 윈도우 탐색 결과 패턴을 찾지는 못했다.\n\n- txt[] = `ABABC`AAA\n- pat[] = `ABABD`\n\nNaive 알고리즘 방식대로 이어서 두번째 윈도우를 탐색해보자.\n\n- txt[] = A`BABCA`AA\n- pat[] = `ABABD`\n\nNaive 알고리즘 방식대로 이어서 세번째 윈도우를 탐색해보자.\n\n- txt[] = AB`ABCAA`A\n- pat[] = `ABABD`\n\n하지만 KMP 알고리즘은 적절하게 문자를 건너뛰어서 첫번째 윈도우 후 다음으로 탐색할 두번째 윈도우는 아래와 같다.\n\n- txt[] = AB`ABCAA`A\n- pat[] = `ABABD`\n\n첫번째 윈도우 탐색 결과 ABAB까지는 패턴과 일치하는 것을 이용한 것이다. 패턴의 부분 문자열이기도한 ABAB는 접두사 AB와 접미사 AB가 일치한다. 다음 패턴의 시작점을 접미사의 시작점으로 할 수가 있는 거다.\n\n## lps[] 란?\n\n- lps 배열의 크기는 패턴의 길이와 같고 패턴 탐색 시 몇 개의 문자를 건너뛸지를 결정한다.\n- lps[i]는 패턴의 0~ i 까지의 부분 문자열에서의 접두어(prefix)와 접미어(suffix)가 같은 부분 문자열 중 가장 긴 것의 길이다. 단 접두어로 전체 문자열은 허용하지않는다.\n\n## Ips[] 예시\n\n\"AAAA\"\n\n- \"A\" : Ips[0] = **0** (prefix는 전체 문자열이 안됨)\n- \"AA\" : lps[1] = **1** ( prefix `A` suffix `A` )\n- \"AAA\" : lps[2] = **2** ( prefix `AA` suffix `AA` )\n- \"AAAA\" : lps[3] = **3** ( prefix `AAA` suffix `AAA` )\n\n\"ABCDE\"\n\n- \"A\" : Ips[0] = **0**\n- \"AB\" : lps[1] = **0**\n- \"ABC\" : lps[2] = **0**\n- \"ABCD\" : lps[3] = **0**\n- \"ABCDE\" : lps[4] = **0**\n\n\"AABAACAABAA\"\n\n- \"A\" : lps[0] = 0\n- \"`A` `A`\" : lps[1] = 1\n- \"AAB\" : lps[2] = 0\n- \"`A`AB`A`\" : lps[3] = 1\n- \"`AA`B`AA`\" : lps[4] = 2\n- \"AABAAC\" : lps[5] = 0\n- \"`A`ABAAC`A`\" : lps[6] = 1\n- \"`AA`BAAC`AA`\" : lps[7] = 2\n- \"`AAB`AAC`AAB`\" : lps[8] = 3\n- \"`AABA`AC`AABA`\" : lps[9] = 4\n- \"`AABAA`C`AABAA`\" : lps[10] = 5\n\n## lps를 이용해 탐색하기\n\n- 현재 txt 윈도우에서 pat[j] j는 0부터 비교를 시작하기\n- txt[i]와 pat[j]가 일치하면 i와 j를 증가하기\n- txt[i]와 pat[j]가 일치하지않으면\n  - 패턴 0~j-1과 탐색문자 i-j~i-1 까지는 일치한다는 것은 알고 있다.\n  - lps[j-1]은 패턴의 0~j-1 부분 문자열의 접두어 접미어가 일치하는 부분 문자열 중 길이가 가장 긴 값이라는 것은 위 정의를 통해 이미 알고 있다.\n  - 현재 윈도우 txt[i-j~i-1]에서 lps[j-1]만큼은 탐색할 필요는 없다.\n\n## C++\n\n\"AABAACAABAA\"\n\n- lps[0] = 0\n- i = 1, len = 0 ⇒ **lps[1] = 1**\n  - pat[1] == pat[0] , len=1, lps[1] = 1, i = 2\n- i = 2, len = 1\n  - pat[2] != pat[1] && len ! = 0, len = lps[1-1] =lps[0] = 0\n- i = 2, len = 0 ⇒ **lps[2] = 0**\n  - pat[2] ≠ pat[0] && len == 0, lps[2] = 0, i = 3\n\n```cpp\n    #include <iostream>\n    #include <cstring>\n    using namespace std;\n\n    void computeLPSArray(char* pat, int M, int *lps) {\n    \t// 현재까지 계산한 lps 중 가장 큰 값\n    \tint len = 0;\n    \t// 부분문자열 길이가 1이면 lps 값은 언제나 0\n    \tlps[0] = 0;\n\n    \t// i ~ M - 1 까지 계산\n    \tint i = 1;\n    \twhile (i < M) {\n    \t\tif (pat[i] == pat[len]) {\n    \t\t\tlen++;\n    \t\t\tlps[i] = len;\n    \t\t\ti++;\n    \t\t} else {\n    \t\t\tif (len != 0) {\n    \t\t\t\tlen = lps[len - 1];\n    \t\t\t} else {\n    \t\t\t\tlps[i] = 0;\n    \t\t\t\ti++;\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    void KMPSearch(char* pat, char* txt) {\n    \tint M = strlen(pat);\n    \tint N = strlen(txt);\n\n    \tint lps[M];\n\n    \tcomputeLPSArray(pat, M, lps);\n\n    \tint i = 0, j = 0;\n    \twhile (i < N) {\n    \t\tif (pat[j] == txt[i]) {\n    \t\t\tj++;\n    \t\t\ti++;\n    \t\t}\n    \t\tif (j == M) {\n    \t\t\tcout << \"Found Pattern at index \" << (i - j) << endl;\n    \t\t\tj = lps[j - 1];\n    \t\t}\n    \t\t// 패턴이 일치하지않으면\n    \t\telse if (i < N && pat[j] != txt[i]) {\n    \t\t\t// 미스매칭이 1~M이면\n    \t\t\tif (j != 0)\n    \t\t\t\tj = lps[j - 1];\n    \t\t\telse // 첫 문자부터 미스매칭\n    \t\t\t\ti = i + 1;\n    \t\t}\n    \t}\n    }\n    int main() {\n    \tchar txt[] = \"AABAACAADAABAABA\";\n    \tchar pat[] = \"AABA\";\n    \tKMPSearch(pat, txt);\n    \treturn 0;\n    }\n```\n"}}}},"pageContext":{"id":"94ca86fd0ce6c18a378cb92e9a8e202b4974c91f","previousPostId":"4f925fc92243abb58588445af492b3fed43f4848","nextPostId":"d4a60dea091fb5b6e0163278ddd1345bb5131c7c"}},"staticQueryHashes":["2685952063","2841359383"]}