{"componentChunkName":"component---src-templates-blog-post-js","path":"/cc4c2ba350ff2dcd7d43ee1ce312d69f9c1991b8","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"cc4c2ba350ff2dcd7d43ee1ce312d69f9c1991b8","text":"# 백준 문제 - 문자열 처리\n\n- Title : [백준] 문자열 처리\n- Date : 2020-03-27\n- Category : 알고리즘 문제 풀기\n\n# Why?\n\nC++ 로 문자열 문제를 풀 때 입출력, 파싱 등 부분에서 막힌다는 생각이 들어서 연습겸 문자열 관련 문제만 풀어보았다. 난이도는 브론즈 정도?\n\n## 11654 아스키 코드\n\n알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하세요.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tchar c;\n    \tcin >> c;\n    \tcout << (int) c;\n    \treturn 0;\n    }\n\n> 'A' 는 65, 'a' 는 97\n\n## 1152 단어의 개수\n\n영어 대소문자와 띄어쓰기만으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \tint ans = 0;\n    \tgetline(cin, str);\n    \tcin.ignore();\n    \t\n    \tfor (int i=0; i<str.size(); i++) {\n    \t\tif (str[i] == ' ') ans++;\n    \t}\n    \t\n    \tif (str[str.size()-1] == ' ') ans--;\n    \tif (str[0] != ' ') ans++;\n    \t\n    \tcout << ans;\n    \treturn 0;\n    }\n\n> 문자열을 공백으로 파싱해야할 때\n\n    #include <iostream>\n    #include <vector>\n    #include <sstream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \t\n    \tgetline(cin, str);\n    \tcin.ignore();\n    \t\n    \tstring buf;\n    \tstringstream ss(str);\n    \tvector<string> tokens;\n    \t\n    \twhile (ss >> buf) {\n    \t\ttokens.push_back(buf);\n    \t}\n    \t\n    \tcout << tokens.size();\t\n    \t\n    \treturn 0;\n    }\n\n> `getline(cin, str)` 로 공백을 포함한 문자열을 입력받을 수 있다. 단, `\\n` 을 포함하지않으므로 버퍼에서 `\\n` 을 제거하기 위해 `cin.ignore()` 을 해야한다.\n\n## 10809 알파벳 찾기\n\n알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \tcin >> str;\n    \tint ans[26];\n    \tfill(&ans[0], &ans[26], -1);\n    \t\n    \tfor (int i=str.size()-1; i>=0; i--) {\n    \t\tint c = (int) str[i];\n    \t\tans[c - 97] = i;\n    \t}\n    \t\n    \tfor (int i=0; i<26; i++) {\n    \t\tcout << ans[i] << ' ';\n    \t}\n    \t\n    \treturn 0;\n    }\n\n## 1157 단어공부\n\n알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tchar str[1000000];\n    \tint cnt[26] = {0};\n    \tint idx = 0, max = 0, maxi = 0;\n    \t\n    \tscanf(\"%s\", str);\n    \t\n    \tfor (int i=0; str[i]; i++) {\n    \t\tif (str[i] < 97) idx = str[i] - 65;\n    \t\telse idx = str[i] - 97;\n    \t\t\n    \t\tcnt[idx]++;\n    \t\tif (cnt[idx] > max) {\n    \t\t\tmax = cnt[idx];\n    \t\t\tmaxi = idx;\n    \t\t} else if (cnt[idx] == max) {\n    \t\t\tmaxi = -1;\n    \t\t}\n    \t}\n    \t\n    \tprintf(\"%c\", maxi == -1 ? '?' : maxi + 65);\n    \t\n    \treturn 0;\n    }\n\n## 2908 상수\n\n상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다. 두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오.\n\n### strcmp로 문자열 비교\n\n    #include <iostream>\n    #include <string.h>\n    using namespace std;\n    \n    int main() {\n    \tchar a[4], b[4];\n    \tscanf(\"%s %s\", a, b);\n    \t\n    \tswap(a[2], a[0]);\n    \tswap(b[2], b[0]);\n    \t\n    \tif (strcmp(a, b) < 0) printf(\"%s\", b);\n    \telse printf(\"%s\", a);\n    \t\n    \treturn 0;\n    }\n\n### atoi로 char * → int로 변경 후 비교\n\n    #include <iostream>\n    #include <string>\n    using namespace std;\n    \n    int main() {\n    \tchar a[4], b[4];\n    \tscanf(\"%s %s\", a, b);\n    \t\n    \tswap(a[2], a[0]);\n    \tswap(b[2], b[0]);\n    \t\n    \tint na = atoi(a);\n    \tint nb = atoi(b);\n    \t\n    \tif (na > nb) printf(\"%d\", na);\n    \telse printf(\"%d\", nb);\n    \t\n    \treturn 0;\n    }\n\n- a, b 값을.. 3으로 했을 때 입력을 제대로 못 받는 문제 생김 ㅜ_ㅜ\n    - c의 문자열은 `\\0` 을 기준으로 구분한다. 문자열의 끝에 있는 `\\0` 이 어떤 식으로든 없어지게 된다면 그 뒤에 `\\0` 이 나타날 때까지 진행하게 된다\n    - 123 456 일 때, a, b 크기를 3으로 하면 a에는 \"123\"이 들어간다. 그럼 `\\0` 은 b[0]에 들어갔을 거다. 이 상태로 456을 입력받으면 b[0]에 4가 쓰여진다. 마찬가지로 b의  `\\0` 도 메모리 어딘가에 들어가게된다.\n    - 즉, a 출력시 123456이 나오는 이유는 123을 입력받을 때 `\\0` 을 받지 못해 456까지 입력받게 되서다."}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"4f925fc92243abb58588445af492b3fed43f4848","text":"# 가깝고도 먼 HTML 1탄\n\n- Title : 가깝고도 먼 HTML 1탄\n- Date : 2020-03-28\n- Category : 프론트\n\n# WHY?\n\nHTML, 잘 알고 있다고 생각했으나 지식이 구멍이 뻥뻥 뚫려있었다. 그래서 시작한 **가깝고도 먼 HTML!** 오늘부터 GO GO!\n\n# `< !DOCTYPE>` 을 왜 선언할까?\n\n> HTML 문서를 작성할 때 항상 DOCTYPE을 문서의 맨 위에 선언한다. ... 왜 선언할까?\n\n`<html>` 태그 전에 선언되야하며 `<!DOCTYPE>` 을 통해 브라우저가 해당 웹 문서가 어떤 타입(HTML5, HTML, XHTML)의 문서인지 파악할 수 있다. 웹 브라우저에게 HTML 버전을 알려주는 역할을 한다. HTML2 ~ HTML4는 SGML(Standard Generalized Markup Language, HTML 할아버지)에 기반을 두어 만들어져서 `<!DOCTYPE>` 을 통한 DTD 참조가 필요하다. 반면에 HTML5는 SGML에 기반을 두지 않아서 DTD 참조가 필요 없고 표준 모드로 작동되게 하는 역할만 하면 되서`<!DOCTYPE html>` 으로 간단하게 선언할 수 있다. \n\nDTD(Document Type Definition: 문서형 정의)는 마크업 언어를 위한 규칙으로 HTML5, XHTML, HTML 등의 문서 형식을 정의할 수 있다. `<!DOCTYPE>` 과 같은 문법을 사용한다. 기술한 유형에 따라 **마크업 문서의 요소와 속성등을 처리하며 유효성 검사 에 이용**된다. DTD를 생략하는 경우 웹 브라우저가 표준 모드가 아니라 비 표준 모드로 렌더링되어 크로스 브라우징에 어려움을 겪는다.\n\n# head 태그에는 무엇이 있을까? 메타가 있죠.\n\n> 보통 에디터의 자동 완성으로 HTML5 기본 형태를 작성한 후 `<body>` 부터 태그를 작성했다. `<body>` 앞은 신경쓰지도 않았다. 물론 예전에 일할 때 페이지 공유 기능을 위해 메타 태그를 설정한 적이 있었지만, 가물가물하니 다시 정리해보았다.\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <meta charset='utf-8'>\n      <meta http-equiv='X-UA-Compatible' content='IE=edge'>\n      <title>Page Title</title>\n      <meta name='viewport' content='width=device-width, initial-scale=1'>\n      <link rel='stylesheet' type='text/css' media='screen' href='main.css'>\n      <script src='main.js'></script>\n    </head>\n    <body>\n      \n    </body>\n    </html>\n\n## HTML head란?\n\nhead는 페이지를 열 때 브라우저에 표시되지는 않는다. head는 `<title>`, `CSS 링크`, `favicon`(사이트 아이콘), `메타 데이터`(작성자, 중요한 키워드 같은 HTML에 대한 내용)를 포함한다.\n\n## 메타데이터 `<meta>` 요소들\n\n### `<meta charset='utf-8'>`\n\n문서에서 허용하는 encoding에 대해 표시\n\n### Viewport\n\n모바일 브라우저들은 뷰포트로 알려진 가상 window 상에 페이지를 렌더링한다. 데스크탑의 뷰포트는 브라우저 창(visible area)의 뷰포트와 같고 사용자가 창의 크기를 조절하면 뷰포트의 크기도 조절된다. 웹 페이지가 뷰포트보다 크면 스크롤 하여 나머지 영역을 볼 수 있다. 반면에 모바일 뷰포트는 웹 브라우저 창보다 크거나 작을 수 있고 상하좌우로 움직이거나, 더블 탭, 줌인, 줌아웃을 통해 뷰포트의 배율을 변경할 수 있다. \n\n뷰포트를 설정안하면 기본 뷰포트가 980px라 페이지가 작게 보인다. ~~아.. 그래서 예전에 작게 보였었구나..~~\n\n기본 사용법\n\n`<meta name='viewport' content='width=device-width, initial-scale=1'>`\n\n- width : viewport의 가로 크기를 조정한다. 숫자가 들어갈 수도 있다. device-width는 100% 스케일에서 css 픽셀들로 계산된 화면의 폭을 의미한다. 즉 기기의 가로 크기에 맞게 설정된다.\n- initial-scale : 페이지가 처음 로딩될 때 줌 레벨을 조정한다. 값이 1이면 CSS 픽셀과 기기 종속적인 픽셀 간의 1:1 관계를 형성한다.\n\n> 미디어 쿼리(@media) 에서 선언된 width 범위에 따라 css를 적용하는 반응형 웹을 만드려면 `width=device-width`를 설정해야한다.\n\n### IE 문서 모드\n\n같은 웹문서를 IE 버전에 따라 마크업과 CSS를 다르게 렌더링하는 경우가 있다. 이 문제를 해결하기 위해 MS는 호환성 보기(쿼크 모드 == 비표준모드) 기능을 제공한다. 하지만 모든 사용자가 직접 호환성 보기를 설정하는 것은 불가능한 일이라 아래 메타태그가 등장했다.\n\n`<meta http-equiv='X-UA-Compatible' content='IE=edge'>` \n\n`content='IE=edge'` 이 메타 태그를 넣으면 자동으로 호환성 보기 기능이 활성화 된다. IE=edge로 선언하면 IE 버전 중 가장 최신 모드를 기준으로 보여지도록 하겠다는 의미다. 이 때, DOCTYPE 선언과 함께 사용해야 유효하다.\n\n# HTML에 CSS와 Javascript 적용하기\n\n## `<link>` 의 위치\n\n`<link>` 는 현재 문서와 외부 리소스의 관계를 명시할 때 사용한다. 스타일 시트를 연결할 때 제일 많이 사용하지만, 사이트 아이콘 연결 등 여러 가지로 쓰일 수 있다. 항상 문서의 **head** 부분에 위치하며 ret=\"stylesheet\" 와 href=\"경로\" 속성을 가진다. head에 놓아야 화면이 여러번 렌더링되는 것을 줄일 수 있다.\n\n## `<script>` 의 위치\n\n`<script>` 요소는 실행 가능한 코드를 문서에 포함하거나 참조할 때 사용한다. head에 들어갈 필요는 없고 `</body>` 태그 바로 앞, 문서 본문의 맨 끝에 넣는 것이 좋다. 자바스크립트를 적용하기 전에 브라우저가 모든 HTML 내용을 읽었는지 확인하여 자바스크립트가 아직 존재하지 않은 요소에 접근하는 경우를 방지해야 한다.\n\n# `<script>` 요소의 defer, async 속성의 차이점\n\n브라우저는 구문 분석을 진행하다 인라인 스크립트(`<script>` 내부에 코드 작성하는 방식) 또는 `async`, `defer`, `type=\"module\"` 속성이 없는 스크립트에 도달하면 스크립트를 가져온 후 실행하기 전까지 분석을 중단한다. HTML이 화면에 출력되는 시간이 길어져 사용자의 불편을 유발한다.\n\n## async\n\nasync 속성이 있으면 HTML 구문 분석 중에도 스크립트를 비동기적으로 가져올 수 있고 사용이 가능해지는 즉시 수행한다. 실행 순서가 다운로드 완료 시점이므로 실행 순서가 중요한 스크립트들에 async를 사용할 때는 유의해야 한다.\n\n## defer\n\nasync과 마찬가지로 브라우저가 HTML 구문 분석을 수행 중에도 스크립트를 다운로드 할 수 있다. 하지만 구문 분석이 완료된 후, **DOMContentLoaded** 발생 이전에 스크립트가 실행된다. defer 속성을 가진 스크립트는 문서 상의 순서를 따라 실행된다.\n\n> `DOMContentLoaded` 이벤트는 초기 HTML 문서를 완전히 불러오고 분석했을 때 발생한다. 스타일 시트, 이미지, 하위 프레임의 로딩은 기다리지 않는다.\n\n# HTML5의 섹셔닝 요소들\n\n> div로 뼈대를 만들던 시대는 지나갔다. HTML5부터 등장한 구조를 위한 태그들.. 잘 알고 잘 사용하고 있을까?\n\nHTML5 에서는 `<header>` `<nav>` `<aside>` `<article>` `<section>` `<footer>` 등의 섹셔닝 요소가 생겨 좀 더 시멘틱한(의미 있는) 마크업 작업을 할 수 있고 여기에 h1 ~ h6 로 섹션의 제목을 작성하면 좋다. 휴. 이제 `<div>` 로 레이아웃을 만들지 않아도 된다. \n\n![HTML%201/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Front/images/2020-03-28-img/Untitled.png)\n\n[https://www.w3schools.com/html/html5_semantic_elements.asp](https://www.w3schools.com/html/html5_semantic_elements.asp)\n\n### SECTION\n\n`<section>` 은 테마별로 연관된 컨텐츠를 묶어 더 큰 **논리적**인 단위를 형성할 수 있게 돕는다. 하나의 페이지 안에서 **주제가 다른 영역을 구분 짓거나 하나의 글을 부분으로 나누기도 한다.** 주로 heading 요소들과 함께 사용한다. 스타일링이나 스크립트를 위해서 엘리먼트들을 감싸는 요소가 필요하다면 `<section>` 을 사용하지 말고 문서 구조상 특별한 의미가 없는 `<div>` 를 사용해야 한다.\n\n- 예) 홈페이지의 뉴스, 긴 글의 세부 사항과 같은 관련 컨텐츠의 묶음\n\n### ARTICLE\n\n`<article>` 은 문서, 페이지, 애플리케이션, 사이트 안에 들어가는 **독립적**으로 구성할 수 있는 컴포넌트로 별도로 배포하거나 재사용하기 위한 구조다. `<article>` 은 완전히 떼어내 다른 사이트에 붙여도 그 의미를 사용자가 알 수 있는 컨텐츠를 담으면 된다. article 요소 안에 article이 들어간 경우, 밖의 article 요소의 내용과 안쪽의 article 요소의 내용이 관련있다는 것을 의미한다. article 중첩 사용은 피하는 게 좋고 대신 논리적인 부분들을 section 요소로 사용하면 된다.\n\n- 예) 블로그에서 글, 포럼에서 포스팅, 코멘트 등\n\n### NAV\n\n`<nav>`는 사이트 네비게이션(다른 페이지로의 이동) 또는 같은 페이지에서 섹션 이동을 위한 네비게이션 링크 목록을 담는 섹션이다.  페이지 안의 모든 링크 그룹이 nav로 기술될 필요는 없다.\n\n    <nav>\n    \t<h1>메인 내비게이션</h1>\n    \t<ul>\n    \t\t<li>메뉴1</li>\n    \t\t<li>메뉴2</li>\n    \t</ul>\n    </nav>\n\n### ASIDE\n\n`<aside>`  본문 컨텐츠 흐름과 분리되지만 약간의 관련성이 있는 컨텐츠에 사용한다.\n\n- 예) 관련 사이트 링크나 광고, nav 요소의 그룹, 메인 콘텐츠와 별도의 내용이라고 생각되는 것, 사이드바, 글의 발췌, 각주 부분, 글에 대한 정보, 여백을 메우는 추가 정보, 코멘트 세션\n\n### HEADER\n\n`<header>` 는 소개나 내비게이션 기능들의 묶음을 나타낸다. 보통 문서나 section의 최상단에 나타나지만, 꼭 그래야 할 필요는 없으며 여러번 사용 가능하다. 한 섹션의 목차나 검색폼, 관련 로고 등을 감싸는 용도로 사용할 수 있다.\n\n### FOOTER\n\n`<footer>` 는 페이지를 만든 사람, 저작권 정보, 연관된 컨텐츠에 대한 링크, 블로그 포스트 작성자, 발행일시 등에 쓰인다. 이 요소는 가장 가까운 섹션의 푸터를 의미한다. 작성자의 연락처는 footer 안의 `<address>` 로 표현, 저작권은 `<small>`로 표현한다.\n\n### FIGURE\n\n`<figure>` 요소는 이미지와 캡션을 그룹화하여 독립적인 컨텐츠를 표현할 때 사용한다. `<figurecaption>` 요소를 사용해 설명을 붙일 수 있다. \n\n    <figure>\n        <img src=\"/media/examples/elephant-660-480.jpg\"\n             alt=\"Elephant at sunset\">\n        <figcaption>An elephant at sunset</figcaption>\n    </figure>\n\n### MAIN\n\n`<main>` 말 그대로 문서의 메인 컨텐츠를 표현할 때 사용하며 `<main>` 안의 내용은 문서에서 유일해야한다. 여러 문서에서 반복적으로 사용되는 사이드바, 네비게이션, 로고, 검색 폼 등을 포함해서는 안되며 문서에 `<main>`은 한 개 여야 한다.\n\n# `<ul>` `<ol>` `<dl>` 의 차이점\n\n> HTML에서 목록을 표현하는 요소는? 각 요소의 차이점은?\n\n### ul(Unordered List)\n\n순서가 없는 목록을 표현할 때 사용하며 목록 앞에 점이나 사각형 등의 도형이 붙는다. 목록의 내용은 `<li>` 로 만든다.\n\n### ol(Ordered List)\n\n순서가 있는 목록을 표현할 때 사용하며 1, 2, 3... 처럼 차례대로 증가하는 번호가 붙는다. 목록의 내용은 `<li>` 로 만든다.\n\n### dl(Definition List)\n\n용어와 그 뜻을 나열할 때 사용한다. 용어는 `<dt>` , 뜻은 `<dd>` 로 만든다.\n\n참조\n\n[[HTML5] 4-1장 구조를 위한 태그](https://webdir.tistory.com/86?category=607030)"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"aca141df670b8b9c9474fa873d833730c6d80a8f","text":"# [자바스크립트] 이벤트 위임(Event delegation)\n\n- Title : [자바스크립트] 이벤트 위임(event delegation)\n- Date : 2020-03-20\n- Category : Javascript\n\n# Why?\n\n웹 개발자라면 이벤트 핸들러를 등록할 때 **캡처링**과 **버블링**을 적절하게 선택할 수 있어야 하지 않을까?\n```javascript\n    // 이벤트 캡처\n    element1.addEventListener('click',doSomething2,true)\n    // 이벤트 버블링\n    element2.addEventListener('click',doSomething,false)\n```\n> 🔊 익명함수로 이벤트 핸들러를 정의할 수 있는 데 이 때 화살표 함수의 this 컨텍스트는 event.currentTarget이 아님을 알고 있어야 한다. function (e) {} 형태로 정의해야 this 컨텍스트가 event.currentTarget이 된다.\n\n# addEventListener 동작 방식\n\naddEventListener() 메서드의 마지막 argument의 값으로 이벤트 전파 방식을 지정할 수 있다. true면 캡쳐, false(기본값)면 버블링으로 이벤트가 전파된다. 아래 예시로 이해를 어떤식으로 전파되는 지 이해해보자.\n```html\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <meta charset=\"utf-8\">\n      <meta name=\"viewport\" content=\"width=device-width\">\n      <title>JS Bin</title>\n    </head>\n    <body>\n      <div id=\"element1\">\n        element1\n        <div id=\"element2\">\n           element2\n          <div id=\"element3\">element3</div\n        </div>\n      </div>\n    </body>\n    </html>\n```\n```javascript\n    var element1 = document.getElementById(\"element1\");\n    var element2 = document.getElementById(\"element2\");\n    var element3 = document.getElementById(\"element3\");\n    function doSomething1(){\n      console.log(\"doSomething1\");\n    }\n    function doSomething2(){\n      console.log(\"doSomething2\");\n    }\n    function doSomething3(){\n      console.log(\"doSomething3\");\n    }\n```\n🎈 3개의 element가 버블링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,false)\n    element3.addEventListener('click',doSomething3,false)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething2`→ `doSomething1`\n- element3 클릭시 출력 :  `doSomething3`→ `doSomething2` -> `doSomething1`\n\n🎈 3개의 element가 캡처링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,true)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,true)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething1`→ `doSomething2`\n- element3 클릭시 출력 :  `doSomething1`→ `doSomething2` -> `doSomething3`\n\n🎈 맨 밖의 엘리먼트는 버블링 내부 엘리먼트는 캡처링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,true)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething2`→ `doSomething1`\n- element3 클릭시 출력 :  `doSomething2`→ `doSomething3` -> `doSomething1`\n\n🎈 섞여있으면..?\n```javascript\n    document.body.addEventListener('click',doSomething0,true)\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,false)\n```\nelement3 클릭시 출력 :  `doSomething0`→ `doSomething2` -> `doSomething3` → `doSomething1`\n\n### 테스트 결과\n\n- 이벤트 타켓에 이벤트가 발생하면 이벤트가 다른 이벤트 타켓(이벤트 핸들러가 등록된)으로 전파된다.\n- 이벤트 캡처는 이벤트 타켓의 최상위 요소(단, 이벤트 핸들러가 등록된)부터 이벤트 타켓까지 이벤트 핸들러를 처리한다.\n- 이벤트 버블링은 캡처와 반대로 이벤트 타켓부터 최상위 요소까지 이벤트 핸들러를 처리한다.\n- 섞여있으면 캡처링 우선인 이벤트 타켓부터 처리한 후 버블링을 수행한\n\n# 이벤트 버블링과 캡쳐\n\n아래 사진은 DOM 트리에서 일어나는 이벤트 전파 방법이다.\n\n[UI Events](https://www.w3.org/TR/DOM-Level-3-Events/#event-flow)\n\n![Event%20delegation/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/Untitled.png)\n\n캡처와 버블링은 두 요소(엘리먼트)가 해당 이벤트에 대한 핸들(함수)를 등록한 경우, 다른 요소 내에 중첩된 요소에서 발생하는 이벤트를 전파하는 방법이다. 이벤트 전파 모드로 요소가 이벤트를 수신하는 순서를 판별한다.\n\n## 이벤트 전파..? 신경쓰기 싫어!\n\n현재 이벤트 이후의 이벤트 전파(캡처링, 버블링)를 막고 싶다면 **`event.stopPropagation()`** 메서드를 사용하면 된다.\n\n## 이벤트는 취소하고 전파는 하고 싶어!\n\n**`event.preventDefault()`** 는 이벤트를 취소하지만 이벤트 전파를 막지 않는다. 전파를 막으려면 `event.stopPropagation()`을 사용해야한다.  주로 `a` 태그나 `submit` 태그 등 고유의 동작을 막고 원하는 이벤트 핸들러를 실행할 때 사용한다.\n\n## 메모리 이슈\n\n루프의 각 반복마다 새로운 익명 행들러 함수가 생성되는 방식으로 이벤트를 등록하지 말자. 따로 이벤트 핸들러를 생성한 후 등록하는 방식을 사용해야 메모리 소비가 줄고 `removeEventListener()`를 호출할 수 있다. 익명 함수는 참조가 유지되지않기에 이벤트 리스너를 제거할 수 없다.\n\n# 이벤트 위임(Event delegation)\n\n이벤트 발생 시 document 레벨까지 버블링 되어 올라가는 것을 활용하는 것으로 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식이다.\n\n- 동적인 엘리먼트에 대한 이벤트 처리 수월\n- 하위 엘리먼트는 자유롭게 추가 삭제 가능\n- 동일한 이벤트를 한 곳에서 관리할 수 있고 이벤트 핸들러 관리 쉽다.\n- 생성되는 이벤트 핸들러 함수가 줄어 메모리 사용량이 줄고 메모리 누수 가능성이 감소된다.\n\n참조\n\n[왜 이벤트 위임(delegation)을 해야 하는가?](https://ui.toast.com/weekly-pick/ko_20160826/)\n\n[EventTarget.addEventListener()](https://developer.mozilla.org/ko/docs/Web/API/EventTarget/addEventListener)"}}}},"pageContext":{"id":"cc4c2ba350ff2dcd7d43ee1ce312d69f9c1991b8","previousPostId":"4f925fc92243abb58588445af492b3fed43f4848","nextPostId":"aca141df670b8b9c9474fa873d833730c6d80a8f"}},"staticQueryHashes":["2685952063","2841359383"]}