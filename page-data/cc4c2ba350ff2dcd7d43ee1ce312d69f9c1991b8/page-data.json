{"componentChunkName":"component---src-templates-blog-post-js","path":"/cc4c2ba350ff2dcd7d43ee1ce312d69f9c1991b8","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"cc4c2ba350ff2dcd7d43ee1ce312d69f9c1991b8","text":"# 백준 문제 - 문자열 처리\n\n- Title : [백준] 문자열 처리\n- Date : 2020-03-27\n- Category : 알고리즘 문제 풀기\n\n# Why?\n\nC++ 로 문자열 문제를 풀 때 입출력, 파싱 등 부분에서 막힌다는 생각이 들어서 연습겸 문자열 관련 문제만 풀어보았다. 난이도는 브론즈 정도?\n\n## 11654 아스키 코드\n\n알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하세요.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tchar c;\n    \tcin >> c;\n    \tcout << (int) c;\n    \treturn 0;\n    }\n\n> 'A' 는 65, 'a' 는 97\n\n## 1152 단어의 개수\n\n영어 대소문자와 띄어쓰기만으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \tint ans = 0;\n    \tgetline(cin, str);\n    \tcin.ignore();\n    \t\n    \tfor (int i=0; i<str.size(); i++) {\n    \t\tif (str[i] == ' ') ans++;\n    \t}\n    \t\n    \tif (str[str.size()-1] == ' ') ans--;\n    \tif (str[0] != ' ') ans++;\n    \t\n    \tcout << ans;\n    \treturn 0;\n    }\n\n> 문자열을 공백으로 파싱해야할 때\n\n    #include <iostream>\n    #include <vector>\n    #include <sstream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \t\n    \tgetline(cin, str);\n    \tcin.ignore();\n    \t\n    \tstring buf;\n    \tstringstream ss(str);\n    \tvector<string> tokens;\n    \t\n    \twhile (ss >> buf) {\n    \t\ttokens.push_back(buf);\n    \t}\n    \t\n    \tcout << tokens.size();\t\n    \t\n    \treturn 0;\n    }\n\n> `getline(cin, str)` 로 공백을 포함한 문자열을 입력받을 수 있다. 단, `\\n` 을 포함하지않으므로 버퍼에서 `\\n` 을 제거하기 위해 `cin.ignore()` 을 해야한다.\n\n## 10809 알파벳 찾기\n\n알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \tcin >> str;\n    \tint ans[26];\n    \tfill(&ans[0], &ans[26], -1);\n    \t\n    \tfor (int i=str.size()-1; i>=0; i--) {\n    \t\tint c = (int) str[i];\n    \t\tans[c - 97] = i;\n    \t}\n    \t\n    \tfor (int i=0; i<26; i++) {\n    \t\tcout << ans[i] << ' ';\n    \t}\n    \t\n    \treturn 0;\n    }\n\n## 1157 단어공부\n\n알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tchar str[1000000];\n    \tint cnt[26] = {0};\n    \tint idx = 0, max = 0, maxi = 0;\n    \t\n    \tscanf(\"%s\", str);\n    \t\n    \tfor (int i=0; str[i]; i++) {\n    \t\tif (str[i] < 97) idx = str[i] - 65;\n    \t\telse idx = str[i] - 97;\n    \t\t\n    \t\tcnt[idx]++;\n    \t\tif (cnt[idx] > max) {\n    \t\t\tmax = cnt[idx];\n    \t\t\tmaxi = idx;\n    \t\t} else if (cnt[idx] == max) {\n    \t\t\tmaxi = -1;\n    \t\t}\n    \t}\n    \t\n    \tprintf(\"%c\", maxi == -1 ? '?' : maxi + 65);\n    \t\n    \treturn 0;\n    }\n\n## 2908 상수\n\n상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다. 두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오.\n\n### strcmp로 문자열 비교\n\n    #include <iostream>\n    #include <string.h>\n    using namespace std;\n    \n    int main() {\n    \tchar a[4], b[4];\n    \tscanf(\"%s %s\", a, b);\n    \t\n    \tswap(a[2], a[0]);\n    \tswap(b[2], b[0]);\n    \t\n    \tif (strcmp(a, b) < 0) printf(\"%s\", b);\n    \telse printf(\"%s\", a);\n    \t\n    \treturn 0;\n    }\n\n### atoi로 char * → int로 변경 후 비교\n\n    #include <iostream>\n    #include <string>\n    using namespace std;\n    \n    int main() {\n    \tchar a[4], b[4];\n    \tscanf(\"%s %s\", a, b);\n    \t\n    \tswap(a[2], a[0]);\n    \tswap(b[2], b[0]);\n    \t\n    \tint na = atoi(a);\n    \tint nb = atoi(b);\n    \t\n    \tif (na > nb) printf(\"%d\", na);\n    \telse printf(\"%d\", nb);\n    \t\n    \treturn 0;\n    }\n\n- a, b 값을.. 3으로 했을 때 입력을 제대로 못 받는 문제 생김 ㅜ_ㅜ\n    - c의 문자열은 `\\0` 을 기준으로 구분한다. 문자열의 끝에 있는 `\\0` 이 어떤 식으로든 없어지게 된다면 그 뒤에 `\\0` 이 나타날 때까지 진행하게 된다\n    - 123 456 일 때, a, b 크기를 3으로 하면 a에는 \"123\"이 들어간다. 그럼 `\\0` 은 b[0]에 들어갔을 거다. 이 상태로 456을 입력받으면 b[0]에 4가 쓰여진다. 마찬가지로 b의  `\\0` 도 메모리 어딘가에 들어가게된다.\n    - 즉, a 출력시 123456이 나오는 이유는 123을 입력받을 때 `\\0` 을 받지 못해 456까지 입력받게 되서다."}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"46f1163ddd6eee6183debd713845d84759157be4","text":"# 운영체제 - 교착상태\n\n- Title : 운영체제 - 교착상태\n- Date : 2020-03-29\n- Category : 운영체제\n\n# 시스템 모델(System Model)\n\n시스템은 경쟁하는 프로세스들 사이에 분배되어야 할 유한한 자원들로 구성되며 여러 프로세스들은 해당 자원을 점유하기 위해 서로 경쟁 구도에 놓여있다. 프로세스가 자원을 사용하기 위해서는 반드시 사용하기 전에 요청을 해야 하고 사용 후에는 반드시 방출해야한다. 정상적인 작동 모드에서 프로세스는 다음의 순서로만 자원을 사용할 수 있다.\n\n1. 요청(Request) : 자원을 요청한다. 다른 프로세스가 사용 중이라서 자원를 받을 수 없다면 대기한다.\n2. 사용(Use) : 프로세스는 자원에 대해 작업 수행한다.\n3. 방출(Release) : 자원을 다 사용했으면 자원을 방출한다.\n\n# 교착상태(Deadlocks)\n\n둘 이상의 프로세스들이 자원(CPU, 메모리, 파일, 프린터 등..)을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상을 말한다. 교착 상태에서 프로세스들은 결코 실행을 끝낼 수 없으며, 시스템 자원이 묶여 있어서 다른 작업을 시작하는 것도 불가능하다.\n\n# 교착상태 필요조건\n\n교착 상태는 아래 4가지 조건이 **모두 만족**되야 발생할 수 있다.\n\n## 1. 상호배제(mutual exclusion)\n\n여러 프로세스 중 하나만 임계 구역에 진입할 수 있을 때 즉, 자원을 동시에 공유하지 못할 때\n\n## 2. 점유하며 대기(hold-and-height)\n\n최소 하나의 자원을 점유한 채, 현재 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 대기 중일 때\n\n## 3. 비선점(no-preemption)\n\n자원들을 선점할 수 없어야 한다. 즉, OS가 작동 중인 프로세스를 임의로 중단시킬 수 없을 때\n\n## 4. 순환대기(circular-wait)\n\n프로세스가 순환적으로 서로를 기다릴 때\n\n# 자원 할당 그래프(Resource Allocation Graph)\n\n자원과 프로세스의 관계를 그래프로 도식화한 **자원 할당 그래프**를 통해 데드락 유무를 파악할 수 있다. 자원 할당 그래프란 시스템 내 모든 활성 프로세스의 집합인 P와 모든 자원의 집합인 R로 정점의 집합 V를 구성한다. 이 그래프에서 P로부터 R로 뻣어나가는 간선은 특정 프로세스가 해당 자원을 요청하고 기다리는 것을 표시하며 자원 R에서 P로 뻣어나가는 간선은 할당 간선으로 해당 자원이 해당 프로세스에 할당되어있음을 나타낸다. 이러한 **자원 할당 그래프에 사이클이 있다면 데드락 위험이 있다는 의미가 된다.** 사이클이 있다고 무조건 데드락이 발생하는 것은 아니지만, 사이클이 없으면 절대로 데드락이 발생하지 않는다. 가능성이라고 얘기하는 이유는 자원이 하나의 인스턴스가 아닌 여러 개의 인스턴스를 가질 수도 있기 때문이다. 만약 자원이 여러 개의 인스턴스를 가질 수 있어서 여러 프로세스에게 자원을 제공한다면 교착 상태가 일어나지 않게 된다.\n\n# 교착상태 처리 방법\n\n## 1. 교착 상태 방지(Deadlock Prevention)\n\n교착상태 4가지 필요조건 중 하나를 만족시키지 않음으로서 교착 상태가 발생하는 것을 방지할 수 있다.\n\n### 상호배타 (Mutual exclusion)\n\n읽기 전용 파일은 여러 프로세스가 공유할 수 있게 하여 상호 배타를 깰 수가 있다. 하지만 대부분의 컴퓨터 자원들은 임계 구역 문제를 해결하기위해 상호 배타를 만족해야만 한다. 상호 배타를 깨는 건 현실적으로 불가능한 일이다.\n\n### 보유 및 대기 (Hold and wait)\n\n프로세스가 실행되기 전에 필요한 모든 자원을 요청하여 할당받도록 하는 거다. 이렇게 하면 프로세스가 다른 자원을 요청하여 할당받을 때까지 대기하는 일이 없고 모든 자원을 가지고 프로세스를 시작하기 때문에 대기하는 일이 발생하지 않는다. 하지만 많은 자원들이 할당된 후 오랫동안 사용되지 않기 때문에 자원 활용률이 떨어지는 단점이 있고 **기아 문제**가 발생할 수 있다. 식사하는 철학자를 예를 들면 젓가락을 동시에 두개를 집게 하고 하나만 집을 수 있다면 아예 못 집게 하는 방법이다. 또는 프로세스가 자원을 점유하지 않을 때만 자원을 요청할 수 있도록 하는 방법도 있다.\n\n### 비선점 (No Preemption)\n\n자원을 점유하고 있는 프로세스가 다른 자원를 요청했을 때 즉시 리자원를 사용할 수 없다면 점유하고 있던 자원을 방출(release)한다.\n\n### 순환 대기 (Circular wait)\n\n모든 자원 유형들에게 전체적인 순서를 부여하여 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 강제하는 것이다. 이를 통해 모든 자원들은 먼저 할당되는 순서가 정해져 있기 때문에 교착상태가 일어날 수 없다. 즉, 자원의 타입에 따라 프로세스마다 일대일 함수로 순서를 지정해준다. 식사하는 철학자 같은 경우는 아이디를 부여하여 홀수번은 오른쪽 왼쪽, 짝수번은 왼쪽 오른쪽 순서로 집도록 하였다. 역시 자원 활용률을 떨어트린다.\n\n## 2. 교착 상태 회피(Deadlock Avoidance)\n\n여기서는 교착 상태를 자원 요청에 대해 운영체제가 잘못 할당한 것으로 정의한다. 운영체제는 리소스 매니저, 리소스 allocator라고 불리듯이 자원을 프로세스에게 골고루 나눠주는 역할을 한다. 즉, **운영체제의 프로세스 관리 부서가 자원을 잘 못 나눠줘서 교착상태가 발생했다고 보는 것**이다. 은행 파산으로 비유할 수 있다. \n\n이러한 교착 상태는 어떤 프로세스가 요청을 할 때 미래에 대한 분석을 통해 자원 요청을 늦추는 방법으로 피할 수 있다. 시스템이 unsafe 상태가 되지 않도록 해야 하며 만약 unsafe 상태면 최대한 빨리 safe 상태로 복구한다. 데드락 가능성은 자원 할당 그래프를 구현해 파악하며 리소스 타입이 여러 개면 Banker's algorithm을 사용한다.\n\n> 안전 상태란 이러한 교착 상태 알고리즘을 설계함에 있어 각 유효 자원의 최대 개수까지 어떤 순서로 요청을 하더라도 교착상태를 야기하지 않고 모두 할당을 잘 해줄 수 있음 을 뜻한다.\n\n### Banker's Alogorithm\n\n교착상태 회피 알고리즘으로 프로세스가 리소스를 요청할때마다 수행되며, 이 자원을 할당하면 미래에 교착상태가 발생할지를 시뮬레이션한다.\n\n## 3. 교착 상태 검출 및 복구\n\n교착 상태가 일어나는 것을 허용하며 자원을 마음껏 나눠준다. 어쩌다가 교착상태가 일어나면 이를 회복하는 방법이다. 검출을 위한 오버헤드가 크다. 복구를 위해 프로세스 일부를 강제 종료하거나 자원을 선점하여 일부 프로세스에게 할당한다. 복구를 위해 주기적으로 현재 상태를 기억해둬야하며 데드락이 일어나지 않은 상태로 다시 돌아가야 한다.\n\n### 복구 1. 프로세스를 종료시키는 방법\n\n- 교착 상태 프로세스를 모두 중지\n    - 다시 처음부터 계산해야한다.\n- 교착 상태가 제거될 때까지 한 프로세스씩 중지하는 방법\n    - 각 프로세스가 중지될 때마다 아직도 교착 상태에 있는 지 매번 살펴봐야 하기 때문에 상당한 오버헤드를 유발한다.\n\n**어떤 프로세스를 종료시킬까?**\n\n- 프로세스의 중요도\n- 프로세스가 얼마나 오래 실행됐는가\n- 얼마나 많을 자원을 사용했는가\n- 프로세스가 작업을 마치기 위해 얼마나 많은 리소스가 필요한가\n- 프로세스가 종료되기 위해 얼마나 많은 리소스가 필요한가\n- 프로세스가 batch인가 interactive한가?\n\n### 복구 2. 자원 선점 방법\n\n교착 상태가 깨어질 때까지 프로세스로부터 자원을 계속적으로 선점해 다른 프로세스에게 주는 방법이다.\n\n**고려사항**\n\n- 희생자 선택(selection of a victim)\n    - 어떤 자원과 어느 프로세스가 선점될 것인가 를 고민\n- 롤백(rollback)\n    - 만약 특정 프로세스의 자원을 강제로 방출하고 선점시켰다면, 그 프로세스를 어떻게 처리 할 것인가에 대한 고민이다. 보통 가장 안전한 방법은 프로세스를 중지시키고 재시작하는 것 즉, 롤백하는 것이다.\n- 기아 상태(starvation)\n    - 특정 프로세스의 자원을 강제 방출시켜 선점을 시켜주게 되면 그 프로세스는 계속해서 희생자로 선택될 확률이 높고 이경우 그 프로세스는 영원히 실행이 완료되지 못하는 기아상태에 빠질 수 있다. 프로세스가 한정된 시간에만 희생자로 선정된다는 것을 반드시 보장 해야 한다.\n\n## 4. 교착 상태 무시\n\n실제 잘 안일어나니깐 그냥 무시하고..교착상태를 처리하는 것을 응용 개발자의 몫으로 맡기는 것.\n\n참고\n\n[운영체제 | 교착상태(deadlock)란 무엇인가?](https://frontalnh.github.io/2018/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-deadlock-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/)"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"aca141df670b8b9c9474fa873d833730c6d80a8f","text":"# [자바스크립트] 이벤트 위임(Event delegation)\n\n- Title : [자바스크립트] 이벤트 위임(event delegation)\n- Date : 2020-03-20\n- Category : Javascript\n\n# Why?\n\n웹 개발자라면 이벤트 핸들러를 등록할 때 **캡처링**과 **버블링**을 적절하게 선택할 수 있어야 하지 않을까?\n```javascript\n    // 이벤트 캡처\n    element1.addEventListener('click',doSomething2,true)\n    // 이벤트 버블링\n    element2.addEventListener('click',doSomething,false)\n```\n> 🔊 익명함수로 이벤트 핸들러를 정의할 수 있는 데 이 때 화살표 함수의 this 컨텍스트는 event.currentTarget이 아님을 알고 있어야 한다. function (e) {} 형태로 정의해야 this 컨텍스트가 event.currentTarget이 된다.\n\n# addEventListener 동작 방식\n\naddEventListener() 메서드의 마지막 argument의 값으로 이벤트 전파 방식을 지정할 수 있다. true면 캡쳐, false(기본값)면 버블링으로 이벤트가 전파된다. 아래 예시로 이해를 어떤식으로 전파되는 지 이해해보자.\n```html\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <meta charset=\"utf-8\">\n      <meta name=\"viewport\" content=\"width=device-width\">\n      <title>JS Bin</title>\n    </head>\n    <body>\n      <div id=\"element1\">\n        element1\n        <div id=\"element2\">\n           element2\n          <div id=\"element3\">element3</div\n        </div>\n      </div>\n    </body>\n    </html>\n```\n```javascript\n    var element1 = document.getElementById(\"element1\");\n    var element2 = document.getElementById(\"element2\");\n    var element3 = document.getElementById(\"element3\");\n    function doSomething1(){\n      console.log(\"doSomething1\");\n    }\n    function doSomething2(){\n      console.log(\"doSomething2\");\n    }\n    function doSomething3(){\n      console.log(\"doSomething3\");\n    }\n```\n🎈 3개의 element가 버블링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,false)\n    element3.addEventListener('click',doSomething3,false)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething2`→ `doSomething1`\n- element3 클릭시 출력 :  `doSomething3`→ `doSomething2` -> `doSomething1`\n\n🎈 3개의 element가 캡처링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,true)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,true)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething1`→ `doSomething2`\n- element3 클릭시 출력 :  `doSomething1`→ `doSomething2` -> `doSomething3`\n\n🎈 맨 밖의 엘리먼트는 버블링 내부 엘리먼트는 캡처링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,true)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething2`→ `doSomething1`\n- element3 클릭시 출력 :  `doSomething2`→ `doSomething3` -> `doSomething1`\n\n🎈 섞여있으면..?\n```javascript\n    document.body.addEventListener('click',doSomething0,true)\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,false)\n```\nelement3 클릭시 출력 :  `doSomething0`→ `doSomething2` -> `doSomething3` → `doSomething1`\n\n### 테스트 결과\n\n- 이벤트 타켓에 이벤트가 발생하면 이벤트가 다른 이벤트 타켓(이벤트 핸들러가 등록된)으로 전파된다.\n- 이벤트 캡처는 이벤트 타켓의 최상위 요소(단, 이벤트 핸들러가 등록된)부터 이벤트 타켓까지 이벤트 핸들러를 처리한다.\n- 이벤트 버블링은 캡처와 반대로 이벤트 타켓부터 최상위 요소까지 이벤트 핸들러를 처리한다.\n- 섞여있으면 캡처링 우선인 이벤트 타켓부터 처리한 후 버블링을 수행한\n\n# 이벤트 버블링과 캡쳐\n\n아래 사진은 DOM 트리에서 일어나는 이벤트 전파 방법이다.\n\n[UI Events](https://www.w3.org/TR/DOM-Level-3-Events/#event-flow)\n\n![Event%20delegation/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/Untitled.png)\n\n캡처와 버블링은 두 요소(엘리먼트)가 해당 이벤트에 대한 핸들(함수)를 등록한 경우, 다른 요소 내에 중첩된 요소에서 발생하는 이벤트를 전파하는 방법이다. 이벤트 전파 모드로 요소가 이벤트를 수신하는 순서를 판별한다.\n\n## 이벤트 전파..? 신경쓰기 싫어!\n\n현재 이벤트 이후의 이벤트 전파(캡처링, 버블링)를 막고 싶다면 **`event.stopPropagation()`** 메서드를 사용하면 된다.\n\n## 이벤트는 취소하고 전파는 하고 싶어!\n\n**`event.preventDefault()`** 는 이벤트를 취소하지만 이벤트 전파를 막지 않는다. 전파를 막으려면 `event.stopPropagation()`을 사용해야한다.  주로 `a` 태그나 `submit` 태그 등 고유의 동작을 막고 원하는 이벤트 핸들러를 실행할 때 사용한다.\n\n## 메모리 이슈\n\n루프의 각 반복마다 새로운 익명 행들러 함수가 생성되는 방식으로 이벤트를 등록하지 말자. 따로 이벤트 핸들러를 생성한 후 등록하는 방식을 사용해야 메모리 소비가 줄고 `removeEventListener()`를 호출할 수 있다. 익명 함수는 참조가 유지되지않기에 이벤트 리스너를 제거할 수 없다.\n\n# 이벤트 위임(Event delegation)\n\n이벤트 발생 시 document 레벨까지 버블링 되어 올라가는 것을 활용하는 것으로 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식이다.\n\n- 동적인 엘리먼트에 대한 이벤트 처리 수월\n- 하위 엘리먼트는 자유롭게 추가 삭제 가능\n- 동일한 이벤트를 한 곳에서 관리할 수 있고 이벤트 핸들러 관리 쉽다.\n- 생성되는 이벤트 핸들러 함수가 줄어 메모리 사용량이 줄고 메모리 누수 가능성이 감소된다.\n\n참조\n\n[왜 이벤트 위임(delegation)을 해야 하는가?](https://ui.toast.com/weekly-pick/ko_20160826/)\n\n[EventTarget.addEventListener()](https://developer.mozilla.org/ko/docs/Web/API/EventTarget/addEventListener)"}}}},"pageContext":{"id":"cc4c2ba350ff2dcd7d43ee1ce312d69f9c1991b8","previousPostId":"46f1163ddd6eee6183debd713845d84759157be4","nextPostId":"aca141df670b8b9c9474fa873d833730c6d80a8f"}},"staticQueryHashes":["2841359383"]}