{"componentChunkName":"component---src-templates-blog-post-js","path":"/116d87bf74c4c19e11740085d22550d499c73a9d","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"116d87bf74c4c19e11740085d22550d499c73a9d","text":"# [생활코딩] javascript 함수지향2\n\n- Title : [생활코딩] javascript 함수지향2\n- Date : 2018-01-13\n- Category: Javascript\n\n생활코딩 함수지향 파트 중 값으로서의 함수와 콜백에 대한 내용을 정리했습니다.\n\n# 1. 값으로서 함수\n\n예제1) 자바스크립트에서는 함수도 객체이며, 함수도 값이 될 수 있다.\n\n```javascript\nfunction a() {} //함수는 a라는 변수에 담겨진 값.\nvar a = function() {};\n```\n\n예제2) 함수는 객체 안에 저장될 수 있다.\n\n```javascript\na = {\n  b: function() {}\n};\n```\n\nb는 key, 객체 안에서 변수 역할(어떤 값을 저장하고 있기 때문) = 속성(property)  \n속성에 저장된 값이 함수면 메소드라 부름.  \n즉, a라는 객체에 b라는 속성이 있는데, 이 속성의 값은 함수(메소드)다.\n\n예제3) 함수는 변수, 객체에 저장될 수 있고 인자로도 사용할 수 있다.\n\n```javascript\nfunction cal (func, num){\n   return func(num)\n}\n\nfunction increase (num){\n   return num+1;\n}\nalert (cal (increase, 1) );\n\n// 위 코드는 아래와 같이 해석될 수 있다.\nfunction cal ( func, num){\n   var func = increase (num){\n       return num+1\n   }\n}\n// 즉, func(1) => 2가 출력됨.\n```\n\n예제4) 함수를 리턴 값으로도 사용할 수 있다.\n\n```javascript\nfunction cal (mode){\n val funcs = {\n  'plus' : function (left, right) { return left + right },\n  'minus' : function (left, right) { return left - right }\n }\n return funcs[mode];\n}\nalert (cal('plus')(2,1));\n```\n\nreturn funcs['plus'] 는 funcs 객체의 plus 속성의 값인 function(left, right) {return left+right} 메소드를 리턴시킨다.  \ncal('plus')(2,1)은 cal('plus')함수의 인자 값으로 2, 1을 전달하겠다는 의미이다.  \ncal('plus')는 function(left, right) {return left+right} 이므로 알럿창에 3이 뜬다.\n\n예제5) 함수를 배열의 값으로 사용할 수 있다.\n\n```javascript\nvar process = [\n  function(input) {\n    return input + 10;\n  },\n  function(input) {\n    return input * input;\n  },\n  function(input) {\n    return input / 2;\n  }\n];\nvar input = 1;\nfor (var i = 0; i < process.length; i++) input = process[i](input);\n\nalert(input); //60.5\n```\n\n# 2. 콜백\n\n```javascript\nvar numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];\nnumbers.sort(); // numbers는 배열객체, sort()는 메소드(내장메소드)\nconsole.log(numbers); // 1, 10, 2, 20, 3, 4, 5, 6, 7, 8, 9 - 문자 기준으로 정렬한 듯.\n```\n\n<span class=\"clr-grey\">\nsort()    \narray.sort (sortfunc)    \n반환값 : 정렬된 배열\n</span>\n\n```javascript\nvar numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];\nvar sortfunc = function(a, b) {\n  if (a > b) return 1;\n  else if (a < b) return -1;\n  else return 0;\n};\nvar sortfunc = function(a, b) {\n  return a - b; //역순은 return b-a;\n};\nnumbers.sort(sortfunc); // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20\n```\n\nsortfunc가 콜백함수가 된다.  \n함수는 값으로서 사용할 수 있기 때문에 sortfunc를 sort에 인자로 전달함으로서 sort 메소드를 사용자가 원하는 방식으로 바꿀 수 있다.\n\n<span class=\"clr-note\">\\*\\*콜백은 비동기처리에서 유용하게 사용된다.</span>\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"43c62d138aba5719c8fa3bc79ecccce9865fb59c","text":"# 자바스크립트 단위테스트 시작하기\n\n- Title : 자바스크립트 단위테스트 시작하기\n- Date : 2018-01-27\n- Category: Nodejs\n\nmocha 자바스크립트 테스트 프레임워크로 단위테스트 시작하는 방법입니다.\n\n# 단위테스트(Unit Test)가 필요한 이유?\n\n프로그램을 작은 단위로 쪼개서 내가 짠 프로그램이 내가 원하는 결과대로 동작하는 지 테스트할 수 있다.  \n단위테스트를 거치면 프로그램의 안정성이 높아지며, 단위테스트를 믿고 리팩토링을 할 수 있다.\n\n자바스크립트로 짜여진 프로그램에서 오류를 찾을 때, 단위테스트를 거치지 않은 프로그램의 경우는 전체 흐름을 파악해가며 원인을 찾아야한다.  \n원인을 찾아 수정한다해도 이 결과가 어떤 이펙트를 가져올지 예상하기가 어려울 수 있다.\n\n# mocha 자바스크립트 테스트 프레임워크\n\n## 1. 셋팅하기 (Windows8)\n\nmocha는 node.js가 기반인 프레임워크이기 때문에 node.js가 설치되어있어야 한다.  \n설치 후 cmd 창에 node --version 이라고 쳐서 버전 정보가 제대로 나오면 설치가 잘 된 것이다.\n\ncmd 창에 아래와 같이 입력하면 mocha 사용 준비 완료!\n\n```\n$npm install -g mocha\n```\n\n그리고 Assertion Library인 Chai를 추가해보자. 작업 디렉토리에서 아래를 cmd 창에서 실행한다.\n\n```\n$nbm install chai\n```\n\n그 결과, node_moduls 폴더가 생성된다.\n\n## 2. 사용하기\n\n[InspiredJW님의 티스토리 블로그를 참고했습니다!](http://inspiredjw.com/entry/Mocha-%EB%A1%9C-%ED%95%98%EB%8A%94-JavaScript-Testing).\n\n모카는 test 디렉토리에 있는 파일을 실행하기 때문에, 테스트 코드는 이 디렉토리 안에 위치시켜야한다.\n\nJsStudy/JsStudy.js\n\n```javascript\n\"use strict\";\nexports.foo = (a, b) => {\n  if (typeof a !== \"number\" || typeof b !== \"number\") return false;\n  return a * b;\n};\nexports.bar = callback => {};\n```\n\nJsStudy/test/JsStudyTest.js\n\n```javascript\n\"use strict\";\n\nlet chai = require(\"chai\");\nlet should = chai.should();\nlet foo = require(\"../JsStudy\").foo;\n\ndescribe(\"Function Foo\", () => {\n  describe(\"with two number params\", () => {\n    it(\"should return product\", () => {\n      let result = foo(3, 4);\n      result.should.be.a(\"number\");\n      result.should.equal(12);\n    });\n  });\n});\n\ndescribe(\"with non-number params\", () => {\n  it(\"should return false\", () => {\n    let result = foo(3, null);\n    result.should.be.false;\n  });\n});\n```\n\n테스트 실행방법은 cmd 창에서 JsStudy 폴더로 이동한후, mocha 실행하기\n\n```\n$mocha\n```\n\n<span class=\"clr-grey\">\nAPI    \n- describe() : 테이스틔 이름을 지정하며, 중첩하여 사용할 수 있다. 테스트를 구분하는 section이며, 단위테스트 부분을 콜백으로 넘겨준다.\n- it() : 단위테스트의 이름을 작성하고 실제 실행되는 코드를 콜백(done)으로 넘겨준다.\n- befor() : 테스트 코드가 실행되기 전 한번 실행된다.\n- after() : 모든 테스트 코드가 실행된 후 한 번 실행된다.\n- beforeEach() : (테스트 코드가 여러개일 경우) 각각의 테스트 코드가 실행되기 전마다 실행된다.\n- afterEach() : (테스트코드가 여러개일 경우) 각각의 테스트 코드가 실행된 후마다 실행된다.\n- .a(type[,msg]) : 지정된 타입과 동일한지 리턴.\n- .equal(val[,msg]) : === var과 주어진 타켓이 같은지.\n- .false : 타켓 === false\n</span>\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"82bfa87848bd4512f9dba35b6b23b9234a890615","text":"# [생활코딩] javascript 함수지향3\n\n- Title : [생활코딩] javascript 함수지향3\n- Date : 2018-01-13\n- Category: Javascript\n\n생활코딩 함수지향 파트 중 클로저에 대한 내용을 정리했습니다.\n\n# 1. 클로저의 개념\n\n```javascript\nfunction outter() {\n  var title = \"coding everybody\";\n  return function() {\n    alert(title);\n  };\n}\ninner = outter();\ninner();\n```\n\n함수 outter의 리턴 값은 내부함수이며 변수 inner에 내부함수가 값으로 저장된다.  \noutter 호출이 종료된 순간, outter는 사라진다.  \n하지만, inner()를 실행했을 때 알럿창에 coding everybody가 보인다.\n\n왜?  \n<span class=\"clr-note\">내부함수는 외부함수가 종료되도 외부함수에 접근할 수 있다.</span>\n\n# 2. private variable\n\n```javascript\nfunction factory_movie(title) {\n  return {\n    get_title: function() {\n      return title;\n    },\n    set_tile: function(_title) {\n      if (typeof _title === \"String\") {\n        title = _title;\n      } else {\n        alert(\"제목은 문자열이여야 합니다.\");\n      }\n    }\n  };\n}\nghost = factory_movie(\"Ghost in the shell\");\nmatrix = factory_movie(\"Matrix\");\nalert(ghost.get_title()); //Ghost in the shell\nalert(matrix.get_tiel()); //Matrix\n```\n\nfactory_movie의 리턴 값은 get_title, set_title 메소드를 속성으로 가지고 있는 객체이다.  \nghost, matrix 변수는 객체를 담게된다.  \nfactory_movie 호출 후, 함수의 생이 종료되어도 ghost, matrix를 통해 함수의 지역변수인 title에 접근할 수 있다.\n\n왜 private variable을 사용해야 하는가?  \n<span class=\"clr-note\">외부에서 title 변수를 수정해도 ghost, matrix가 가진 title의 맥락에는 영향을 주지 않는다. 즉, 데이터의 수정과 저장을 안전하게 할 수 있다.</span>\n\n# 3. 클로저의 응용\n\n```javascript\nvar arr = [];\nfor (var i = 0; i < 5; i++) {\n  arr[i] = function() {\n    console.log(i);\n  };\n}\n\nfor (var index in arr) {\n  console.log(arr[index]());\n}\n//결과는 5 5 5 5 5\n```\n\n함수가 실행되는 시점의 변수가 내부함수에 저장된다.  \n두번째 반목문에서 배열객체의 함수를 실행하는 순간의 i가 콘솔에 찍히게 된다.  \n그러나, i는 첫번째 포문에 의해 이미 5가 되어버린 상태이므로 5만 다섯번 찍히게 된다.\n\n```javascript\nvar arr = [];\nfor (var i = 0; i < 5; i++) {\n  arr[i] = (function(id) {\n    return function() {\n      return id;\n    };\n  })(i);\n}\n\nfor (var index in arr) {\n  console.log(arr[index]());\n}\n//결과는 0,1,2,3,4\n```\n\n외부함수의 인자 값으로 i가 전달되고, 내부함수는 이 시점의 i를 저장한다.  \n첫번째 포문에서 외부함수가 i를 인자값으로 하면서 실행되는 시점에서 내부함수가 정의된다.\n"}}}},"pageContext":{"id":"116d87bf74c4c19e11740085d22550d499c73a9d","previousPostId":"43c62d138aba5719c8fa3bc79ecccce9865fb59c","nextPostId":"82bfa87848bd4512f9dba35b6b23b9234a890615"}},"staticQueryHashes":["2841359383"]}