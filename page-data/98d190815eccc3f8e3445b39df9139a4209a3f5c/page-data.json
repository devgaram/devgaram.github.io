{"componentChunkName":"component---src-templates-blog-post-js","path":"/98d190815eccc3f8e3445b39df9139a4209a3f5c","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"98d190815eccc3f8e3445b39df9139a4209a3f5c","text":"# 운영체제 - 프로세스 생성과 종료 및 쓰레드\n\n- Title : 운영체제 - 프로세스 생성과 종료 및 쓰레드\n- Date : 2019-12-27\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # Process Creation(프로세스 생성)\n\n## 프로세스는 프로세스에 의해 만들어진다!\n\n부팅 후 OS가 프로세스를 만들면 그 프로세스에 자식 프로세스가 만들어지고 또 자식의 자식 프로세스가 만들어진다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-27-img/1.png)<br/>\n\n- 부모 프로세스(Parent process)\n- 자식 프로세스(Child process)\n- 형제 프로세스(Sibling process) : 부모가 같은 프로세스\n- 프로세스 트리 (process tree) = 족보, 가계도\n\n## Process Identifier (PID)\n\n프로세스의 유니크 번호로 주민등록번호와 비슷한 개념이다. 절대 PID 중복되면 안됀다. cf) PPID : 부모 프로세스의 PID\n\n## 프로세스 생성\n\n- fork() system call – 부모 프로세스 복사해서 새로운 프로그램을 만든다.\n- exec() – 새로 만들어진 프로그램의 실행파일을 메모리로 가져온다.\n\n# # Process Termination(프로세스 종료)\n\n- exit() system call - 프로세스를 종료시킨다. 해당 프로세스가 가졌던 모든 자원(메모리, 열었던 파일, 프린터같은 입출력 장치 등)을 회수해서 O/S에게 반환한다.\n\n# # 쓰레드(Thread)\n\n쓰레드란? <span class=\"clr-note\">프로그램 내부의 흐름, 맥</span>이다.\n\n```java\nclass Test {\n  public static void main(String[] args) {\n    int n = 0;\n    int m = 6;\n    System.out.println(n+m);\n    while (n < m) n++;\n    System.out.println(\"Bye\");\n  }\n```\n\n이처럼 하나의 프로그램에는 보통 맥(쓰레드)이 하나 있으나 어떤 프로그램은 맥(쓰레드)이 여러 개가 있다. 하나의 프로그램에 2개 이상의 맥이 있으면 <span class=\"clr-note\">다중 쓰레드 (Multithreads)</span>라고 한다. 맥이 빠른 시간 간격으로 스위칭되기 때문에 여러 맥이 동시에 실행되는 것처럼 보인다.(=<code class=\"codetainer\">Concurrent</code> 동시성) cf) <code class=\"codetainer\">simultaneous</code>는 진짜로 동시에 실행되는 경우를 말하며 CPU가 하나면 일어날 수 없는 일이다.\n\n## 예시\n\nWeb browser(화면 출력하는 쓰레드 + 데이터 읽어오는 쓰레드), Word processor(화면 출력하는 쓰레드 + 키보드 입력 받는 쓰레드 + 철자/문법\n오류 확인 쓰레드), 음악 연주기, 동영상 플레이어, Eclipse IDE\n\n우리가 이전 포스팅에서는 <code class=\"codetainer\">Process1 -> Process2 -> Process3...</code>로 프로세스가 스위칭된다고 했지만 사실 운영체제는 다중 스레드를 지원하고 있어서 다음과 같은 흐름을 가진다. <code class=\"codetainer\">Thread1 of Process1 -> Thread2 of Process1 -> Thread1 of Process2 -> Thread2 of Process2 -> Thread3 of Process2 .....</code>\n\n## 쓰레드 구조\n\n![process](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-27-img/2.JPG)<br/>\n\n- 프로세스의 메모리 공간 공유 (code, data)\n- 프로세스의 자원 공유 (file, i/o, …)\n- 비공유: 개별적인 PC(program counter), SP(stack pointer), registers, stack\n\n![process](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-27-img/3.JPG)<br/>\n\n**vs 프로세스** <br/>\n프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받는다. 즉, 각 프로세스는 별도의 주소 공간에서 실행되고 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다. 다른 프로세스의 자원에 접근하려면 <code class=\"codetainer\">프로세스 간의 통신(IPC, inter-process communication, 파일, 소켓, 파이프...)</code>을 사용해야 한다.\n\n# # 잠깐 컴퓨터 구조 지식을 채워보자.\n\n## Register(레지스터)\n\nCPU 내부에서 처리할 명령어나 연산의 중간 결과값 등을 일시적으로 기억하는 임시 기억장소다.\n\n- 데이터 레지스터(data register) : CPU가 처리하는 데이터를 임시로 저장\n- <code class=\"codetainer\">주소 레지스터(address register)</code> : 기억장치를 액세스할 주소를 저장하며 포인터(Pointer)라고도 한다. 스택 포인터(SP, Stack Pointer), 베이스 포인터(BP, Base Pointer), 인덱스 포인터(IX, Index Pointer)가 있다.\n- 범용 레지스터(GPR) :주소 레지스터 혹은 데이터 레지스터로 사용될 수 있는 레지스터\n\n## PC\n\n프로그램 카운터(Program counter, PC)는 마이크로프로세서(중앙 처리 장치) 내부에 있는 레지스터 중의 하나로서, 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정한다. 때문에 명령어 포인터라고도 한다.\n\n## 버스\n\nCPU, 메모리, I/O 장치 등과 상호 필요한 정보를 교환하기 위해 연결된 공동의 전송선이다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"badecf2a1d8b27736ed2d861abdb95aeffc07070","text":"# 프로그래머스 - lv3 네트워크, lv2 짝지어 제거하기\n\n- Title : 프로그래머스 - lv3 네트워크, lv2 짝지어 제거하기\n- Date : 2019-12-30\n- Category: 알고리즘 풀이\n\n# # LV3 네트워크\n\n각 행을 순회해서 컬럼 값이 1일 때, 해당 col을 row로 하여 또 순회하는 식으로 해결했다.\n\n```javascript\nfunction solution(n, computers) {\n  var answer = 0;\n  var arr = [];\n  arr = computers.reduce((acc, cur) => {\n    acc.push(cur.includes(1));\n    return acc;\n  }, []);\n\n  for (let i = 0; i < n; i++) {\n    if (arr[i]) {\n      dfs(i);\n      answer++;\n    }\n  }\n\n  function dfs(row) {\n    if (!arr[row]) return;\n    arr[row] = false;\n    for (let i = 0; i < n; i++) {\n      if (computers[row][i] > 0) {\n        computers[row][i] = 0;\n        dfs(i);\n      }\n    }\n  }\n\n  return answer;\n}\n```\n\n# # lv2 짝지어 제거하기\n\n스택을 생각해냈으면 쉽게 해결할 수 있다.\n\n```javascript\nfunction solution(s) {\n  var stack = [];\n  stack.push(s[0]);\n  for (let i = 1; i < s.length; i++) {\n    if (stack[stack.length - 1] === s[i]) stack.pop();\n    else stack.push(s[i]);\n  }\n  return stack.length ? 0 : 1;\n}\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"8793d0abc3d1f564012b2736421ca0daed848670","text":"# 운영체제 - CPU Scheduling\n\n- Title : 운영체제 - CPU Scheduling\n- Date : 2019-12-26\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # CPU 스케줄링 관련 용어 정리\n\n## <span class=\"clr-note\">Preemptive(선점) vs Non-preemptive(비선점)</span>\n\n<code class=\"codetainer\">Preemptive(선점)</code>은 I/O 인터럽트, 프로세스 실행 완료의 경우가 아님에도 CPU 서비스를 받고 있는 프로세스를 강제로 쫒아내 다른 프로세스를 실행하는 것을 말한다. <span class=\"clr-grey\">예) 응급실에서 응급 환자를 우선 치료하는 것</span>\n\n<code class=\"codetainer\">Non-preemptive(비선점)</code>은 프로세스 실행 중 I/O 인터럽트가 발생하거나 프로세스 실행 완료되기 전에는 절대 문맥전환 일어나지 않는 것을 말한다. <span class=\"clr-grey\">예) 은행 </span>\n\n## <span class=\"clr-note\">Scheduling criteria</span>\n\n스케줄링의 성능 판단을 위한 척도\n\n- CPU Utilization (CPU 이용률, %): CPU가 얼마나 쉬지 않고 일하는 가?\n- Throughput (처리율, jobs/sec) : 시간 당 몇개의 작업을 처리하는 가?\n- Turnaround time (반환시간, sec) : 프로세스의 실행 시작 후, 완전히 종료되기까지의 시간. 프로세스는 보통 한번에 실행이 완료되지 않고 문맥전환이 발생한다는 사실을 기억해두고 반환시간을 이해하자.\n- Waiting time (대기시간, sec) : CPU 서비스 받기 위해 <code class=\"codetainer\">Ready Queue</code>에서 얼마나 기다렸나?\n- Response time (응답시간, sec) : 대화형 시스템에서 가장 중요한 척도로 명령을 내렸을 때, 처음 응답이 나오는 데까지 걸린 시간이다\n\n# # CPU 스케쥴링 알고리즘\n\n## <span class=\"clr-note\">1. First-Come, First-Served (FCFS)</span>\n\n![FCFS](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/1.png)<br/>\n**AWT = (0+24+27)/3 = 17 msec**<br/>\n**최적은 3 msec!**\n<br/><br/><br/>\n\n- 먼저 들어온 순서대로 서비스 받는다(단순, 공평)\n- Average Waiting Time(AWT) 면에서 좋지 않을 수 있다.\n- Convoy Effect (호위효과) : <code class=\"codetainer\">CPU Burst Time</code>이 긴 프로그램이 앞에 있으면 뒤 프로그램이 영향을 크게 받음\n- Non-preemptive(비선점)스케줄링이다.\n\n## <span class=\"clr-note\">2. Shortest-Job-First (SJF)</span>\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/2.png)<br/>\n**AWT = (3+16+9+0)/4 = 7 msec**\n<br/><br/><br/>\nAWT 줄이는 면에서는 제일 좋지만 비현실적이다. 실제로 프로세스가 CPU를 얼마나 썼는 지 계산하려면 과거에 CPU를 얼마나 사용했는 지를 기억하고 있어야 하고 미래는 이정도 쓰겠다 계산하여 예측해야한다. 또, 이 예측이 맞는 지 일일이 계산해야한다. 실제로는 문맥 전환이 잦기 때문에 이런 작업은 <span class=\"clr-note\">오버헤드를 증가시킨다.</span>\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/3.png)<br/>\n**Preemptive: AWT = (9+0+15+2)/4 = 26/4 = 6.5 msec**<br/>\n**Nonpreemptive: 7.75 msec**\n<br/><br/><br/>\nSJF 정책은 Preemptive(선점)과 Non-preemptive(비선점) 두 가지로 만들 수 있고 Preemptive SJF는 <code class=\"codetainer\">Shortest-Remaining-Time-First (최소잔여시간 우선)</code> 라고도 한다.\n\n## <span class=\"clr-note\">3. Priority Scheduling</span>\n\n정수 값으로 우선 순위를 정하고 우선 순위가 높을 프로세스를 먼저 서비스 해주는 방법이다. 일반적으로 값이 낮을 수록 높은 우선 순위를 가진다.\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/4.png)<br/>\n**AWT = 8.2 msec**\n<br/><br/>\n\n1. 우선순위 정하는 방법<br/>\n\n내부적\n\n- time limit : time limit 짧은 프로세스\n- memory requirement: 메모리 작게 차지하는 프로세스\n- i/o to CPU burst : I/O 처리 시간 길고 CPU 처리 시간 짧은 프로세스\n\n외부적\n\n- amount of funds being paid : 돈 많이 낸 프로세스 <span class=\"clr-grey\">예) 컴퓨터를 여러 학과가 쓴다면 등록금 많이 낸 학과가 우선순위</span>\n- political factors : 정치적 요소 <span class=\"clr-grey\">예) 학생</span>\n\n2. Preemptive, Nonpreemptive 둘다 가능하다.<br/>\n\n3. 문제점 - starvation (기아) <br/>\n\n어떤 프로세스의 우선 순위가 너무 낮아서 아무리 기다려도 CPU 서비스를 받지 못하는 상황을 <code class=\"codetainer\">starvation(기아)</code>라고 한다. 외부에서 그 프로세스보다 우선 순위가 높은 프로세스가 계속 들어올 경우에 발생한다. 해결법으로 <code class=\"codetainer\">againg</code>을 쓰는 데, 이는 운영체제가 주기적으로 Ready Queue를 조사해서 어떤 JOB이 너무 오래 기다리고 있다면 점진적으로 우선순위를 높여주는 방법이다.\n\n## <span class=\"clr-note\">4. Round-Robin</span>\n\n- Time-sharing system (시분할/시공유 시스템)에서 쓴다.\n- Time quantum 시간양자 = time slice (10 ~ 100msec) 주기로 메인 메모리의 프로세스를 실행한다. 만약 Time quantum이 100msec면 1초에 100번 문맥전환이 일어난다는 것\n- 오직 Preemptive scheduling 정책만 있다.\n- Time quantum에 의존적이므로 좋은 성능을 위해서는 Time quantum의 크기를 잘 고려해야한다.\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/5.png)<br/>\n\n위와 같이 Time quantum을 무한대로 하면 FCFS 알고리즘과 같아진다. 반대로 0으로 수렴시키면 Process sharing이라고 하는 데, 이는 스위칭이 빈번하게 일어나 프로세스들이 거의 동시에 도는 것처럼 느껴진다. 문맥전환이 빈번하므로 Context switching overhead가 크다.\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/6.png)<br/>\n위와 같이 Time quantum 크기에 따라 Average turnaround time (ATT)가 어떻게 되는 지 계산을 해보라.\n\n## <span class=\"clr-note\">5. Multilevel Queue Scheduling</span>\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/7.png)<br/>\n\n프로세스를 성격에 따라 그룹화하여 여러 개의 큐에 그룹별로 JOB을 줄 세우는 방법이다. 각 큐는 절대적 우선 순위를 가지고 있으며 CPU 시간을 큐에 차등으로 배분한다. 또한, 각 큐는 독립된 스케줄링 정책을 가진다.\n\n## <span class=\"clr-note\">6. Multilevel Feedback Queue Scheduling</span>\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/8.png)<br/>\n\n복수 개의 큐를 둔다는 점은 Multilevel Queue Scheduling와 비슷하나 모든 프로세스가 하나의 입구로 진입한다는 차이점이 있다. 프로세스가 너무 많은 CPU를 사용하면 다른 큐에 줄 세우고 기아 상태가 우려되는 JOB이 있다면 우선순위가 높은 큐에 다시 줄 세우는 방식이다.\n"}}}},"pageContext":{"id":"98d190815eccc3f8e3445b39df9139a4209a3f5c","previousPostId":"badecf2a1d8b27736ed2d861abdb95aeffc07070","nextPostId":"8793d0abc3d1f564012b2736421ca0daed848670"}},"staticQueryHashes":["2841359383"]}