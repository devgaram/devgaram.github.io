{"componentChunkName":"component---src-templates-blog-post-js","path":"/4f925fc92243abb58588445af492b3fed43f4848","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"4f925fc92243abb58588445af492b3fed43f4848","text":"# 가깝고도 먼 HTML 1탄\n\n- Title : 가깝고도 먼 HTML 1탄\n- Date : 2020-03-28\n- Category : 프론트\n\n# WHY?\n\nHTML, 잘 알고 있다고 생각했으나 지식이 구멍이 뻥뻥 뚫려있었다. 그래서 시작한 **가깝고도 먼 HTML!** 오늘부터 GO GO!\n\n# `< !DOCTYPE>` 을 왜 선언할까?\n\n> HTML 문서를 작성할 때 항상 DOCTYPE을 문서의 맨 위에 선언한다. ... 왜 선언할까?\n\n`<html>` 태그 전에 선언되야하며 `<!DOCTYPE>` 을 통해 브라우저가 해당 웹 문서가 어떤 타입(HTML5, HTML, XHTML)의 문서인지 파악할 수 있다. 웹 브라우저에게 HTML 버전을 알려주는 역할을 한다. HTML2 ~ HTML4는 SGML(Standard Generalized Markup Language, HTML 할아버지)에 기반을 두어 만들어져서 `<!DOCTYPE>` 을 통한 DTD 참조가 필요하다. 반면에 HTML5는 SGML에 기반을 두지 않아서 DTD 참조가 필요 없고 표준 모드로 작동되게 하는 역할만 하면 되서`<!DOCTYPE html>` 으로 간단하게 선언할 수 있다. \n\nDTD(Document Type Definition: 문서형 정의)는 마크업 언어를 위한 규칙으로 HTML5, XHTML, HTML 등의 문서 형식을 정의할 수 있다. `<!DOCTYPE>` 과 같은 문법을 사용한다. 기술한 유형에 따라 **마크업 문서의 요소와 속성등을 처리하며 유효성 검사 에 이용**된다. DTD를 생략하는 경우 웹 브라우저가 표준 모드가 아니라 비 표준 모드로 렌더링되어 크로스 브라우징에 어려움을 겪는다.\n\n# head 태그에는 무엇이 있을까? 메타가 있죠.\n\n> 보통 에디터의 자동 완성으로 HTML5 기본 형태를 작성한 후 `<body>` 부터 태그를 작성했다. `<body>` 앞은 신경쓰지도 않았다. 물론 예전에 일할 때 페이지 공유 기능을 위해 메타 태그를 설정한 적이 있었지만, 가물가물하니 다시 정리해보았다.\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <meta charset='utf-8'>\n      <meta http-equiv='X-UA-Compatible' content='IE=edge'>\n      <title>Page Title</title>\n      <meta name='viewport' content='width=device-width, initial-scale=1'>\n      <link rel='stylesheet' type='text/css' media='screen' href='main.css'>\n      <script src='main.js'></script>\n    </head>\n    <body>\n      \n    </body>\n    </html>\n\n## HTML head란?\n\nhead는 페이지를 열 때 브라우저에 표시되지는 않는다. head는 `<title>`, `CSS 링크`, `favicon`(사이트 아이콘), `메타 데이터`(작성자, 중요한 키워드 같은 HTML에 대한 내용)를 포함한다.\n\n## 메타데이터 `<meta>` 요소들\n\n### `<meta charset='utf-8'>`\n\n문서에서 허용하는 encoding에 대해 표시\n\n### Viewport\n\n모바일 브라우저들은 뷰포트로 알려진 가상 window 상에 페이지를 렌더링한다. 데스크탑의 뷰포트는 브라우저 창(visible area)의 뷰포트와 같고 사용자가 창의 크기를 조절하면 뷰포트의 크기도 조절된다. 웹 페이지가 뷰포트보다 크면 스크롤 하여 나머지 영역을 볼 수 있다. 반면에 모바일 뷰포트는 웹 브라우저 창보다 크거나 작을 수 있고 상하좌우로 움직이거나, 더블 탭, 줌인, 줌아웃을 통해 뷰포트의 배율을 변경할 수 있다. \n\n뷰포트를 설정안하면 기본 뷰포트가 980px라 페이지가 작게 보인다. ~~아.. 그래서 예전에 작게 보였었구나..~~\n\n기본 사용법\n\n`<meta name='viewport' content='width=device-width, initial-scale=1'>`\n\n- width : viewport의 가로 크기를 조정한다. 숫자가 들어갈 수도 있다. device-width는 100% 스케일에서 css 픽셀들로 계산된 화면의 폭을 의미한다. 즉 기기의 가로 크기에 맞게 설정된다.\n- initial-scale : 페이지가 처음 로딩될 때 줌 레벨을 조정한다. 값이 1이면 CSS 픽셀과 기기 종속적인 픽셀 간의 1:1 관계를 형성한다.\n\n> 미디어 쿼리(@media) 에서 선언된 width 범위에 따라 css를 적용하는 반응형 웹을 만드려면 `width=device-width`를 설정해야한다.\n\n### IE 문서 모드\n\n같은 웹문서를 IE 버전에 따라 마크업과 CSS를 다르게 렌더링하는 경우가 있다. 이 문제를 해결하기 위해 MS는 호환성 보기(쿼크 모드 == 비표준모드) 기능을 제공한다. 하지만 모든 사용자가 직접 호환성 보기를 설정하는 것은 불가능한 일이라 아래 메타태그가 등장했다.\n\n`<meta http-equiv='X-UA-Compatible' content='IE=edge'>` \n\n`content='IE=edge'` 이 메타 태그를 넣으면 자동으로 호환성 보기 기능이 활성화 된다. IE=edge로 선언하면 IE 버전 중 가장 최신 모드를 기준으로 보여지도록 하겠다는 의미다. 이 때, DOCTYPE 선언과 함께 사용해야 유효하다.\n\n# HTML에 CSS와 Javascript 적용하기\n\n## `<link>` 의 위치\n\n`<link>` 는 현재 문서와 외부 리소스의 관계를 명시할 때 사용한다. 스타일 시트를 연결할 때 제일 많이 사용하지만, 사이트 아이콘 연결 등 여러 가지로 쓰일 수 있다. 항상 문서의 **head** 부분에 위치하며 ret=\"stylesheet\" 와 href=\"경로\" 속성을 가진다. head에 놓아야 화면이 여러번 렌더링되는 것을 줄일 수 있다.\n\n## `<script>` 의 위치\n\n`<script>` 요소는 실행 가능한 코드를 문서에 포함하거나 참조할 때 사용한다. head에 들어갈 필요는 없고 `</body>` 태그 바로 앞, 문서 본문의 맨 끝에 넣는 것이 좋다. 자바스크립트를 적용하기 전에 브라우저가 모든 HTML 내용을 읽었는지 확인하여 자바스크립트가 아직 존재하지 않은 요소에 접근하는 경우를 방지해야 한다.\n\n# `<script>` 요소의 defer, async 속성의 차이점\n\n브라우저는 구문 분석을 진행하다 인라인 스크립트(`<script>` 내부에 코드 작성하는 방식) 또는 `async`, `defer`, `type=\"module\"` 속성이 없는 스크립트에 도달하면 스크립트를 가져온 후 실행하기 전까지 분석을 중단한다. HTML이 화면에 출력되는 시간이 길어져 사용자의 불편을 유발한다.\n\n## async\n\nasync 속성이 있으면 HTML 구문 분석 중에도 스크립트를 비동기적으로 가져올 수 있고 사용이 가능해지는 즉시 수행한다. 실행 순서가 다운로드 완료 시점이므로 실행 순서가 중요한 스크립트들에 async를 사용할 때는 유의해야 한다.\n\n## defer\n\nasync과 마찬가지로 브라우저가 HTML 구문 분석을 수행 중에도 스크립트를 다운로드 할 수 있다. 하지만 구문 분석이 완료된 후, **DOMContentLoaded** 발생 이전에 스크립트가 실행된다. defer 속성을 가진 스크립트는 문서 상의 순서를 따라 실행된다.\n\n> `DOMContentLoaded` 이벤트는 초기 HTML 문서를 완전히 불러오고 분석했을 때 발생한다. 스타일 시트, 이미지, 하위 프레임의 로딩은 기다리지 않는다.\n\n# HTML5의 섹셔닝 요소들\n\n> div로 뼈대를 만들던 시대는 지나갔다. HTML5부터 등장한 구조를 위한 태그들.. 잘 알고 잘 사용하고 있을까?\n\nHTML5 에서는 `<header>` `<nav>` `<aside>` `<article>` `<section>` `<footer>` 등의 섹셔닝 요소가 생겨 좀 더 시멘틱한(의미 있는) 마크업 작업을 할 수 있고 여기에 h1 ~ h6 로 섹션의 제목을 작성하면 좋다. 휴. 이제 `<div>` 로 레이아웃을 만들지 않아도 된다. \n\n![HTML%201/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Front/images/2020-03-28-img/Untitled.png)\n\n[https://www.w3schools.com/html/html5_semantic_elements.asp](https://www.w3schools.com/html/html5_semantic_elements.asp)\n\n### SECTION\n\n`<section>` 은 테마별로 연관된 컨텐츠를 묶어 더 큰 **논리적**인 단위를 형성할 수 있게 돕는다. 하나의 페이지 안에서 **주제가 다른 영역을 구분 짓거나 하나의 글을 부분으로 나누기도 한다.** 주로 heading 요소들과 함께 사용한다. 스타일링이나 스크립트를 위해서 엘리먼트들을 감싸는 요소가 필요하다면 `<section>` 을 사용하지 말고 문서 구조상 특별한 의미가 없는 `<div>` 를 사용해야 한다.\n\n- 예) 홈페이지의 뉴스, 긴 글의 세부 사항과 같은 관련 컨텐츠의 묶음\n\n### ARTICLE\n\n`<article>` 은 문서, 페이지, 애플리케이션, 사이트 안에 들어가는 **독립적**으로 구성할 수 있는 컴포넌트로 별도로 배포하거나 재사용하기 위한 구조다. `<article>` 은 완전히 떼어내 다른 사이트에 붙여도 그 의미를 사용자가 알 수 있는 컨텐츠를 담으면 된다. article 요소 안에 article이 들어간 경우, 밖의 article 요소의 내용과 안쪽의 article 요소의 내용이 관련있다는 것을 의미한다. article 중첩 사용은 피하는 게 좋고 대신 논리적인 부분들을 section 요소로 사용하면 된다.\n\n- 예) 블로그에서 글, 포럼에서 포스팅, 코멘트 등\n\n### NAV\n\n`<nav>`는 사이트 네비게이션(다른 페이지로의 이동) 또는 같은 페이지에서 섹션 이동을 위한 네비게이션 링크 목록을 담는 섹션이다.  페이지 안의 모든 링크 그룹이 nav로 기술될 필요는 없다.\n\n    <nav>\n    \t<h1>메인 내비게이션</h1>\n    \t<ul>\n    \t\t<li>메뉴1</li>\n    \t\t<li>메뉴2</li>\n    \t</ul>\n    </nav>\n\n### ASIDE\n\n`<aside>`  본문 컨텐츠 흐름과 분리되지만 약간의 관련성이 있는 컨텐츠에 사용한다.\n\n- 예) 관련 사이트 링크나 광고, nav 요소의 그룹, 메인 콘텐츠와 별도의 내용이라고 생각되는 것, 사이드바, 글의 발췌, 각주 부분, 글에 대한 정보, 여백을 메우는 추가 정보, 코멘트 세션\n\n### HEADER\n\n`<header>` 는 소개나 내비게이션 기능들의 묶음을 나타낸다. 보통 문서나 section의 최상단에 나타나지만, 꼭 그래야 할 필요는 없으며 여러번 사용 가능하다. 한 섹션의 목차나 검색폼, 관련 로고 등을 감싸는 용도로 사용할 수 있다.\n\n### FOOTER\n\n`<footer>` 는 페이지를 만든 사람, 저작권 정보, 연관된 컨텐츠에 대한 링크, 블로그 포스트 작성자, 발행일시 등에 쓰인다. 이 요소는 가장 가까운 섹션의 푸터를 의미한다. 작성자의 연락처는 footer 안의 `<address>` 로 표현, 저작권은 `<small>`로 표현한다.\n\n### FIGURE\n\n`<figure>` 요소는 이미지와 캡션을 그룹화하여 독립적인 컨텐츠를 표현할 때 사용한다. `<figurecaption>` 요소를 사용해 설명을 붙일 수 있다. \n\n    <figure>\n        <img src=\"/media/examples/elephant-660-480.jpg\"\n             alt=\"Elephant at sunset\">\n        <figcaption>An elephant at sunset</figcaption>\n    </figure>\n\n### MAIN\n\n`<main>` 말 그대로 문서의 메인 컨텐츠를 표현할 때 사용하며 `<main>` 안의 내용은 문서에서 유일해야한다. 여러 문서에서 반복적으로 사용되는 사이드바, 네비게이션, 로고, 검색 폼 등을 포함해서는 안되며 문서에 `<main>`은 한 개 여야 한다.\n\n# `<ul>` `<ol>` `<dl>` 의 차이점\n\n> HTML에서 목록을 표현하는 요소는? 각 요소의 차이점은?\n\n### ul(Unordered List)\n\n순서가 없는 목록을 표현할 때 사용하며 목록 앞에 점이나 사각형 등의 도형이 붙는다. 목록의 내용은 `<li>` 로 만든다.\n\n### ol(Ordered List)\n\n순서가 있는 목록을 표현할 때 사용하며 1, 2, 3... 처럼 차례대로 증가하는 번호가 붙는다. 목록의 내용은 `<li>` 로 만든다.\n\n### dl(Definition List)\n\n용어와 그 뜻을 나열할 때 사용한다. 용어는 `<dt>` , 뜻은 `<dd>` 로 만든다.\n\n참조\n\n[[HTML5] 4-1장 구조를 위한 태그](https://webdir.tistory.com/86?category=607030)"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"46f1163ddd6eee6183debd713845d84759157be4","text":"# 운영체제 - 교착상태\n\n- Title : 운영체제 - 교착상태\n- Date : 2020-03-29\n- Category : 운영체제\n\n# 시스템 모델(System Model)\n\n시스템은 경쟁하는 프로세스들 사이에 분배되어야 할 유한한 자원들로 구성되며 여러 프로세스들은 해당 자원을 점유하기 위해 서로 경쟁 구도에 놓여있다. 프로세스가 자원을 사용하기 위해서는 반드시 사용하기 전에 요청을 해야 하고 사용 후에는 반드시 방출해야한다. 정상적인 작동 모드에서 프로세스는 다음의 순서로만 자원을 사용할 수 있다.\n\n1. 요청(Request) : 자원을 요청한다. 다른 프로세스가 사용 중이라서 자원를 받을 수 없다면 대기한다.\n2. 사용(Use) : 프로세스는 자원에 대해 작업 수행한다.\n3. 방출(Release) : 자원을 다 사용했으면 자원을 방출한다.\n\n# 교착상태(Deadlocks)\n\n둘 이상의 프로세스들이 자원(CPU, 메모리, 파일, 프린터 등..)을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상을 말한다. 교착 상태에서 프로세스들은 결코 실행을 끝낼 수 없으며, 시스템 자원이 묶여 있어서 다른 작업을 시작하는 것도 불가능하다.\n\n# 교착상태 필요조건\n\n교착 상태는 아래 4가지 조건이 **모두 만족**되야 발생할 수 있다.\n\n## 1. 상호배제(mutual exclusion)\n\n여러 프로세스 중 하나만 임계 구역에 진입할 수 있을 때 즉, 자원을 동시에 공유하지 못할 때\n\n## 2. 점유하며 대기(hold-and-height)\n\n최소 하나의 자원을 점유한 채, 현재 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 대기 중일 때\n\n## 3. 비선점(no-preemption)\n\n자원들을 선점할 수 없어야 한다. 즉, OS가 작동 중인 프로세스를 임의로 중단시킬 수 없을 때\n\n## 4. 순환대기(circular-wait)\n\n프로세스가 순환적으로 서로를 기다릴 때\n\n# 자원 할당 그래프(Resource Allocation Graph)\n\n자원과 프로세스의 관계를 그래프로 도식화한 **자원 할당 그래프**를 통해 데드락 유무를 파악할 수 있다. 자원 할당 그래프란 시스템 내 모든 활성 프로세스의 집합인 P와 모든 자원의 집합인 R로 정점의 집합 V를 구성한다. 이 그래프에서 P로부터 R로 뻣어나가는 간선은 특정 프로세스가 해당 자원을 요청하고 기다리는 것을 표시하며 자원 R에서 P로 뻣어나가는 간선은 할당 간선으로 해당 자원이 해당 프로세스에 할당되어있음을 나타낸다. 이러한 **자원 할당 그래프에 사이클이 있다면 데드락 위험이 있다는 의미가 된다.** 사이클이 있다고 무조건 데드락이 발생하는 것은 아니지만, 사이클이 없으면 절대로 데드락이 발생하지 않는다. 가능성이라고 얘기하는 이유는 자원이 하나의 인스턴스가 아닌 여러 개의 인스턴스를 가질 수도 있기 때문이다. 만약 자원이 여러 개의 인스턴스를 가질 수 있어서 여러 프로세스에게 자원을 제공한다면 교착 상태가 일어나지 않게 된다.\n\n# 교착상태 처리 방법\n\n## 1. 교착 상태 방지(Deadlock Prevention)\n\n교착상태 4가지 필요조건 중 하나를 만족시키지 않음으로서 교착 상태가 발생하는 것을 방지할 수 있다.\n\n### 상호배타 (Mutual exclusion)\n\n읽기 전용 파일은 여러 프로세스가 공유할 수 있게 하여 상호 배타를 깰 수가 있다. 하지만 대부분의 컴퓨터 자원들은 임계 구역 문제를 해결하기위해 상호 배타를 만족해야만 한다. 상호 배타를 깨는 건 현실적으로 불가능한 일이다.\n\n### 보유 및 대기 (Hold and wait)\n\n프로세스가 실행되기 전에 필요한 모든 자원을 요청하여 할당받도록 하는 거다. 이렇게 하면 프로세스가 다른 자원을 요청하여 할당받을 때까지 대기하는 일이 없고 모든 자원을 가지고 프로세스를 시작하기 때문에 대기하는 일이 발생하지 않는다. 하지만 많은 자원들이 할당된 후 오랫동안 사용되지 않기 때문에 자원 활용률이 떨어지는 단점이 있고 **기아 문제**가 발생할 수 있다. 식사하는 철학자를 예를 들면 젓가락을 동시에 두개를 집게 하고 하나만 집을 수 있다면 아예 못 집게 하는 방법이다. 또는 프로세스가 자원을 점유하지 않을 때만 자원을 요청할 수 있도록 하는 방법도 있다.\n\n### 비선점 (No Preemption)\n\n자원을 점유하고 있는 프로세스가 다른 자원를 요청했을 때 즉시 리자원를 사용할 수 없다면 점유하고 있던 자원을 방출(release)한다.\n\n### 순환 대기 (Circular wait)\n\n모든 자원 유형들에게 전체적인 순서를 부여하여 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 강제하는 것이다. 이를 통해 모든 자원들은 먼저 할당되는 순서가 정해져 있기 때문에 교착상태가 일어날 수 없다. 즉, 자원의 타입에 따라 프로세스마다 일대일 함수로 순서를 지정해준다. 식사하는 철학자 같은 경우는 아이디를 부여하여 홀수번은 오른쪽 왼쪽, 짝수번은 왼쪽 오른쪽 순서로 집도록 하였다. 역시 자원 활용률을 떨어트린다.\n\n## 2. 교착 상태 회피(Deadlock Avoidance)\n\n여기서는 교착 상태를 자원 요청에 대해 운영체제가 잘못 할당한 것으로 정의한다. 운영체제는 리소스 매니저, 리소스 allocator라고 불리듯이 자원을 프로세스에게 골고루 나눠주는 역할을 한다. 즉, **운영체제의 프로세스 관리 부서가 자원을 잘 못 나눠줘서 교착상태가 발생했다고 보는 것**이다. 은행 파산으로 비유할 수 있다. \n\n이러한 교착 상태는 어떤 프로세스가 요청을 할 때 미래에 대한 분석을 통해 자원 요청을 늦추는 방법으로 피할 수 있다. 시스템이 unsafe 상태가 되지 않도록 해야 하며 만약 unsafe 상태면 최대한 빨리 safe 상태로 복구한다. 데드락 가능성은 자원 할당 그래프를 구현해 파악하며 리소스 타입이 여러 개면 Banker's algorithm을 사용한다.\n\n> 안전 상태란 이러한 교착 상태 알고리즘을 설계함에 있어 각 유효 자원의 최대 개수까지 어떤 순서로 요청을 하더라도 교착상태를 야기하지 않고 모두 할당을 잘 해줄 수 있음 을 뜻한다.\n\n### Banker's Alogorithm\n\n교착상태 회피 알고리즘으로 프로세스가 리소스를 요청할때마다 수행되며, 이 자원을 할당하면 미래에 교착상태가 발생할지를 시뮬레이션한다.\n\n## 3. 교착 상태 검출 및 복구\n\n교착 상태가 일어나는 것을 허용하며 자원을 마음껏 나눠준다. 어쩌다가 교착상태가 일어나면 이를 회복하는 방법이다. 검출을 위한 오버헤드가 크다. 복구를 위해 프로세스 일부를 강제 종료하거나 자원을 선점하여 일부 프로세스에게 할당한다. 복구를 위해 주기적으로 현재 상태를 기억해둬야하며 데드락이 일어나지 않은 상태로 다시 돌아가야 한다.\n\n### 복구 1. 프로세스를 종료시키는 방법\n\n- 교착 상태 프로세스를 모두 중지\n    - 다시 처음부터 계산해야한다.\n- 교착 상태가 제거될 때까지 한 프로세스씩 중지하는 방법\n    - 각 프로세스가 중지될 때마다 아직도 교착 상태에 있는 지 매번 살펴봐야 하기 때문에 상당한 오버헤드를 유발한다.\n\n**어떤 프로세스를 종료시킬까?**\n\n- 프로세스의 중요도\n- 프로세스가 얼마나 오래 실행됐는가\n- 얼마나 많을 자원을 사용했는가\n- 프로세스가 작업을 마치기 위해 얼마나 많은 리소스가 필요한가\n- 프로세스가 종료되기 위해 얼마나 많은 리소스가 필요한가\n- 프로세스가 batch인가 interactive한가?\n\n### 복구 2. 자원 선점 방법\n\n교착 상태가 깨어질 때까지 프로세스로부터 자원을 계속적으로 선점해 다른 프로세스에게 주는 방법이다.\n\n**고려사항**\n\n- 희생자 선택(selection of a victim)\n    - 어떤 자원과 어느 프로세스가 선점될 것인가 를 고민\n- 롤백(rollback)\n    - 만약 특정 프로세스의 자원을 강제로 방출하고 선점시켰다면, 그 프로세스를 어떻게 처리 할 것인가에 대한 고민이다. 보통 가장 안전한 방법은 프로세스를 중지시키고 재시작하는 것 즉, 롤백하는 것이다.\n- 기아 상태(starvation)\n    - 특정 프로세스의 자원을 강제 방출시켜 선점을 시켜주게 되면 그 프로세스는 계속해서 희생자로 선택될 확률이 높고 이경우 그 프로세스는 영원히 실행이 완료되지 못하는 기아상태에 빠질 수 있다. 프로세스가 한정된 시간에만 희생자로 선정된다는 것을 반드시 보장 해야 한다.\n\n## 4. 교착 상태 무시\n\n실제 잘 안일어나니깐 그냥 무시하고..교착상태를 처리하는 것을 응용 개발자의 몫으로 맡기는 것.\n\n참고\n\n[운영체제 | 교착상태(deadlock)란 무엇인가?](https://frontalnh.github.io/2018/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-deadlock-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/)"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"cc4c2ba350ff2dcd7d43ee1ce312d69f9c1991b8","text":"# 백준 문제 - 문자열 처리\n\n- Title : [백준] 문자열 처리\n- Date : 2020-03-27\n- Category : 알고리즘 문제 풀기\n\n# Why?\n\nC++ 로 문자열 문제를 풀 때 입출력, 파싱 등 부분에서 막힌다는 생각이 들어서 연습겸 문자열 관련 문제만 풀어보았다. 난이도는 브론즈 정도?\n\n## 11654 아스키 코드\n\n알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하세요.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tchar c;\n    \tcin >> c;\n    \tcout << (int) c;\n    \treturn 0;\n    }\n\n> 'A' 는 65, 'a' 는 97\n\n## 1152 단어의 개수\n\n영어 대소문자와 띄어쓰기만으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \tint ans = 0;\n    \tgetline(cin, str);\n    \tcin.ignore();\n    \t\n    \tfor (int i=0; i<str.size(); i++) {\n    \t\tif (str[i] == ' ') ans++;\n    \t}\n    \t\n    \tif (str[str.size()-1] == ' ') ans--;\n    \tif (str[0] != ' ') ans++;\n    \t\n    \tcout << ans;\n    \treturn 0;\n    }\n\n> 문자열을 공백으로 파싱해야할 때\n\n    #include <iostream>\n    #include <vector>\n    #include <sstream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \t\n    \tgetline(cin, str);\n    \tcin.ignore();\n    \t\n    \tstring buf;\n    \tstringstream ss(str);\n    \tvector<string> tokens;\n    \t\n    \twhile (ss >> buf) {\n    \t\ttokens.push_back(buf);\n    \t}\n    \t\n    \tcout << tokens.size();\t\n    \t\n    \treturn 0;\n    }\n\n> `getline(cin, str)` 로 공백을 포함한 문자열을 입력받을 수 있다. 단, `\\n` 을 포함하지않으므로 버퍼에서 `\\n` 을 제거하기 위해 `cin.ignore()` 을 해야한다.\n\n## 10809 알파벳 찾기\n\n알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \tcin >> str;\n    \tint ans[26];\n    \tfill(&ans[0], &ans[26], -1);\n    \t\n    \tfor (int i=str.size()-1; i>=0; i--) {\n    \t\tint c = (int) str[i];\n    \t\tans[c - 97] = i;\n    \t}\n    \t\n    \tfor (int i=0; i<26; i++) {\n    \t\tcout << ans[i] << ' ';\n    \t}\n    \t\n    \treturn 0;\n    }\n\n## 1157 단어공부\n\n알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tchar str[1000000];\n    \tint cnt[26] = {0};\n    \tint idx = 0, max = 0, maxi = 0;\n    \t\n    \tscanf(\"%s\", str);\n    \t\n    \tfor (int i=0; str[i]; i++) {\n    \t\tif (str[i] < 97) idx = str[i] - 65;\n    \t\telse idx = str[i] - 97;\n    \t\t\n    \t\tcnt[idx]++;\n    \t\tif (cnt[idx] > max) {\n    \t\t\tmax = cnt[idx];\n    \t\t\tmaxi = idx;\n    \t\t} else if (cnt[idx] == max) {\n    \t\t\tmaxi = -1;\n    \t\t}\n    \t}\n    \t\n    \tprintf(\"%c\", maxi == -1 ? '?' : maxi + 65);\n    \t\n    \treturn 0;\n    }\n\n## 2908 상수\n\n상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다. 두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오.\n\n### strcmp로 문자열 비교\n\n    #include <iostream>\n    #include <string.h>\n    using namespace std;\n    \n    int main() {\n    \tchar a[4], b[4];\n    \tscanf(\"%s %s\", a, b);\n    \t\n    \tswap(a[2], a[0]);\n    \tswap(b[2], b[0]);\n    \t\n    \tif (strcmp(a, b) < 0) printf(\"%s\", b);\n    \telse printf(\"%s\", a);\n    \t\n    \treturn 0;\n    }\n\n### atoi로 char * → int로 변경 후 비교\n\n    #include <iostream>\n    #include <string>\n    using namespace std;\n    \n    int main() {\n    \tchar a[4], b[4];\n    \tscanf(\"%s %s\", a, b);\n    \t\n    \tswap(a[2], a[0]);\n    \tswap(b[2], b[0]);\n    \t\n    \tint na = atoi(a);\n    \tint nb = atoi(b);\n    \t\n    \tif (na > nb) printf(\"%d\", na);\n    \telse printf(\"%d\", nb);\n    \t\n    \treturn 0;\n    }\n\n- a, b 값을.. 3으로 했을 때 입력을 제대로 못 받는 문제 생김 ㅜ_ㅜ\n    - c의 문자열은 `\\0` 을 기준으로 구분한다. 문자열의 끝에 있는 `\\0` 이 어떤 식으로든 없어지게 된다면 그 뒤에 `\\0` 이 나타날 때까지 진행하게 된다\n    - 123 456 일 때, a, b 크기를 3으로 하면 a에는 \"123\"이 들어간다. 그럼 `\\0` 은 b[0]에 들어갔을 거다. 이 상태로 456을 입력받으면 b[0]에 4가 쓰여진다. 마찬가지로 b의  `\\0` 도 메모리 어딘가에 들어가게된다.\n    - 즉, a 출력시 123456이 나오는 이유는 123을 입력받을 때 `\\0` 을 받지 못해 456까지 입력받게 되서다."}}}},"pageContext":{"id":"4f925fc92243abb58588445af492b3fed43f4848","previousPostId":"46f1163ddd6eee6183debd713845d84759157be4","nextPostId":"cc4c2ba350ff2dcd7d43ee1ce312d69f9c1991b8"}},"staticQueryHashes":["2685952063","2841359383"]}