{"componentChunkName":"component---src-templates-blog-post-js","path":"/492e9413883721c4edee853633cd2b4713e6aade","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"492e9413883721c4edee853633cd2b4713e6aade","text":"# 운영체제 - 이중모드, 하드웨어 보호\n\n- Title : 운영체제 - 이중모드, 하드웨어 보호\n- Date : 2019-12-25\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # 이중모드(Dual Mode)\n\n## 이중모드의 등장 배경은?\n\n하나의 서버 컴퓨터를 여러 사람이 동시에 사용하는 또는 한 사람이 여러 개의 프로그램을 동시에 사용하는 환경에서 한 사람의 고의/실수 프로그램은 전체에 영향을 끼치게 된다. 예를 들어, 한 사용자 프로그램에서 <code class=\"codetainer\">STOP, HALT, RESET, SET_TIMER, SET_HW</code>등의 명령을 실행한다면 컴퓨터 전체가 영향을 받는다. 즉, <span class=\"clr-note\">시스템에 치명적인 명령은 관리자만 실행할 수 있도록</span> 하기 위해 이중모드(사용자모드, 관리자모드)가 등장하게 된 것이다.\n\n## 이중모드란?\n\n<code class=\"codetainer\">시스템(system) 모드 = 관리자(supervisor) 모드 = 모니터(monitor) 모드 = 특권(priviliged) 모드</code> 와 <code class=\"codetainer\">사용자 모드</code>가 있다. 시스템 모드일 때, <code class=\"codetainer\">STOP, HALT</code> 와 같은 <code class=\"codetainer\">특권 명령</code>을 내릴 수 있고 사용자 프로그램에서는 치명적 명령을 사용 못하게 막는다.\n\n## 이중모드는 어떻게 동작할까?\n\nCPU에 있는 <code class=\"codetainer\">레지스터</code>는 비트를 가지고 있으며 각 비트는 <code class=\"codetainer\">carry, negative, zero, overflow</code> 발생을 알려주는 플래그 역할을 한다. 여기에 이중모드를 위한 비트를 추가하여 <span class=\"clr-note\">시스템 모드면 1</span>을 <span class=\"clr-note\">사용자 모드면 0</span>으로 표시한다. <br/><br/>\n![이중모드](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-25-img/dual-mode.png)<br/>\n\n- 운영체제 서비스를 실행될 때는 <span class=\"clr-note\">관리자 모드</span>\n- 사용자 프로그램 실행될 때는 <span class=\"clr-note\">사용자 모드</span>\n- 하드웨어/소프트웨어 인터럽트 발생하면 <span class=\"clr-note\">관리자 모드</span>\n- 운영체제 서비스가 끝나면 다시 <span class=\"clr-note\">사용자 모드</span>\n\n## 이중모드 예시\n\n전원을 켰을 때 하드 디스크에 있는 운영체제가 메인 메모리에 올라가는 것은 **시스템 모드**에서 동작한다. 부팅이 끝나면 **사용자 모드**가 된다. 게임 아이콘을 더블클릭하여 인터럽트가 발생하면 다시 **시스템 모드**가 되어 인터럽트 서비스 루틴이 게임을 메인 메모리에 올리고 cpu가 실행할 수 있도록 한다. 다시 **사용자 모드**로 돌아오고 열심히 게임을 한다. 이제 게임 스코어를 하드디스크에 저장해보자. 게임 프로그램이 직접 하드디스크에 저장하는 것이 아니라 소프트웨어 인터럽트를 걸어 CPU가 지금 하던 일을 멈추고 운영체제의 ISR로 점프해서 실행하도록 한다. 이 때는 **시스템 모드**이다. ISR이 완료되면 레지스터 비트를 0으로 하여 **사용자 모드**로 만들고 다시 게임으로 돌아오게 된다.\n\n하드웨어 인터럽트도 마찬가지다. **사용자 모드**에서 마우스를 움직이게 되면 CPU로 인터럽트를 보내 **시스템 모드**로 바꾼 후 ISR을 실행한다. 완료되면 다시 **사용자 모드**가 된다. 즉, <span class=\"clr-note\">하나의 프로그램이 실행되는 동안 사용자 모드, 시스템 모드가 계속 반복된다.</span>\n\n## 만약 사용자 프로그램에서 특권 명령을 내리면?\n\nCPU는 레지스터의 모니터 비트를 확인하여 특권 명령이 사용자 모드일 때 내려지면 인터럽트를 발생시킨다. 운영체제의 인터럽트 서비스 루틴이 실행되고 이 ISR은 잘못된 시도를 한 프로그램을 강제 종료시켜 메모리에서 사라지게 한다.\n\n# # 하드웨어 보호\n\n## 입출력 장치 보호\n\n사용자 A가 프린터를 사용 중인 상황에서 사용자 B가 프린트 출력 명령을 내리면 어떻게 될까? 운영체제가 없다면 A 사용자꺼 한 줄, B 사용자꺼 한 줄..식으로 출력이 될 것이다. 이같은 프린트 혼선, 리셋 등의 상황이 적절한가? 다른 예시로 하드디스크에 저장된 A의 정보를 B가 마음대로 읽고 쓰는 상황을 생각해보자. 이 것도 적절한가? 답은 <span class=\"clr-note\">NO!!</span>\n\n**어떻게 해야할까?** 컴퓨터는 바로 이렇게 해결했다.\n\n입출력 명령인 <code class=\"codetainer\">IN, OUT</code>을 특권 명령으로 하여 사용자가 직접 입출력 명령을 내릴 수 없도록 했다. 만약 사용자가 직접 내리면 <code class=\"codetainer\">Privileged instruction violation</code>이기에 강제로 프로그램을 종료시킨다. 즉, 사용자가 입출력을 하기 위해서는 <code class=\"codetainer\">소프트웨어 인터럽트</code>를 발생시켜 운영체제에 요청해야한다. 인터럽트에 의해 CPU가 시스템 모드로 전환하고 운영체제의 ISR을 실행하면 운영체제가 입출력을 대행한다. ISR에는 요청이 적절한 지를 확인하는 코드가 있어 올바른 요청에만 실행된다. 만약, 올바른 요청이 아니면 운영체제는 이를 거부한다. ISR이 완료되면 다시 사용자 모드로 복귀된다.\n\n## 메모리 보호\n\n메인 메모리에는 운영체제와 여러 개의 사용자 프로그램이 동시에 있기 때문에 다른 사용자 메모리 또는 운영체제에 접근하는 것을 막아야 한다. 보호하지 않으면 다른 사용자 정보나 프로그램을 해킹하거나 운영체제를 해킹하는 경우가 생긴다.\n\n**어떻게 메모리를 보호할까?** 컴퓨터는 바로 이렇게 해결했다.\n\nCPU와 메인 메모리 사이는 Bus로 연결되어있고 CPU -> 메모리는 <code class=\"codetainer\">Address Bus</code>, 메모리 -> CPU는 <code class=\"codetainer\">Data Bus</code>로 부른다. 컴퓨터는 다른 메모리 영역의 침범을 막기 위해 Address Bus에 <code class=\"codetainer\">MMU(Memory Management Unit)</code>을 두었고 문지기 역할을 하도록 했다. MMU에는 <code class=\"codetainer\">Base, Limit</code>가 있고 값 설정은 특권 명령으로 운영체제만 바꿀 수 있다. MMU는 Base~Limit 사이면 통과시키고 범위 밖이면 CPU로 인터럽트 신호를 발생시켜 해당 명령을 내린 프로그램을 종료시킨다. 이처럼 다른 사용자 또는 운영체제 영역 메모리에 접근하려는 것을 <code class=\"codetainer\">Segment Violation</code> 이라고 한다.\n\n## cpu 보호\n\n한 사용자가 <code class=\"codetainer\">while(n = 1)</code> 과 같은 명령을 실행하면 CPU를 계속 독점하여 다른 사용자의 프로그램을 실행할 수 없게 된다. 이를 막기 위해 CPU 보호가 필요한 것이다. <span class=\"clr-note\">컴퓨터는 Timer를 두어 일정 시간 경과 시 타이머 인터럽트를 발생시키는 방법으로 해결했다.</span> 일정 신호 주기로 타이머가 CPU에 인터럽트를 걸게 되면 CPU는 ISR을 실행시켜 프로그램이 CPU를 너무 오랜 시간 독점하고 있는 지를 확인한다. 독점하고 있다고 판단되면 CPU를 강제 전환시켜 다른 프로그램을 실행토록 한다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"8793d0abc3d1f564012b2736421ca0daed848670","text":"# 운영체제 - CPU Scheduling\n\n- Title : 운영체제 - CPU Scheduling\n- Date : 2019-12-26\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # CPU 스케줄링 관련 용어 정리\n\n## <span class=\"clr-note\">Preemptive(선점) vs Non-preemptive(비선점)</span>\n\n<code class=\"codetainer\">Preemptive(선점)</code>은 I/O 인터럽트, 프로세스 실행 완료의 경우가 아님에도 CPU 서비스를 받고 있는 프로세스를 강제로 쫒아내 다른 프로세스를 실행하는 것을 말한다. <span class=\"clr-grey\">예) 응급실에서 응급 환자를 우선 치료하는 것</span>\n\n<code class=\"codetainer\">Non-preemptive(비선점)</code>은 프로세스 실행 중 I/O 인터럽트가 발생하거나 프로세스 실행 완료되기 전에는 절대 문맥전환 일어나지 않는 것을 말한다. <span class=\"clr-grey\">예) 은행 </span>\n\n## <span class=\"clr-note\">Scheduling criteria</span>\n\n스케줄링의 성능 판단을 위한 척도\n\n- CPU Utilization (CPU 이용률, %): CPU가 얼마나 쉬지 않고 일하는 가?\n- Throughput (처리율, jobs/sec) : 시간 당 몇개의 작업을 처리하는 가?\n- Turnaround time (반환시간, sec) : 프로세스의 실행 시작 후, 완전히 종료되기까지의 시간. 프로세스는 보통 한번에 실행이 완료되지 않고 문맥전환이 발생한다는 사실을 기억해두고 반환시간을 이해하자.\n- Waiting time (대기시간, sec) : CPU 서비스 받기 위해 <code class=\"codetainer\">Ready Queue</code>에서 얼마나 기다렸나?\n- Response time (응답시간, sec) : 대화형 시스템에서 가장 중요한 척도로 명령을 내렸을 때, 처음 응답이 나오는 데까지 걸린 시간이다\n\n# # CPU 스케쥴링 알고리즘\n\n## <span class=\"clr-note\">1. First-Come, First-Served (FCFS)</span>\n\n![FCFS](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/1.png)<br/>\n**AWT = (0+24+27)/3 = 17 msec**<br/>\n**최적은 3 msec!**\n<br/><br/><br/>\n\n- 먼저 들어온 순서대로 서비스 받는다(단순, 공평)\n- Average Waiting Time(AWT) 면에서 좋지 않을 수 있다.\n- Convoy Effect (호위효과) : <code class=\"codetainer\">CPU Burst Time</code>이 긴 프로그램이 앞에 있으면 뒤 프로그램이 영향을 크게 받음\n- Non-preemptive(비선점)스케줄링이다.\n\n## <span class=\"clr-note\">2. Shortest-Job-First (SJF)</span>\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/2.png)<br/>\n**AWT = (3+16+9+0)/4 = 7 msec**\n<br/><br/><br/>\nAWT 줄이는 면에서는 제일 좋지만 비현실적이다. 실제로 프로세스가 CPU를 얼마나 썼는 지 계산하려면 과거에 CPU를 얼마나 사용했는 지를 기억하고 있어야 하고 미래는 이정도 쓰겠다 계산하여 예측해야한다. 또, 이 예측이 맞는 지 일일이 계산해야한다. 실제로는 문맥 전환이 잦기 때문에 이런 작업은 <span class=\"clr-note\">오버헤드를 증가시킨다.</span>\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/3.png)<br/>\n**Preemptive: AWT = (9+0+15+2)/4 = 26/4 = 6.5 msec**<br/>\n**Nonpreemptive: 7.75 msec**\n<br/><br/><br/>\nSJF 정책은 Preemptive(선점)과 Non-preemptive(비선점) 두 가지로 만들 수 있고 Preemptive SJF는 <code class=\"codetainer\">Shortest-Remaining-Time-First (최소잔여시간 우선)</code> 라고도 한다.\n\n## <span class=\"clr-note\">3. Priority Scheduling</span>\n\n정수 값으로 우선 순위를 정하고 우선 순위가 높을 프로세스를 먼저 서비스 해주는 방법이다. 일반적으로 값이 낮을 수록 높은 우선 순위를 가진다.\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/4.png)<br/>\n**AWT = 8.2 msec**\n<br/><br/>\n\n1. 우선순위 정하는 방법<br/>\n\n내부적\n\n- time limit : time limit 짧은 프로세스\n- memory requirement: 메모리 작게 차지하는 프로세스\n- i/o to CPU burst : I/O 처리 시간 길고 CPU 처리 시간 짧은 프로세스\n\n외부적\n\n- amount of funds being paid : 돈 많이 낸 프로세스 <span class=\"clr-grey\">예) 컴퓨터를 여러 학과가 쓴다면 등록금 많이 낸 학과가 우선순위</span>\n- political factors : 정치적 요소 <span class=\"clr-grey\">예) 학생</span>\n\n2. Preemptive, Nonpreemptive 둘다 가능하다.<br/>\n\n3. 문제점 - starvation (기아) <br/>\n\n어떤 프로세스의 우선 순위가 너무 낮아서 아무리 기다려도 CPU 서비스를 받지 못하는 상황을 <code class=\"codetainer\">starvation(기아)</code>라고 한다. 외부에서 그 프로세스보다 우선 순위가 높은 프로세스가 계속 들어올 경우에 발생한다. 해결법으로 <code class=\"codetainer\">againg</code>을 쓰는 데, 이는 운영체제가 주기적으로 Ready Queue를 조사해서 어떤 JOB이 너무 오래 기다리고 있다면 점진적으로 우선순위를 높여주는 방법이다.\n\n## <span class=\"clr-note\">4. Round-Robin</span>\n\n- Time-sharing system (시분할/시공유 시스템)에서 쓴다.\n- Time quantum 시간양자 = time slice (10 ~ 100msec) 주기로 메인 메모리의 프로세스를 실행한다. 만약 Time quantum이 100msec면 1초에 100번 문맥전환이 일어난다는 것\n- 오직 Preemptive scheduling 정책만 있다.\n- Time quantum에 의존적이므로 좋은 성능을 위해서는 Time quantum의 크기를 잘 고려해야한다.\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/5.png)<br/>\n\n위와 같이 Time quantum을 무한대로 하면 FCFS 알고리즘과 같아진다. 반대로 0으로 수렴시키면 Process sharing이라고 하는 데, 이는 스위칭이 빈번하게 일어나 프로세스들이 거의 동시에 도는 것처럼 느껴진다. 문맥전환이 빈번하므로 Context switching overhead가 크다.\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/6.png)<br/>\n위와 같이 Time quantum 크기에 따라 Average turnaround time (ATT)가 어떻게 되는 지 계산을 해보라.\n\n## <span class=\"clr-note\">5. Multilevel Queue Scheduling</span>\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/7.png)<br/>\n\n프로세스를 성격에 따라 그룹화하여 여러 개의 큐에 그룹별로 JOB을 줄 세우는 방법이다. 각 큐는 절대적 우선 순위를 가지고 있으며 CPU 시간을 큐에 차등으로 배분한다. 또한, 각 큐는 독립된 스케줄링 정책을 가진다.\n\n## <span class=\"clr-note\">6. Multilevel Feedback Queue Scheduling</span>\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/8.png)<br/>\n\n복수 개의 큐를 둔다는 점은 Multilevel Queue Scheduling와 비슷하나 모든 프로세스가 하나의 입구로 진입한다는 차이점이 있다. 프로세스가 너무 많은 CPU를 사용하면 다른 큐에 줄 세우고 기아 상태가 우려되는 JOB이 있다면 우선순위가 높은 큐에 다시 줄 세우는 방식이다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"222f530a5cea814f9af2afcc2e90f0d55d3d0902","text":"# 운영체제 - 운영체제 주요 서비스 간략하게!\n\n- Title : 운영체제 - 운영체제 주요 서비스 간략하게!\n- Date : 2019-12-25\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # 운영체제의 주요 서비스\n\n- 프로세스 관리\n- 주 기억장치 관리(메인 메모리 관리)\n- 파일 관리(하드디스크의 파일)\n- 보조기억장치 관리\n- 입출력 장치 관리(프린트, 키보드, 마우스..)\n- 네트워킹\n- 보호\n- 기타..\n\n## 프로세스 관리\n\n메인 메모리에서 실행 중인 프로그램을 프로세스라고 한다.\n\n- 프로세스의 생성, 소멸(creation, deletion)\n- 프로세스 활동 일시 중지, 활동 재개(suspend, resume)\n- 프로세스간 통신(interprocess communication: IPC)\n- 프로세스간 동기화(synchromization)\n- 교착 상태 처리(deadlock handling)\n\n## 주기억장치관리(메인메모리)\n\n- 프로세스에게 메모리 공간 할당 (allocation)\n- 메모리의 어느 부분이 어느 프로세스에게 할당되었는가 추적 및 감시\n- 프로세스 종료 시 메모리 회수 (deallocation)\n- 메모리의 효과적 사용\n- 가상 메모리: 물리적 실제 메모리보다 큰 용량 갖도록\n\n## 파일 관리\n\n원래 디스크는 판 위의 Track과 sector의 집합이지만 파일이라는 논리적 관점으로 볼 수 있게 운영체제가 처리해준다.\n\n- 파일의 생성과 삭제 (file creation & deletion)\n- 디렉토리(directory)의 생성과 삭제 (또는 폴더 folder)- 기본동작지원: open, close, read, write, create, delete\n- Track/sector – file 간의 매핑(mapping) – 백업(backup)\n\n## 보조기억장치 관리\n\n하드디스크, 플래시 메모리.\n\n- 빈 공간 관리 (free space management) - 포맷 후 비워져있는 Block(섹터/트랙 집합)은 사용하다보면 비워져있는 공간, 사용되고 있는 공간으로 나눠진다. 이 공간을 관리하는 것\n- 저장공간 할당 (storage allocation)\n- 디스크 스케쥴링 (disk scheduling) : 어떻게 하면 헤더를 적게 움직이면서 원하는 트랙이나 섹터를 읽을 수 있을까?\n\n## 입출력 장치 관리\n\n- 장치 드라이브\n- 입출력 장치의 성능 향상 : <span class=\"clr-note\">buffering</span>(입출력 장치에서 읽은 내용을 일단 메모리에 가져오는 것, 한번 메모리에 가져오면 일단 빠르게 읽을 수 있음), <span class=\"clr-note\">caching</span>, <span class=\"clr-note\">spooling</span>(메모리 대신에 하드디스크를 중간 매체로 사용하는 것, 프린트로 출력할 내용을 디스크에 저장해서 cpu가 다른 일 할 수 있게)\n\n## 시스템 콜\n\n운영체제 서비스를 받기 위한 호출\n\n- <span class=\"clr-note\">Process</span>: end, abort, load, execute, create, terminate, get/set\n  attributes, wait event, signal event\n- <span class=\"clr-note\">Memory</span>: allocate, free\n- <span class=\"clr-note\">File</span>: create, delete, open, close, read, write, get/set attributes\n- <span class=\"clr-note\">Device</span>: request, release, read, write, get/set attributes,\n  attach/detache devices\n- <span class=\"clr-note\">Information</span>: get/set time, get/set system data\n- <span class=\"clr-note\">Communication</span>: socket, send, receive\n"}}}},"pageContext":{"id":"492e9413883721c4edee853633cd2b4713e6aade","previousPostId":"8793d0abc3d1f564012b2736421ca0daed848670","nextPostId":"222f530a5cea814f9af2afcc2e90f0d55d3d0902"}},"staticQueryHashes":["2841359383"]}