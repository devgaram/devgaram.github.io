{"componentChunkName":"component---src-templates-blog-post-js","path":"/1915e03780a46a3344b4cdf3bc8284ba7af6804e","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"1915e03780a46a3344b4cdf3bc8284ba7af6804e","text":"# npm Working with package.json\n\n- Title : npm Working with package.json\n- Date : 2018-04-16\n- Category: Nodejs\n\n# 5. Working with package.json\n\n로컬에 설치된 npm 패키지를 관리하는 최상의 방법은 package.json 파일을 생성하는 것입니다.\n\npackage.json 파일은 :\n\n- 프로젝트가 의존하고 있는 패키지들의 리스트를 보여줍니다.\n- semantic versioning rule에 따라 프로젝트에 의존한 패키지들의 버전을 설정할 수 있습니다.\n- 빌드를 재현할 수 있으므로, 좀 더 쉽게 다른 개발자와 공유할 수 있습니다.\n\n## 요구사항\n\npackage.json 파일이 반드시 가져야하는 것\n\n- \"name\"\n  - 소문자\n  - 한단어, 띄어쓰기 허용X\n  - -(dashes) 와 \\_ (underscores) 허용O\n- \"version\"\n  - x.x.x 형태\n  - semver spec을 따름\n\n```\n{\n \"name\" : \"my-awesome-package\",\n \"version\" : \"1.0.0\"\n}\n```\n\n## package.json 파일 생성하기\n\n```\n> npm init\n또는\n> npm init --yes\n#--yes === -y\n```\n\n위 명령어는 현재 디렉토리로부터 정보를 추출해서 해당 package.json 파일을 생성합니다.\n\n```\n{\n  \"name\": \"my_package\",\n  \"description\": \"\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/ashleygwilliams/my_package.git\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/ashleygwilliams/my_package/issues\"\n  },\n  \"homepage\": \"https://github.com/ashleygwilliams/my_package\"\n}\n```\n\n- name : 현재 디렉토리 이름\n- version : 항상 1.0.0\n- description : readme 정보 또는 \"\"\n- main : 항상 index.js\n- scripts : 기존적으로 빈 테스트 스크립트를 만든다.\n- keywords : empty\n- author : empty\n- license : ISC\n- bugs : 현재 디렉토리의 정보\n- homepage : 현재 디렉토리의 정보\n\n다음과 같이 명령어 실행시 옵션을 설정할 수 있습니다.\n\n```\n> npm set init.author.email \"wombat@npmjs.com\"\n> npm set init.author.name \"ag_dubs\"\n> npm set init.license \"MIT\"\n```\n\n## Dependencies 지정하기\n\n프로젝트가 의존하는 패키지를 지정하려면 package.json 파일에 사용할 패키지들을 나열해야합니다. 그리고 패키지들은 두 개의 타입으로 나열될 수 있습니다.\n\n- \"dependencies\" : 프로젝트 배포 시\n- \"devDependencies\" : 프로젝트 개발 또는 테스트 시\n\npackage.jsondp dependencies를 추가하는 더 쉬운 방법은 npm install 명령어 실행시 --save 또는 --save-dev 플래그를 사용하는 것 입니다.\n\n```\n> npm install <package_name> --save\n> npm install <package_name> --save-dev\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"577478fb0b78d854a14f939dd2ff68114511aa30","text":"# [안드로이드] 시작하기 앞서 기초 학습\n\n- Title : [안드로이드] 시작하기 앞서 기초 학습\n- Date : 2018-11-30\n- Category: Android\n\n안드로이드 학습을 시작하기 전에 간단히 자바 기본 개념을 정리했습니다.\n\n# 안드로이드 기초\n\n## 안드로이드 4대 구성요소\n\n- 액티비티  \n  화면 하나당 하나의 액티비티 가짐. 여러개의 액티비티 중 하나가 메인 액티비티가 되며 manifest에 정의된다.\n- 리시버  \n  전화&문자 수신, 배터리 부족 등의 브로드캐스트를 수신하는 객체\n- 프로바이더  \n  데이터베이스나 파일 등의 정보를 외부의 앱에 공개하기 위한 객체. ContentProvider 클래스를 상속받아 구현\n- 서비스  \n  백그라운드(음악재생, 파일다운로드)에서 오래 수행되어야 하는 앱. 화면 없음\n\n## 액티비티끼리 데이터를 주고받는 과정\n\n1. A 액티비티에서 startActivityForResult()로 B 액티비티 시작\n2. B 액티비티에서 setResult()로 결과를 A 액티비티로 전달\n3. A 액티비티의 onActivityResult()에서 B 액티비티에서 전달받은 데이터 처리\n\n# 자바 기초 개념\n\n---\n\n## 자바 상속과 인터페이스 개념 정리 [출처]\n\n1. 상속\n\n- 어떤 클래스보다 내용이 구체적인 새로운 클래스가 필요할 때 기존 클래스에서 물려받아 새로운 부분만 추가하거나 수정하려고 만든 개념이다.\n- 상속을 이용하면 슈퍼 클래스(부모)의 필드, 메서드를 상속받으며 서브 클래스(자식)에서 자신만의 필드나 메서드를 추가하여 구체화할 수 있다.\n  물론 상속받은 메서드를 재정의(오버라이딩)하는 것도 가능하다.\n- 상속은 클래스를 선언할 때 extends 키워드를 사용하여 정의한다.\n- 다른 객체지향 언어와 달리 다중 상속을 지원하지 않는다.\n- 다형성 : 슈퍼클래스가 같은 서브 클래스들이 동일한 요청(메서드)을 다르게 처리할 수 있는 특징을 말한다. 메서드를 오버라이딩(재정의)하여 구현한다.\n\n2. 클래스의 기본 구조\n\n- 패키지 : 자바 클래스들을 같은 성격으로 묶어서 관리하는 디렉토리 개념\n- 클래스 : 자바 프로그램의 기본 단위\n- 인스턴스 : 객체지향개념에 따라 클래스는 바로 사용할 수 없고 인스턴스로 사용해야한다. 인스턴스를 이용하여 메서드 호출 등 필요한 작업을 처리한다.\n- 생성자 : 클래스를 생성할 때 제일 먼저 실행되는 특수한 형태의 메서드, 리턴값이 없으며(데이터형 입력하면 안됨) 메서드 이름은 반드시 클래스 이름과 일치해야 한다.\n\n3. 접근 한정자의 종류와 접근 범위\n\n- public : 클래스 내부, 동일 패키지, 하위클래스, 그 외의 영역에서 접근 가능\n- protected : 클래스 내부, 동일 패키지, 하위클래스에서 접근 가능\n- default : 클래스 내부, 동일 패키지에서 접근 가능\n- private : 클래스 내부에서만 접근 가능\n\n4. 일반 한정자의 종류\n\n- static : 클래스 메서드와 클래스 변수를 선언하는 데 사용한다.\n  자바의 정적 영역에 할당되는 리소스를 선언하는 데 사용.\n  동일한 가상머신 상에서 실행 중인 모든 클래스에서 공유한다.\n  인스턴스를 생성하지 않고도 클래스의 메서드나 멤버에 접근할 수 있다.\n- final : 더 이상 변경할 수 없도록 선언하는 한정자. 클래스에서 사용하면 서브 클래스를 만들 수 없다. 메서드에서 사용하면 오버라이딩을 할 수 없다.\n  변수에 사용하면 저장된 값은 변할 수 없으므로 상수의 역할을 한다.\n- abstract : 추상 클래스를 선언하는 데 사용하는 한정사\n\n5. 인스턴스 변수와 클래스 변수\n\n- 인스턴스 변수는 클래스의 인스턴스로만 접근 가능한 변수(일반적인 멤버 변수), 클래스 외부에서 접근 차단하려고 private 키워드를 사용하기도 함.\n- 동일 클래스의 인스턴스라 해도 각 인스턴스의 변수는 값이 서로 다르고 서로에 영향을 주지 않는다.\n- 클래스 변수는 모든 클래스의 인스턴스로 공유되는 변수, static 키워드를 사용하여 선언한다.\n\n6. 자바 가상머신의 메모리 구조\n\n- Heap 영역 : 자바 객체, 인스턴스 변수\n- Stack 영역 : 메서드 파라미터, 지역 변수\n- Method 영역 : 메서드 바이트 코드, 클래스(static) 변수\n\n7. 추상 클래스와 인터페이스\n\n- 추상클래스\n  - 추상 메서드(정의만 한 메서드)를 하나 이상 포함한다, 추상 메서드가 포함된 클래스는 반드시 추상 클래스로 정의해야 한다.\n  - 그 자체를 인스턴스화(객체 생성)에 사용할 수 없다. 추상 클래스를 상속받는 클래스를 만든 후 추상클래스에 선언된 모든 추상 메서드를 오버라이딩해서 구현해야 한다.\n\n8. 인터페이스\n\n- 모두 추상 메서드로만 구성해야 한다.\n- 일반 멤버 필드는 없고, public, static, final로 선언한 상수만 있다.\n- 그 자체를 인스턴스화(객체 생성) 불가. 다른 클래스로 구현할 때는 implements 키워드로 구현을 선언해야한다.\n- 다중 상속 개념 지원하는 형태로 사용 가능\n\n9. 캡슐화\n\n- 외부에서 변수에 직접 접근할 수 없도록 하는 객체지향 프로그래밍 방법이다.\n- 캡슐화된 변수에 접근하려면 getter, setter 메서드를 만들어서 접근해야한다.\n\n[출처]: http://nyebo.net/2016/01/just-java-summary/\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"c636b7749da7503e1608b5aa12d6ee7b06881fa5","text":"# npm 로컬 패키지 설치하기\n\n- Title : npm 로컬 패키지 설치하기\n- Date : 2018-04-13\n- Category: Nodejs\n\n# 4. 로컬에 패키지를 설치해보자\n\n패키지를 어떤 방식으로 사용하는지에 따라 우리는 로컬 또는 전역에 npm 패키지를 설치할 수 있습니다.\n\n- Node.js의 require을 사용하여 당신의 모듈에서 패키지를 사용하려면 로컬로 설치하면 됩니다. 이는 npm 설치의 기본 동작입니다.\n- 패키지를 CLI와 같은 커맨드 라인 툴에서 사용하려면 전역으로 설치하면 됩니다.\n\n## 패키지 다운로드하기\n\n```\n> npm install <package_name>\n```\n\n명령어를 실행하면 현재 디렉토리에 node_modules 디렉토리가 생성됩니다. (node_modules 디렉토리가 없을 경우)\n그리고 node_modules 디렉토리 안에 다운로드 받은 패키지가 존재하게됩니다.\n\n## 설치된 패키지 어떤 버전일까?\n\n로컬 디렉토리에 package.json 파일이 없다면, 가장 최신 버전의 패키지가 설치됩니다. package.json 파일이 있으면 npm은 package.json 파일에 선언된 semver rule을 만족하는 최신버전을 설치합니다.\n\n예) package.json\n\n```\n...\n\"dependencies\" : {\n\"lodash\" : \"~1.0.4\"\n}\n....\n```\n\nnpm은 package.json에 따라 1.0.4 버전의 lodash 패키지를 설치하게됩니다.\n\n## 패키지를 어떻게 사용할까?\n\n일단 node_modules 디렉토리에 패키지가 있다면, 우리의 코드에서 패키지를 사용할 수 있습니다.\n\n예) index.js 파일\n\n```\nvar lodash = require('lodash');\nvar output = lodash.without([1,2,3],1);\nconsole.log(output);    // 결과 : [2,3]\n```\n\n만약 lodash 패키지가 설치되지않았다면 Error : Cannot find module 'lodash' 에러를 보게될 것 입니다.\n\n# 7. 로컬에 설치된 패키지 삭제해보자\n\nnode_modules 디렉토리의 패키지를 삭제하는 명령어\n\n```\n> npm uninstall lodash\n```\n\npackage.json의 dependecies에서 패키지를 제거하려면 save 플래그를 사용해야합니다.\n\n```\n> npm uninstall --save lodash\n```\n\n**Note:** 패키지가 devDependency로 설치된 경우, package.json에서 제거하는 방법은 다음과 같습니다.\n\n```\n> npm uninstall --save-dev lodash\n```\n\nnode_modules 디렉토리에 해당 패키지가 없다면 삭제가 정상적으로 된 것입니다.\n\n# 8~10. 전역에 패키지를 설치/업데이트/삭제 해보기\n\n패키지 설치\n\n```\n> npm install -g jshint\n```\n\n패키지업데이트\n\n```\n> npm update -g jshint\n```\n\n패키지 삭제\n\n```\n> npm uninstall -g jshint\n```\n"}}}},"pageContext":{"id":"1915e03780a46a3344b4cdf3bc8284ba7af6804e","previousPostId":"577478fb0b78d854a14f939dd2ff68114511aa30","nextPostId":"c636b7749da7503e1608b5aa12d6ee7b06881fa5"}},"staticQueryHashes":["2685952063","2841359383"]}