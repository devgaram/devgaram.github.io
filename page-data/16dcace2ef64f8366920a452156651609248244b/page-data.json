{"componentChunkName":"component---src-templates-blog-post-js","path":"/16dcace2ef64f8366920a452156651609248244b","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"16dcace2ef64f8366920a452156651609248244b","text":"# 백준 - 17837 새로운 게임2(C++)\n\n- Title : 백준 - 17837 새로운 게임2(C++)\n- Date : 2020-01-30\n- Category: 알고리즘 풀이\n\n## 생각의 흐름\n\n- 자료구조는 뭘 사용해야하지?\n- 체스는 구조체로 정의해서 배열로 저장해야겠고.. 보드판 각 칸마다 어떤 체스가 순서대로 있는 지를 표현해야하는 데.. 어떤 걸 사용할까?\n- 앞, 뒤로 pop, push 하고 싶으니깐 deque를 사용해보자..!\n  > 다 푼 후,.. <br/>\n  > 근데.. 다른 사람들 코드를 보니깐 vector를 사용했던 데 나중에 살펴봐야겠다..\n- 구조체 배열을 받을 때는 &를 사용한 참조변수를 사용하자! 그래야 수정도 가능하니깐!\n- A말이 위치한 체스칸의 큐에서 뒤부터 하나씩 빼야겠다. 단, A가 나올 때까지만!\n- 그 다음 뺀 거를 가지고 A말이 이동할 체스칸에 push_back을 해줘야겠지..?\n- 빨간색은 반대로 넣어줘야하니깐 pop_front, pop_back을 적절히 활용해봐야겠다..\n\n```cpp\n#include <iostream>\n#include <deque>\nusing namespace std;\n\nstruct Horse {\n int row, col, dir;\n};\n\nint N, K;\nint prow[4] = {0, 0, -1, 1}; //우,좌,상,하\nint pcol[4] = {1, -1, 0, 0};\n\nHorse horse[10];\nint color[12][12];\ndeque<int> board[12][12];\n\nvoid input() {\n scanf(\"%d %d\", &N, &K);\n\n for (int i=0; i<N; i++) {\n  for (int j=0; j<N; j++) {\n   scanf(\"%d\", &color[i][j]);\n  }\n }\n\n for (int i=0; i<K; i++) {\n  scanf(\"%d %d %d\", &horse[i].row, &horse[i].col, &horse[i].dir);\n  horse[i].row--, horse[i].col--, horse[i].dir--;\n  board[horse[i].row][horse[i].col].push_back(i);\n }\n}\n\nbool move(int k) {\n Horse &h = horse[k];\n int nextrow = h.row + prow[h.dir];\n int nextcol = h.col + pcol[h.dir];\n\n // 범위 밖 or 파란색\n if ((nextrow < 0 || nextcol < 0 || nextrow >= N || nextcol >= N) || color[nextrow][nextcol] == 2) {\n  // 방향 반대로\n  switch(h.dir) {\n   case 0:\n    h.dir = 1;\n    break;\n   case 1:\n    h.dir = 0;\n    break;\n   case 2:\n    h.dir = 3;\n    break;\n   case 3:\n    h.dir = 2;\n    break;\n   default: break;\n  }\n  nextrow = h.row + prow[h.dir];\n  nextcol = h.col + pcol[h.dir];\n\n  if ((nextrow < 0 || nextcol < 0 || nextrow >= N || nextcol >= N) || color[nextrow][nextcol] == 2)\n   return false;\n }\n\n deque<int> &q = board[h.row][h.col];\n deque<int> tmpq;\n int tmpk;\n while (!q.empty()) {\n  tmpk = q.back();\n  // k말 좌표 이동\n  horse[tmpk].row = nextrow;\n  horse[tmpk].col = nextcol;\n\n  // 원래 큐에서 이동할 말들 빼기\n  tmpq.push_front(tmpk);\n  q.pop_back();\n\n  if (tmpk == k) break;\n }\n deque<int> &nextq = board[nextrow][nextcol];\n // 다음 이동칸이 흰색\n if (color[nextrow][nextcol] == 0) {\n  while (!tmpq.empty()) {\n   nextq.push_back(tmpq.front());\n   tmpq.pop_front();\n  }\n } else if (color[nextrow][nextcol] == 1) { // 빨간(순서 반대로)\n  while (!tmpq.empty()) {\n   nextq.push_back(tmpq.back());\n   tmpq.pop_back();\n  }\n }\n if (nextq.size() >= 4) return true;\n else return false;\n}\n\nint main() {\n int ans = 0;\n int i;\n input();\n while (ans++ < 1000) {\n  for (i=0; i<K; i++) {\n   if (move(i)) break;\n  }\n  if (i < K) break;\n }\n\n if (ans > 1000) ans = -1;\n printf(\"%d\", ans);\n return 0;\n}\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"743834917aab9e696c3a64fdc6a0a3dd281ebb68","text":"# 백준 - 17779 게리멘더링2(C++)\n\n- Title : 백준 - 17779 게리멘더링2(C++)\n- Date : 2020-01-31\n- Category: 알고리즘 풀이\n\n## 생각의 흐름\n\n- x, y, d1, d2를 정해야되서 4중 포문을 써야지.. 시간 초과가 나려나.. 일단 해본 후에 최적화하자 --> 시간 초과 발생하지 않음\n\n```cpp\n#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint N;\nint total = 0;\nint A[21][21]; // 인풋용\nint C[21][21]; // 각 구역 표시 용도\nint S[6] ={0, 0, 0, 0, 0, 0}; // 1~5 구역 인구수 합 표시\nint prow[4] = {1, -1, 0, 0};\nint pcol[4]= {0, 0, -1, 1};\nint ans = 40001;\n\n// 구역 그리기\nvoid dfs(int sx, int sy, int ex, int ey, int area) {\n // 좌표가 범위 밖인 경우\n if (sx < 1 || sy < 1 || sx > ex || sy > ey) return;\n if (C[sx][sy] > 0) return; // 이미 다른 구역인 경우\n S[area] += A[sx][sy]; // 인구 수 더하기\n C[sx][sy] = area; // 구역 방문했다는 표시\n for (int i=0; i<4; i++) { // 상하좌우\n  dfs(sx + prow[i], sy + pcol[i], ex, ey, area);\n }\n}\nvoid dividearea(int x, int y, int d1, int d2) {\n int tx, ty;\n memset(C, 0, sizeof(C));\n memset(S, 0, sizeof(S));\n\n /* 경계선 그리기 */\n // 경계선 1, 4번 조건\n for (tx=x, ty=y; tx<=x+d1 && ty>=y-d1; tx++, ty--) {\n  C[tx][ty] = 5, C[tx+d2][ty+d2] = 5;\n  S[5] += A[tx][ty] + A[tx+d2][ty+d2];\n }\n // 경계선 2, 3번 조건\n for (tx=x, ty=y; tx<=x+d2 && ty<=y+d2; tx++, ty++) {\n  C[tx][ty] = 5, C[tx+d1][ty-d1] = 5;\n  S[5] += A[tx][ty] + A[tx+d1][ty-d1];\n }\n\n // 각 구역 인구수 세기\n // 문제에서 주어진 조건대로 시작 좌표와 종료 좌표 입력\n dfs(1, 1, x+d1-1, y, 1); // 1번 구역\n dfs(1, y+1, x+d2, N, 2); // 2번 구역\n dfs(N, 1, N, y-d1+d2-1, 3); // 3번 구역\n dfs(N, N, N, N, 4); // 4번 구역\n\n // 경계선 내부 인구수 계산\n // 위 dfs로 인해 S[]에 인구수 합이 있으므로 얘를 이용하면 경계선 내부 인구 수 알 수 있다.\n int inside= total;\n for (int i=1; i<=5; i++) {\n  inside -= S[i];\n }\n S[5] += inside;\n\n // 최댓값, 최솟값, 정답 구하기\n int largest = 0, smallest = 40001;\n for (int i=1; i<=5; i++) {\n  largest = max(largest, S[i]);\n   smallest = min(smallest, S[i]);\n }\n ans = min(ans, largest - smallest);\n\n}\n\n// x, y, d1, d2 구하기 == 경계썬 구하기\nvoid selectval() {\n int x, y, d1, d2;\n for (x=1; x<=N; x++) {\n  for (y=1; y<=N; y++) {\n   for (d1=1; d1<N; d1++) {\n    for (d2=1; d2<N; d2++) {\n     if (x + d1 + d2 <= N && 1 <= y - d1 && y + d2 <= N) {\n      dividearea(x, y, d1, d2);\n     } else break;\n    }\n   }\n  }\n }\n}\nint main() {\n scanf(\"%d\", &N);\n for (int i=1; i<=N; i++) {\n  for (int j=1; j<=N; j++) {\n   scanf(\"%d\", &A[i][j]);\n   total += A[i][j]; // 나중에 경계선 내부 인구 수 계산할 때 쓰려고 전체 인구수를 저장해놓음\n  }\n }\n selectval();\n printf(\"%d\", ans);\n return 0;\n}\n\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"74f84e9d20d88dabd2edfd88b79237bc44153e4a","text":"# 백준 - 17142 연구소3(C++)\n\n- Title : 백준 - 17142 연구소3(C++)\n- Date : 2020-01-29\n- Category: 알고리즘 풀이\n\n## 입력 받기\n\n- 연구소 상태는 N x N 이니깐 int A[N][n] 형태로 입력을 저장해야겠다.\n- 입력을 받을 때, 선택 가능한 바이러스들(값이 2인)의 row, col 값을 따로 저장할 필요가 있겠네. pair<int, int> V[10] 형태로 저장해야겠다. 바이러스 개수는 최대 10이니깐 배열의 크기는 10으로 하자.\n- 퍼트릴 수 있는 빈 칸의 개수도 카운트 해놓자. 그래야 모든 빈칸에 바이러스를 퍼트렸는 지 알 수 있으니깐.\n- 아! 퍼트린 후 연구소 상태를 원상 복귀해야하니깐 int TMP[N][n] 형태의 2차원 배열을 만들어놔야지.\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nint main() {\n  int A[50][50]; // 연구소\n  int TMP[50][50]; // 연구소 결과 처리용\n  int N, M; // N: 연구소 크기, M: 활성화할 바이러스 수\n  int tcnt = 0; // 연구소 빈칸(0)의 개수\n  pair<int, int> V[10]; // 연구소 선택 가능한 바이러스(2)의 위치\n  int vcnt = 0; // V 배열을 위한 인덱스\n  int prow[4] = {-1, 1, 0, 0}; // 상하좌우 확산 시 사용 row\n  int pcol[4] = {0, 0, -1, 1}; // 상하좌우 확산 시 사용 col\n\n  // 입력받기\n  scanf(\"%d %d\", &N, &M);\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n      TMP[i][j] = A[i][j];\n      if (A[i][j] == 2) V[vcnt++] = make_pair(i, j);\n      if (A[i][j] == 0) tcnt++;\n    }\n  }\n}\n```\n\n## 활성화할 바이러스 선택하기\n\n- DFS로 할 수도 있지만 비트 마스크로 풀어봐야지\n- 만약 5개의 바이러스 중 3개를 선택해야한다면 범위는 00111 ~ 11100 이다.\n- 근데 사실, DFS로 하는 게 코드가 간단해서... DFS가 나을 듯,, 비트 마스크로 풀다가 실수를 너무 많이 했다.\n\n```cpp\n  unsigned int flag = (1 << M) - 1; // 시작 플래그, unsigned int는 양수 범위를 가짐\n  int tcc = M;\n  unsigned int fin = 0; // 종료 플래그\n  // 종료 플래그 만들기.\n  while (tcc-- > 0) {\n    fin |= (1 <<  (vcnt - 1 - tcc));\n  }\n  unsigned int curflag = 0; // 조작용\n  int fcnt = 0;\n  int pos = 0;\n  queue<pair<int, int> > q;\n  // 시작플래그 ~ 종료플래그\n  for (flag; flag<=fin; flag++) {\n    curflag = flag;\n    fcnt = 0;\n    // 1비트 개수 세기, M개 일때만 코드 진행\n    while (curflag > 0) {\n      if (curflag & 1 == 1) fcnt++;\n      if (fcnt > M) break;\n      curflag = curflag >> 1;\n    }\n    if (fcnt != M) continue;\n\t\t// 이제 고른 바이러스 표시하기\n    curflag = flag;\n    pos = 0;\n    while (curflag > 0) {\n      if (curflag & 1 == 1) {\n        TMP[V[pos].first][V[pos].second] = -1; // 바이러스 복제\n        // 큐에 선택한 바이러스 넣기 -> 퍼트리기에서 BFS로 사용할 예정\n        q.push(make_pair(V[pos].first, V[pos].second));\n      }\n      pos++;\n      curflag = curflag >> 1;\n    }\n    // ...바이러스 퍼트리기가 이어진다.\n  }\n```\n\n## 바이러스 퍼트리기\n\n- 만약 백준에서 제출 시 100%에서 틀린다면 비활성화 바이러스도 시간 체크했는 지 살펴봐야한다.\n  여기서 엄청 헤매서 시간 다 잡아먹었다ㅠㅠ\n- 쉽게 설명하자면 대부분 BFS로 q가 빌 때까지 반복을 돌릴텐데 만약 이미 빈칸(0)에는 다 전파했는 데 q에 비활성화(선택 못 받은 바이러스)가 있다면? 이 상황을 이해한다면 오류를 잡을 수 있을 거다.\n  > 반례가 있어야 이해가 되겠죠?  \n  > 5 1  \n  > 1 1 1 1 1  \n  > 1 1 1 1 1  \n  > 1 1 1 1 1  \n  > 2 0 0 2 0  \n  > 1 1 1 1 1  \n  > answer : 2\n- 사실 q에 시간 체크용 값도 넣어버려서.. 복잡하게 풀어버린 것 같다..\n- 더 간단히 풀 수 있을 듯..\n\n```cpp\n  // ..위에는 바이러스 선택하기\n  // 시간 체크용, 현재 q에는 선택된 바이러스가 있고 얘는 0초이므로 0을 넣어준다. -1은 구분 용\n  q.push(make_pair(-1, 0));\n  spread = 0; // 퍼진 바이러스\n  time = 0; // 시간\n  stopflag = false; // 빈칸에 다 퍼트렸으면 true로 바꿀거다.\n  while (!q.empty()) {\n    // c++에서 q.pop()은 void 메소드라서 q.front()로 값 가져온다.\n    pair<int, int> po = q.front();\n    q.pop();\n    if (po.first >= 0) { // 퍼트린 칸이면\n      if (A[po.first][po.second] == 0) spread++; // 해당 칸이 원래 빈칸(0)이면 값 증가\n      if (spread == tcnt) stopflag = true; // 빈칸에 다 퍼트리면 시간체크용 값 나올 때 스탑하려고\n      for (int i=0; i<4; i++) { // 상하좌우 처리\n        nextrow = po.first + prow[i];\n        nextcol = po.second + pcol[i];\n        if (nextrow < 0 || nextrow >= N || nextcol < 0 || nextcol >= N) continue; // 범위 밖\n        if (TMP[nextrow][nextcol] == -1 || TMP[nextrow][nextcol] == 1) continue;\n        q.push(make_pair(nextrow, nextcol)); // 큐에 넣자넣자!\n        TMP[nextrow][nextcol] = -1; // 퍼트렸다는(방문했다는) 표시!\n      }\n    } else { // 시간체크용\n      time = po.second;\n      if (!q.empty()) q.push(make_pair(-1, po.second + 1));\n      if (stopflag) break; // 이미 모든 빈칸에 퍼트렸으면 나오자!\n    }\n  }\n  while (!q.empty()) // 위 반복에서 stopflag에 의해 중간에 빠져나왔을 경우를 대비해서\n  {\n    q.pop();\n  }\n  // 시간 넣자!!\n  if (spread == tcnt && ans > time) ans = time;\n```\n\n## 원상복귀\n\n- TMP는 또 써야하니깐!\n\n```cpp\nfor (int i=0; i<N; i++) {\n  for (int j=0; j<N; j++) {\n    TMP[i][j] = A[i][j];\n  }\n}\n```\n\n## 전체 코드\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <limits>\nusing namespace std;\n\n\nint A[50][50];\nint TMP[50][50];\nint N, M;\nint vcnt = 0;\nint tcnt = 0;\npair<int, int> V[10];\nint prow[4] = {-1, 1, 0, 0};\nint pcol[4] = {0, 0, -1, 1};\n\nint main() {\n  // 입력받기\n  scanf(\"%d %d\", &N, &M);\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n      TMP[i][j] = A[i][j];\n      if (A[i][j] == 2) V[vcnt++] = make_pair(i, j);\n      if (A[i][j] == 0) tcnt++;\n    }\n  }\n  unsigned int flag = (1 << M) - 1; // 시작 플래그, unsigned int는 양수 범위를 가짐\n  int tcc = M;\n  unsigned int fin = 0; // 종료 플래그\n  // 종료 플래그 만들기.\n  while (tcc-- > 0) {\n    fin |= (1 <<  (vcnt - 1 - tcc));\n  }\n  unsigned int curflag = 0; // 조작용\n  int fcnt = 0;\n  int pos = 0;\n  int nextrow = 0, nextcol = 0;\n  queue<pair<int, int> > q;\n  int spread = 0, time = 0;\n  int ans = numeric_limits<int>::max();\n  bool stopflag = false;\n  // 시작플래그 ~ 종료플래그\n  for (flag; flag<=fin; flag++) {\n    curflag = flag;\n    fcnt = 0;\n    // 1비트 개수 세기, M개 일때만 코드 진행\n    while (curflag > 0) {\n      if (curflag & 1 == 1) fcnt++;\n      if (fcnt > M) break;\n      curflag = curflag >> 1;\n    }\n    if (fcnt != M) continue;\n\t\t// 이제 고른 바이러스 표시하기\n    curflag = flag;\n    pos = 0;\n    while (curflag > 0) {\n      if (curflag & 1 == 1) {\n        TMP[V[pos].first][V[pos].second] = -1; // 바이러스 복제\n        // 큐에 선택한 바이러스 넣기 -> 퍼트리기에서 BFS로 사용할 예정\n        q.push(make_pair(V[pos].first, V[pos].second));\n      }\n      pos++;\n      curflag = curflag >> 1;\n    }\n    q.push(make_pair(-1, 0));\n    spread = 0; // 퍼진 바이러스\n    time = 0; // 시간\n    stopflag = false; // 빈칸에 다 퍼트렸으면 true로 바꿀거다.\n    while (!q.empty()) {\n      // c++에서 q.pop()은 void 메소드라서 q.front()로 값 가져온다.\n      pair<int, int> po = q.front();\n      q.pop();\n      if (po.first >= 0) { // 퍼트린 칸이면\n        if (A[po.first][po.second] == 0) spread++; // 해당 칸이 원래 빈칸(0)이면 값 증가\n        if (spread == tcnt) stopflag = true; // 빈칸에 다 퍼트리면 시간체크용 값 나올 때 스탑하려고\n        for (int i=0; i<4; i++) { // 상하좌우 처리\n          nextrow = po.first + prow[i];\n          nextcol = po.second + pcol[i];\n          if (nextrow < 0 || nextrow >= N || nextcol < 0 || nextcol >= N) continue; // 범위 밖\n          if (TMP[nextrow][nextcol] == -1 || TMP[nextrow][nextcol] == 1) continue;\n          q.push(make_pair(nextrow, nextcol)); // 큐에 넣자넣자!\n          TMP[nextrow][nextcol] = -1; // 퍼트렸다는(방문했다는) 표시!\n        }\n      } else { // 시간체크용\n        time = po.second;\n        if (!q.empty()) q.push(make_pair(-1, po.second + 1));\n        if (stopflag) break; // 이미 모든 빈칸에 퍼트렸으면 나오자!\n      }\n    }\n    while (!q.empty()) // 위 반복에서 stopflag에 의해 중간에 빠져나왔을 경우를 대비해서\n    {\n      q.pop();\n    }\n    // 시간 넣자!!\n    if (spread == tcnt && ans > time) ans = time;\n    for (int i=0; i<N; i++) {\n      for (int j=0; j<N; j++) {\n        TMP[i][j] = A[i][j];\n      }\n    }\n  }\n  if (ans == numeric_limits<int>::max()) ans = -1;\n  printf(\"%d\", ans);\n  return 0;\n}\n```\n"}}}},"pageContext":{"id":"16dcace2ef64f8366920a452156651609248244b","previousPostId":"743834917aab9e696c3a64fdc6a0a3dd281ebb68","nextPostId":"74f84e9d20d88dabd2edfd88b79237bc44153e4a"}},"staticQueryHashes":["2685952063","2841359383"]}