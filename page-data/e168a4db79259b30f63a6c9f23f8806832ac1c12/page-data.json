{"componentChunkName":"component---src-templates-blog-post-js","path":"/e168a4db79259b30f63a6c9f23f8806832ac1c12","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e168a4db79259b30f63a6c9f23f8806832ac1c12","text":null}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"a4f5ba562def4c89e50365067823859bbeb87faf","text":"# mssql 쿼리 팁 - 여러 행의 데이터를 한 칼럼에 담기\n\n- Title : mssql 쿼리 팁 - 여러 행의 데이터를 한 칼럼에 담기\n- Date : 2018-01-26\n- Category: Database\n\n<table class=\"half\">\n<thead>\n\t<tr><th>IDX</th><th>NAME </th></tr>\n</thead>\n<tbody>\n\t<tr><td>1</td><td>A</td></tr>\n\t<tr><td>1</td><td>B</td></tr>\n\t<tr><td>1</td><td>C</td></tr>\n\t<tr><td>2</td><td>B</td></tr>\n\t<tr><td>2</td><td>D</td></tr>\n</tbody>\n</table>\n\n위 테이블을 아래와 같이 출력하고 싶다.\n\n<table class=\"half\">\n<thead>\n\t<tr><th>IDX</th><th>NAME </th></tr>\n</thead>\n<tbody>\n\t<tr><td>1</td><td>A,B,C</td></tr>\n\t<tr><td>2</td><td>B,D</td></tr>\t\n</tbody>\n</table>\n\n<br/><br/>\n\n```sql\nSELECT\n\tDISTINCT IDX,\n\tSTUFF\n\t( (\n\t\tSELECT ',' + NAME FROM TB_NAME A WHERE A.IDX = B.IDX\n\t\tFOR XML PATH('')\n\t),1,1,'') AS NAME\nFROM TB_NAME B\n```\n\nSTUFF(STRING,1,1,'') - 맨 앞 문자 한개 제거\n\n# STUFF 함수\n\n[참고페이지](https://docs.microsoft.com/ko-kr/sql/t-sql/functions/stuff-transact-sql)\n\nSTUFF ( character_expression , start , length , replaceWith_expression )\n\n<table>\n<thead>\n\t<tr><th>인수</th><th>설명</th></tr>\n</thead>\n<tbody>\n\t<tr><td>start</td><td>삭제 및 삽입 시작 위치, 0, 음수면 NULL이 반환된다.</td></tr>\n\t<tr><td>length</td><td>삭제 할 문자 수 지정, 0, 음수면 NULL이 반환된다.</td></tr>\t\n\t<tr><td>replaceWith_expression </td><td>''이면 아무것도 삽입하지 않고 문자를 제거</td></tr>\t\n</tbody>\n</table>\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"730d28228be53db5c50f0e775778382b6d38f577","text":"# HTTP 커넥션(part 2, TCP 성능에 대한 고려)\n\n- Title : HTTP 커넥션(part 2, TCP 성능에 대한 고려)\n- Date : 2020-12-26\n- Category : Network\n\n> HTTP는 TCP 바로 위의 계층이기 때문에 좋은 성능의 HTTP 애플리케이션을 설계하고 구현하기 위해서는 기본적인 TCP 성능의 특성을 이해해야 한다.\n\n## HTTP 트랜잭션 지연의 원인\n\n![HTTP트랜잭션 처리되는 과정](https://raw.githubusercontent.com/devgaram/TIL/master/Network/images/2020-12-26-img/1.png)\n\n위 그림은 HTTP 트랜잭션이 처리되는 과정을 타임라인 방식으로 보여준다. 그림을 보면 HTTP 트랜잭션을 처리하는 시간은 TCP 커넥션을 설정하고, 요청을 전송하고, 응답 메시지를 보내는 것에 비하면 상당히 짧다는 것을 알 수 있다. 클라이언트와 서버가 너무 많은 데이터를 내려받거나 복잡하고 동적인 자원들을 실행하지 않는 한 **대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생**한다.\n\n### 원인\n\n1. DNS Lookup: 클라이언트는 DNS 이름 분석 인프라를 사용하여 URI에서 웹 서버의 IP 주소와 포트 번호를 알아내야 한다.\n2. Connect: 클라이언트는 TCP 커넥션 요청을 서버에게 보내고 서버가 커넥션 허가 응답을 회신하기를 기다린다. 수백 개의 HTTP 트랜잭션이 만들어지면 소요 시간은 크게 증가한다.\n3. Request: 커넥션이 맺어지면 클라이언트는 HTTP 요청을 새로 생성된 TCP 파이프를 통해 전송한다.\n4. Process: 웹 서버는 데이터 도착하는 대로 TCP 커넥션에서 요청 메시지를 읽고 처리한다.\n5. Response: 웹 서버가 HTTP 응답을 보낸다.\n\n## HTTP 성능에 영향을 주는 TCP 지연의 원인\n\n### TCP 커넥션 핸드셰이크 지연\n\n![TCP 커넥션 핸드셰이크](https://raw.githubusercontent.com/devgaram/TIL/master/Network/images/2020-12-26-img/2.png)\n\n✔️  **TCP 커넥션이 핸드셰이크 하는 순서**\n\n1. 클라이언트는 **SYN** 플래그를 가진 TCP 패킷을 서버에게 보낸다. 40~60바이트로 작은 크기의 패킷이다. \n2. 서버는 커넥션 요청을 받아들였다는 의미로 **SYN + ACK** 플래그를 가진 TCP 패킷을 클라이언트에게 보낸다.\n3. 클라이언트는 커넥션이 잘 맺어졌다는 것을 알리기 위해 서버에게 **ACK 와 HTTP 요청 메시지**를 보낸다.\n\n✔️  **결론**\n\n작은 크기의 HTTP 트랜잭션은 SYN, SYN+ACK 핸드셰이크로 인해 50%의 시간을 TCP 구성에 써버린다. 또한 ACK 패킷은 HTTP 요청 메시지 전체를 전달할 수 있을 만큼 크고 HTTP 서버 응답 메시지는 하나의 IP 패킷에도 담길 수 있다.\n\n### 확인 응답(ACK) 지연\n\n✔️  **TCP는 어떻게 신뢰성 있는 통신을 할까?**\n\nTCP 세그먼트는 순번과 데이터 무결성 체크섬을 가진다. 수신자는 세그먼트가 온전하다고 판단되면 ACK 패킷을 송신자에게 반환한다. 송신자는 특정 시간 안에 ACK 패킷을 받지 못하면 패킷이 파괴되었거나 오류가 있는 것으로 판단하고 데이터를 다시 전송한다.\n\n✔️  **확인 응답 알고리즘이란?**\n\n네트워크를 효율적으로 사용하기 위해 TCP는 크기가 작은 확인 응답을 같은 방향으로 송출되는 **데이터 패킷에 편승(piggyback)** 시킨다. 피기백 경우를 늘리기 위해 확인 응답 알고리즘을 사용한다. 알고리즘은 송출할 확인 응답을 특정 시간 동안 버퍼에 저장해두고 편승시킬 데이터 패킷을 찾는다. 일정 시간안에 데이터 패킷을 찾지 못하면 확인 응답을 별도 패킷을 만들어 전송한다. 이 때 발생되는 지연이 확인 응답 지연이다.\n\n✔️  **결론**\n\n요청과 응답 두 가지 형식으로만 이루어지는 HTTP 동작 방식은 확인 응답이 송출 데이터 패킷에 편승할 기회를 감소시킨다. 막상 편승할 패킷을 찾으려고 하면 해당 방향으로 송출될 패킷이 많지 않기 때문에 확인응답 지연 알고리즘으로 인한 지연이 자주 발생한다.\n\n### TCP 느린 시작\n\nTCP 느린 시작은 TCP가 한 번에 전송할 수 있는 패킷의 수를 제한한다. 패킷이 성공적으로 전달되는 각 시점에 송신자는 추가로 2개의 패킷을 더 전송할 수 있는 권한을 얻는다. 급작스런 부하와 혼잡을 방지하는 데 쓰이는 이 혼잡 제어 기능 때문에 새로운 커넥션보다 이미 어느 정도 데이터를 주고 받은 튜닝된 커넥션이 더 빠르다. HTTP 지속 커넥션과 관련 있다.\n\n### 네이글(Nagle) 알고리즘과 TCP_NODELAY\n\n> 실리 윈도 증후군 전송자는 1바이트 크기의 패킷을 대량으로 전송하는 것으로 네트워크 성능을 크게 떨어뜨린다. 네이글 알고리즘은 이를 방지하기 위해 등장했다.\n\n네이글 알고리즘은 네트워크 효율을 위해 **패킷을 전송하기 전에 많은 양의 TCP 데이터를 한 개의 덩어리로** 합친다. 세그먼트가 최대 크기(랜상 1,500바이트, 인터넷상 수백 바이트)가 되지 않으면 전송을 하지 않는다. 다만 다른 **모든 패킷이 확인 응답을 받았을 경우에는 최대 크기보다 작은 패킷의 전송을 허락**한다. 다른 패킷들이 아직 전송 중이면 데이터는 버퍼에 저장된다. \n\n✔️  **네이글 알고리즘은 HTTP 성능을 어떻게 지연시키나?**\n\n- 크기가 작은 HTTP 메시지는 세그먼트의 최대 크기를 채우지 못해 계속해서 지연된다.\n- 확인 응답 알고리즘과 함께 쓰면 지연이 더 심해진다. 확인 응답 알고리즘은 확인 응답을 100~200 밀리초 지연시키게 되고 네이글 알고리즘은 확인 응답이 도착할 때까지 데이터 전송을 멈추기 때문이다.\n\n✔️  **해결**\n\nHTTP 스택에 TCP_NODELAY 파라미터 값을 설정하여 네이글 알고리즘을 비활성화 할 수 있다. 단, 작은 크기의 패킷이 너무 많이 생기지 않도록 큰 크기의 데이터 덩어리를 만들어야 한다.\n\n### TIME_WAIT의 누적과 포트 고갈\n\n성능 측정 시에 심각한 성능 저하를 발생시키나, 실제 상황에서는 문제를 발생시키지 않는다.\n\n참고 책 - HTTP 완벽 가이드"}}}},"pageContext":{"id":"e168a4db79259b30f63a6c9f23f8806832ac1c12","previousPostId":"a4f5ba562def4c89e50365067823859bbeb87faf","nextPostId":"730d28228be53db5c50f0e775778382b6d38f577"}},"staticQueryHashes":["2685952063","2841359383"]}