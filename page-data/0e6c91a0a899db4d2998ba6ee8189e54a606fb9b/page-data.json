{"componentChunkName":"component---src-templates-blog-post-js","path":"/0e6c91a0a899db4d2998ba6ee8189e54a606fb9b","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"0e6c91a0a899db4d2998ba6ee8189e54a606fb9b","text":"# 알고리즘 개념 잡자 - 연결리스트\n\n- Title : [코딩인터뷰] 연결리스트\n- Date : 2019-12-12\n- Category: Algorithm\n\n코딩 인터뷰 완전분석 연결리스트 파트 예제 문제 풀이\n\n# 배열\n\n## Random access\n\n배열의 엘리먼트들은 메모리에 연속적으로 저장되므로 어떤 엘리먼트도 첫번째 엘리먼트의 주소에 각 엘리먼트 크기를 더해서 접근할 수 있다.  \n각 엘리먼트가 4byte고 세번째 엘리먼트 접근하려면 첫번째 주소 + 4\\*3 이다.  \n즉, 첫번째 탐색이나 마지막 엘리먼트 탐색 시간 차이가 없다. 탐색 시간 O(1) 가능하다.\n\n## 메모리 낭비\n\n개발자가 메모리를 얼마나 사용할 지 모르는 상태에서 배열의 크기를 초기화해야한다.\n\n## 삽입 삭제 연산 느림\n\n첫번째 또는 중간 삽입의 경우 삽입 엘리먼트 공간 확보를 위해 배열을 한칸씩 뒤로 이동시켜야한다.  \n삭제는 반대로 한칸씩 앞으로 이동시켜야하고 배열의 크기를 재조정해야 한다.  \n즉, n개의엘리먼트를 이동시켜야하므로 O(n) 단 맨끝 삭제는 o(1)\n\n# 연결리스트\n\n## Iterate access\n\n배열과 달리 메모리에 연속적 공간 갖지않고 첫번째 노드의 포인터부터 순회해야한다.  \n즉, 탐색은 O(n) 시간복잡도를 가져서 배열보다 탐색이 느리다.\n\n## 리스트 크기를 미리 정의해놓을필요가없음\n\n## 삽입 삭제 연산 빠름\n\n중간노드 끝노드의 경우 위치 찾는데는 o(n) 이지만 실제 삽.삭은 포인터만 업데이트하면되니깐 o(1)이다.  \n단, 맨 앞 노드는 o(1)\n\n# 2.1 중복 없애기 : 정렬되어 있지 않은 연결리스트가 주어졌을 때 이 리스트에서 중복되는 원소를 제거하는 코드를 작성하자. 임시 버퍼를 사용할 수 없는 경우도 생각해보자.\n\n1. 임시버퍼를 사용할 수 있다면, 중복을 허용하지 않는 Set 컬렉션을 이용해서 해결할 수 있다. 이 경우는 O(N)의 시간 복잡도를 갖는다.\n2. 임시버퍼를 사용할 수 없다면, 이중 반복문을 통해 중복 노드를 찾은 후 제거하면 된다. 이 경우는 O(N^2)의 시간 복잡도를 갖는다.\n\n## 자바스크립트 풀이\n\n```javascript\n\"use strict\";\n\nclass Node {\n  constructor(data, next) {\n    this.data = data;\n    this.next = next;\n  }\n}\n\nclass LinkedList {\n  constructor(head) {\n    this.head = head;\n  }\n\n  display() {\n    let cur = this.head;\n    while (cur != null) {\n      console.log(cur.data);\n      cur = cur.next;\n    }\n  }\n}\n\nfunction makeList() {\n  let n6 = new Node(4);\n  let n5 = new Node(5, n6);\n  let n4 = new Node(3, n5);\n  let n3 = new Node(5, n4);\n  let n2 = new Node(4, n3);\n  let n1 = new Node(5, n2);\n  let list = new LinkedList(n1);\n  return list;\n}\n\n// O(n) n: 연결리스트 길이\nfunction solution() {\n  const list = makeList();\n  const set = new Set();\n  let cur = list.head;\n  let pre = null;\n  while (cur != null) {\n    if (set.has(cur.data)) {\n      pre.next = cur.next;\n    } else {\n      set.add(cur.data);\n      pre = cur;\n    }\n    cur = cur.next;\n  }\n  list.display();\n}\n\n// O(N^2) 버퍼 없이\nfunction solution_2() {\n  const list = makeList();\n  let cur = list.head;\n\n  while (cur != null) {\n    let mn = cur;\n\n    while (mn.next != null) {\n      if (cur.data === mn.next.data) {\n        mn.next = mn.next.next;\n      } else {\n        mn = mn.next;\n      }\n    }\n    cur = cur.next;\n  }\n\n  list.display();\n}\n\nsolution();\nsolution_2();\n```\n\n**자바스크립트의 null과 undefined**  \n자바스크립트에서 '없음'을 나타내는 값에 null과 undefined가 있다. 값이 대입되지 않은 변수나 속성의 경우는 undefined이며 객체가 없는 경우는 null로 나타낸다.  \n자바스크립트의 === 등호는 값이 정확히 같을 때 true를 반환하나 == 등호는 그렇지 않을 때가 많다. 보통의 경우는 === 를 권장하나 null check 할 때는 == 쓰면 값이 null 또는 undefined의 경우 false를 리턴 받을 수 있다.\n\n**자바스크립트의 class**  \nES6의 클래스 선언은 호이스팅이 되지 않아서 클래스를 사용하기 위해서는 클래스를 먼저 선언해야 한다. class body는 {}로 묶여 있는 안쪽 부분으로 constructor(생성자)가 있는 곳이다. 객체를 생성하고 초기화하는 메소드로 클래스 안에 한 개만 존재할 수 있다. 부모 생성자를 호출하기 위해 super 키워드를 사용할 수도 있다.\n\n**자바스크립트에서 오토박싱**  \nnon-strict 모드에서 this 값이 null 혹은 undefined 일 경우 window 객체로 자동으로 변환을 해주는 것을 오토박싱이라고 한다. 그래서 일반 메서드에서 this 값이 window 객체가 된다. class 문법 안에 있는 코드는 항상 strict mode로 실행되기 때문에 클래스 메서드 호출에서 this의 초기값은 undefined다.\n\n**자바에서 오토박싱**  \n자바에는 int, float와 같은 기본형(primitive type)과 Integer, Float와 같은 래퍼 클래스가 있다. 래퍼 클래스는 기본형을 객체로 다루어야 할 경우에 사용할 수 있다. 컬렉션에서 엘리먼트는 객체가 되어야 되서 int 기본형을 사용하지 않고 Integer를 사용하는 것을 본 적이 있을 거다. 박싱은 기본형을 참조형으로 변환하는 것이고 언박싱은 반대로 참조형을 기본형으로 바꾸는 것이다. 예제를 통해 확실히 이해해보자.\n\n```java\nint pa = 1;\nInteger wa = pa; // 오토박싱\n\nInteger wb = new Integer(2);\nint pb = wb; // 오토언박싱\n\n```\n\n## 자바 풀이\n\n**리스트 반복하면서 삭제하기**  \nfor(;;)를 이용한 방법은 반복 도중 엘리먼트가 삭제되면 반복문의 크기가 변한다. 또한 삭제된 엘리먼트 자리를 채우기 위해 모든 인덱스가 하나씩 이동하게 된다. 생각대로 동작하지 않는 것 당연하다.\n\nfor-each문 안에서 엘리먼트를 삭제하게 되면 **java.util.ConcurrentModificationException** 에러를 보게 된다. Iterator로 반복 중인 리스트를 수정하려 하면 이 에러가 발생된다. for-each 문은 내부적으로 iterator를 실행하므로 remove()나 add()를 할 경우 에러가 발생되는 것이다.\n\n그래서 반복을 하면서 삭제를 하려면 Itertor 인터페이스를 사용하거나 Collection 인터페이스의 removeif 메서드를 사용한다.\n\n```java\n  public static void main(String[] args) {\n\t\tLinkedList<Integer> list = new LinkedList<>(Arrays.asList(5,4,2,3,5,4));\n\t\tsolution(list);\n\t}\n\n\tpublic static void solution(LinkedList<Integer> list) {\n\t\t// 1번 iterator 사용\n\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\tIterator<Integer> it = list.iterator();\n\n\t\twhile(it.hasNext()) {\n\t\t\tint next = it.next();\n\t\t\tif (set.contains(next)) it.remove();\n\t\t\telse set.add(next);\n\t\t}\n\n\t\t// 2번 removeif 사용\n\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\tlist.removeIf(num -> {\n\t\t\tif (set.contains(num)) return true;\n\t\t\telse {\n\t\t\t\tset.add(num);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}\n```\n\n# 2.2 뒤에서 K번째 원소 구하기: 단방향 연결리스트가 주어졌을 때 뒤에서 K번째 원소를 찾는 알고리즘을 구현하라.\n\n## 내 풀이\n\n리스트의 크기를 구하기 위해 한번 순회한 다음, 리스트 크기에 k만큼 뺀 index까지 반복을 돌려 원소를 찾았다.  \n시간 복잡도는 O(N)\n\n```javascript\nfunction solution_2(k) {\n  const list = makeList();\n\n  let cur = list.head;\n  let len = 0;\n  while (cur != null) {\n    len++;\n    cur = cur.next;\n  }\n\n  cur = list.head;\n  for (let i = 0; i < len - k; i++) {\n    cur = cur.next;\n  }\n\n  if (len - k < 0) return null;\n  else return cur.data;\n  //console.log(`뒤에서 ${k}번째 원소 값 : ${cur.data}`);\n}\n```\n\n## 반복문을 한번만 돌릴 수 있다면?\n\nRunner 기법을 사용했다. 연결리스트 문제에서 많이 활용되는 기법으로 순회할 때 두 개의 포인터를 동시에 사용하는 방법이다. 이 때 한 포인트가 다른 포인터보다 앞서도록 하며 앞선 포인터가 따라오는 포인터보다 **항상 지정된 개수만큼** 앞서거나, 따라오는 포인터를 **여러 노드를 한번에 뛰어넘도록** 설정할 수 있다.\n\n시간복잡도는 O(N) 이다.\n\n```javascript\nfunction solution_2_1(k) {\n  const list = makeList();\n\n  let cur = list.head;\n  let runner = cur;\n  let len = 0;\n  while (cur != null) {\n    if (len++ >= k) runner = runner.next;\n    cur = cur.next;\n  }\n  if (len - k < 0) return null;\n  else return runner.data;\n  // console.log(`뒤에서 ${k}번째 원소 값 : ${runner.data}`);\n}\n```\n\n# 2.3 중간 노드 삭제: 단방향 연결리스트가 주어졌을 때 중간(정확히 가운데 노드일 필요는 없고 처음과 끝 노드만 아니면 된다)에 있는 노드 하나를 삭제하는 알고리즘을 구현해라. 단, 삭제할 노드에만 접근할 수 있다.\n\nRunner 기법으로 중간 노드를 찾고 찾은 노드의 data와 next 값을 바로 다음 노드의 값으로 바꾼 다음 다음 노드의 next를 찾은 노드의 next로 지정한다.\n\n```javascript\nfunction solution_3() {\n  const list = makeList();\n  let cur = list.head;\n  let runner = list.head;\n  let len = 0;\n  while (cur != null) {\n    cur = cur.next;\n    if (++len % 2 == 0) runner = runner.next;\n  }\n\n  if (runner.next == null) {\n    runner.data = null;\n  } else {\n    runner.data = runner.next.data;\n    runner.next = runner.next.next;\n  }\n\n  list.display();\n}\n```\n\n```javascript\nfunction solution_3() {\n  const list = makeList();\n\n  let cur = list.head;\n  let prerunner = null;\n  let runner = list.head;\n  let len = 0;\n  while (cur != null && cur.next != null) {\n    cur = cur.next.next;\n    prerunner = runner;\n    runner = runner.next;\n  }\n  if (cur != null) {\n    prerunner = runner;\n    runner = runner.next;\n  }\n  // 노드 갯수가 2 이하일 때, 처음/끝 노드가 삭제되는 것을 막기 위해\n  if (prerunner == null || runner.next == null) return;\n\n  prerunner.next = runner.next;\n  list.display();\n}\n```\n\n# 2.4 분할: 값 x가 주어졌을 때 x보다 작은 노드들을 x보다 크거나 같은 노드들보다 앞에 오도록 하는 코드를 작성하라. 만약 x가 리스트에 있다면 x는 그보다 작은 원소들보다 뒤에 나오기만 하면 된다. 즉, 원소 x는 '오른쪽 그룹' 어딘가에만 존재하면 된다. 왼쪽과 오른쪽 그룹 사이에 있을 필요는 없다.\n\n- 입력: 3->5->8->5->10->2->1 (분할값 x = 5)\n- 출력: 3->1->2->10->5->5->8\n\n순회를 하면서 data 값이 x보다 작은 경우에는 무조건 맨 앞으로 이동시키는 식으로 해결했다.\n\n```javascript\nfunction solution_4(x) {\n  const list = makeList();\n  let cur, pre;\n  if (list.head.data < x) {\n    cur = list.head.next;\n    pre = list.head;\n  } else {\n    cur = list.head;\n    pre = null;\n  }\n\n  while (cur != null) {\n    if (cur.data < x) {\n      pre.next = cur.next;\n      cur.next = list.head;\n      list.head = cur;\n      cur = pre.next;\n    } else {\n      pre = cur;\n      cur = cur.next;\n    }\n  }\n\n  list.display();\n}\n```\n\n## 그렇다면 원소의 순서를 유지하면서 x보다 작은 노드들을 x의 앞에 위치하게 하고 싶다면?\n\n두 개의 연결리스트를 만들어서 하나는 x보다 작은 노드들을 삽입하고 다른 하나는 x보다 크거나 같은 노드들을 넣는다. 모든 작업이 완료된 후 두 리스트를 합하면 된다.\n\n# 2.5 리스트의 합: 연결리스트로 숫자를 표현할 때 각 노드가 자릿수 하나를 가리키는 방식으로 표현할 수 있다. 각 숫자는 역순으로 배열되어 있는데, 첫 번째 자릿수가 리스트의 맨 앞에 위치하도록 배열된다는 뜻이다. 이와 같은 방식으로 표현된 숫자 두 개가 있을 때, 이 두 수를 더하여 그 합을 연결리스트로 반환하는 함수를 작성하라\n\n- 입력: (7->1->6) + (5->9->2) 즉, 617 + 295\n- 출력: 2->1->9 즉, 912\n\n```javascript\nfunction solution_5(list_1, list_2) {\n  let cur_1 = list_1.head,\n    cur_2 = list_2.head;\n  let c = 0;\n  let newListHead = null;\n  let newList = null;\n  while (cur_1 != null || cur_2 != null) {\n    if (cur_1 == null || cur_2 == null) {\n      newList.next = cur_1 == null ? cur_2 : cur_1;\n      break;\n    }\n    let sum = cur_1.data + cur_2.data + c;\n    if (newList == null) {\n      newList = new Node(sum % 10);\n      newListHead = new LinkedList(newList);\n    } else {\n      newList.next = new Node(sum % 10);\n      newList = newList.next;\n    }\n    c = parseInt(sum / 10);\n    cur_1 = cur_1.next;\n    cur_2 = cur_2.next;\n  }\n\n  newListHead.display();\n}\n```\n\n## 각 자릿수가 정상적으로 배열된다고 가정하고 같은 문제를 풀면?\n\n- 입력: (6->1->7) + (2->9->5) 즉, 617+295\n- 출력: 9->1->2 즉, 912\n\n재귀로 순회해서 끝에서 부터 더해가면 된다. 단, 리스트의 길이가 다를 경우가 있으므로 이 부분을 고려해야 한다.\n재귀 안에서 해결해볼까 했는 데, 복잡해져서 아예 길이를 같게 만드는 방법으로 해보았다.\n\n```javascript\nfunction solution_5_1(list_1, list_2) {\n  let list_1_len = getSize(list_1.head),\n    list_2_len = getSize(list_2.head);\n\n  while (list_1_len > list_2_len) {\n    list_2.head = new Node(0, list_2.head);\n    list_2_len++;\n  }\n  while (list_1_len < list_2_len) {\n    list_1.head = new Node(0, list_1.head);\n    list_1_len++;\n  }\n\n  let newList = null;\n  recursion(list_1.head, list_2.head);\n\n  newList.display();\n  function recursion(cur_1, cur_2) {\n    if (cur_1 == null && cur_2 == null) return 0;\n    let sum = cur_1.data + cur_2.data + recursion(cur_1.next, cur_2.next);\n    if (newList == null) {\n      newList = new LinkedList(new Node(sum % 10));\n    } else {\n      newList.head = new Node(sum % 10, newList.head);\n    }\n    return parseInt(sum / 10);\n  }\n\n  function getSize(list) {\n    let cur = list;\n    let len = 0;\n    while (cur != null) {\n      len++;\n      cur = cur.next;\n    }\n    return len;\n  }\n}\n```\n\n# 회문: 주어진 연결리스트가 회문인지 검사하는 함수를 작성하라\n\n회문이란? 순서를 거꾸로 읽어도 제대로 읽은 것과 같은 단어와 문장을 말한다.  \n예시) level, sos\n\n```javascript\nfunction solution_6(list) {\n  let cur = list.head;\n  return recursion(list.head);\n\n  function recursion(list) {\n    if (list == null) return true;\n    let chk = recursion(list.next) && cur.data === list.data;\n    cur = cur.next;\n    return chk;\n  }\n}\n```\n\n## 책 해법 1. 뒤집어서 비교하기\n\n연결리스트를 순회하면서 새 리스트의 맨 앞에 삽입하면서 역순 리스트를 만든 후 비교한다.\n\n## 책 해법 2. runner와 스택 이용\n\n```javascript\nfunction solution_6_1(list) {\n  let cur = list.head;\n  let runner = cur;\n  let len = 0;\n  let array = Array();\n  while (cur != null && cur.next != null) {\n    len++;\n    array.push(runner.data);\n    runner = runner.next;\n    cur = cur.next.next;\n  }\n\n  if (len % 2 === 0) runner = runner.next;\n\n  while (runner != null) {\n    if (array.pop() !== runner.data) return false;\n    runner = runner.next;\n  }\n  return true;\n}\n```\n\n# 교집합: 단방향 연결리스트 두 개가 주어졌을 때 이 두 리스트의 교집합 노드를 찾은 뒤 반환하는 코드를 작성하라. 여기서 교집합이란 노드의 값이 아니라 노드의 주소가 완전히 같은 경우를 말한다. 즉, 첫 번째 리스트에 있는 k번째 노드와 두 번째 리스트에 있는 j번째 노드가 주소까지 완전히 같다면 이 노드는 교집합의 원소가 된다.\n\n두 연결리스트에서 교집합이 있다는 것은.. 그 교집합 노드 뒤부터는 같은 노드라는 것, 즉 마지막 노드가 같다.\n\n```javascript\nfunction solution_7(list_1, list_2) {\n  let set = new Set();\n  let newList = null;\n  let cur = list_1.head;\n  while (cur != null) {\n    set.add(cur);\n    cur = cur.next;\n  }\n\n  cur = list_2.head;\n  while (cur != null) {\n    if (set.has(cur)) {\n      newList = cur;\n      break;\n    }\n    cur = cur.next;\n  }\n  if (newList == null) return null;\n  return new LinkedList(newList);\n}\n```\n\n## 책 풀이\n\n1. 두 연결리스트를 순회해서 마지막 노드와 사이즈를 구하고 각 마지막 노드가 같으면 교집합이 존재하며 다르면 교집합은 없다.\n2. 길이가 더 긴 연결리스트의 포인터를 이동시켜서 두 연결리스트 순회 길이가 같도록 포인터를 맞춘다.\n3. 동시에 두 연결리스트의 포인트를 이동시키면서 같은 노드가 발견되는 순간을 찾는다.\n\n# 루프발견: 순환 연결리스트가 주어졌을 때, 순환되는 부분의 첫째 노드를 반환하는 알고리즘을 작성하라. 순환 연결리스트란 노드의 next 포인터가 앞선 노드들 가운데 어느 하나를 가리키도록 설정되어 있는, 엄밀히 말해서 변질된 방식의 연결리스트를 의미한다.\n\n- 입력: A->B->C->D->E->C (앞에 나온 C와 같음)\n- 출력: C\n\n```javascript\nfunction solution_8(list) {\n  let set = new Set();\n  let cur = list.head;\n\n  while (cur != null) {\n    if (set.has(cur)) return cur.data;\n    set.add(cur);\n    cur = cur.next;\n  }\n  return null;\n}\n```\n\n# 끝!\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"050c203f0de4fcd23578d6b6bc29d88531fc4775","text":"# 알고리즘 개념 잡자 - 트리\n\n- Title : 알고리즘 개념 잡자 - 트리\n- Date : 2020-01-03\n- Category: Algorithm\n\n> 참고 서적<br/> > [코딩 인터뷰 완전분석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545) 트리와 그래프<br/> > [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539) 제 7장 트리, 제 8장 우선순위 큐\n\n# 1. 트리(Tree)\n\n- 트리는 노드(node)와 간선(edge)로 이루어진 자료구조이다.\n- 트리는 하나의 루트 노드를 가진다.\n- 루트 노드는 0개 이상의 자식 노드를 가진다.\n- 그 자식 노드 또한 0개 이상의 자식 노드를 가진다.\n- 그 자식의 자식 노드 또한..\n- 노드들은 특정 순서대로 나열될 수도 있고 없을 수도 있다.\n- 각 노드는 어떤 자료형으로도 표현이 가능하다.\n- 각 노드는 부모 노드로의 연결이 있을 수도 있고 없을 수도 있다.\n\n## 용어 정리\n\n- 트리에는 **사이클(cycle)**이 존재할 수 없다.\n- 자식이 없는 노드는 **말단 노드(leaf node)**라고 부른다.\n- **차수(degree)**는 자식 노드의 개수로 자식 노드가 3개면 그 노드의 차수는 3이다. 트리의 차수는 트리가 가지고 있는 노드의 차수 중에서 가장 큰 차수이다.\n- **레벨(level)**은 트리의 각 층에 번호를 매긴 것으로 루트의 레벨은 1이 되고 한 층씩 내려갈수록 1씩 증가한다\n- 트리의 **높이(height)**는 트리가 가진 최대 레벨이다.\n\n예시) 노드 클래스\n\n```java\nclass Node {\n  public String name;\n  public Node[] children;\n}\n```\n\n예시) 트리 클래스\n\n```java\nclass Tree {\n  public Node root;\n}\n```\n\n## 이진 트리(Binary tree)와 이진 탐색 트리(Binary search tree)\n\n- 이진트리\n  - 이진 트리의 노드는 최대 2개까지의 자식 노드가 존재할 수 있고 모든 노드의 차수는 2 이하가 된다.\n  - n개의 노드를 가진 이진 트리는 n-1개의 간선을 가진다. 루트 노드를 제외한 노드들은 부모와 정확히 하나의 간선으로 이어져있기 때문이다.\n  - 높이가 h인 이진 트리는 최소 h개 노드를 가지고 최대 2<sup>h</sup>-1 노드를 가진다.\n  - 레벨 i에서 노드의 개수는 2<sup>i-1</sup> 다.\n  - n개의 노드를 가진 이진 트리의 최대 높이는 n이며 최소 높이는 log<sub>2</sub>(n+1) 이다.\n- 이진 탐색 트리\n  - 모든 노드 n은 <span class=\"clr-note\">모든 왼쪽 자식들 <= n < 모든 오른쪽 자식들</span> 속성을 만족한다.\n  - 이진 탐색 트리의 탐색, 삽입, 삭제 연산의 시간 복잡도는 트리의 높이를 h라고 했을 때 O(h)가 된다.\n  - n개의 노드를 가진 균형 잡힌 이진 트리의 높이는 log<sub>2</sub>n 이므로 평균적인 시간 복잡도는 O(log<sub>2</sub>n)\n  - 한쪽으로 치우친 이진 트리의 경우 트리의 높이가 노드의 개수 n과 같게 되어 시간복잡도는 선형 탐색과 같이 O(n)이 된다.\n\n## 이진 트리 표현 방법\n\n**1. 배열 이용** <br/><br/>\n![배열 이용](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-03-img/1.png)<br/>\n\n- 주로 포화 이진 트리나 완전 이진 트리의 경우에 많이 쓰인다.\n- 높이가 k인 완전 이진 트리로 가정하여 배열의 크기를 최대 노드 개수인 2<sup>k</sup>-1 로 할당한 다음 완전 이진 트리의 번호대로 노드를 저장한다.\n- 편한 계산을 위해 인덱스는 1부터 시작한다.\n- 오른쪽 그림처럼 일반 이진 트리의 경우 공간 낭비가 크다.\n\n> 부모 & 자식 노드 찾는 법 <br/><br/>\n> 현재 노드 i를 기준으로, <br/>\n> 부모 노드의 인덱스 = **i/2** <br/>\n> 왼쪽 자식 노드의 인덱스 = **i\\*2** <br/>\n> 오른쪽 자식 노드의 인덱스 = **i\\*2 + 1** <br/>\n\n<br/>\n\n**2. 연결리스트 이용** <br/><br/>\n\n- 노드가 자바에서는 클래스, C에서는 구조체로 표현되고 각 노드가 포인터를 가지고 있어서 이 포인터를 이용하여 노드와 노드를 연결하는 방법이다.\n- 하나의 노드가 왼쪽 자식 노드, 오른쪽 자식 노드를 필드로 가진다.\n\n## 트리가 '균형' 트리인지 아닌지 확인하는 방법\n\n<span class=\"clr-note\">O(log N)</span> 시간에 insert와 find를 할 수 있는 정도로 균형이 잘 잡혀있는 지 확인하면 된다. 꼭 완전 이진 트리처럼 완벽하게 균형 잡혀 있을 필요는 없다.\n\n> 예) 레드-블랙 트리와 AVL 트리\n\n## 이진 트리의 종류\n\n- 완전 이진 트리(complete binary tree) : 트리의 모든 높이에서 노드가 꽉 차 있다. 마지막 단계(level)은 꽉 차 있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져야 한다.\n- 전 이진 트리(full binary tree) : 자식노드가 0개 또는 2개인 경우다.\n- 포화 이진 트리(perfect binary tree) : 전 이진 트리면서 완전 이진 트리인 경우다. 모든 말단 노드는 같은 레벨에 있으며 마지막 레벨에서 노드의 개수가 최대가 되어야 한다. 노드의 개수는 정확히 2<sup>k-1</sup>(k는 트리의 레벨)\n\n## 이진 트리 순회 방법\n\n**중위 순회(in-order traversal)**는 <span class=\"clr-note\">왼쪽 가지(branch) - 현재 노드 - 오른쪽 가지</span> 순서로 노드를 방문하고 출력하는 방법이다.\n\n> 이진 탐색 트리를 이 방법으로 순회한다면? <span class=\"is-has-danger\">오름차순</span>으로 방문!\n\n```java\nvoid inOrderTraversal(TreeNode node) {\n  if (node != null) {\n    inOrderTraversal(node.left);\n    visit(node);\n    inOrderTraversal(node.right);\n  }\n}\n```\n\n<br/>\n\n**전위 순회(pre-order traversal)**는 <span class=\"clr-note\">현재 노드 - 왼쪽 가지(branch) - 오른쪽 가지</span> 순서로 노드를 방문하고 출력하는 방법이다.\n\n> 가장 먼저 방문할 노드는? 루트 노드!\n\n```java\nvoid preOrderTraversal(TreeNode node) {\n  if (node != null) {\n    visit(node);\n    preOrderTraversal(node.left);\n    preOrderTraversal(node.right);\n  }\n}\n```\n\n<br/>\n\n**후위 순회(post-order traversal)**는 <span class=\"clr-note\">왼쪽 가지(branch) - 오른쪽 가지 - 현재 노드</span> 순서로 노드를 방문하고 출력하는 방법이다. 예) 현재 디렉토리 용량 계산\n\n> 맨 마지막에 방문할 노드는? 루트 노드!\n\n```java\nvoid postOrderTraversal(TreeNode node) {\n  if (node != null) {\n    postOrderTraversal(node.left);\n    postOrderTraversal(node.right);\n    visit(node);\n  }\n}\n```\n\n<br/>\n\n**레벨 순회(level traversal)**는 각 노드를 레벨 순으로 순회하는 방법이다. 레벨 1에서 시작하며 동일한 레벨의 경우에는 왼쪽에서 오른쪽으로 순으로 방문한다.\n\n> 중위, 전위, 후위는 스택을 사용하며 레벨 순회는 **큐**를 이용한다.\n\n## 이진 트리 순회의 응용\n\n**수식 트리(expression tree)**를 처리하는 데 사용\n<br/>\n\n![수식 트리 예제](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-03-img/2.png)<br/>\n\n- 루트 노드는 연산자이고 서브 트리가 피연산자이므로 서브 트리를 계산하면 전체 수식을 계산할 수 있다.\n- 위 표에 나와있듯이 가장 적합한 순회 방식은 **후위 순회**다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"2570d25c403b748053bcd53d0ff0e32d37cc4697","text":"# Java Comparator과 Comparable\n\n- Title : Java Comparator과 Comparable\n- Date : 2019-10-18\n- Category: Java\n\nPS 문제를 풀다가 Arrays.sort()와 Collections.sort()를 오름차순(디폴트)이 아닌 다른 기준으로 정렬하고 싶을 때가 있었다. 찾아보니 Comparator 또는 Comparable을 사용하면 된다고 한다. 음.. 알아본 김에 잊어버리지않게 기록을 해야겠다!\n\n# 컬렉션을 입맛대로 정렬하고 싶다면?\n\n내맘대로 컬렉션의 정렬 기준을 정하고 싶다면 `Comparator`과 `Comparable` 인터페이스를 사용하면 된다.\n\n```java\nimport java.util.Comparator;\npublic interface Comparator {\n    int compare(Object o1, Object o2);\n    boolean equals(Object obj);\n}\n```\n\n<br/>\n\n```java\nimport java.lang.Comparable;\npublic interface Comparable {\n    public int compareTo(Object o); // 양수 : 내림차순, 음수 : 오름차순\n}\n```\n\n# 그럼 둘의 차이는 무엇일까?\n\nComparable을 구현한 클래스들은 기본적으로 오름차순으로 정렬되도록 구현되어있다.  \nInteger, Character와 같은 `wrapper` 클래스(int, long, float, double 등을 객체화한 클래스)와 `String, Date, File`과 같은 것이 Comparable을 구현한 대표적 클래스이다. 그 외 Java API 문서에서 클래스 목록을 확인할 수 있다.  \n그래서 우리가 `Arrays.sort(정렬대상)` 로 오름차순 정렬을 할 수 있는 것이다. 아하!\n\n```java\npublic final class Integer extends Number implements Comparable {\n    ...\n    public int compareTo(Object o) {\n        return compareTo((Integer) o);\n    }\n\n    public int compareTo(Integer anotherInteger) {\n        int thisVal = this.value;\n        int anotherVal = anotherInteger.value;\n        return (thisVal < anotherVal ? -1 : (thisVal ==anotherVal ? 0 : 1));\n    }\n}\n```\n\n실제 Integer 클래스의 일부이다.  \n보이는 것 처럼 Comparable 인터페이스를 구현하고 compareTo 메서드에서 오름차순으로 정렬되도록 정의해놓았다.\n\nComparator 인터페이스는 Comparable로 구현된 클래스를, 또는 커스텀 클래스를 기본 정렬 기준 외에 다른 기준으로 정렬하고자 할 때 사용하면 된다.  \n아래는 실제 예제로 백준 16236 아기 상어 문제를 풀 때 우선순위큐의 정렬기준을 Comparator을 이용해 정의한 것이다.\n\n```java\nPriorityQueue<Point> pq = new PriorityQueue<>(new Comparator<Point>() {\n\t@Override\n\tpublic int compare(Point o1, Point o2) {\n\t\tif (o1.dis != o2.dis) return o1.dis-o2.dis;\n\t\tif (o1.row != o2.row) return o1.row-o2.row;\n\t\treturn o1.col-o2.col;\n\t}\n});\n```\n\n또는 책의 예제를 보면 따로 클래스를 정의해서 사용할 수 있다.  \n이 예제는 Comparable을 구현한 클래스 String의 정렬 방식을 내림차순으로 바꾸는 방법이다.  \n단순히 -1을 곱해 반대의 값을 반환하게 구현했다.\n\n```java\n\nArrays.sort(strArr, new Descending());\n\nClass Descending implements Comparator {\n    public int compareTo(Object o1, Object o2) {\n        if (o1 instanceof Comparable && o2 instanceof Comparable) {\n            Comparable c1 = (Comparable) o1;\n            Comparable c2 = (Comparable) o2;\n            return c1.compareTo(c2) * -1;\n        }\n    }\n}\n```\n\n이제 내맘대로 정렬할 수 있게 되었담!!!!\n\n자바의 정석 책을 참고했습니다.\n"}}}},"pageContext":{"id":"0e6c91a0a899db4d2998ba6ee8189e54a606fb9b","previousPostId":"050c203f0de4fcd23578d6b6bc29d88531fc4775","nextPostId":"2570d25c403b748053bcd53d0ff0e32d37cc4697"}},"staticQueryHashes":["2685952063","2841359383"]}