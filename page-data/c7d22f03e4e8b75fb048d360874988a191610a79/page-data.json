{"componentChunkName":"component---src-templates-blog-post-js","path":"/c7d22f03e4e8b75fb048d360874988a191610a79","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"c7d22f03e4e8b75fb048d360874988a191610a79","text":"# [생활코딩] javascript 함수지향4\n\n- Title : [생활코딩] javascript 함수지향4\n- Date : 2018-01-13\n- Category: Javascript\n\n생활코딩 함수지향 파트 중 arguments와 apply()에 대한 내용을 정리했습니다.\n\n# 1. arguments\n\n```javascript\nfunction sum(){\n    var i, _sum = 0;\n    for( i=0; i< arguments.length; i++){\n        document.write(i +  \":\" + arguments[i] + <'br/>');\n        _sum += arguments[i];\n    }\n    return _sum;\n}\ndocument.write('result : ' + sum(1,2,3,4));\n```\n\narguments는 사용자가 전달한 인자들이 담겨있는 객체다.\n\n- .length를 통해 함수가 몇개의 인자 전달 받았는 지를 알 수 있다.\n- arguments[i] 를 통해 각 자리의 인자 값을 알 수 있다.\n\n자바스크립트는 매개변수의 수가 함수의 정의와 달라도 에러가 발생하지 않는다.\n\n```javascript\nfunction one(arg1) {\n  console.log(\n    \"one.length\",\n    one.length, //1\n    \"arguments\",\n    arguments.length //2\n  );\n}\none(\"val1\", \"val2\");\n```\n\n위의 차이점을 이용해보면. 함수에 정의된 매개변수의 갯수와 실제 전달받는 인자의 갯수를 비교해서 대상 함수가 올바르게 사용되었는 지를 체크 할 수 있다.\n\n# 2. apply() 내장함수\n\n```javascript\nfunction sum(arg1, arg2) {\n  return arg1 + arg2;\n}\nsum(1, 2); //3\nsum.apply; //function apply(){[native code]}     native code : 내장함수란 뜻\nsum.apply(null, [1, 2]); //3     -첫번째 인자가 null로 들어갈 때는, 쓰지않기.\n```\n\n왜 사용할까?\n\n```javascript\no1 = { val1: 1, val2: 2, val3: 3 };\no2 = { v1: 10, v2: 50, v3: 100, v4: 25 };\nfunction sum() {\n  var _sum = 0;\n  for (name in this) {\n    _sum += this[name];\n  }\n  return _sum;\n}\nalert(sum.apply(o1)); //6\nalert(sum.apply(o2)); //185\n```\n\no1 객체를 sum의 인자 값으로 전달한다.  \nthis는 var this = o1; 과 암시적으로 같다.  \n실행되는 그 순간에는 o1이라는 객체의 메소드 sum이 된다는 것.  \n즉, o1 = { va1 : 1, val2 : 2, val3 : 3, sum : sum} 에 o1.sum()과 같다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"82bfa87848bd4512f9dba35b6b23b9234a890615","text":"# [생활코딩] javascript 함수지향3\n\n- Title : [생활코딩] javascript 함수지향3\n- Date : 2018-01-13\n- Category: Javascript\n\n생활코딩 함수지향 파트 중 클로저에 대한 내용을 정리했습니다.\n\n# 1. 클로저의 개념\n\n```javascript\nfunction outter() {\n  var title = \"coding everybody\";\n  return function() {\n    alert(title);\n  };\n}\ninner = outter();\ninner();\n```\n\n함수 outter의 리턴 값은 내부함수이며 변수 inner에 내부함수가 값으로 저장된다.  \noutter 호출이 종료된 순간, outter는 사라진다.  \n하지만, inner()를 실행했을 때 알럿창에 coding everybody가 보인다.\n\n왜?  \n<span class=\"clr-note\">내부함수는 외부함수가 종료되도 외부함수에 접근할 수 있다.</span>\n\n# 2. private variable\n\n```javascript\nfunction factory_movie(title) {\n  return {\n    get_title: function() {\n      return title;\n    },\n    set_tile: function(_title) {\n      if (typeof _title === \"String\") {\n        title = _title;\n      } else {\n        alert(\"제목은 문자열이여야 합니다.\");\n      }\n    }\n  };\n}\nghost = factory_movie(\"Ghost in the shell\");\nmatrix = factory_movie(\"Matrix\");\nalert(ghost.get_title()); //Ghost in the shell\nalert(matrix.get_tiel()); //Matrix\n```\n\nfactory_movie의 리턴 값은 get_title, set_title 메소드를 속성으로 가지고 있는 객체이다.  \nghost, matrix 변수는 객체를 담게된다.  \nfactory_movie 호출 후, 함수의 생이 종료되어도 ghost, matrix를 통해 함수의 지역변수인 title에 접근할 수 있다.\n\n왜 private variable을 사용해야 하는가?  \n<span class=\"clr-note\">외부에서 title 변수를 수정해도 ghost, matrix가 가진 title의 맥락에는 영향을 주지 않는다. 즉, 데이터의 수정과 저장을 안전하게 할 수 있다.</span>\n\n# 3. 클로저의 응용\n\n```javascript\nvar arr = [];\nfor (var i = 0; i < 5; i++) {\n  arr[i] = function() {\n    console.log(i);\n  };\n}\n\nfor (var index in arr) {\n  console.log(arr[index]());\n}\n//결과는 5 5 5 5 5\n```\n\n함수가 실행되는 시점의 변수가 내부함수에 저장된다.  \n두번째 반목문에서 배열객체의 함수를 실행하는 순간의 i가 콘솔에 찍히게 된다.  \n그러나, i는 첫번째 포문에 의해 이미 5가 되어버린 상태이므로 5만 다섯번 찍히게 된다.\n\n```javascript\nvar arr = [];\nfor (var i = 0; i < 5; i++) {\n  arr[i] = (function(id) {\n    return function() {\n      return id;\n    };\n  })(i);\n}\n\nfor (var index in arr) {\n  console.log(arr[index]());\n}\n//결과는 0,1,2,3,4\n```\n\n외부함수의 인자 값으로 i가 전달되고, 내부함수는 이 시점의 i를 저장한다.  \n첫번째 포문에서 외부함수가 i를 인자값으로 하면서 실행되는 시점에서 내부함수가 정의된다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"803f4d7096343a90d391862bb2f929d76497a8e8","text":"# [생활코딩] javascript 객체지향1\n\n- Title : [생활코딩] javascript 객체지향1\n- Date : 2018-01-13\n- Category: Javascript\n\n생활코딩 객체지향에 대한 내용을 정리했습니다.\n\n객체(object)는 연관되어 있는 것(변수, 메소드)들을 그룹화한 것, 각 그룹화된 것은 독립성을 가지는 부품이 된다.\n\n# 1. 객체의 생성 방법\n\nthis는 함수가 속해있는 객체인 person을 가리킨다.\n\n```javascript\nvar person = {};\nperson.name = \"egoing\";\nperson.introduce = function() {\n  return \"My name is\" + this.name;\n};\ndocument.write(person.introduce());\n```\n\n```javascript\nvar person = {\n  name: \"egoing\",\n  introduce: function() {\n    return \"My name is\" + this.name;\n  }\n};\n```\n\n# 2. 생성자와 new\n\n생성자는 객체를 만드는 역할을 하는 함수.\n\n```javascript\nfunction Person() {}\nvar p0 = Person(); //undefined\nvar p = new Person(); //Person{} 비어있는 객체\n```\n\nnew Person()  \nPerson() 함수가 객체의 참조자가 될 수 있다.\n\n자바는 클래스 안에 생성자가 있고, 클래스의 객체를 만든다.  \n자바스크립트에서는 생성자가 함수일 뿐, 어디에 속해있지 않다.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n  this.introduce = function() {\n    return \"My name is \" + this.name;\n  };\n}\n\nvar p1 = new Person(\"egoing\");\nvar p2 = new Person(\"leezche\");\n\ndocument.write(p1.introduce()); //My name is egoing\ndocument.write(p2.introduce()); //My name is leezche\n```\n\n생성자 Person이라는 함수를 정의했다.  \nPerson 앞에 new가 존재하기 때문에 함수가 아닌 생성자가 된다.  \n생성자 함수가 하는 일은 객체의 초기화이며, 객체가 가지고 있는 정보, 객체가 할 수 있는 일을 정의하게 된다.  \n덕분에 코드의 재사용성이 높아진다.\n\n# 3. 함수와 this\n\n전역변수와 전역함수는 모두 window라는 전역객체의 속성과 메소드다.  \n<span class=\"clr-grey\">node.js에서 전역객체는 global이다.</span>\n\n## 1) 메소드와 this\n\nthis는 함수를 어떻게 호출하느냐에 따라 this를 가리키는 대상이 달라진다.\n\n전역함수의 this는 window와 같다.\n\n```javascript\nfunction func() {\n  if (window === this) {\n    console.log(\"window === this\");\n  }\n}\nfunc(); //window === this\n```\n\n객체의 소속인 메소드의 this는 그 객체를 가르킨다.\n\n```javascript\nvar o = {\n  func: function() {\n    if (o === this) {\n      document.write(\"o === this\");\n    }\n  }\n};\no.func(); //o===this\n```\n\n## 2) 생성자와 this\n\n```javascript\nvar funcThis = null;\nfunction Func() {\n  funcThis = this;\n}\n\nvar o1 = Func();\nif (funcThis === window) {\n  document.write(\"window\");\n}\n\nvar o2 = new Func();\nif (funcThis === o2) {\n  document.write(\"o2 </br>\");\n}\n// window, o2 둘다 출력됨.\n```\n\nFunc를 생성자로 사용되면 this는 객체를 가리키고, 함수로 사용되면 this는 window는 가리킨다.\n\n## 3) 객체로서 함수\n\n```javascript\nfunction sum(x, y) {\n  return x + y;\n}\nvar sum2 = new Function(\"x\", \"y\", \"return x+y\");\n```\n\nsum이라는 함수는 sum이라는 객체를 만든 것이다.  \n<span class=\"clr-grey\">\nfunction sum(){} 함수 리터럴  \nvar o ={} 객체리터럴  \nvar a = [0,1,2] 배열 리터럴  \n편리하게 값을 만들 수 있는 문법적인 체계를 리터럴이라고 한다.\n</span>\n\n## 4) apply와 this\n\n```javascript\nvar o = {};\nvar p = {};\n\nfunction func() {\n  switch (this) {\n    case o:\n      document.write(\"o\");\n      break;\n    case p:\n      document.write(\"p\");\n      break;\n    case window:\n      document.write(\"window\");\n      break;\n  }\n}\n\nfunc(); //window\nfunc.apply(o); //o\nfunc.apply(p); //p\n```\n\n자바스크립트의 this는 변화무쌍하다.\n"}}}},"pageContext":{"id":"c7d22f03e4e8b75fb048d360874988a191610a79","previousPostId":"82bfa87848bd4512f9dba35b6b23b9234a890615","nextPostId":"803f4d7096343a90d391862bb2f929d76497a8e8"}},"staticQueryHashes":["2841359383"]}