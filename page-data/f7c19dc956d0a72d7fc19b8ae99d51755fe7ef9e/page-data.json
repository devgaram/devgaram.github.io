{"componentChunkName":"component---src-templates-blog-post-js","path":"/f7c19dc956d0a72d7fc19b8ae99d51755fe7ef9e","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f7c19dc956d0a72d7fc19b8ae99d51755fe7ef9e","text":"# 시스템 설계 및 규모 확장성 테스트\n\n- Title : [코딩인터뷰] 시스템 설계 및 규모 확장성 이론\n- Date : 2019-08-28\n- Category: Algorithm\n\n> (코딩인터뷰 완전분석) 책의 '시스템 설계 및 규모 확장성' 파트를 정리한 글입니다. 이런 류의 질문에는 실제로 어떻게 행동할 것인지를 답하면 됩니다.\n\n# 문제를 다루는 방법\n\n- 면접관과 소통하기\n- 처음에는 포괄적으로 접근하기\n- 화이트보드에 제안하는 설계를 그리며 설명하기\n- 면접관이 짚은 문제점을 인정하고 적절히 수정하기\n- 가정을 할 때 주의하기\n- 가정을 할 때 그것을 면접관에게 알리기\n- 필요하다면 어림잡아 보기 예) 공간\n- 계속해서 깊이 파고들고 질문하기\n\n# 시스템 설계 : 단계별 접근법\n\n면접관 : TinyUrl과 같은 시스템을 설계해보세요.  \n지원자 : ???\n\n## 1단계 : 문제의 범위를 한정하라\n\n지원자 : 정확히 무엇을 구현해야 하는거지?..\n\n지원자는 위와 같은 물음이 생기기 마련이다.  \n질문을 통해 물음을 해결하지 않으면 지원자가 만들 시스템과 면접관이 원하는 것이 다를 수 있다.  \n아래와 같은 질문을 던지면서 문제의 범위를 한정해나가는 게 필요하다.\n\n- 개개인이 원하는 대로 축약된 URL을 만들 수 있어야 하나? 아니면 축약된 URL이 항상 자동으로 생성되는 건가?\n- 클릭에 관한 통계 정보를 기록할 필요가 있나?\n- 한번 설정된 URL은 영원히 없어지지 않는건가? 아니면 일정 시간이 지나면 삭제되는건가?\n\n## 2단계 : 필요하다면 가정을 세워라, 단 합당해야 한다.\n\n이러한 가정은 합당하지 않다.\n\n- 시스템이 하루에 100명의 사용자를 처리할 수 있으면 된다.\n- 메모리에 제약이 없다.\n- URL이 제대로 동작하기까지 10분 걸린다.\n\n이러한 가정은 합당하다.\n\n- 하루에 최대 백만 개의 URL을 생성한다.\n- 최근 데이터에 대해 최대 10분 정도 오차가 있다.\n\n## 3단계 : 중요한 부분을 먼저 그려라\n\n화이트보드에 시스템의 주요 부분을 다이어그램으로 그린다.\n\n예시\n\n- 여러 개의 프론트엔드 서버가 백엔드에서 데이터를 받아 오는 시스템\n- 한 서버군은 크롤링, 다른 서버군은 크롤링 데이터를 분석하는 시스템\n\n예를 들어 TinyURL을 설계한다면\n\n지원자 : (사용자가 URL을 입력했을 때 어떤 식으로 진행되는 지 그린다) ...\n\n## 4단계 : 핵심 문제점을 찾아라\n\n- 어느 부분이 병목지점일까?\n- 이 시스템이 풀어야 할 주된 문제는 무엇인가?\n\n예를 들어 TinyURL을 설계한다면 아래와 같은 문제점을 찾아내야한다.\n\n지원자 : 어떤 URL은 드물게 사용되는 반면 특정 URL의 사용량이 갑자기 치솟는 상황이라면..\n시스템이 끊임없이 데이터베이스를 읽어오면 안될텐데....\n\n## 5단계 : 핵심 문제점을 해결할 수 있도록 다시 설계하라\n\n핵심 문제에 맞게 설계를 수정한다. 전체를 갈아 엎을 수도 있고 자잘한 부분만 수정해서 해결할 수도 있다.\n\n지원자 : 캐시를 사용해서 해결하면 되려나..\n\n# 규모 확장을 위한 알고리즘 : 단계별 접근법\n\n면접관 : 시스템의 한 부분 혹은 알고리즘을 설계해보세요\n\n## 1단계 : 질문하라\n\n질문을 통해 문제를 확실히 이해해야한다.\n\n## 2단계 : 현실적 제약을 무시하라\n\n메모리 제약 없고, 컴퓨터 한 대에서 모든 데이터를 다 처리할 수 있다고 가정해서 풀어본다.\n\n## 3단계 : 현실로 돌아오라\n\n- 컴퓨터 한 대에 저장할 수 있는 데이터 크기에 대해 생각하기\n- 데이터를 여러 조각으로 쪼갰을 때 어떤 문제가 발생할지 생각하기\n- 데이터를 여러 조각으로 쪼갤 때 어떤 논리로 데이터를 나눌 것인지 생각하기\n- 데이터를 여러 조각으로 쪼갤 때 특정 컴퓨터가 어느 데이터 조각을 사용했는지 어떻게 알 수 있을 것인지\n\n## 4단계 : 문제를 풀어라\n\n순환적 접근법을 이용한다.\n\n# 시스템 설계의 핵심 개념\n\n## 수평적 vs 수직적 규모 확장\n\n- 수직적 규모 확장 : 특정 노드의 자원의 양을 늘리는 방법 예) 서버에 메모리 추가\n- 수평적 규모 확장 : 노드의 개수를 늘리는 방법 예) 서버를 추가해서 서버 한 대가 다루는 부하를 줄인다.\n\n## 서버 부하 분산 장치(load balancer)\n\n일반적으로 규모 확장성이 있는 웹사이트의 프론트엔드 부분은 서버 부하 분산 장치를 통해서 제공된다.  \n이렇게 해야 서버에 걸리는 부하를 여러 대의 서버에 균일하게 분신시킬 수 있고 서버 한대 때문에 전체 시스템이 죽거나\n다운되는 상황을 방지할 수 있다.  \n물론 서버 여러 대가 근본적으로 똑같은 코드와 데이터를 사용하도록 하는 네트워크를 구현해놔야 한다.\n\n## 데이터베이스 역정규화(denormalization)와 NoSQL\n\nSQL 같은 RDMS의 조인 연산은 시스템이 커질수록 굉장히 느려지므로 가능하면 피해야 한다.\n\n역정규화란?  \n데이터베이스에 여분의 정보를 추가해서 읽기 연산 속도를 향상시킨 것을 의미한다.\n\n예를 들어, 한 프로젝트가 여러 과제를 수행하도록 설계된 데이터베이스를 생각해보자.  \n이 데이터베이스에서 프로젝트 이름이랑 과제 정보를 함께 알고 싶은 경우에 두 테이블을 조인하기보단\n애초에 과제 테이블에 프로젝트 이름 정보를 추가로 저장해 놓으면 더 빠르게 작업을 수행할 수 있다.\n\n혹은, NoSQL 데이터베이스를 이용하면 된다.\nNoSQL은 초고용량 데이터 처리 등 성능에 특화된 목적을 위해, 비관계형 데이터 저장소에, 비구조적인 데이터를 저장하기 위한 분산 저장 시스템이다.  \n저장되는 데이터 구조는 주로 Key-Value 형태이다.  \n예) 몽고DB  \nNoSQL의 특징\n\n- 관계형 모델을 사용하지 않으며 테이블간의 조인 기능 없음\n- 직접 프로그래밍을 하는 등의 비SQL 인터페이스를 통한 데이터 액세스\n- 대부분 여러 대의 데이터베이스 서버를 묶어서(클러스터링) 하나의 데이터베이스를 구성\n- 관계형 데이터베이스에서는 지원하는 Data처리 완결성(Transaction ACID 지원) 미보장\n- 데이터의 스키마와 속성들을 다양하게 수용 및 동적 정의 (Schema-less)\n- 데이터베이스의 중단 없는 서비스와 자동 복구 기능지원\n- 다수가 Open Source로 제공\n- 확장성, 가용성, 높은 성능\n\n# 데이터베이스 분할(샤딩)\n\n샤딩(sharding)은 데이터를 여러 컴퓨터에 나눠서 저장하는 동시에 어떤 데이터가 어떤 컴퓨터에 저장되어 있는지 알 수 있는 방식을 말한다.\n\n- 수직적 분할 : 자료의 특성별로 분할 예) SNS를 만든다면, 개인정보 부분과 메시지 부분으로 자료를 분할 (특정 테이블의 크기가 일정 수준 이상으로 커질 수 있음)\n- 키 혹은 해시 기반 분할 : mod(key, n)의 값을 이용해서 N개의 서버에 분할 (서버의 개수가 고정되어 있어야 하며, 서버를 새로 추가할 때마다 모든 데이터를 재분배 해야함)\n- 디렉터리 기반 분할 : 데이터를 찾을 때 사용되는 조회 테이블(lookup table)을 유지하는 방법, 서버 추가하기는 쉬움 (조회 테이블이 \\*단일 장애 지점이 될 수 있음, 지속적으로 테이블 읽는 행위가 전체 성능에 영향을 미칠 수 있음)\n\n<span class=\"clr-grey\">\\*단일 장애 지점 : 네트워크의 한 지점(노드)의 장애가 전체 네트워크(시스템)의 장애를 초래하는 것</span>\n\n## 캐싱(caching)\n\n인메모리(in-memory) 캐시를 사용하면 결과를 빠르게 가져올 수 있다.\n\n- KEY-VALUE 쌍의 구조\n- 애플리케이션과 데이터 저장소 사이에 자리잡고 있음\n- 쿼리와 그 결과를 캐시하는 경우가 많음\n- 특정 객체를 캐시에 저장할 수 있음\n\n애플리케이션이 어떤 자료를 요청 -> 캐시를 먼저 확인 -> 캐시가 해당 키 값을 갖고 있지 않음 -> 데이터 저장소에서 자료 가져옴\n\n예) 웹 페이지의 어떤 부분을 렌더링한 결과나 블로그에 올라온 최근 포스팅 리스트를 캐시에 갖고 있음\n\n## 비동기식 처리 & 큐\n\n이상적이라면, 속도가 느린 연산은 비동기식으로 처리해야 한다.  \n그렇지 않으면 해당 연산이 끝나기까지 하염없이 기다려야 할 수도 있기 때문이다.\n\n어떤 경우에는 연산을 미리 해 큐에 넣을 수도 있다.\n\n예) 포럼 웹사이트에서 큐에 들어 있는 작업 중 하나는 가장 최근의 글들과 몇가지 코멘트를 보여주는 페이지를 다시 만들어 주는 일이다.  \n새로운 코멘트 하나 때문에 캐시미스가 나서 웹사이트를 새로 불러오는 것보다 큐의 데이터를 이용해 약간 오래되어 덜 정확한 최신 글 리스트를\n보여주는 것이 낫다.\n\n## 네트워크 성능 척도\n\n- 대역폭(bandwidth) : 단위 시간에 전송할 수 있는 데이터의 최대치 (초당 몇 비트(혹은, 몇 기가 바이트)를 보낼 수 있는 가)\n- 처리량(throughput) : 단위 시간에 실제로 전송된 데이터의 양\n- 지연 속도(latency) : 데이터를 전송하는 데 걸리는 시간 (발송자가 데이터를 보낸 시점 - 수신자가 데이터를 받는 지점)\n\n## MapReduce\n\n많은 과정을 병렬로 처리할 수 있게 도와주며 굉장히 커다란 데이터를 처리하는 데 사용\n\n- Map은 데이터를 입력으로 받은 뒤 key-value 쌍을 반환한다.\n- Reduce는 키와 관련된 값들을 입력으로 받은 뒤 나름의 처리 과정을 거친 뒤 새로운 키와 값을 반환하다.\n\n# 시스템 설계 시 고려할 점\n\n- 실패 : 실패에 대한 대비책\n- 가용성 및 신뢰성 : 가용성은 사용 가능한 시스템의 시간을 백분율로 나타낸 것, 신뢰성은 특정 단위 시간에 시스템이 사용 가능할 확률\n- 읽기 중심 vs 쓰기 중심 : 쓰는 연산이 많으면 큐를 사용하는 방법이 좋음, 읽는 연산이 많으면 캐시를 사용하는 것이 좋음\n- 보안\n\n# 연습문제\n\n수백만 개의 문서가 주어졌을 때, 특정 단어 리스트가 포함된 문서를 찾으려고 한다.  \n어떻게 할 수 있을까? 단어가 등장하는 순서는 중요하지 않지만, 해당 단어가 완벽하게 나타나야 한다.\n\nfindwords를 같은 문서 집합에 대해서 여러 번 호출한다고 가정한다.\n\n## 1단계\n\n현실적 제약을 무시해보고 문서가 수십 개 있을 때로 가정하여 문제를 풀어본다.  \nfindWords를 어떻게 구현할까...?\n\n전처리 과정을 통해 모든 문서에 대한 해시테이블을 만든다.  \n해시테이블은 단어와 해당 단어를 포함하는 문서 리스트에 대한 정보를 담고 있다.\n\n\"books\" -> {doc2, doc3, doc6, doc8}  \n\"many\" -> {doc1, dod3, doc7, doc8, doc9}\n\n\"many books\"를 탐색한다면, \"books\"와 \"many\"의 교집합을 구하면 된다. {doc3, doc8}\n\n## 2단계\n\n현실로 돌아와 문서의 개수를 수백만 개로 늘려본다.  \n어떻게 해야할까?  \n일단, 문서를 여러 대의 컴퓨터로 나눠서 보내야 할 것이다.  \n또한 단어의 수나 출현 빈도 등 때문에 해시테이블조차도 한 컴퓨터에 온전히 보관할 수 없을 수 있다.\n\n실제로 해시테이블도 분할해서 저장해야 하는 상황이 벌어졌다고 가정해보자.  \n그러면 다음과 같은 고민을 해야한다.\n\n- 해시테이블은 어떻게 분할하지? 키워드에 따라? 문서에 따라?\n- 데이터를 분할하기로 결정하면, 어떤 컴퓨터에서는 문서를 처리하고 그 처리 결과를 다른 컴퓨터로 옮겨야 할텐데 어떻게 정의할 수 있을까?\n- 어떤 컴퓨터에 어떤 데이터가 보관되어 있는지 알 수 있어야 할텐데.. 그리고 조회 테이블의 형태는? 조회 테이블은 어디에 두어야 되지?\n\n## 3단계\n\n문제점에 대한 해법을 찾아야 한다.\n한 가지 방법은 키워드를 알파벳 순서에 따라 분할하는 것이다.  \n즉, 한 컴퓨터가 특정한 범위의 단어들(예, after~apple)만 통제하게 하는 것이다.  \n키워드를 알파벳 순서로 돌면서 가능한 데이터를 저장하는 알고리즘은 쉽게 구현할 수 있다. 용량이 꽉 차면, 다른 컴퓨터로 옮겨 가야 한다.\n\n장점 : 조회 테이블을 작고 단순하게 만들 수 있음, 각 컴퓨터에 조회 테이블의 복사본을 저장할 수 있음  \n단점 : 새로운 문서나 단어 추가시 키워드를 굉장히 많이 이동시킴\n\n\"after builds boat amaze banana\"\n\n컴퓨터에 키워드가 알파벳 순서로 분할되어 있으니 문자열을 정렬한 후 요청을 보낸다.\n\n일번 컴퓨터는 \"after~apple\" 범위의 키워드가 있으니 after와 amaze에 대한 요청을 보내고, builds, boat, banana는 삼번 컴퓨터 범위에 해당되므로\n삼번 컴퓨터로 요청을 보낸다.  \n각 컴퓨터에서 요청 사항에 대한 교집합을 구하여 반환한다.  \n마지막으로, 초반에 전체 요청을 보낸 컴퓨터는 일번과 삼번의 컴퓨터로 부터 받은 결과의 교집합을 구하면 된다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"11dd1a4e3a3fb9c66c9aed0ca88c6c669d88bab4","text":"# 시스템 설계 및 규모 확장성 문제 4 - 캐시\n\n- Title : [코딩인터뷰] 시스템 설계 및 규모 확장성 문제 4 - 캐시\n- Date : 2019-08-30\n- Category: Algorithm\n\n> 코딩 인터뷰 완전분석 (CRACKING THE CODING INTERVIEW 6/E) / 게일 라크만 맥도웰 지음 / 인사이트\n\n# Q. 캐시 : 간단한 검색 엔진으로 구현된 웹 서버를 생각해보자. 이 시스템에선 100개의 컴퓨터가 검색 요청을 처리하는 역할을 하고 있다. 예를 들어 하나의 컴퓨터 집단에 processSearch(string query)라는 요청을 보내면 그에 상응하는 검색 결과를 반환해 준다. 하지만 어떤 컴퓨터가 요청을 처리하게 될지는 그때그때 다르며, 따라서 같은 요청을 한다고 같은 컴퓨터가 처리할 거라고 장담할 수 없다. processSearch 메서드는 아주 고비용이다. 최근 검색 요청을 캐시에 저장하는 메커니즘을 설계하라. 데이터가 바뀌었을 때 어떻게 캐시를 갱신할 것인지 반드시 설명하라.\n\n## 가정을 통해 문제를 구체화하자\n\n- 필요할 때 processSearch를 호출하는 것 이외에도, 모든 쿼리는 최초로 호출된 서버에서 처리된다.\n- 캐시하고자 하는 쿼리의 수는 굉장히 크다(수백만 개)\n- 서버 간 호출은 상대적으로 빨리 처리된다.\n- 쿼리의 결과는 정렬된 URL 리스티이다. 각 원소에는 최대 50글자의 제목과 200글자의 요약문이 따라 붙는다.\n- 가장 인기 있는 쿼리의 경우 항상 캐시에 보관되어 있다.\n\n## 시스템 요구 사항을 정리하자\n\n1. 최근 검색 요청을 캐시에 저장해야 한다.\n2. 캐시를 통해 빠른 탐색이 가능해야 한다.\n3. 쿼리 결과가 변경될 경우 캐시를 변경하거나 삭제할 수 있어야 한다.\n\n## 단순하게 생각하자 - 요구사항 1, 2번\n\n단순하게 컴퓨터가 하나일 경우로 가정하여 설계해본다.\n\n빠른 탐색이 가능하려면 key-value 쌍의 자료구조인 해시맵을 사용하는 게 적절할 것 같다.  \n쿼리를 해시 처리하여 key값을 생성하고 쿼리의 결과 값을 value로 해서 해시맵에 저장하면 될 듯 싶다.\n\n첫번째 요구사항을 보면 캐시에 최신 검색 순으로 저장될 필요가 있다. 데이터를 순서대로 저장해야 한다.  \n하지만 해시맵은 데이터의 순서를 기억하기에는 적절치 못한 자료구조다.  \n순서를 위한 자료구조는 배열과 연결리스트가 있는데 최신 검색의 삽입과 오래된 검색의 삭제가 빈번하므로 연결리스트 자료구조가 적절하지 않을까?  \n그러나,,,, 연결리스트는 탐색 시 Q(N) 시간이라 빠른 탐색이 힘들다..\n\n어떻게 할까?  \n두 자료구조를 합치면 어떨까?\n\n이는 LRU 캐시를 구현하라는 것과 같다.  \nLRU는 OS의 페이지 교체 알고리즘의 하나로 최근에 가장 오랫동안 사용되지 않은 페이지를 교체하는 기법이다.\n다음은 LRU 캐시 구현 그림이다.\n\n![1](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2019-08-30-img/4-1.jpg) <br/>\n\n## 이제 현실로 돌아와서 생각하자 - 여러 서버로 확장\n\n**방법1 - 각 서버에 별도의 캐시를 둔다**\n\n서버 1에 같은 쿼리를 2번 보내면, 두 번째 처리 결과는 캐시에서 가져온다.  \n그러나 서버 1에 보냈다가 서버 2에 보내면 서버 2는 해당 쿼리를 새로운 쿼리로 처리한다.\n\n- 장점 : 서버 간 통신이 필요없기에 상대적으로 빠르다.\n- 단점 : 같은 쿼리가 반복되도 새로운 쿼리로 인식하기 때문에 최적화를 위한 방법으로 부적절\n\n**방법2 - 각 서버에 캐시 복사본을 둔다**\n\n각 서버에 전체 캐시의 완전한 복사본을 유지하는 방법이다.  \n새로운 데이터가 캐시에 추가되는 순간 그 데이터는 모든 서버로 보내진다.  \n따라서 연결리스트와 해시테이블을 비롯한 모든 자료구조가 중복되어 저장된다.\n\n- 장점 : 어느 서버에서도 동일하게 존재하기 때문에 빈번하게 사용되는 쿼리와 실행 결과는 항상 캐시 내에 존재한다.\n- 단점1 : 캐시를 갱신할 때마다 데이터를 N개의 서로 다른 서버로 전송해야 한다는 점\n- 단점2 : 각 캐시를 저장하기 위해 N배 더 큰 공간이 필요하므로 캐시에 저장 가능한 항목의 수가 줄어든다.\n\n**방법3 - 각 서버에 캐시의 일부를 저장한다**\n\n캐시를 분할하여 각 서버에 그 일부만을 보관한다.  \n예를 들어, 서버 i가 어떤 쿼리에 대한 결과를 알고 싶다고 하자.\n\n![1](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2019-08-30-img/4-2.jpg) <br/>\n\n## 요구 사항 3번을 해결하자\n\n- 요구사항 3 : 쿼리 결과가 변경될 경우 캐시를 변경하거나 삭제할 수 있어야 한다.\n\n캐시가 충분히 클 경우 어떤 쿼리는 너무 빈번해서 항상 캐시에 남아 있을 수 있다.  \n따라서 주기적으로 혹은 어떤 쿼리 결과가 변경되었을 때마다 캐시에 보관된 결과를 갱신할 수 있는 방법이 필요하다.\n\n쿼리의 결과가 바뀌는 순간\n\n1. URL이 가리키는 페이지 내용이 바뀔 때(URL이 가리키는 페이지가 삭제되었을 때)\n2. 페이지의 랭킹이 바뀌어서 결과의 순서가 변경될 때\n3. 특정한 쿼리에 관련있는 새로운 페이지가 등장할 때\n\n방법\n\n1. 데이터가 수정되었을 때 곧바로 캐시를 갱신할 필요가 없다. ->각 서버에 저장된 캐시를 주기적으로 탐색한 뒤 갱신된 URL에 대해서는 캐시 결과를 비운다.\n2. X분이 지나면 자동으로 캐시가 버려지도록 한다.\n\n## 관련문제\n\n[카카오 코딩테스트 문제](https://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/).\n\n## 캐시(난이도: 하)\n\n지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다. <br/>\n이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다.<br/>\n어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고, 제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다.<br/>\n\n어피치에게 시달리는 제이지를 도와, DB 캐시를 적용할 때 캐시 크기에 따른 실행시간 측정 프로그램을 작성하시오.\n\n### 입력 형식\n\n- 캐시 크기(cacheSize)와 도시이름 배열(cities)을 입력받는다.\n- cacheSize는 정수이며, 범위는 0 ≦ cacheSize ≦ 30 이다.\n- cities는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다.\n- 각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다.\n\n### 출력 형식\n\n입력된 도시이름 배열을 순서대로 처리할 때, “총 실행시간”을 출력한다.\n\n### 조건\n\n- 캐시 교체 알고리즘은 LRU(Least Recently Used)를 사용한다.\n- cache hit일 경우 실행시간은 1이다.\n- cache miss일 경우 실행시간은 5이다.\n\n### 입출력 예제\n\n<table>\n<thead>\n\t<tr><th>캐시크기</th><th>도시이름</th><th>실행시간</th></tr>\n</thead>\n<tbody>\n\t<tr>\n    <td>3\t</td><td>[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”]\t</td><td>50</td>\n    </tr>\n    <tr>\n<td>3\t</td><td>[“Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”]</td>\t<td>21</td>\n</tr>\n<tr>\n<td>2\t</td><td>[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”]</td><td>\t60</td>\n</tr>\n<tr>\n<td>5</td><td>\t[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”]</td><td>\t52</td>\n</tr>\n<tr>\n<td>2</td><td>\t[“Jeju”, “Pangyo”, “NewYork”, “newyork”]</td>\t<td>16</td>\n</tr>\n<tr>\n<td>0\t</td><td>[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”]\t</td><td>25</td>\n</tr>\n</tbody>\n</table>\n\n```java\nimport java.util.*;\npublic class Cache {\n\tprivate int cacheSize;\n\tprivate HashMap<String, Node> map;\n\tprivate LinkedList<Node> list;\n\tprivate int time;\n\n\tpublic Cache(int cacheSize) {\n\t\tthis.cacheSize = cacheSize;\n\t\tmap = new HashMap<String, Node>();\n\t\tlist = new LinkedList<Node>();\n\t\ttime = 0;\n\t}\n\n\tpublic void insertResults(String city) {\n\t\tcity = city.toLowerCase();\n\t\tif (map.containsKey(city)) {\n\t\t\ttime+=1;\n\t\t\tNode node = map.get(city);\n\t\t\tlist.remove(node);\n\t\t\tlist.addFirst(node);\n\t\t\treturn;\n\t\t}\n\n\t\ttime+=5;\n\t\tNode node = new Node(city);\n\t\tmap.put(city, node);\n\t\tlist.addFirst(node);\n\n\t\tif (list.size() > cacheSize) {\n\t\t\tNode lastNode = list.removeLast();\n\t\t\tmap.remove(lastNode.cityName);\n\t\t}\n\t}\n\n\tpublic void printCache() {\n\t\tIterator<Node> i = list.iterator();\n\t\twhile (i.hasNext()) {\n\t\t\tSystem.out.print(i.next().cityName + \" \");\n\t\t}\n\t}\n\n\tpublic int getTime() {\n\t\treturn time;\n\t}\n\n\tclass Node {\n\t\tString cityName;\n\t\tNode next;\n\n\t\tpublic Node(String cityName) {\n\t\t\tthis.cityName = cityName;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\n}\n```\n\n```java\npublic class LRUQuestion {\n\tpublic static void main(String[] args) {\n\n\t\tString[] cities1 = {\"Jeju\", \"Pangyo\", \"Seoul\", \"NewYork\", \"LA\", \"Jeju\", \"Pangyo\", \"Seoul\", \"NewYork\", \"LA\"};\n\t\tSystem.out.println(\"실행시간 : \" + testCache(3,cities1));\n\t\tString[] cities2 = {\"Jeju\", \"Pangyo\", \"Seoul\", \"Jeju\", \"Pangyo\", \"Seoul\", \"Jeju\", \"Pangyo\", \"Seoul\"};\n\t\tSystem.out.println(\"실행시간 : \" + testCache(3,cities2));\n\t\tString[] cities3 = {\"Jeju\", \"Pangyo\", \"Seoul\", \"NewYork\", \"LA\", \"SanFrancisco\", \"Seoul\", \"Rome\", \"Paris\", \"Jeju\", \"NewYork\", \"Rome\"};\n\t\tSystem.out.println(\"실행시간 : \" + testCache(2,cities3));\n\t\tString[] cities4 = {\"Jeju\", \"Pangyo\", \"Seoul\", \"NewYork\", \"LA\", \"SanFrancisco\", \"Seoul\", \"Rome\", \"Paris\", \"Jeju\", \"NewYork\", \"Rome\"};\n\t\tSystem.out.println(\"실행시간 : \" + testCache(5,cities4));\n\t\tString[] cities5 = {\"Jeju\", \"Pangyo\", \"NewYork\", \"newyork\"};\n\t\tSystem.out.println(\"실행시간 : \" + testCache(2,cities5));\n\t\tString[] cities6 = {\"Jeju\", \"Pangyo\", \"Seoul\", \"NewYork\", \"LA\"};\n\t\tSystem.out.println(\"실행시간 : \" + testCache(0,cities6));\n\t}\n\n\tpublic static int testCache(int cacheSize, String[] cities) {\n\t\tCache cache = new Cache(cacheSize);\n\t\tfor (String city : cities)\n\t\t\tcache.insertResults(city);\n\n\t\treturn cache.getTime();\n\t}\n}\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"c30c7b633b6e2cf9a63592eefd001cac75a67c14","text":"# 자바 API 정리\n\n- Title : 자바 API 정리\n- Date : 2019-06-27\n- Category: Java\n\nJAVA 공부하면서 알게 된 API 정리한 글 입니다.\n\n# java.lang.String\n\n## compareTo\n\n```java\npublic int compareTo(String anotherString)\n```\n\n두 개의 String을 사전적으로 비교하는 함수다.\n\n- 내부적으로\n\n```java\nthis.charAt(k) - anotherString.charAt(k)\n```\n\nString을 구성하는 char의 유니코드 값으로 비교를 한다.\n\n```java\nthis.length()-anotherString.length()\n```\n\n각 String의 각 char index의 값이 모두 동일하면, 길이가 더 짧은 스트링이 사전적으로 앞선다.\n\n**사용법**\n\n```java\nint returnVal = string1.compareTo(string2);\n```\n\nreturnVal = 0, string1 == string2  \nreturnVal > 0, string1 > string2 사전적으로 string1이 string2보다 뒤에 있다는 뜻.  \nreturnVal < 0, string1 < string2 사전적으로 string1이 string2보다 앞에 있다는 뜻.\n\n---\n"}}}},"pageContext":{"id":"f7c19dc956d0a72d7fc19b8ae99d51755fe7ef9e","previousPostId":"11dd1a4e3a3fb9c66c9aed0ca88c6c669d88bab4","nextPostId":"c30c7b633b6e2cf9a63592eefd001cac75a67c14"}},"staticQueryHashes":["2685952063","2841359383"]}