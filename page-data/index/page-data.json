{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"github":{"repository":{"categories":{"__typename":"GitHub_Tree","entries":[{"name":".DS_Store","type":"blob","posts":{"__typename":"GitHub_Blob"}},{"name":"Algorithm","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":"2019-08-28-coding-interview.md","oid":"f7c19dc956d0a72d7fc19b8ae99d51755fe7ef9e","content":{"__typename":"GitHub_Blob","text":"# 시스템 설계 및 규모 확장성 테스트\n\n- Title : [코딩인터뷰] 시스템 설계 및 규모 확장성 이론\n- Date : 2019-08-28\n- Category: Algorithm\n\n> (코딩인터뷰 완전분석) 책의 '시스템 설계 및 규모 확장성' 파트를 정리한 글입니다. 이런 류의 질문에는 실제로 어떻게 행동할 것인지를 답하면 됩니다.\n\n# 문제를 다루는 방법\n\n- 면접관과 소통하기\n- 처음에는 포괄적으로 접근하기\n- 화이트보드에 제안하는 설계를 그리며 설명하기\n- 면접관이 짚은 문제점을 인정하고 적절히 수정하기\n- 가정을 할 때 주의하기\n- 가정을 할 때 그것을 면접관에게 알리기\n- 필요하다면 어림잡아 보기 예) 공간\n- 계속해서 깊이 파고들고 질문하기\n\n# 시스템 설계 : 단계별 접근법\n\n면접관 : TinyUrl과 같은 시스템을 설계해보세요.  \n지원자 : ???\n\n## 1단계 : 문제의 범위를 한정하라\n\n지원자 : 정확히 무엇을 구현해야 하는거지?..\n\n지원자는 위와 같은 물음이 생기기 마련이다.  \n질문을 통해 물음을 해결하지 않으면 지원자가 만들 시스템과 면접관이 원하는 것이 다를 수 있다.  \n아래와 같은 질문을 던지면서 문제의 범위를 한정해나가는 게 필요하다.\n\n- 개개인이 원하는 대로 축약된 URL을 만들 수 있어야 하나? 아니면 축약된 URL이 항상 자동으로 생성되는 건가?\n- 클릭에 관한 통계 정보를 기록할 필요가 있나?\n- 한번 설정된 URL은 영원히 없어지지 않는건가? 아니면 일정 시간이 지나면 삭제되는건가?\n\n## 2단계 : 필요하다면 가정을 세워라, 단 합당해야 한다.\n\n이러한 가정은 합당하지 않다.\n\n- 시스템이 하루에 100명의 사용자를 처리할 수 있으면 된다.\n- 메모리에 제약이 없다.\n- URL이 제대로 동작하기까지 10분 걸린다.\n\n이러한 가정은 합당하다.\n\n- 하루에 최대 백만 개의 URL을 생성한다.\n- 최근 데이터에 대해 최대 10분 정도 오차가 있다.\n\n## 3단계 : 중요한 부분을 먼저 그려라\n\n화이트보드에 시스템의 주요 부분을 다이어그램으로 그린다.\n\n예시\n\n- 여러 개의 프론트엔드 서버가 백엔드에서 데이터를 받아 오는 시스템\n- 한 서버군은 크롤링, 다른 서버군은 크롤링 데이터를 분석하는 시스템\n\n예를 들어 TinyURL을 설계한다면\n\n지원자 : (사용자가 URL을 입력했을 때 어떤 식으로 진행되는 지 그린다) ...\n\n## 4단계 : 핵심 문제점을 찾아라\n\n- 어느 부분이 병목지점일까?\n- 이 시스템이 풀어야 할 주된 문제는 무엇인가?\n\n예를 들어 TinyURL을 설계한다면 아래와 같은 문제점을 찾아내야한다.\n\n지원자 : 어떤 URL은 드물게 사용되는 반면 특정 URL의 사용량이 갑자기 치솟는 상황이라면..\n시스템이 끊임없이 데이터베이스를 읽어오면 안될텐데....\n\n## 5단계 : 핵심 문제점을 해결할 수 있도록 다시 설계하라\n\n핵심 문제에 맞게 설계를 수정한다. 전체를 갈아 엎을 수도 있고 자잘한 부분만 수정해서 해결할 수도 있다.\n\n지원자 : 캐시를 사용해서 해결하면 되려나..\n\n# 규모 확장을 위한 알고리즘 : 단계별 접근법\n\n면접관 : 시스템의 한 부분 혹은 알고리즘을 설계해보세요\n\n## 1단계 : 질문하라\n\n질문을 통해 문제를 확실히 이해해야한다.\n\n## 2단계 : 현실적 제약을 무시하라\n\n메모리 제약 없고, 컴퓨터 한 대에서 모든 데이터를 다 처리할 수 있다고 가정해서 풀어본다.\n\n## 3단계 : 현실로 돌아오라\n\n- 컴퓨터 한 대에 저장할 수 있는 데이터 크기에 대해 생각하기\n- 데이터를 여러 조각으로 쪼갰을 때 어떤 문제가 발생할지 생각하기\n- 데이터를 여러 조각으로 쪼갤 때 어떤 논리로 데이터를 나눌 것인지 생각하기\n- 데이터를 여러 조각으로 쪼갤 때 특정 컴퓨터가 어느 데이터 조각을 사용했는지 어떻게 알 수 있을 것인지\n\n## 4단계 : 문제를 풀어라\n\n순환적 접근법을 이용한다.\n\n# 시스템 설계의 핵심 개념\n\n## 수평적 vs 수직적 규모 확장\n\n- 수직적 규모 확장 : 특정 노드의 자원의 양을 늘리는 방법 예) 서버에 메모리 추가\n- 수평적 규모 확장 : 노드의 개수를 늘리는 방법 예) 서버를 추가해서 서버 한 대가 다루는 부하를 줄인다.\n\n## 서버 부하 분산 장치(load balancer)\n\n일반적으로 규모 확장성이 있는 웹사이트의 프론트엔드 부분은 서버 부하 분산 장치를 통해서 제공된다.  \n이렇게 해야 서버에 걸리는 부하를 여러 대의 서버에 균일하게 분신시킬 수 있고 서버 한대 때문에 전체 시스템이 죽거나\n다운되는 상황을 방지할 수 있다.  \n물론 서버 여러 대가 근본적으로 똑같은 코드와 데이터를 사용하도록 하는 네트워크를 구현해놔야 한다.\n\n## 데이터베이스 역정규화(denormalization)와 NoSQL\n\nSQL 같은 RDMS의 조인 연산은 시스템이 커질수록 굉장히 느려지므로 가능하면 피해야 한다.\n\n역정규화란?  \n데이터베이스에 여분의 정보를 추가해서 읽기 연산 속도를 향상시킨 것을 의미한다.\n\n예를 들어, 한 프로젝트가 여러 과제를 수행하도록 설계된 데이터베이스를 생각해보자.  \n이 데이터베이스에서 프로젝트 이름이랑 과제 정보를 함께 알고 싶은 경우에 두 테이블을 조인하기보단\n애초에 과제 테이블에 프로젝트 이름 정보를 추가로 저장해 놓으면 더 빠르게 작업을 수행할 수 있다.\n\n혹은, NoSQL 데이터베이스를 이용하면 된다.\nNoSQL은 초고용량 데이터 처리 등 성능에 특화된 목적을 위해, 비관계형 데이터 저장소에, 비구조적인 데이터를 저장하기 위한 분산 저장 시스템이다.  \n저장되는 데이터 구조는 주로 Key-Value 형태이다.  \n예) 몽고DB  \nNoSQL의 특징\n\n- 관계형 모델을 사용하지 않으며 테이블간의 조인 기능 없음\n- 직접 프로그래밍을 하는 등의 비SQL 인터페이스를 통한 데이터 액세스\n- 대부분 여러 대의 데이터베이스 서버를 묶어서(클러스터링) 하나의 데이터베이스를 구성\n- 관계형 데이터베이스에서는 지원하는 Data처리 완결성(Transaction ACID 지원) 미보장\n- 데이터의 스키마와 속성들을 다양하게 수용 및 동적 정의 (Schema-less)\n- 데이터베이스의 중단 없는 서비스와 자동 복구 기능지원\n- 다수가 Open Source로 제공\n- 확장성, 가용성, 높은 성능\n\n# 데이터베이스 분할(샤딩)\n\n샤딩(sharding)은 데이터를 여러 컴퓨터에 나눠서 저장하는 동시에 어떤 데이터가 어떤 컴퓨터에 저장되어 있는지 알 수 있는 방식을 말한다.\n\n- 수직적 분할 : 자료의 특성별로 분할 예) SNS를 만든다면, 개인정보 부분과 메시지 부분으로 자료를 분할 (특정 테이블의 크기가 일정 수준 이상으로 커질 수 있음)\n- 키 혹은 해시 기반 분할 : mod(key, n)의 값을 이용해서 N개의 서버에 분할 (서버의 개수가 고정되어 있어야 하며, 서버를 새로 추가할 때마다 모든 데이터를 재분배 해야함)\n- 디렉터리 기반 분할 : 데이터를 찾을 때 사용되는 조회 테이블(lookup table)을 유지하는 방법, 서버 추가하기는 쉬움 (조회 테이블이 \\*단일 장애 지점이 될 수 있음, 지속적으로 테이블 읽는 행위가 전체 성능에 영향을 미칠 수 있음)\n\n<span class=\"clr-grey\">\\*단일 장애 지점 : 네트워크의 한 지점(노드)의 장애가 전체 네트워크(시스템)의 장애를 초래하는 것</span>\n\n## 캐싱(caching)\n\n인메모리(in-memory) 캐시를 사용하면 결과를 빠르게 가져올 수 있다.\n\n- KEY-VALUE 쌍의 구조\n- 애플리케이션과 데이터 저장소 사이에 자리잡고 있음\n- 쿼리와 그 결과를 캐시하는 경우가 많음\n- 특정 객체를 캐시에 저장할 수 있음\n\n애플리케이션이 어떤 자료를 요청 -> 캐시를 먼저 확인 -> 캐시가 해당 키 값을 갖고 있지 않음 -> 데이터 저장소에서 자료 가져옴\n\n예) 웹 페이지의 어떤 부분을 렌더링한 결과나 블로그에 올라온 최근 포스팅 리스트를 캐시에 갖고 있음\n\n## 비동기식 처리 & 큐\n\n이상적이라면, 속도가 느린 연산은 비동기식으로 처리해야 한다.  \n그렇지 않으면 해당 연산이 끝나기까지 하염없이 기다려야 할 수도 있기 때문이다.\n\n어떤 경우에는 연산을 미리 해 큐에 넣을 수도 있다.\n\n예) 포럼 웹사이트에서 큐에 들어 있는 작업 중 하나는 가장 최근의 글들과 몇가지 코멘트를 보여주는 페이지를 다시 만들어 주는 일이다.  \n새로운 코멘트 하나 때문에 캐시미스가 나서 웹사이트를 새로 불러오는 것보다 큐의 데이터를 이용해 약간 오래되어 덜 정확한 최신 글 리스트를\n보여주는 것이 낫다.\n\n## 네트워크 성능 척도\n\n- 대역폭(bandwidth) : 단위 시간에 전송할 수 있는 데이터의 최대치 (초당 몇 비트(혹은, 몇 기가 바이트)를 보낼 수 있는 가)\n- 처리량(throughput) : 단위 시간에 실제로 전송된 데이터의 양\n- 지연 속도(latency) : 데이터를 전송하는 데 걸리는 시간 (발송자가 데이터를 보낸 시점 - 수신자가 데이터를 받는 지점)\n\n## MapReduce\n\n많은 과정을 병렬로 처리할 수 있게 도와주며 굉장히 커다란 데이터를 처리하는 데 사용\n\n- Map은 데이터를 입력으로 받은 뒤 key-value 쌍을 반환한다.\n- Reduce는 키와 관련된 값들을 입력으로 받은 뒤 나름의 처리 과정을 거친 뒤 새로운 키와 값을 반환하다.\n\n# 시스템 설계 시 고려할 점\n\n- 실패 : 실패에 대한 대비책\n- 가용성 및 신뢰성 : 가용성은 사용 가능한 시스템의 시간을 백분율로 나타낸 것, 신뢰성은 특정 단위 시간에 시스템이 사용 가능할 확률\n- 읽기 중심 vs 쓰기 중심 : 쓰는 연산이 많으면 큐를 사용하는 방법이 좋음, 읽는 연산이 많으면 캐시를 사용하는 것이 좋음\n- 보안\n\n# 연습문제\n\n수백만 개의 문서가 주어졌을 때, 특정 단어 리스트가 포함된 문서를 찾으려고 한다.  \n어떻게 할 수 있을까? 단어가 등장하는 순서는 중요하지 않지만, 해당 단어가 완벽하게 나타나야 한다.\n\nfindwords를 같은 문서 집합에 대해서 여러 번 호출한다고 가정한다.\n\n## 1단계\n\n현실적 제약을 무시해보고 문서가 수십 개 있을 때로 가정하여 문제를 풀어본다.  \nfindWords를 어떻게 구현할까...?\n\n전처리 과정을 통해 모든 문서에 대한 해시테이블을 만든다.  \n해시테이블은 단어와 해당 단어를 포함하는 문서 리스트에 대한 정보를 담고 있다.\n\n\"books\" -> {doc2, doc3, doc6, doc8}  \n\"many\" -> {doc1, dod3, doc7, doc8, doc9}\n\n\"many books\"를 탐색한다면, \"books\"와 \"many\"의 교집합을 구하면 된다. {doc3, doc8}\n\n## 2단계\n\n현실로 돌아와 문서의 개수를 수백만 개로 늘려본다.  \n어떻게 해야할까?  \n일단, 문서를 여러 대의 컴퓨터로 나눠서 보내야 할 것이다.  \n또한 단어의 수나 출현 빈도 등 때문에 해시테이블조차도 한 컴퓨터에 온전히 보관할 수 없을 수 있다.\n\n실제로 해시테이블도 분할해서 저장해야 하는 상황이 벌어졌다고 가정해보자.  \n그러면 다음과 같은 고민을 해야한다.\n\n- 해시테이블은 어떻게 분할하지? 키워드에 따라? 문서에 따라?\n- 데이터를 분할하기로 결정하면, 어떤 컴퓨터에서는 문서를 처리하고 그 처리 결과를 다른 컴퓨터로 옮겨야 할텐데 어떻게 정의할 수 있을까?\n- 어떤 컴퓨터에 어떤 데이터가 보관되어 있는지 알 수 있어야 할텐데.. 그리고 조회 테이블의 형태는? 조회 테이블은 어디에 두어야 되지?\n\n## 3단계\n\n문제점에 대한 해법을 찾아야 한다.\n한 가지 방법은 키워드를 알파벳 순서에 따라 분할하는 것이다.  \n즉, 한 컴퓨터가 특정한 범위의 단어들(예, after~apple)만 통제하게 하는 것이다.  \n키워드를 알파벳 순서로 돌면서 가능한 데이터를 저장하는 알고리즘은 쉽게 구현할 수 있다. 용량이 꽉 차면, 다른 컴퓨터로 옮겨 가야 한다.\n\n장점 : 조회 테이블을 작고 단순하게 만들 수 있음, 각 컴퓨터에 조회 테이블의 복사본을 저장할 수 있음  \n단점 : 새로운 문서나 단어 추가시 키워드를 굉장히 많이 이동시킴\n\n\"after builds boat amaze banana\"\n\n컴퓨터에 키워드가 알파벳 순서로 분할되어 있으니 문자열을 정렬한 후 요청을 보낸다.\n\n일번 컴퓨터는 \"after~apple\" 범위의 키워드가 있으니 after와 amaze에 대한 요청을 보내고, builds, boat, banana는 삼번 컴퓨터 범위에 해당되므로\n삼번 컴퓨터로 요청을 보낸다.  \n각 컴퓨터에서 요청 사항에 대한 교집합을 구하여 반환한다.  \n마지막으로, 초반에 전체 요청을 보낸 컴퓨터는 일번과 삼번의 컴퓨터로 부터 받은 결과의 교집합을 구하면 된다.\n"}},{"name":"2019-08-30-coding-interview-question-1.md","oid":"a1f625269928ae850f3014fdc0614633e4ee091c","content":{"__typename":"GitHub_Blob","text":"# 시스템 설계 및 규모 확장성 문제 1 - 중복 URL\n\n- Title : [코딩인터뷰] 시스템 설계 및 규모 확장성 문제 1 - 중복 URL\n- Date : 2019-08-30\n- Category: Algorithm\n\n> 코딩 인터뷰 완전분석 (CRACKING THE CODING INTERVIEW 6/E) / 게일 라크만 맥도웰 지음 / 인사이트\n\n# Q. 중복 URL : 100억 개의 URL이 있다. 중복된 문서를 찾으려면 어떻게 해야 하는가? 여기서 '중복'이란 '같은 URL'이라는 뜻이다.\n\n## 내풀이\n\n만약 100억 개의 URL을 저장할 수 있는 충분한 공간이 있다면, 리스트를 정렬한 후 중복된 값 찾으면 될 것 같다.  \n아니면 100억 개의 URL을 해시테이블에 저장하는 전처리 과정을 하면 전처리 과정 중에도 중복된 문서를 찾을 수 있고\n그 후 데이터가 추가될 때도 쉽게 중복 여부를 확인할 수 있을 것 같다.\n\n## 책풀이\n\n## 1단계 : 합당한 가정을 세운다.\n\n책은 100억 개의 URL을 처리하기위한 공간을 계산하기위해 다음과 같은 합당한 가정을 세운다.\n\n- 각 URL이 평균적으로 100개의 문자로 구성되어 있고 각 문자는 4바이트라고 가정한다.\n- 100(문자) _ 4(bytes) _ 100억(url개수) = 4,000,000,000,000 bytes = 4 \\* 10<sup>12</sup> = 4TB\n- 즉, 100억 개의 URL을 처리하기위해서는 4TB 정도의 메모리 공간이 필요하다.\n\n## 2단계 : 현실적 제약을 무시한다.\n\n모든 데이터를 메모리에 보관할 수 있다고 가정한 후 문제에 접근한다.\n\n이미 살펴본 URL에 대해 true를 반환하는 해시테이블을 사용하여 문제를 해결할 수 있다.  \n리스트를 정렬하는 방식은 시간도 더 들고 장점도 없다.\n\n## 3단계 : 현실로 돌아온다.\n\n4TB의 데이터를 메모리(RAM)에 전부 올릴 수 없는 상황에서 어떻게 해야하는지 생각한다.\n\n**해법 #1 : 디스크 저장**\n\n각 URL을 .txt 파일에 저장한다.  \n.txt 파일의 크기는 1GB(10<sup>9</sup>)로 4TB URL을 저장하기위해서는 4000개의 파일이 필요하다.  \nx = hash(u) % 4000로 저장할 .txt 파일을 결정한다.  \n같은 해시값을 갖는 URL은 같은 파일에 저장된다.  \n각 파일을 메모리에 올려 URL의 해시테이블을 생성한 다음에 중복이 존재하는 지 확인하면 된다.\n\n**해법 #2 : 데이터를 여러 서버에 분할**\n\n본질적으로는 해법1과 같으나, 여러 서버를 사용한다는 차이가 있다.  \nURL을 .txt라는 파일에 저장하는 대신 서버 x에 전송하는 것이다.\n\n- 장점 : 병렬처리가능\n- 단점 : 4000개의 서버가 완벽 동작해야함(비현실적)\n"}},{"name":"2019-08-30-coding-interview-question-2.md","oid":"725f6823a549cb3bd4d8fddd15021a218c438de0","content":{"__typename":"GitHub_Blob","text":"# [코딩인터뷰] 시스템 설계 및 규모 확장성 문제 2 - 소셜네트워크\n\n- Title : [코딩인터뷰] 시스템 설계 및 규모 확장성 문제 2 - 소셜네트워크\n- Date : 2019-08-30\n- Category: Algorithm\n\n> 코딩 인터뷰 완전분석 (CRACKING THE CODING INTERVIEW 6/E) / 게일 라크만 맥도웰 지음 / 인사이트\n\n# Q. 소셜 네트워크 : 페이스북이나 링크드인과 같은 대규모 소셜 네트워크를 위한 자료구조는 어떻게 설계하겠는가? 두 사람 사이의 최단 경로를 보여주는 알고리즘은 어떻게 설계하겠는가? (가령, 나->밥->수잔->제이슨->당신)\n\n## 내풀이\n\n'나'를 기준으로 '나'의 친구들을 연결할 필요가 있고, '친구'의 친구들을 연결할 필요가 있다.  \n각 사용자를 '노드'로 정의하고 관계를 '에지'로 정의한다고 하면 자료구조로 그래프를 사용하는 게 적절하다고 생각한다.  \n사용자 간의 경로 탐색은 너비우선탐색(BFS)로 하는 것이 적절하다고 생각한다.\n'나'를 기준으로 동심원을 그리며 찾는 것이 깊이우선탐색(DFS)보다 낫다.\nDFS는 '노드'를 기준으로 방문하지않은 노드 끝까지 갔다가 돌아가는 식으로 탐색하므로 최단경로가 아닐 수도 있다.\n\n## 책풀이\n\n## 단계1 : 문제를 단순화하기 - 수백만이 아닌 10명의 사용자로 생각해보기\n\n각 사용자를 노드, 친구 관계를 간선으로 설정하여 하나의 그래프를 만들 수 있다.  \n두 사용자 간의 경로는 한 사용자에서 시작해서 너비 우선 탐색을 돌려보면된다.\n혹은 양방향 너비 우선 탐색을 할 수도 있다.  \n하나는 출발지에서, 나머지 하나는 도착지에서 시작해서 너비 우선 탐색 두 개를 동시에 돌리는 것을 말한다.  \n두 탐색이 어느 지점에서 충돌하는 순간 경로를 찾은 것이다.\n\n**깊이우선탐색을 사용하지 않는 이유는?**  \n깊이 우선 탐색은 단순히 경로 하나를 찾기 때문이고, 이 경로가 가장 짧은 경로가 아닐 수도 있다.  \n또한, 경로 하나를 찾는 과정도 비효율적이다. 두 사용자가 1촌 관계라 하더라도 하위 트리에 존재하는 수백만 개의 노드를 탐색하게 될 수 있기 때문이다.\n\n**구현방법**  \n![1](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2019-08-30-img/2-1.jpg) <br/>\n![2](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2019-08-30-img/2-2.jpg) <br/>\n![3](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2019-08-30-img/2-3.jpg) <br/>\n![4](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2019-08-30-img/2-4.jpg) <br/>\n\n양방향 너비 우선 탐색이 일반 너비 우선 탐색보다 빠르다.  \nS와 D가 친구 C를 공유할 때, (각 사용자는 K명의 친구가 있다, q는 경로의 길이)\n\n- 일반적인 너비 우선 탐색으로 S -> D로 가려면 대략 K + K\\*K개의 노드를 거쳐야 한다. = Q(K<sup>q</sup>)\n- 양방향 너비 우선 탐색은 S 친구 K, D친구 K로 2K 노드만 거치면 된다. = Q(K<sup>q/2</sup>)\n\n단, 양방향 너비 우선 탐색은 시작 지점과 도착 지점 모두 접근 가능할 때에나 사용 가능하다.\n\n## 단계2 : 수백만 사용자의 처리\n\n링크드인이나 페이스북 규모의 서비스를 만들 때에는 컴퓨터 하나만으로는 부족하다.  \n다시 말해 Person을 위와 같이 단순하게 설계해서는 제대로 동작하지 않을 것이라는 뜻이다.  \n우리가 찾는 '친구'는 같은 서버에 있지 않을 수도 있다.  \n따라서 ID로 구성되는 친구 리스트를 만들고, ID를 통해 해당 사용자 정보가 있는 컴퓨터 정보를 얻는다.  \n얻은 컴퓨터 정보 안에서 사용자 정보를 다시 탐색한다.  \n효율적 탐색을 위해서 해시테이블을 사용한다.\n\n**최적화하기**\n\n- 다른 서버에 대한 탐색을 줄인다.\n- 컴퓨터에 사용자 정보를 분배할 때, 무작위로 나누는 것이 아닌 사용자가 거주하는 나라나 시, 도, 군 등의 정보를 이용한다.\n"}},{"name":"2019-08-30-coding-interview-question-3.md","oid":"715125ef37493c20558b7c22e3a63779c2d38594","content":{"__typename":"GitHub_Blob","text":"# 시스템 설계 및 규모 확장성 문제 3 - 웹 크롤러\n\n- Title : [코딩인터뷰] 시스템 설계 및 규모 확장성 문제 3 - 웹 크롤러\n- Date : 2019-08-30\n- Category: Algorithm\n\n> 코딩 인터뷰 완전분석 (CRACKING THE CODING INTERVIEW 6/E) / 게일 라크만 맥도웰 지음 / 인사이트\n\n# Q. 웹 크롤러 : 웹에 있는 데이터를 긁어 오는 크롤러를 설계할 때, 무한루프에 빠지는 일을 방지하려면 어떻게 해야 하는가?\n\n## 무한루프는 어떻게 발생하는가?\n\n단순히 웹의 링크에 의해 만들어지는 그래프로 볼 경후, 사이클이 존재하면 무한루프가 발생할 수 있다.  \n따라서 무한루프를 막으려면 사이클을 탐지해야 한다.  \n그러기 위해선 해시테이블을 두고 이미 방문한 페이지 v의 hash[v] 값을 true로 바꿔줘야 한다.  \n이 해법은 웹을 너비 우선으로 탐색한다는 것을 의미한다.\n\n## 페이지 v를 방문한다는 것의 의미\n\n1. 단순히 URL 기준으로 판단해야 할까?\n2. 페이지 내용에 따라 방문 여부를 확인해야 할까?\n\n1번의 경우는 URL의 파라미타 값이 달라졌을 때 실제로 페이지는 달라지지 않을 때를 생각해야한다.  \n2번의 경우 같은 페이지라 할지라도 내용이 무작위로 생성된다면 다른 페이지라고 해야하는 지를 생각해봐야한다.  \n즉, 이 페이지가 저 페이지와 '다른' 페이지인지 판단하는 완벽한 방법은 없는 셈이다.\n\n이 문제를 해결하는 방법은 페이지 내용과 URL을 토대로 페이지 간의 유사성을 가늠해 보는 것이다.\n\n- 크롤러가 탐색해야 하는 항목들을 데이터베이스에 저장해 둔다.\n- 탐색 우선순위가 가장 높은 페이지를 고른다.\n- 페이지를 열어 해당 페이지의 특정한 섹션과 URL을 토대로 시그니처를 생성한다.\n- 데이터베이스 쿼리를 통해 해당 시그니처의 페이지가 최근에 탐색된 적 있는지 살핀다.\n- 만일 해당 시그니처를 갖는 페이지가 최근에 탐색된 적이 있으면 해당 페이지의 우선순위를 낮춰서 데이터베이스에 추가한다.\n- 그렇지 않다면 해당 페이지를 탐색하고, 그 페이지에 연결된 링크를 데이터베이스에 추가한다.\n"}},{"name":"2019-08-30-coding-interview-question-4.md","oid":"11dd1a4e3a3fb9c66c9aed0ca88c6c669d88bab4","content":{"__typename":"GitHub_Blob","text":"# 시스템 설계 및 규모 확장성 문제 4 - 캐시\n\n- Title : [코딩인터뷰] 시스템 설계 및 규모 확장성 문제 4 - 캐시\n- Date : 2019-08-30\n- Category: Algorithm\n\n> 코딩 인터뷰 완전분석 (CRACKING THE CODING INTERVIEW 6/E) / 게일 라크만 맥도웰 지음 / 인사이트\n\n# Q. 캐시 : 간단한 검색 엔진으로 구현된 웹 서버를 생각해보자. 이 시스템에선 100개의 컴퓨터가 검색 요청을 처리하는 역할을 하고 있다. 예를 들어 하나의 컴퓨터 집단에 processSearch(string query)라는 요청을 보내면 그에 상응하는 검색 결과를 반환해 준다. 하지만 어떤 컴퓨터가 요청을 처리하게 될지는 그때그때 다르며, 따라서 같은 요청을 한다고 같은 컴퓨터가 처리할 거라고 장담할 수 없다. processSearch 메서드는 아주 고비용이다. 최근 검색 요청을 캐시에 저장하는 메커니즘을 설계하라. 데이터가 바뀌었을 때 어떻게 캐시를 갱신할 것인지 반드시 설명하라.\n\n## 가정을 통해 문제를 구체화하자\n\n- 필요할 때 processSearch를 호출하는 것 이외에도, 모든 쿼리는 최초로 호출된 서버에서 처리된다.\n- 캐시하고자 하는 쿼리의 수는 굉장히 크다(수백만 개)\n- 서버 간 호출은 상대적으로 빨리 처리된다.\n- 쿼리의 결과는 정렬된 URL 리스티이다. 각 원소에는 최대 50글자의 제목과 200글자의 요약문이 따라 붙는다.\n- 가장 인기 있는 쿼리의 경우 항상 캐시에 보관되어 있다.\n\n## 시스템 요구 사항을 정리하자\n\n1. 최근 검색 요청을 캐시에 저장해야 한다.\n2. 캐시를 통해 빠른 탐색이 가능해야 한다.\n3. 쿼리 결과가 변경될 경우 캐시를 변경하거나 삭제할 수 있어야 한다.\n\n## 단순하게 생각하자 - 요구사항 1, 2번\n\n단순하게 컴퓨터가 하나일 경우로 가정하여 설계해본다.\n\n빠른 탐색이 가능하려면 key-value 쌍의 자료구조인 해시맵을 사용하는 게 적절할 것 같다.  \n쿼리를 해시 처리하여 key값을 생성하고 쿼리의 결과 값을 value로 해서 해시맵에 저장하면 될 듯 싶다.\n\n첫번째 요구사항을 보면 캐시에 최신 검색 순으로 저장될 필요가 있다. 데이터를 순서대로 저장해야 한다.  \n하지만 해시맵은 데이터의 순서를 기억하기에는 적절치 못한 자료구조다.  \n순서를 위한 자료구조는 배열과 연결리스트가 있는데 최신 검색의 삽입과 오래된 검색의 삭제가 빈번하므로 연결리스트 자료구조가 적절하지 않을까?  \n그러나,,,, 연결리스트는 탐색 시 Q(N) 시간이라 빠른 탐색이 힘들다..\n\n어떻게 할까?  \n두 자료구조를 합치면 어떨까?\n\n이는 LRU 캐시를 구현하라는 것과 같다.  \nLRU는 OS의 페이지 교체 알고리즘의 하나로 최근에 가장 오랫동안 사용되지 않은 페이지를 교체하는 기법이다.\n다음은 LRU 캐시 구현 그림이다.\n\n![1](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2019-08-30-img/4-1.jpg) <br/>\n\n## 이제 현실로 돌아와서 생각하자 - 여러 서버로 확장\n\n**방법1 - 각 서버에 별도의 캐시를 둔다**\n\n서버 1에 같은 쿼리를 2번 보내면, 두 번째 처리 결과는 캐시에서 가져온다.  \n그러나 서버 1에 보냈다가 서버 2에 보내면 서버 2는 해당 쿼리를 새로운 쿼리로 처리한다.\n\n- 장점 : 서버 간 통신이 필요없기에 상대적으로 빠르다.\n- 단점 : 같은 쿼리가 반복되도 새로운 쿼리로 인식하기 때문에 최적화를 위한 방법으로 부적절\n\n**방법2 - 각 서버에 캐시 복사본을 둔다**\n\n각 서버에 전체 캐시의 완전한 복사본을 유지하는 방법이다.  \n새로운 데이터가 캐시에 추가되는 순간 그 데이터는 모든 서버로 보내진다.  \n따라서 연결리스트와 해시테이블을 비롯한 모든 자료구조가 중복되어 저장된다.\n\n- 장점 : 어느 서버에서도 동일하게 존재하기 때문에 빈번하게 사용되는 쿼리와 실행 결과는 항상 캐시 내에 존재한다.\n- 단점1 : 캐시를 갱신할 때마다 데이터를 N개의 서로 다른 서버로 전송해야 한다는 점\n- 단점2 : 각 캐시를 저장하기 위해 N배 더 큰 공간이 필요하므로 캐시에 저장 가능한 항목의 수가 줄어든다.\n\n**방법3 - 각 서버에 캐시의 일부를 저장한다**\n\n캐시를 분할하여 각 서버에 그 일부만을 보관한다.  \n예를 들어, 서버 i가 어떤 쿼리에 대한 결과를 알고 싶다고 하자.\n\n![1](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2019-08-30-img/4-2.jpg) <br/>\n\n## 요구 사항 3번을 해결하자\n\n- 요구사항 3 : 쿼리 결과가 변경될 경우 캐시를 변경하거나 삭제할 수 있어야 한다.\n\n캐시가 충분히 클 경우 어떤 쿼리는 너무 빈번해서 항상 캐시에 남아 있을 수 있다.  \n따라서 주기적으로 혹은 어떤 쿼리 결과가 변경되었을 때마다 캐시에 보관된 결과를 갱신할 수 있는 방법이 필요하다.\n\n쿼리의 결과가 바뀌는 순간\n\n1. URL이 가리키는 페이지 내용이 바뀔 때(URL이 가리키는 페이지가 삭제되었을 때)\n2. 페이지의 랭킹이 바뀌어서 결과의 순서가 변경될 때\n3. 특정한 쿼리에 관련있는 새로운 페이지가 등장할 때\n\n방법\n\n1. 데이터가 수정되었을 때 곧바로 캐시를 갱신할 필요가 없다. ->각 서버에 저장된 캐시를 주기적으로 탐색한 뒤 갱신된 URL에 대해서는 캐시 결과를 비운다.\n2. X분이 지나면 자동으로 캐시가 버려지도록 한다.\n\n## 관련문제\n\n[카카오 코딩테스트 문제](https://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/).\n\n## 캐시(난이도: 하)\n\n지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다. <br/>\n이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다.<br/>\n어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고, 제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다.<br/>\n\n어피치에게 시달리는 제이지를 도와, DB 캐시를 적용할 때 캐시 크기에 따른 실행시간 측정 프로그램을 작성하시오.\n\n### 입력 형식\n\n- 캐시 크기(cacheSize)와 도시이름 배열(cities)을 입력받는다.\n- cacheSize는 정수이며, 범위는 0 ≦ cacheSize ≦ 30 이다.\n- cities는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다.\n- 각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다.\n\n### 출력 형식\n\n입력된 도시이름 배열을 순서대로 처리할 때, “총 실행시간”을 출력한다.\n\n### 조건\n\n- 캐시 교체 알고리즘은 LRU(Least Recently Used)를 사용한다.\n- cache hit일 경우 실행시간은 1이다.\n- cache miss일 경우 실행시간은 5이다.\n\n### 입출력 예제\n\n<table>\n<thead>\n\t<tr><th>캐시크기</th><th>도시이름</th><th>실행시간</th></tr>\n</thead>\n<tbody>\n\t<tr>\n    <td>3\t</td><td>[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”]\t</td><td>50</td>\n    </tr>\n    <tr>\n<td>3\t</td><td>[“Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”]</td>\t<td>21</td>\n</tr>\n<tr>\n<td>2\t</td><td>[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”]</td><td>\t60</td>\n</tr>\n<tr>\n<td>5</td><td>\t[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”]</td><td>\t52</td>\n</tr>\n<tr>\n<td>2</td><td>\t[“Jeju”, “Pangyo”, “NewYork”, “newyork”]</td>\t<td>16</td>\n</tr>\n<tr>\n<td>0\t</td><td>[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”]\t</td><td>25</td>\n</tr>\n</tbody>\n</table>\n\n```java\nimport java.util.*;\npublic class Cache {\n\tprivate int cacheSize;\n\tprivate HashMap<String, Node> map;\n\tprivate LinkedList<Node> list;\n\tprivate int time;\n\n\tpublic Cache(int cacheSize) {\n\t\tthis.cacheSize = cacheSize;\n\t\tmap = new HashMap<String, Node>();\n\t\tlist = new LinkedList<Node>();\n\t\ttime = 0;\n\t}\n\n\tpublic void insertResults(String city) {\n\t\tcity = city.toLowerCase();\n\t\tif (map.containsKey(city)) {\n\t\t\ttime+=1;\n\t\t\tNode node = map.get(city);\n\t\t\tlist.remove(node);\n\t\t\tlist.addFirst(node);\n\t\t\treturn;\n\t\t}\n\n\t\ttime+=5;\n\t\tNode node = new Node(city);\n\t\tmap.put(city, node);\n\t\tlist.addFirst(node);\n\n\t\tif (list.size() > cacheSize) {\n\t\t\tNode lastNode = list.removeLast();\n\t\t\tmap.remove(lastNode.cityName);\n\t\t}\n\t}\n\n\tpublic void printCache() {\n\t\tIterator<Node> i = list.iterator();\n\t\twhile (i.hasNext()) {\n\t\t\tSystem.out.print(i.next().cityName + \" \");\n\t\t}\n\t}\n\n\tpublic int getTime() {\n\t\treturn time;\n\t}\n\n\tclass Node {\n\t\tString cityName;\n\t\tNode next;\n\n\t\tpublic Node(String cityName) {\n\t\t\tthis.cityName = cityName;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\n}\n```\n\n```java\npublic class LRUQuestion {\n\tpublic static void main(String[] args) {\n\n\t\tString[] cities1 = {\"Jeju\", \"Pangyo\", \"Seoul\", \"NewYork\", \"LA\", \"Jeju\", \"Pangyo\", \"Seoul\", \"NewYork\", \"LA\"};\n\t\tSystem.out.println(\"실행시간 : \" + testCache(3,cities1));\n\t\tString[] cities2 = {\"Jeju\", \"Pangyo\", \"Seoul\", \"Jeju\", \"Pangyo\", \"Seoul\", \"Jeju\", \"Pangyo\", \"Seoul\"};\n\t\tSystem.out.println(\"실행시간 : \" + testCache(3,cities2));\n\t\tString[] cities3 = {\"Jeju\", \"Pangyo\", \"Seoul\", \"NewYork\", \"LA\", \"SanFrancisco\", \"Seoul\", \"Rome\", \"Paris\", \"Jeju\", \"NewYork\", \"Rome\"};\n\t\tSystem.out.println(\"실행시간 : \" + testCache(2,cities3));\n\t\tString[] cities4 = {\"Jeju\", \"Pangyo\", \"Seoul\", \"NewYork\", \"LA\", \"SanFrancisco\", \"Seoul\", \"Rome\", \"Paris\", \"Jeju\", \"NewYork\", \"Rome\"};\n\t\tSystem.out.println(\"실행시간 : \" + testCache(5,cities4));\n\t\tString[] cities5 = {\"Jeju\", \"Pangyo\", \"NewYork\", \"newyork\"};\n\t\tSystem.out.println(\"실행시간 : \" + testCache(2,cities5));\n\t\tString[] cities6 = {\"Jeju\", \"Pangyo\", \"Seoul\", \"NewYork\", \"LA\"};\n\t\tSystem.out.println(\"실행시간 : \" + testCache(0,cities6));\n\t}\n\n\tpublic static int testCache(int cacheSize, String[] cities) {\n\t\tCache cache = new Cache(cacheSize);\n\t\tfor (String city : cities)\n\t\t\tcache.insertResults(city);\n\n\t\treturn cache.getTime();\n\t}\n}\n```\n"}},{"name":"2019-08-31-coding-interview-question-5.md","oid":"d3dc616060fb13934c41fc45065d110b9e8704ee","content":{"__typename":"GitHub_Blob","text":"# 시스템 설계 및 규모 확장성 문제 5 - 판매순위\n\n- Title : [코딩인터뷰] 시스템 설계 및 규모 확장성 문제 5 - 판매순위\n- Date : 2019-08-31\n- Category: Algorithm\n\n> 코딩 인터뷰 완전분석 (CRACKING THE CODING INTERVIEW 6/E) / 게일 라크만 맥도웰 지음 / 인사이트\n\n# Q. 판매순위 : 한 전자상거래 회사는 가장 잘 팔리는 제품의 리스트(전체에서 그리고 각 목록별로)를 알고 싶어 한다. 예를 들어, 어떤 제품은 전체 제품 중에서 1,506번째로 잘 팔리지만 운동 장비 중에서는 13번째로 잘 팔리고, 안전용품 중에서는 24번째로 잘 팔릴 수 있다. 이 시스템을 어떻게 설계할지 설명하라.\n\n## 내풀이\n\n각 제품 정보에 판매수량을 저장을 하고 리스트 조회할 때마다 정렬하는 건 좀 그럴거 같긴한뎁,,\n동시에 전체 중 ~위 운동 장비 중 ~위.. 이런식으로 표현하게 되면 정렬을 넘 많이 하게 되는 듯싶은뎅\n구입할 때마다 리스트의 맨앞에..?음..\n매번 순위 조회할때마다 정렬해야되니깐 이건 좀 별루고\n아예 전체 연결리스트를 순서가 유지되게 하는 게 좋을 듯\n삽입 삭제가 빈번하니깐 연결리스트가 좋을거같고...\n\n## 책풀이\n\n**1단계 : 문제 범위를 한정하고 합리적인 가정을 하자**\n\n구현하려는 시스템을 다음과 같이 정의했다.\n\n- 잘 팔린다는 것은 판매량이 많다는 것을 의미한다.\n- 판매량은 평생/지난달/저번주 판매량인지 명확하게 정의할 것이다. 여기서는 저번주 판매량으로 한정한다.\n- 각 제품은 여러 목록에 포함될 수 있고 하위목록 개념은 없다고 가정한다.\n\n다음과 같은 합리적인 가정을 세웠다.\n\n- 통계 결과가 언제나 100% 최신 데이터가 아닐 수 있다고 가정할 것이다.\n- 인기 있는 제품의 경우 정확도가 중요하나 인기 없는 제품은 약간의 오차가 있어도 괜찮다.\n- 가장 인기 있는 제품의 경우 한 시간마다 갱신이 이루어진다고 가정할 것이다.\n\n**2단계 : 주요 구성요소 그리기**\n\n![1](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2019-08-30-img/5-1.jpg) <br/>\n\n**3단계 : 핵심문제 파악**\n\n1. 분석은 비용이 비싸다.\n2. 데이터베이스에 너무 자주 기록한다.\n3. join 비용이 비싸다\n\n2번 데이터베이스에 너무 자주 기록된다.  \n구매할 때마다 판매량 정보 테이블을 업데이트하기보다는 모아서 일괄적(batch)으로 한번에 데이터베이스에 쓰는 방법을 쓴다.  \n즉, 곧바로 데이터베이스에 자료를 집어넣기보단, 메모리 내의 캐시와 같은 저장소에 구매 정보와 백업용 로그 파일을 저장해 놓은 뒤 주기적으로 로그/캐시 데이터를 모아서 한 번에 데이터베이스에 넣는 것이다. (특정 시점까지의 자료만 데이터베이스에 넣는 식)\n\n3번 join 비용이 비싸다.  \n수천 개의 제품 목록을 제품 ID에 join 하는 작업은 고비용이다.\n"}},{"name":"2019-12-12-coding-interview-linkedlist-1.md","oid":"0e6c91a0a899db4d2998ba6ee8189e54a606fb9b","content":{"__typename":"GitHub_Blob","text":"# 알고리즘 개념 잡자 - 연결리스트\n\n- Title : [코딩인터뷰] 연결리스트\n- Date : 2019-12-12\n- Category: Algorithm\n\n코딩 인터뷰 완전분석 연결리스트 파트 예제 문제 풀이\n\n# 배열\n\n## Random access\n\n배열의 엘리먼트들은 메모리에 연속적으로 저장되므로 어떤 엘리먼트도 첫번째 엘리먼트의 주소에 각 엘리먼트 크기를 더해서 접근할 수 있다.  \n각 엘리먼트가 4byte고 세번째 엘리먼트 접근하려면 첫번째 주소 + 4\\*3 이다.  \n즉, 첫번째 탐색이나 마지막 엘리먼트 탐색 시간 차이가 없다. 탐색 시간 O(1) 가능하다.\n\n## 메모리 낭비\n\n개발자가 메모리를 얼마나 사용할 지 모르는 상태에서 배열의 크기를 초기화해야한다.\n\n## 삽입 삭제 연산 느림\n\n첫번째 또는 중간 삽입의 경우 삽입 엘리먼트 공간 확보를 위해 배열을 한칸씩 뒤로 이동시켜야한다.  \n삭제는 반대로 한칸씩 앞으로 이동시켜야하고 배열의 크기를 재조정해야 한다.  \n즉, n개의엘리먼트를 이동시켜야하므로 O(n) 단 맨끝 삭제는 o(1)\n\n# 연결리스트\n\n## Iterate access\n\n배열과 달리 메모리에 연속적 공간 갖지않고 첫번째 노드의 포인터부터 순회해야한다.  \n즉, 탐색은 O(n) 시간복잡도를 가져서 배열보다 탐색이 느리다.\n\n## 리스트 크기를 미리 정의해놓을필요가없음\n\n## 삽입 삭제 연산 빠름\n\n중간노드 끝노드의 경우 위치 찾는데는 o(n) 이지만 실제 삽.삭은 포인터만 업데이트하면되니깐 o(1)이다.  \n단, 맨 앞 노드는 o(1)\n\n# 2.1 중복 없애기 : 정렬되어 있지 않은 연결리스트가 주어졌을 때 이 리스트에서 중복되는 원소를 제거하는 코드를 작성하자. 임시 버퍼를 사용할 수 없는 경우도 생각해보자.\n\n1. 임시버퍼를 사용할 수 있다면, 중복을 허용하지 않는 Set 컬렉션을 이용해서 해결할 수 있다. 이 경우는 O(N)의 시간 복잡도를 갖는다.\n2. 임시버퍼를 사용할 수 없다면, 이중 반복문을 통해 중복 노드를 찾은 후 제거하면 된다. 이 경우는 O(N^2)의 시간 복잡도를 갖는다.\n\n## 자바스크립트 풀이\n\n```javascript\n\"use strict\";\n\nclass Node {\n  constructor(data, next) {\n    this.data = data;\n    this.next = next;\n  }\n}\n\nclass LinkedList {\n  constructor(head) {\n    this.head = head;\n  }\n\n  display() {\n    let cur = this.head;\n    while (cur != null) {\n      console.log(cur.data);\n      cur = cur.next;\n    }\n  }\n}\n\nfunction makeList() {\n  let n6 = new Node(4);\n  let n5 = new Node(5, n6);\n  let n4 = new Node(3, n5);\n  let n3 = new Node(5, n4);\n  let n2 = new Node(4, n3);\n  let n1 = new Node(5, n2);\n  let list = new LinkedList(n1);\n  return list;\n}\n\n// O(n) n: 연결리스트 길이\nfunction solution() {\n  const list = makeList();\n  const set = new Set();\n  let cur = list.head;\n  let pre = null;\n  while (cur != null) {\n    if (set.has(cur.data)) {\n      pre.next = cur.next;\n    } else {\n      set.add(cur.data);\n      pre = cur;\n    }\n    cur = cur.next;\n  }\n  list.display();\n}\n\n// O(N^2) 버퍼 없이\nfunction solution_2() {\n  const list = makeList();\n  let cur = list.head;\n\n  while (cur != null) {\n    let mn = cur;\n\n    while (mn.next != null) {\n      if (cur.data === mn.next.data) {\n        mn.next = mn.next.next;\n      } else {\n        mn = mn.next;\n      }\n    }\n    cur = cur.next;\n  }\n\n  list.display();\n}\n\nsolution();\nsolution_2();\n```\n\n**자바스크립트의 null과 undefined**  \n자바스크립트에서 '없음'을 나타내는 값에 null과 undefined가 있다. 값이 대입되지 않은 변수나 속성의 경우는 undefined이며 객체가 없는 경우는 null로 나타낸다.  \n자바스크립트의 === 등호는 값이 정확히 같을 때 true를 반환하나 == 등호는 그렇지 않을 때가 많다. 보통의 경우는 === 를 권장하나 null check 할 때는 == 쓰면 값이 null 또는 undefined의 경우 false를 리턴 받을 수 있다.\n\n**자바스크립트의 class**  \nES6의 클래스 선언은 호이스팅이 되지 않아서 클래스를 사용하기 위해서는 클래스를 먼저 선언해야 한다. class body는 {}로 묶여 있는 안쪽 부분으로 constructor(생성자)가 있는 곳이다. 객체를 생성하고 초기화하는 메소드로 클래스 안에 한 개만 존재할 수 있다. 부모 생성자를 호출하기 위해 super 키워드를 사용할 수도 있다.\n\n**자바스크립트에서 오토박싱**  \nnon-strict 모드에서 this 값이 null 혹은 undefined 일 경우 window 객체로 자동으로 변환을 해주는 것을 오토박싱이라고 한다. 그래서 일반 메서드에서 this 값이 window 객체가 된다. class 문법 안에 있는 코드는 항상 strict mode로 실행되기 때문에 클래스 메서드 호출에서 this의 초기값은 undefined다.\n\n**자바에서 오토박싱**  \n자바에는 int, float와 같은 기본형(primitive type)과 Integer, Float와 같은 래퍼 클래스가 있다. 래퍼 클래스는 기본형을 객체로 다루어야 할 경우에 사용할 수 있다. 컬렉션에서 엘리먼트는 객체가 되어야 되서 int 기본형을 사용하지 않고 Integer를 사용하는 것을 본 적이 있을 거다. 박싱은 기본형을 참조형으로 변환하는 것이고 언박싱은 반대로 참조형을 기본형으로 바꾸는 것이다. 예제를 통해 확실히 이해해보자.\n\n```java\nint pa = 1;\nInteger wa = pa; // 오토박싱\n\nInteger wb = new Integer(2);\nint pb = wb; // 오토언박싱\n\n```\n\n## 자바 풀이\n\n**리스트 반복하면서 삭제하기**  \nfor(;;)를 이용한 방법은 반복 도중 엘리먼트가 삭제되면 반복문의 크기가 변한다. 또한 삭제된 엘리먼트 자리를 채우기 위해 모든 인덱스가 하나씩 이동하게 된다. 생각대로 동작하지 않는 것 당연하다.\n\nfor-each문 안에서 엘리먼트를 삭제하게 되면 **java.util.ConcurrentModificationException** 에러를 보게 된다. Iterator로 반복 중인 리스트를 수정하려 하면 이 에러가 발생된다. for-each 문은 내부적으로 iterator를 실행하므로 remove()나 add()를 할 경우 에러가 발생되는 것이다.\n\n그래서 반복을 하면서 삭제를 하려면 Itertor 인터페이스를 사용하거나 Collection 인터페이스의 removeif 메서드를 사용한다.\n\n```java\n  public static void main(String[] args) {\n\t\tLinkedList<Integer> list = new LinkedList<>(Arrays.asList(5,4,2,3,5,4));\n\t\tsolution(list);\n\t}\n\n\tpublic static void solution(LinkedList<Integer> list) {\n\t\t// 1번 iterator 사용\n\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\tIterator<Integer> it = list.iterator();\n\n\t\twhile(it.hasNext()) {\n\t\t\tint next = it.next();\n\t\t\tif (set.contains(next)) it.remove();\n\t\t\telse set.add(next);\n\t\t}\n\n\t\t// 2번 removeif 사용\n\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\tlist.removeIf(num -> {\n\t\t\tif (set.contains(num)) return true;\n\t\t\telse {\n\t\t\t\tset.add(num);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}\n```\n\n# 2.2 뒤에서 K번째 원소 구하기: 단방향 연결리스트가 주어졌을 때 뒤에서 K번째 원소를 찾는 알고리즘을 구현하라.\n\n## 내 풀이\n\n리스트의 크기를 구하기 위해 한번 순회한 다음, 리스트 크기에 k만큼 뺀 index까지 반복을 돌려 원소를 찾았다.  \n시간 복잡도는 O(N)\n\n```javascript\nfunction solution_2(k) {\n  const list = makeList();\n\n  let cur = list.head;\n  let len = 0;\n  while (cur != null) {\n    len++;\n    cur = cur.next;\n  }\n\n  cur = list.head;\n  for (let i = 0; i < len - k; i++) {\n    cur = cur.next;\n  }\n\n  if (len - k < 0) return null;\n  else return cur.data;\n  //console.log(`뒤에서 ${k}번째 원소 값 : ${cur.data}`);\n}\n```\n\n## 반복문을 한번만 돌릴 수 있다면?\n\nRunner 기법을 사용했다. 연결리스트 문제에서 많이 활용되는 기법으로 순회할 때 두 개의 포인터를 동시에 사용하는 방법이다. 이 때 한 포인트가 다른 포인터보다 앞서도록 하며 앞선 포인터가 따라오는 포인터보다 **항상 지정된 개수만큼** 앞서거나, 따라오는 포인터를 **여러 노드를 한번에 뛰어넘도록** 설정할 수 있다.\n\n시간복잡도는 O(N) 이다.\n\n```javascript\nfunction solution_2_1(k) {\n  const list = makeList();\n\n  let cur = list.head;\n  let runner = cur;\n  let len = 0;\n  while (cur != null) {\n    if (len++ >= k) runner = runner.next;\n    cur = cur.next;\n  }\n  if (len - k < 0) return null;\n  else return runner.data;\n  // console.log(`뒤에서 ${k}번째 원소 값 : ${runner.data}`);\n}\n```\n\n# 2.3 중간 노드 삭제: 단방향 연결리스트가 주어졌을 때 중간(정확히 가운데 노드일 필요는 없고 처음과 끝 노드만 아니면 된다)에 있는 노드 하나를 삭제하는 알고리즘을 구현해라. 단, 삭제할 노드에만 접근할 수 있다.\n\nRunner 기법으로 중간 노드를 찾고 찾은 노드의 data와 next 값을 바로 다음 노드의 값으로 바꾼 다음 다음 노드의 next를 찾은 노드의 next로 지정한다.\n\n```javascript\nfunction solution_3() {\n  const list = makeList();\n  let cur = list.head;\n  let runner = list.head;\n  let len = 0;\n  while (cur != null) {\n    cur = cur.next;\n    if (++len % 2 == 0) runner = runner.next;\n  }\n\n  if (runner.next == null) {\n    runner.data = null;\n  } else {\n    runner.data = runner.next.data;\n    runner.next = runner.next.next;\n  }\n\n  list.display();\n}\n```\n\n```javascript\nfunction solution_3() {\n  const list = makeList();\n\n  let cur = list.head;\n  let prerunner = null;\n  let runner = list.head;\n  let len = 0;\n  while (cur != null && cur.next != null) {\n    cur = cur.next.next;\n    prerunner = runner;\n    runner = runner.next;\n  }\n  if (cur != null) {\n    prerunner = runner;\n    runner = runner.next;\n  }\n  // 노드 갯수가 2 이하일 때, 처음/끝 노드가 삭제되는 것을 막기 위해\n  if (prerunner == null || runner.next == null) return;\n\n  prerunner.next = runner.next;\n  list.display();\n}\n```\n\n# 2.4 분할: 값 x가 주어졌을 때 x보다 작은 노드들을 x보다 크거나 같은 노드들보다 앞에 오도록 하는 코드를 작성하라. 만약 x가 리스트에 있다면 x는 그보다 작은 원소들보다 뒤에 나오기만 하면 된다. 즉, 원소 x는 '오른쪽 그룹' 어딘가에만 존재하면 된다. 왼쪽과 오른쪽 그룹 사이에 있을 필요는 없다.\n\n- 입력: 3->5->8->5->10->2->1 (분할값 x = 5)\n- 출력: 3->1->2->10->5->5->8\n\n순회를 하면서 data 값이 x보다 작은 경우에는 무조건 맨 앞으로 이동시키는 식으로 해결했다.\n\n```javascript\nfunction solution_4(x) {\n  const list = makeList();\n  let cur, pre;\n  if (list.head.data < x) {\n    cur = list.head.next;\n    pre = list.head;\n  } else {\n    cur = list.head;\n    pre = null;\n  }\n\n  while (cur != null) {\n    if (cur.data < x) {\n      pre.next = cur.next;\n      cur.next = list.head;\n      list.head = cur;\n      cur = pre.next;\n    } else {\n      pre = cur;\n      cur = cur.next;\n    }\n  }\n\n  list.display();\n}\n```\n\n## 그렇다면 원소의 순서를 유지하면서 x보다 작은 노드들을 x의 앞에 위치하게 하고 싶다면?\n\n두 개의 연결리스트를 만들어서 하나는 x보다 작은 노드들을 삽입하고 다른 하나는 x보다 크거나 같은 노드들을 넣는다. 모든 작업이 완료된 후 두 리스트를 합하면 된다.\n\n# 2.5 리스트의 합: 연결리스트로 숫자를 표현할 때 각 노드가 자릿수 하나를 가리키는 방식으로 표현할 수 있다. 각 숫자는 역순으로 배열되어 있는데, 첫 번째 자릿수가 리스트의 맨 앞에 위치하도록 배열된다는 뜻이다. 이와 같은 방식으로 표현된 숫자 두 개가 있을 때, 이 두 수를 더하여 그 합을 연결리스트로 반환하는 함수를 작성하라\n\n- 입력: (7->1->6) + (5->9->2) 즉, 617 + 295\n- 출력: 2->1->9 즉, 912\n\n```javascript\nfunction solution_5(list_1, list_2) {\n  let cur_1 = list_1.head,\n    cur_2 = list_2.head;\n  let c = 0;\n  let newListHead = null;\n  let newList = null;\n  while (cur_1 != null || cur_2 != null) {\n    if (cur_1 == null || cur_2 == null) {\n      newList.next = cur_1 == null ? cur_2 : cur_1;\n      break;\n    }\n    let sum = cur_1.data + cur_2.data + c;\n    if (newList == null) {\n      newList = new Node(sum % 10);\n      newListHead = new LinkedList(newList);\n    } else {\n      newList.next = new Node(sum % 10);\n      newList = newList.next;\n    }\n    c = parseInt(sum / 10);\n    cur_1 = cur_1.next;\n    cur_2 = cur_2.next;\n  }\n\n  newListHead.display();\n}\n```\n\n## 각 자릿수가 정상적으로 배열된다고 가정하고 같은 문제를 풀면?\n\n- 입력: (6->1->7) + (2->9->5) 즉, 617+295\n- 출력: 9->1->2 즉, 912\n\n재귀로 순회해서 끝에서 부터 더해가면 된다. 단, 리스트의 길이가 다를 경우가 있으므로 이 부분을 고려해야 한다.\n재귀 안에서 해결해볼까 했는 데, 복잡해져서 아예 길이를 같게 만드는 방법으로 해보았다.\n\n```javascript\nfunction solution_5_1(list_1, list_2) {\n  let list_1_len = getSize(list_1.head),\n    list_2_len = getSize(list_2.head);\n\n  while (list_1_len > list_2_len) {\n    list_2.head = new Node(0, list_2.head);\n    list_2_len++;\n  }\n  while (list_1_len < list_2_len) {\n    list_1.head = new Node(0, list_1.head);\n    list_1_len++;\n  }\n\n  let newList = null;\n  recursion(list_1.head, list_2.head);\n\n  newList.display();\n  function recursion(cur_1, cur_2) {\n    if (cur_1 == null && cur_2 == null) return 0;\n    let sum = cur_1.data + cur_2.data + recursion(cur_1.next, cur_2.next);\n    if (newList == null) {\n      newList = new LinkedList(new Node(sum % 10));\n    } else {\n      newList.head = new Node(sum % 10, newList.head);\n    }\n    return parseInt(sum / 10);\n  }\n\n  function getSize(list) {\n    let cur = list;\n    let len = 0;\n    while (cur != null) {\n      len++;\n      cur = cur.next;\n    }\n    return len;\n  }\n}\n```\n\n# 회문: 주어진 연결리스트가 회문인지 검사하는 함수를 작성하라\n\n회문이란? 순서를 거꾸로 읽어도 제대로 읽은 것과 같은 단어와 문장을 말한다.  \n예시) level, sos\n\n```javascript\nfunction solution_6(list) {\n  let cur = list.head;\n  return recursion(list.head);\n\n  function recursion(list) {\n    if (list == null) return true;\n    let chk = recursion(list.next) && cur.data === list.data;\n    cur = cur.next;\n    return chk;\n  }\n}\n```\n\n## 책 해법 1. 뒤집어서 비교하기\n\n연결리스트를 순회하면서 새 리스트의 맨 앞에 삽입하면서 역순 리스트를 만든 후 비교한다.\n\n## 책 해법 2. runner와 스택 이용\n\n```javascript\nfunction solution_6_1(list) {\n  let cur = list.head;\n  let runner = cur;\n  let len = 0;\n  let array = Array();\n  while (cur != null && cur.next != null) {\n    len++;\n    array.push(runner.data);\n    runner = runner.next;\n    cur = cur.next.next;\n  }\n\n  if (len % 2 === 0) runner = runner.next;\n\n  while (runner != null) {\n    if (array.pop() !== runner.data) return false;\n    runner = runner.next;\n  }\n  return true;\n}\n```\n\n# 교집합: 단방향 연결리스트 두 개가 주어졌을 때 이 두 리스트의 교집합 노드를 찾은 뒤 반환하는 코드를 작성하라. 여기서 교집합이란 노드의 값이 아니라 노드의 주소가 완전히 같은 경우를 말한다. 즉, 첫 번째 리스트에 있는 k번째 노드와 두 번째 리스트에 있는 j번째 노드가 주소까지 완전히 같다면 이 노드는 교집합의 원소가 된다.\n\n두 연결리스트에서 교집합이 있다는 것은.. 그 교집합 노드 뒤부터는 같은 노드라는 것, 즉 마지막 노드가 같다.\n\n```javascript\nfunction solution_7(list_1, list_2) {\n  let set = new Set();\n  let newList = null;\n  let cur = list_1.head;\n  while (cur != null) {\n    set.add(cur);\n    cur = cur.next;\n  }\n\n  cur = list_2.head;\n  while (cur != null) {\n    if (set.has(cur)) {\n      newList = cur;\n      break;\n    }\n    cur = cur.next;\n  }\n  if (newList == null) return null;\n  return new LinkedList(newList);\n}\n```\n\n## 책 풀이\n\n1. 두 연결리스트를 순회해서 마지막 노드와 사이즈를 구하고 각 마지막 노드가 같으면 교집합이 존재하며 다르면 교집합은 없다.\n2. 길이가 더 긴 연결리스트의 포인터를 이동시켜서 두 연결리스트 순회 길이가 같도록 포인터를 맞춘다.\n3. 동시에 두 연결리스트의 포인트를 이동시키면서 같은 노드가 발견되는 순간을 찾는다.\n\n# 루프발견: 순환 연결리스트가 주어졌을 때, 순환되는 부분의 첫째 노드를 반환하는 알고리즘을 작성하라. 순환 연결리스트란 노드의 next 포인터가 앞선 노드들 가운데 어느 하나를 가리키도록 설정되어 있는, 엄밀히 말해서 변질된 방식의 연결리스트를 의미한다.\n\n- 입력: A->B->C->D->E->C (앞에 나온 C와 같음)\n- 출력: C\n\n```javascript\nfunction solution_8(list) {\n  let set = new Set();\n  let cur = list.head;\n\n  while (cur != null) {\n    if (set.has(cur)) return cur.data;\n    set.add(cur);\n    cur = cur.next;\n  }\n  return null;\n}\n```\n\n# 끝!\n"}},{"name":"2020-01-03-heap.md","oid":"bc66abbed338f762f562dfdd8ad9e2e2db1953a7","content":{"__typename":"GitHub_Blob","text":"# 알고리즘 개념 잡자 - 이진힙\n\n- Title : 알고리즘 개념 잡자 - 이진힙\n- Date : 2020-01-03\n- Category: Algorithm\n\n> 참고 서적<br/> > [코딩 인터뷰 완전분석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545) 트리와 그래프<br/> > [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539) 제 7장 트리, 제 8장 우선순위 큐\n\n# 1. 이진 힙(최소힙과 최대힙)\n\n**우선 순위 큐(priority queue)**에서 각 노드들은 우선 순위를 가지고 있고 우선 순위가 높은 노드가 먼저 나가게 된다. 이는 배열, 연결 리스트 등 여러 가지 방법으로 구현이 가능한데, 가장 효율적인 구조는 **히프(heap)**다.\n\n## 우선 순위 큐 구현 방법\n\n**배열을 이용한 방법**\n\n- 정렬이 안 된 배열\n  - 삽입 : 맨 끝에 삽입 O(1)\n  - 삭제 : 가장 우선 순위 높은 요소 찾기 O(n) + 삭제 후 뒤에 요소들 앞으로 이동 부담\n- 정렬이 된 배열(우선 순위 낮은 순으로)\n  - 삽입 : 탐색을 통해 삽입 위치를 결정해야 하며, 위치를 찾은 후에는 요소를 이동시켜서 빈 공간을 만들어야 한다. O(n)\n  - 삭제 : 맨 끝 요소 삭제 O(1)\n\n<br/>\n\n**연결리스트를 이용한 방법**\n\n- 정렬이 안 된 리스트\n  - 삽입 : 첫 번째 노드로 삽입 O(1)\n  - 삭제 : 포인터 따라서 모든 노드를 뒤져보아야 한다. O(n)\n- 정렬이 된 리스트(우선 순위 높은 순으로) - 삽입 : 맨 끝에 삽입해야하므로 O(n) - 삭제 : 맨 앞 노드 삭제 O(1)\n  <br/>\n\n**히프를 이용한 방법**\n\n- 히프는 완전 이진 트리의 일종으로 우선 순위 큐를 위하여 만들어진 자료 구조이다.\n- 반 정렬 상태를 유지한다.\n- 삽입, 삭제 시간복잡도는 **O(log<sub>2</sub>n)**로 상당히 유리\n\n## 히프란?\n\n- 여러 개의 값들 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만들어진 자료구조다.\n- **부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은)** 이진 트리다.\n- 반 정렬 상태로, 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도다.\n- 히프 트리는 중복된 값을 허용한다.\n- 히프는 <span class=\"clr-note\">완전 이진 트리</span>다.\n- 최대 힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리\n- 최소 힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리\n\n## 히프 구현 방법(최대 힙)\n\n히프는 완전 이진 트리이기 때문에 표준적인 자료 구조는 배열이다. 완전 이진 트리 구현 방법은 위 트리의 표현 방법에서 이미 언급했다.\n\n**최대 힙 표현 방법**\n<br/>\n\n![히프](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-03-img/3.png)\n\n<br/>\n\n- 삽입 연산\n\n  - 1단계 - 히프의 끝(마지막 노드 다음)에 새로운 노드를 삽입한다. <span class=\"clr-grey\">위 그림에서 키 값이 3인 말단 노드의 형제로 삽입한다.</span>\n  - 2단계 - 삽입된 노드와 그 부모 노드의 키 값을 비교한다. 삽입된 노드의 키 값이 부모 노드의 키 값보다 크면 두 노드의 위치를 바꾼다.\n  - 3단계 - 삽입된 노드의 키 값이 자신의 부모 노드 키 값보다 작아질 때까지 단계 2를 반복한다.\n\n- 삭제 연산\n  - 1단계 - 루트 노드가 삭제 된다. 빈자리에는 히프의 마지막 노드를 가져온다.\n  - 2단계 - 새로운 루트 노드를 자식 노드들과 비교해보면서 자식 노드가 더 크면 두 노드의 위치를 바꾼다. 자식 노드 두 개 모두 값이 더 크다면 더 큰 값을 가진 노드와 교환한다.\n  - 3단계 - 노드의 값이 자식보다 클 때까지 2단계를 반복한다.\n\n**자바스크립트 구현 코드**\n\n<br/>\n\n```javascript\nclass MaxHeap {\n  constructor(elements) {\n    this.heap = [, ...elements];\n  }\n\n  insert(key) {\n    this.heap.push(key);\n    let current = this.heap.length - 1;\n    let parent = parseInt(current / 2);\n    while (parent >= 1) {\n      if (key > this.heap[parent])\n        [this.heap[current], this.heap[parent]] = [\n          this.heap[parent],\n          this.heap[current]\n        ];\n      else break;\n      current = parent;\n      parent = parseInt(current / 2);\n    }\n  }\n\n  delete() {\n    if (this.heap.length === 1) {\n      return \"heap is empty\";\n    }\n    [this.heap[1], this.heap[this.heap.length - 1]] = [\n      this.heap[this.heap.length - 1],\n      this.heap[1]\n    ];\n    let maxValue = this.heap.pop();\n    let current = 1;\n    let leftChild = current * 2;\n    while (leftChild < this.heap.length) {\n      let largest = leftChild;\n      if (leftChild + 1 < this.heap.length)\n        largest =\n          this.heap[leftChild] < this.heap[leftChild + 1]\n            ? leftChild + 1\n            : leftChild;\n      if (this.heap[largest] > this.heap[current])\n        [this.heap[largest], this.heap[current]] = [\n          this.heap[current],\n          this.heap[largest]\n        ];\n      else break;\n      current = largest;\n      leftChild = current * 2;\n    }\n\n    return maxValue;\n  }\n}\n\nconst maxHeap = new MaxHeap([9, 7, 6, 5, 4, 3, 2, 2, 1, 3]);\nconsole.log(maxHeap.heap);\nmaxHeap.insert(8);\nconsole.log(maxHeap.heap);\nlet maxValue = maxHeap.delete();\nconsole.log(maxValue);\nconsole.log(maxHeap.heap);\n```\n\n## 히프의 시간 복잡도\n\n- 삽입 연산\n  - 최악의 경우는 루트 노드까지 올라간 경우이므로 트리의 높이에 해당하는 비교 연산과 이동 연산이 필요하다. 히프는 완전 이진 탐색이므로 히프의 높이는 log<sub>2</sub>n이 되고 시간 복잡도도 O(log<sub>2</sub>n)\n- 삭제 연산\n  - 삽입 연산과 같다.\n\n## 히프의 응용\n\n- 히프 정렬\n  - 최대 히프를 이용하여 정렬할 수 있다.\n  - 요소가 n개일 때, 시간 복잡도는 **O(nlog<sub>2</sub>n)**이다.\n  - 전체 자료 정렬이 아닌 가장 큰 값 몇 개만 정렬하고 싶을 때 사용하면 좋다.\n\n```javascript\nconst heapSort = (elements, num) => {\n  const sortedElements = [];\n  const maxHeap = new MaxHeap([]);\n  elements.forEach(element => {\n    maxHeap.insert(element);\n  });\n  for (let i = 0; i < num; i++) {\n    sortedElements.push(maxHeap.delete());\n  }\n  return sortedElements;\n};\n\nconsole.log(heapSort([2, 4, 1, 9, 5, 7, 6, 5, 2, 8], 5));\n```\n\n- 허프만 코드 (Huffman Coding) <span class=\"clr-grey\">나중에 추가할 예정..</span>\n"}},{"name":"2020-01-03-prefix-tree.md","oid":"146c143b5de337f212dc8e01ca9473a2a201a1a5","content":{"__typename":"GitHub_Blob","text":"# 알고리즘 개념 잡자 - 트라이\n\n- Title : 알고리즘 개념 잡자 - 트라이\n- Date : 2020-01-03\n- Category: Algorithm\n\n> 참고 서적<br/> > [코딩 인터뷰 완전분석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545) 트리와 그래프<br/>\n> [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539) 제 7장 트리, 제 8장 우선순위 큐\n\n# 3. 트라이(접두사 트리, prefix tree)\n\n> 참조 링크 [wikipedia](https://en.wikipedia.org/wiki/Trie)\n\n![트라이](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-03-img/4.png)\n\n- n-차 트리의 변종으로 각 노드에 문자를 저장하는 자료구조이다.\n- 문자열 탐색에 효율적인 자료구조이다.\n- 트리를 아래쪽으로 순회하면 단어 하나가 나온다.\n- TerminatingTrieNode로 널 노드를 표현한 경우, 트라이에서 각 노드는 1개 ~ 문자열 길이 + 1개 까지 자식을 가질 수 있다.\n- 널 노드 대신 불린 플래그로 표현한 경우, 각 노드는 0개 ~ 문자열 길이개까지 자식을 가질 수 있다.\n\n> **널 노드(\\* 노드)**\n>\n> - 단어의 끝을 나타낸다.\n> - 예) MANY 이후에 널 노드가 나오면 MANY라는 단어가 완성되었다는 의미다.\n>\n> **널 노드 구현 방법**\n>\n> - TrieNode를 상속한 TerminatingTrieNode로 표현하기\n> - 널 노드의 부모 노드 안에 불린 플래그를 새로 정의함으로써 표현하기\n\n**어디에 사용할까?**\n\n- 자동 완성\n- 문자열이 어떤 문자열의 접두사인지 확인하고 싶을 때 <span class=\"clr-grey\">cf) 단순 삽입/조회만 한다면 해시테이블 사용을 권장</span>\n- 예: 'a', 'axe'로 시작하는 단어를 찾고 싶을 때\n\n> 예시, M, MA, MAN, MANY를 차례대로 살펴보는 경우 트리의 현재 노드를 참조값으로 넘김으로써 루트 노드에서 시작할 필요가 없고 단순히 Y가 MAN의 자식인지만 확인해보면 된다.\n\n## 트라이 VS 해시테이블\n\n- 최악의 경우, 시간복잡도는?\n  - 트라이 : O(K) (K: 가장 긴 문자열)\n  - 해시테이블 : 충돌이 자주 발생되었다면 O(N)의 시간복잡도를 가진다. (N: 키의 개수) 또한 입력 문자열을 기반으로 해시 계산을 하므로 O(K)의 시간이 걸린다.\n  - cf) 탐색할 문자열이 트라이에 없는 경우에는 문자열 길이 K보다 시간이 덜 걸린다.\n\n> **트라이와 해시의 시간복잡도가 비슷하다..?** <br/>\n> 길이가 K인 무자열이 주어졌을 때 트라이는 O(K) 시간에 해당 문자열이 유효한 접두사인지 확인할 수 있다. 이 시간은 해시테이블 사용했을 때와 정확히 같은 수행 시간이다. 우리가 종종 해시테이블을 검색하는 시간이 O(1)이라고 하지만 완전히 맞는 말은 아니다. 해시테이블도 입력 문자열은 전부 읽어야 하므로 길이가 K인 단어를 검색하는 데 걸리는 시간은 O(K)가 된다.\n\n- 알파벳 정렬?\n\n  - 일반적으로 자료구조에 문자열을 저장한다면 각 문자열의 순서가 중요하기도 하다. 트라이는 노드를 저장할 때 왼쪽에서 오른쪽으로 사전 순으로 저장한다면 쉽게 정렬이 가능하다.\n\n- 기타\n  - 트라이는 삭제가 직관적이며 해시 함수가 필요 없으나 해시 테이블 보다는 많은 공간을 차지한다.\n\n## 트라이 구현\n\n```javascript\nclass Trie {\n  constructor(key) {\n    this.is_terminal = false;\n    this.key = key;\n    this.trie_child = Array(26).fill(null);\n  }\n\n  char_to_index(key) {\n    return key.charCodeAt(0) - \"a\".charCodeAt(0);\n  }\n\n  // 새로운 문자열을 트라이에 추가\n  insert(key) {\n    let current_trie = this;\n    for (let i = 0; i < key.length; i++) {\n      let index = this.char_to_index(key[i]);\n      if (current_trie.trie_child[index] === null)\n        current_trie.trie_child[index] = new Trie(key.slice(0, i + 1));\n      current_trie = current_trie.trie_child[index];\n    }\n    current_trie.is_terminal = true;\n  }\n\n  // 트라이 출력\n  print(trie, dep) {\n    console.log(dep, trie.key);\n    if (trie.is_terminal) return;\n    for (let i = 0; i < 26; i++) {\n      if (trie.trie_child[i] !== null) this.print(trie.trie_child[i], dep + 1);\n    }\n  }\n\n  // key를 접두어로 가지고 있는지, 가지고 있으면 해당 접두어가 끝나는 부분의 위치를 반환\n  find(key) {\n    let current_trie = this;\n    for (let i = 0; i < key.length; i++) {\n      let index = this.char_to_index(key[i]);\n      if (current_trie.trie_child[index] === null) return false;\n      else current_trie = current_trie.trie_child[index];\n    }\n    return current_trie;\n  }\n\n  // key를 포함하는 지, 포함하면 true\n  exist(key) {\n    let current_trie = this;\n    for (let i = 0; i < key.length; i++) {\n      let index = this.char_to_index(key[i]);\n      if (current_trie.trie_child[index] === null) return false;\n      else current_trie = current_trie.trie_child[index];\n    }\n    return current_trie.is_terminal;\n  }\n}\n\nvar trie = new Trie(null);\nvar arr = [\"to\", \"tea\", \"ted\", \"ten\", \"a\", \"inn\"];\narr.forEach(str => trie.insert(str));\n// trie.print(trie, 0)\nconsole.log(trie.exist(\"tea\")); // true\nconsole.log(trie.exist(\"aaa\")); // false\nconsole.log(trie.exist(\"a\")); // true\nconsole.log(trie.find(\"te\")); // Trie {is_terminal: false, key: \"te\", trie_child: Array(26)}\n```\n"}},{"name":"2020-01-03-tree.md","oid":"050c203f0de4fcd23578d6b6bc29d88531fc4775","content":{"__typename":"GitHub_Blob","text":"# 알고리즘 개념 잡자 - 트리\n\n- Title : 알고리즘 개념 잡자 - 트리\n- Date : 2020-01-03\n- Category: Algorithm\n\n> 참고 서적<br/> > [코딩 인터뷰 완전분석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545) 트리와 그래프<br/> > [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539) 제 7장 트리, 제 8장 우선순위 큐\n\n# 1. 트리(Tree)\n\n- 트리는 노드(node)와 간선(edge)로 이루어진 자료구조이다.\n- 트리는 하나의 루트 노드를 가진다.\n- 루트 노드는 0개 이상의 자식 노드를 가진다.\n- 그 자식 노드 또한 0개 이상의 자식 노드를 가진다.\n- 그 자식의 자식 노드 또한..\n- 노드들은 특정 순서대로 나열될 수도 있고 없을 수도 있다.\n- 각 노드는 어떤 자료형으로도 표현이 가능하다.\n- 각 노드는 부모 노드로의 연결이 있을 수도 있고 없을 수도 있다.\n\n## 용어 정리\n\n- 트리에는 **사이클(cycle)**이 존재할 수 없다.\n- 자식이 없는 노드는 **말단 노드(leaf node)**라고 부른다.\n- **차수(degree)**는 자식 노드의 개수로 자식 노드가 3개면 그 노드의 차수는 3이다. 트리의 차수는 트리가 가지고 있는 노드의 차수 중에서 가장 큰 차수이다.\n- **레벨(level)**은 트리의 각 층에 번호를 매긴 것으로 루트의 레벨은 1이 되고 한 층씩 내려갈수록 1씩 증가한다\n- 트리의 **높이(height)**는 트리가 가진 최대 레벨이다.\n\n예시) 노드 클래스\n\n```java\nclass Node {\n  public String name;\n  public Node[] children;\n}\n```\n\n예시) 트리 클래스\n\n```java\nclass Tree {\n  public Node root;\n}\n```\n\n## 이진 트리(Binary tree)와 이진 탐색 트리(Binary search tree)\n\n- 이진트리\n  - 이진 트리의 노드는 최대 2개까지의 자식 노드가 존재할 수 있고 모든 노드의 차수는 2 이하가 된다.\n  - n개의 노드를 가진 이진 트리는 n-1개의 간선을 가진다. 루트 노드를 제외한 노드들은 부모와 정확히 하나의 간선으로 이어져있기 때문이다.\n  - 높이가 h인 이진 트리는 최소 h개 노드를 가지고 최대 2<sup>h</sup>-1 노드를 가진다.\n  - 레벨 i에서 노드의 개수는 2<sup>i-1</sup> 다.\n  - n개의 노드를 가진 이진 트리의 최대 높이는 n이며 최소 높이는 log<sub>2</sub>(n+1) 이다.\n- 이진 탐색 트리\n  - 모든 노드 n은 <span class=\"clr-note\">모든 왼쪽 자식들 <= n < 모든 오른쪽 자식들</span> 속성을 만족한다.\n  - 이진 탐색 트리의 탐색, 삽입, 삭제 연산의 시간 복잡도는 트리의 높이를 h라고 했을 때 O(h)가 된다.\n  - n개의 노드를 가진 균형 잡힌 이진 트리의 높이는 log<sub>2</sub>n 이므로 평균적인 시간 복잡도는 O(log<sub>2</sub>n)\n  - 한쪽으로 치우친 이진 트리의 경우 트리의 높이가 노드의 개수 n과 같게 되어 시간복잡도는 선형 탐색과 같이 O(n)이 된다.\n\n## 이진 트리 표현 방법\n\n**1. 배열 이용** <br/><br/>\n![배열 이용](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-03-img/1.png)<br/>\n\n- 주로 포화 이진 트리나 완전 이진 트리의 경우에 많이 쓰인다.\n- 높이가 k인 완전 이진 트리로 가정하여 배열의 크기를 최대 노드 개수인 2<sup>k</sup>-1 로 할당한 다음 완전 이진 트리의 번호대로 노드를 저장한다.\n- 편한 계산을 위해 인덱스는 1부터 시작한다.\n- 오른쪽 그림처럼 일반 이진 트리의 경우 공간 낭비가 크다.\n\n> 부모 & 자식 노드 찾는 법 <br/><br/>\n> 현재 노드 i를 기준으로, <br/>\n> 부모 노드의 인덱스 = **i/2** <br/>\n> 왼쪽 자식 노드의 인덱스 = **i\\*2** <br/>\n> 오른쪽 자식 노드의 인덱스 = **i\\*2 + 1** <br/>\n\n<br/>\n\n**2. 연결리스트 이용** <br/><br/>\n\n- 노드가 자바에서는 클래스, C에서는 구조체로 표현되고 각 노드가 포인터를 가지고 있어서 이 포인터를 이용하여 노드와 노드를 연결하는 방법이다.\n- 하나의 노드가 왼쪽 자식 노드, 오른쪽 자식 노드를 필드로 가진다.\n\n## 트리가 '균형' 트리인지 아닌지 확인하는 방법\n\n<span class=\"clr-note\">O(log N)</span> 시간에 insert와 find를 할 수 있는 정도로 균형이 잘 잡혀있는 지 확인하면 된다. 꼭 완전 이진 트리처럼 완벽하게 균형 잡혀 있을 필요는 없다.\n\n> 예) 레드-블랙 트리와 AVL 트리\n\n## 이진 트리의 종류\n\n- 완전 이진 트리(complete binary tree) : 트리의 모든 높이에서 노드가 꽉 차 있다. 마지막 단계(level)은 꽉 차 있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져야 한다.\n- 전 이진 트리(full binary tree) : 자식노드가 0개 또는 2개인 경우다.\n- 포화 이진 트리(perfect binary tree) : 전 이진 트리면서 완전 이진 트리인 경우다. 모든 말단 노드는 같은 레벨에 있으며 마지막 레벨에서 노드의 개수가 최대가 되어야 한다. 노드의 개수는 정확히 2<sup>k-1</sup>(k는 트리의 레벨)\n\n## 이진 트리 순회 방법\n\n**중위 순회(in-order traversal)**는 <span class=\"clr-note\">왼쪽 가지(branch) - 현재 노드 - 오른쪽 가지</span> 순서로 노드를 방문하고 출력하는 방법이다.\n\n> 이진 탐색 트리를 이 방법으로 순회한다면? <span class=\"is-has-danger\">오름차순</span>으로 방문!\n\n```java\nvoid inOrderTraversal(TreeNode node) {\n  if (node != null) {\n    inOrderTraversal(node.left);\n    visit(node);\n    inOrderTraversal(node.right);\n  }\n}\n```\n\n<br/>\n\n**전위 순회(pre-order traversal)**는 <span class=\"clr-note\">현재 노드 - 왼쪽 가지(branch) - 오른쪽 가지</span> 순서로 노드를 방문하고 출력하는 방법이다.\n\n> 가장 먼저 방문할 노드는? 루트 노드!\n\n```java\nvoid preOrderTraversal(TreeNode node) {\n  if (node != null) {\n    visit(node);\n    preOrderTraversal(node.left);\n    preOrderTraversal(node.right);\n  }\n}\n```\n\n<br/>\n\n**후위 순회(post-order traversal)**는 <span class=\"clr-note\">왼쪽 가지(branch) - 오른쪽 가지 - 현재 노드</span> 순서로 노드를 방문하고 출력하는 방법이다. 예) 현재 디렉토리 용량 계산\n\n> 맨 마지막에 방문할 노드는? 루트 노드!\n\n```java\nvoid postOrderTraversal(TreeNode node) {\n  if (node != null) {\n    postOrderTraversal(node.left);\n    postOrderTraversal(node.right);\n    visit(node);\n  }\n}\n```\n\n<br/>\n\n**레벨 순회(level traversal)**는 각 노드를 레벨 순으로 순회하는 방법이다. 레벨 1에서 시작하며 동일한 레벨의 경우에는 왼쪽에서 오른쪽으로 순으로 방문한다.\n\n> 중위, 전위, 후위는 스택을 사용하며 레벨 순회는 **큐**를 이용한다.\n\n## 이진 트리 순회의 응용\n\n**수식 트리(expression tree)**를 처리하는 데 사용\n<br/>\n\n![수식 트리 예제](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-03-img/2.png)<br/>\n\n- 루트 노드는 연산자이고 서브 트리가 피연산자이므로 서브 트리를 계산하면 전체 수식을 계산할 수 있다.\n- 위 표에 나와있듯이 가장 적합한 순회 방식은 **후위 순회**다.\n"}},{"name":"2020-01-09-coding-interview-dp.md","oid":"3c55417e429710884ade0d6c7bca7c149081a2a3","content":{"__typename":"GitHub_Blob","text":"# 알고리즘 개념 잡자 - 재귀와 동적 프로그래밍\n\n- Title : 알고리즘 개념 잡자 - 재귀와 동적 프로그래밍\n- Date : 2020-01-09\n- Category: Algorithm\n\n> 참고 <br/>\n>\n> - [코딩 인터뷰 완전분석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545) 재귀와 동적 프로그래밍\n> - [Geeksforgeeks 바로가기](https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/)\n\n# 동적 프로그래밍\n\n- 주어진 문제를 부분 문제로 나눠 값을 계산하는 것\n- 중복되는 계산을 막기 위해 부분 문제의 결과 값을 저장함 - 메모이제이션(Memoization)과 타뷸레이션(Tabulation)\n\n## 메모이제이션(Memoization)과 타뷸레이션(Tabulation)\n\n- 메모이제이션 : 하향식 접근법 (Top Down) - 재귀적\n  - 테이블을 만들고 NIL(예, -1) 값을 넣음\n  - 서브 문제의 결과값을 구할 때, 먼저 테이블 검색\n  - 계산된 값이 있으면 얘를 리턴\n  - NIL이면 계산 실행하여 계산 결과를 테이블에 저장\n  - 요구가 있을 때 채워지므로 테이블에 데이터가 다 채워지지 않을 수도 있음\n- 타뷸레이션 : 상향식 접근법 (Bottom Up) - 순환적\n  - 테이블의 마지막 요소를 반환하는 구조\n  - 첫번째부터 전체가 채워지는\n\n## DP의 2가지 속성\n\n모든 DP 문제는 Overlapping subproblems 속성을 만족하고 대부분의 클래식 DP 문제는 Optimal Substructure 속성을 만족한다.\n\n**1. overlapping subproblems** <br/><br/>\n\n- 부분 문제들이 공통으로 겹치는 부분이 있는 지?<br/>\n\n  > <span class=\"clr-grey\">우리가 메모이제이션이나 타뷸레이션을 사용하는 이유는 부분 문제의 결과값을 저장해놔서 나중에 이를 활용하려고 사용하죠. 근데 겹치는 부분 문제가 없으면?? 이게 필요가 없음.</span>\n\n- 동적 프로그래밍과 분할 정복\n  - 문제를 나누는 방식에 차이가 있음 <br/><br/>\n  - 피보나치<br/>\n    ![피보나치](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-10-img/2.png)\n  - 이진탐색 <br/>\n    ![이진탐색](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-10-img/1.png)\n\n<br/>\n\n**2. Optimal Substructure** <br/>\n\n- 문제의 답을 부분 문제의 답에서 구할 수 있는 가?\n- 최단 경로 vs 최장 경로<br/>\n  - 경로안에 무수히 많은 경로가 있을 때, 중간 정점들이 각각 최단이 된다면 이를 모든 이은 경로 또한 최단이 된다. <br/><br/>\n    ![경로](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-10-img/3.gif)\n    - q -> t 최단 : q -> r + r -> t\n    - q -> t 최장 : q -> s -> t -> r + r -> q -> s -> t\n\n## 문제 푸는 방법\n\n**1. DP 문제인가?**\n\n- DP의 2가지 속성으로 판단하기\n\n**2. 상태 찾기**\n\n- 서브 문제마다 값이 달라지는 변수 찾기\n- 각 서브 문제를 구별하는 값\n- 파라미타들\n- 적을 수록 좋다.\n- DP(상태) = 결과값(예, 최고 이익, 경우의 수..)\n\n**3. 재귀 방법 알아내기 == 상태들의 관계 알아내기** <br/>\n\n- state(n) = state(n-1) + state(n-3) + state(n-5)\n\n**4. 메모이제이션과 타뷸레이션 쓰기**\n\n# 8.1 트리플 스텝\n\n어떤 아이가 n개의 계단을 오른다. 한 번에 1계단 오르기도 하고 2계단이나 3계단을 오르기도 한다. 계단을 오르는 방법이 몇 가지가 있는지 계산하는 메서드를 구현하라.\n\n- Step 1 : DP 문제인지 판별하기\n  - 느낌..\n- Step 2 : 부분 문제마다 값이 달라지는 변수 찾기\n  - N : 계단의 개수 => 매개변수\n  - DP[N] = N을 만족하는 경우의 수\n- Step 3 : 재귀 방법을 알아내기\n  - 조정할 수 있는 거, 오를 수 있는 계단 개수져\n  - upStair(n) = (n - 1) || (n - 2) || (n - 3)\n  - upStair(n) = (n - 1) + (n - 2) + (n - 3)\n- Step 4 : 메모이제이션, 타뷸레이션\n\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint solution(int n, vector<int>& memo) {\n  if (n < 0) return 0;\n  if (n == 0) return 1;\n  if (memo[n] > -1) return memo[n];\n  memo[n] = solution(n - 1, memo) + solution (n - 2, memo) + solution (n - 3, memo);\n  return memo[n];\n}\n\nint solution_BU(int n) {\n  vector<int> dp(n+1, -1);\n  dp[0] = 1;\n  dp[1] = 1;\n  dp[2] = 2;\n  for (int i=3; i<=n; i++) {\n    dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\n  }\n  return dp[n];\n}\n\nint main(){\n  int n = 10;\n  vector<int> memo(n+1, -1);\n  std::cout << solution(n, memo) << \",\";\n  std::cout << solution_BU(n) << std::endl;\n  return 0;\n}\n```\n\n# 8.11 코인\n\n쿼터(25센트), 다임(10센트), 니켈(5센트), 페니(1센트)의 네 가지 동전이 무한히 주어졌을 때, n센트를 표현하는 모든 방법의 수를 계산하는 코드를 작성하라\n\n- Step 1 : DP 문제인지 판별하기\n  - 10원 방법의 수는 5원 방법에 + 5를 더하는 것....\n  - 느낌..\n- Step 2 : 부분 문제마다 값이 달라지는 변수 찾기\n  - 부분 문제는 1원일 때 방법의 수... 2원일 때 방법의 수..3원일 때....N원일 때 방법의 수\n  - N : 구할 센트, => 매개변수, 상태값\n  - D[N] = 방법의 수\n- Step 3 : 재귀 방법을 알아내기\\*\\*\n  - 재귀의 방법을 조정할 수 있는 값은? 동전의 가치 (25, 10, 5, 1)\n  - D(n) = D(n - 25) + D(n - 10) + D(n - 5) + D(n - 1)\n- Step 4 : 메모이제이션, 타뷸레이션\n\n- 10센트 만들기 (D[0] = 1)\n  - 25센트로 : 0 0 0 0 0 0 0 0 0 0\n  - 10센트로 : 0 0 0 0 0 0 0 0 0 1\n  - 5센트로 : 0 0 0 0 1 0 0 0 0 2\n  - 1센트로 : 1 1 1 1 2 2 2 2 2 4\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint coin[4] = {25, 10, 5, 1};\nint solution(int n, int index, vector<vector<int> >& memo) {\n  if (index >= 3) return 1;\n  if (memo[n][index] > 0) return memo[n][index];\n  int answer = 0;\n  for (int i=0; i * coin[index] <= n; i++) {\n    answer += solution(n - i * coin[index], index + 1, memo);\n  }\n\n  memo[n][index] = answer;\n  return memo[n][index];\n}\n\nint solution_BU(int n) {\n  vector<int> dp(n+1, 0);\n  dp[0] = 1;\n  for (int i=0; i<4; i++) {\n    for (int j=1; j<=n; j++) {\n      if (j - coin[i] >= 0) dp[j] += dp[j-coin[i]];\n    }\n  }\n  return dp[n];\n}\n\nint main() {\n  int n = 10;\n  vector<vector<int> > memo(n + 1, vector<int>(4, 0));\n  int answer = solution(n, 0, memo);\n  std::cout << answer << std::endl;\n  int answer_2 = solution_BU(n);\n  std::cout << answer << std::endl;\n  return 0;\n}\n```\n\n# 8.7 중복 없는 순열\n\n문자열이 주어졌을 때 모든 경우의 순열을 계산하는 메서드를 작성하라. 단, 문자는 중복되어 나타날 수 없다.\n\n# 8.9 괄호\n\nn-쌍의 괄호로 만들 수 있는 모든 합당한(괄호가 적절히 열리고 닫힌) 조합을 출력하는 알고리즘을 구현하라\n\n```cpp\n#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\nvoid fnc(string result, int cur, int dep, int n, vector<string>& answer) {\n  if (cur < 0) return;\n  if (cur > 0 && n - dep < cur) return;\n  if (cur == 0 && dep == n) {\n    answer.push_back(result);\n    return;\n  }\n  fnc(result + \"(\", cur + 1, dep + 1, n, answer);\n  fnc(result + \")\", cur - 1, dep + 1, n, answer);\n}\n\nvector<string> solution(int n) {\n    vector<string> answer;\n    fnc(\"\", 0, 0, n*2, answer);\n    return answer;\n}\n\nvoid solution_2(int leftRem, int rightRem, int index, char *str, vector<string>& answer) {\n  if (leftRem < 0 || leftRem > rightRem) return;\n  if (leftRem == 0 && rightRem == 0) {\n    answer.push_back(str);\n    return;\n  }\n  str[index] = '(';\n  solution_2(leftRem - 1, rightRem, index+1, str, answer);\n\n  str[index] = ')';\n  solution_2(leftRem, rightRem - 1, index + 1, str, answer);\n}\n\nint main() {\n  int n;\n  cout << \"input:\";\n  cin >> n;\n  vector<string> answer = solution(n);\n  for (int i=0; i<answer.size(); i++) {\n    cout << answer[i] << \" \";\n  }\n  cout << endl;\n  vector<string> answer2;\n  char str[n*2];\n  solution_2(n, n, 0, str, answer2);\n  for (int i=0; i<answer2.size(); i++) {\n    cout << answer2[i] << \" \";\n  }\n\n  return 0;\n}\n\n```\n\n# 8.10 영역 칠하기\n\n화면(색이 칠해진 이차원 배열), 화면상의 한 지점, 새로운 색상이 주어졌을 때, 주어진 지점과 색이 같은 주변 영역을 새로운 색상으로 다시 칠하라\n\n- BFS\n\n```cpp\n#include <string>\n#include <vector>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint row[4] = {0, 0, -1, 1};\nint col[4] = {-1, 1, 0, 0};\n\nint solution(vector<vector<int> >& screen, pair<int, int>& point, int newColor) {\n\n  queue<pair<int, int> > q;\n  int next_row, next_col;\n  int pre_color = screen[point.first][point.second];\n  q.push(point);\n  while (!q.empty()) {\n    pair<int, int> pop = q.front();\n    screen[pop.first][pop.second] = newColor;\n    q.pop();\n    for (int i=0; i<4; i++) {\n      next_row = pop.first + row[i];\n      next_col = pop.second + col[i];\n      if (next_row < 0 || next_col < 0) continue;\n      if (next_row >= screen.size() || next_col >= screen[0].size()) continue;\n      if (screen[next_row][next_col] == pre_color) {\n        q.push(make_pair(next_row, next_col));\n      }\n    }\n  }\n  return 0;\n}\n\nint main() {\n  // vector<vector<int> > screen({\n  //   vector<int>({1, 1, 2, 3}),\n  //   vector<int>({2, 1, 2, 3}),\n  //   vector<int>({1, 1, 2, 2}),\n  //   vector<int>({2, 2, 2, 1})\n  // });\n  /*\n  1 2 2 3\n  2 1 2 3\n  1 1 2 2\n  2 2 2 1\n  */\n vector<vector<int> > screen(4, vector<int>(4));\n  screen[0][0] = 1;\n  screen[0][1] = 2;\n  screen[0][2] = 2;\n  screen[0][3] = 3;\n\n  screen[1][0] = 2;\n  screen[1][1] = 1;\n  screen[1][2] = 2;\n  screen[1][3] = 3;\n\n  screen[2][0] = 1;\n  screen[2][1] = 1;\n  screen[2][2] = 2;\n  screen[2][3] = 2;\n\n  screen[3][0] = 2;\n  screen[3][1] = 2;\n  screen[3][2] = 2;\n  screen[3][3] = 1;\n\n  pair<int, int> point = make_pair(1, 2);\n  for (int i=0; i<screen.size(); i++) {\n    for (int j=0; j<screen[0].size(); j++)\n      std::cout << screen[i][j] << \" \";\n    std::cout << std::endl;\n  }\n  solution(screen, point, 0);\n  std::cout << std::endl;\n  for (int i=0; i<screen.size(); i++) {\n    for (int j=0; j<screen[0].size(); j++)\n      std::cout << screen[i][j] << \" \";\n    std::cout << std::endl;\n  }\n  return 0;\n}\n```\n\n# 8.14 불린값 계산\n\n0(false), 1(true), &(AND), |(OR), ^(XOR)으로 구성된 불린 표현식과 원하는 계산 결과(불린값)이 주어졌을 때, 표현식에 괄호를 적절하게 추가하여 그 값이 원하는 결과값과 같게 만들 수 있는 모든 경우의 수 출력하기\n\n출력 예시\n\n- countEval(\"1^0|0|1\", false) -> 2개\n- countEval(\"0&0&0&1^1|0\", true) -> 10개\n\n- Step 1 : DP 문제인지 판별하기\n  - 뭔가.. 적절하게 조합해서 모든 경우 구하는 거라서.. dp같네..?\n- Step 2 : 부분 문제마다 값이 달라지는 변수 찾기\n  - 음.. 전체 수식을 쪼개니깐 수식이 부분문제마다 달라지넵, 매개변수로 쪼개진 수식을 보내야겠댜~\n- Step 3 : 재귀 방법을 알아내기\\*\\*\n  - 괄호를 추가한다라..\n  - 1^0|0|1 예시로 보면..\n  - 1 ^ (0|0|1) 처럼 괄호를 추가하고 싶다는 건데..\n  - 그럼 ^ 같은 표현식을 기준으로 왼쪽 오른쪽 나눠어..\n  - D[수식] = D[왼쪽 수식] \\* D[오른쪽 수식]\n  - 서로 연관있으니깐 \\*곱하기\n  - 표현식은 index 1, 3, 5, 7 ..에 위치\n- Step 4 : 메모이제이션, 타뷸레이션\n\n1 ^ 0|0|1  \n1^0 | 0|1  \n1^0|0 | 1\n\n```cpp\n#include <string>\n#include <vector>\n#include <iostream>\n#include <map>\n\nusing namespace std;\n\nint fnc(std::string exp, bool r, map<string, int>& memo) {\n  if (exp.length() == 1) return exp[0] == (r ? '1' : '0') ? 1 : 0;\n  if (memo.count(exp + (r ? \"-1\" : \"-0\")) == 1) return memo[exp + (r ? \"-1\" : \"-0\")];\n  int sum = 0;\n  for (int i=1; i<exp.length(); i+=2) {\n    char e = exp[i];\n    string left = exp.substr(0, i);\n    string right = exp.substr(i+1);\n    if (e == '^') {\n      if (r) {  // true\n        sum += fnc(left, r, memo) * fnc(right, r^1, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r, memo);\n      } else {\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r^1, memo);\n      }\n\n    } else if (e == '|') {\n      if (r) { // true\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n        sum += fnc(left, r, memo) * fnc(right, r^1, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r, memo);\n      } else { // false\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n      }\n    } else {\n      if (r) { // true\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n      } else { // false\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r, memo);\n        sum += fnc(left, r, memo) * fnc(right, r^1, memo);\n      }\n\n    }\n  }\n  memo.insert(pair<string, int>(exp + (r ? \"-1\" : \"-0\") , sum));\n  return sum;\n}\n\nint countEval(std::string exp, bool result) {\n  map<string, int> map;\n  return fnc(exp, result, map);\n}\n\nint main() {\n  std::cout << countEval(\"1^0|0|1\", false) << std::endl;\n  std::cout << countEval(\"0&0&0&1^1|0\", true) << std::endl;\n  return 0;\n}\n```\n"}},{"name":"2020-01-28-algorithm-cpp-tip.md","oid":"71b6232e760cb058f53c92719edc32233daa262c","content":{"__typename":"GitHub_Blob","text":"# c++로 알고리즘 풀 때 팁들\n\n- Title : c++로 알고리즘 풀 때 팁들\n- Date : 2020-01-28\n- Category: Algorithm\n\n# # 입출력\n\ncin, cout은 느려서 scanf, printf를 사용하는 걸 추천한다.\n\n```cpp\nint N, M, K;\nscanf(\"%d %d %d\", &N, &M, &K);\n```\n\n# # 2차원 배열\n\n1 2 3 4 5 <br/>\n2 3 4 5 6 <br/>\n... 방식의 입력을 받고 싶다면?\n\n```cpp\n#define MAX 10\nint A[MAX][MAX];\n\nint main() {\n\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n    }\n  }\n  return 0;\n}\n```\n\n## 2차원 deque 입력, 정렬\n\n```cpp\n#define MAX 10\ndeque<int> T[MAX][MAX];\n// ...\nint main() {\n  int x, y, age;\n\n  // 입력\n  for (int i=0; i<M; i++) {\n    scanf(\"%d %d %d\", &x, &y, &age);\n    T[--x][--y].push_back(age);\n  }\n\n  // 정렬 오름차순\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      if (T[i][j].size() > 1)\n        sort(T[i][j].begin(), T[i][j].end());\n\n    }\n  }\n\n  // 순회\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      deque<int> &tmp = T[i][j]; // 참조로 받기(수정하려면)\n      for(auto iter=tmp.begin(); iter != tmp.end();) {\n        int &t = *iter;\n        if () //삭제X\n          iter++;\n        else //삭제 O\n          iter = tmp.erase(iter); //다음 iter 받음\n\n      }\n    }\n  }\n  return 0;\n}\n```\n\n# 포인터와 참조\n\n```cpp\n// 새로운게임2 에서..\nstruct Horse {\n  int row, col, dir;\n};\n\n// 참조 변수 : 대상을 직접 할당\n// 선언과 동시에 초기화해야한다!\n// NULL 불가\nHorse &h = horse[0];\nh = horse[1]; // 에러!! (대상 변경 불가)\nprintf(\"%d\", h.row);\n\n// 포인터 변수 : 주소값 할당\nHorse *h = &horse[0];\nh = &horse[1];  // 대상 변경 가능!\nHorse *h = NULL; // NULL 가능\n\nif (h) printf(\"%d\", h->row);\n// 또는\nif (h) printf(\"%d\", (*h).row);\n```\n\n# 배열 초기화할 때, memset 함수 쓰자!\n\n- for문보다 더 빠른 속도가 나올 수 있다.\n- 특정 범위에 있는 **연속된 메모리**에 값을 지정하고 싶을 때 쓰자!\n- cstring 헤더\n\n```cpp\nvoid* memset(void *ptr, int value, size_t num);\n/*\nptr : 메모리 시작 포인터(주소) => 배열 이름\nvalue: 채울 값 => 값\nnum: 채우고자 하는 바이트 수(메모리 크기) => sizeof(배열이름)\n*/\n```\n\n```cpp\n#include <cstring>\nusing namespace std;\nint main() {\n  int C[21][21];\n  memset(C, 0, sizeof(C));\n  return 0;\n}\n```\n\n# 구조체 멤버 내용 복사하고 싶으면? memcpy를 쓰자\n\n```cpp\n#include <cstring>\nusing namespace std;\n\nstruct Horse {\n  int row, col, dir;\n};\n\nint main() {\n  Horse h1, h2;\n  h1.row = 1;\n  h1.col = 2;\n  h1.dir = 3\n\n  memcpy(&h2, &h1, sizeof(Horse)); // Horse 구조체 크기만큼 h1 내용을 h2에 복사\n  return 0;\n}\n```\n\n## 동적 할당된 경우는?\n\n```cpp\n#include <cstring>\nusing namespace std;\n\nstruct Horse {\n  int row, col, dir;\n};\n\nint main() {\n  Horse *h1 = malloc(sizeof(Horse));\n  Horse *h2= malloc(sizeof(Horse));\n  h1->row = 1;\n  h1->col = 2;\n  h1->dir = 3\n\n  memcpy(h2, h1, sizeof(Horse)); // Horse 구조체 크기만큼 h1 내용을 h2에 복사\n  return 0;\n}\n```\n\n## 또 다른 예\n\n```cpp\nHorse h1;\nHorse *h2= malloc(sizeof(Horse));\n\nmemcpy(h2, &h1, sizeof(Horse));    // 구조체 변수에서 동적 메모리로 복사\n```\n\n# 자료형\n\n정수 자료형 int는 4바이트 정보를 기록할 수 있는 자료형으로, signed int(부호가 있는 정수)를 기준으로 기록할 수 있는 양의 정수 범위는 0 ~ 2,147,483,647 (16진수로 7FFFFFFF)이다.\n\n## int 범위를 벗어나는 경우 자료형은 무엇을 쓸까?\n\n8바이트 크기를 가지는 정수 자료형 long long을 쓰는 게 좋다. signed long long을 기준으로 하면 최대 계산할 수 있는 양의 정수 범위는 0 ~ 9,223,372,036,854,775,807(16진수로 7FFFFFFFFFFFFFFF)다.\n\nlong long으로도 불가능하다면 BigInteger를 사용하면 된다.\n\n```cpp\ntypedef long long ll;\nll large, small;\n\n```\n\n# 순열관련 함수\n\nprev_permutation\n"}},{"name":"2020-02-01-graph.md","oid":"77ee51be00a66cb386e84663fe372b319859e4f3","content":{"__typename":"GitHub_Blob","text":"# 알고리즘 개념 잡자 - 그래프\n\n- Title : 알고리즘 개념 잡자 - 그래프\n- Date : 2020-02-01\n- Category: Algorithm\n\n> 참고서적\n>\n> - [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539)\n\n<br/>\n\n# 1. 그래프(graph)란\n\n- 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조다.\n- 정점(vertex)과 간선(edge)들의 집합으로 구성된다 => G = (V, E)\n- 정점 == 객체 == 노드, 간선 == 관계 == 노드\n- 그래프로 표현할 수 있는 것들) 도로, 영역 간 인접 관계, 선수 과목\n- 간선의 종류에 따라 무방향 그래프와 방향 그래프로 구분된다.\n\n> **오일러 경로**\n>\n> - 모든 간선을 한번만 통과하면서 처음 정점으로 되돌아오는 경로다.\n> - 그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 오일러 경로가 존재한다.\n\n# 2. 그래프 용어정리\n\n- 가중치 그래프(네트워크) : 간선에 비용이나 가중치가 할당된 그래프\n- 차수(degree) : 정점이 가지고 있는 인접 링크의 수\n- 인접 정점(adjacent vertex) : 간선에 의해 직접 연결된 정점\n  - 무방향 그래프에서 정점의 차수(degree)는 인접 정점의 수다.\n  - 무방향 그래프에 존재하는 정점의 모든 차수를 합하면 그래프의 간선 수의 2배가 된다.\n- 방향 그래프 : 간선에 방향성이 존재하는 그래프\n  - 집입 차수(in-degree) : 외부에서 오는 간선 수\n  - 진출 차수(out-degree) : 외부로 향하는 간선 수\n  - 정점의 진입 차수와 진출 차수의 합은 방향 그래프의 간선의 수가 된다.\n- 경로 길이(path length) : 경로를 구성하는 데 사용된 간선의 수\n  - 단순 경로(simple path) : 경로 중에서 반복되는 간선이 없는 경우\n  - 사이클(cycle) : 단순 경로의 시작 정점과 종료 정점이 동일한 경우\n- 연결 그래프(connected graph) : 무방향 그래프에 있는 모든 정점에 대해 항상 경로가 존재하면 그래프는 연결되어 있다고 한다.\n  - 그래프의 어느 두 정점을 선택해도 그 사이에 경로가 존재하면 연결 그래프다.\n  - 트리는 그래프의 특수한 형태로 사이클을 가지지 않는 연결 그래프이다.\n- 완전 그래프(complete graph) : 그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프\n  - 무방향 완전 그래프의 정점 수가 n이면 하나의 정점은 n-1개의 다른 정점으로 연결되므로 간선의 수는 n x (n-1)/2가 된다.\n\n# 3. 그래프의 구현\n\n## 1) 인접 행렬(adjacency matrix)\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-23-img/1.png)<br/>\n\n- 2차원 배열로 표현\n- n개의 정점을 가지는 그래프를 표현하기 위해서는 n<sup>2</sup>의 메모리 공간이 필요해서 간선이 많이 존재하는 밀집 그래프를 표현하는 경우에 적합하다.\n- 간선 수가 적은 최소 그래프의 경우에는 메모리의 낭비가 크므로 부적합하다.\n- 두 정점을 연결하는 간선의 존재 여부를 O(1) 시간 안에 알 수 있다.\n- 정점의 차수는 인접 행렬의 행이나 열을 조사하면 알 수 있으므로 O(n)의 연산에 알 수 있다.\n- 정점 i에 대한 차수는 인접 행렬의 i번째 행에 있는 값을 모두 더하면 된다.\n- 그래프에 존재하는 모든 간선의 수를 알아내려면 인접 행렬 전체를 조사해야하므로 O(n<sup>2</sup>)의 시간이 요구된다.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n  int n, m; // n: 정점개수, m: 간선 개수\n  int v1, v2, d, c; // v1: 정점1, v2: 정점2, d: 0(무방향) 1(v1->v2), c: 간선 가중치 (1이상)\n  scanf(\"%d %d\", &n, &m);\n\n  int graph[n+1][n+1] = {0}; // 0으로 초기화\n\n  for (int i=0; i<m+1; i++) {\n    scanf(\"%d %d %d %d\", &v1, &v2, &d, &c);\n    if (d == 0) {\n      graph[v1][v2] = graph[v2][v1] = c;\n    } else {\n      graph[v1][v2] = c;\n    }\n  }\n\n  return 0;\n}\n```\n\n## 2) 인접 리스트(adjacency list)\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-23-img/2.png)<br/>\n\n- 각 정점에 인접한 정점들을 연결리스트로 표현\n- 각 연결 리스트들은 헤드 포인터를 가지고 있고 이 헤드 포인터들은 하나의 배열로 구성되어 있어 정점의 번호만 알면 이 번호를 배열의 인덱스로 하여 각 정점의 연결리스트에 쉽게 접근할 수 있다.\n- 정점의 수가 n개고 간선의 수가 e개인 무방향 그래프를 표시하기 위해서는 n개의 연결 리스트가 필요하고 n개의 헤드 포인터와 2e개의 노드가 필요하다.\n- 간선의 개수가 적은 희소 그래프의 표현에 적합하다.\n- 간선의 존재 여부나 정점 i의 차수를 알기 위해서는 정점 i의 연결리스트를 탐색해야 하므로 연결리스트에 있는 노드의 수만큼(정점 차수만큼)의 시간이 필요하다.\n- n개의 정점, e개의 간선을 가진 그래프의 전체 간선 수를 알아내려면 O(n+e)의 연산이 요구된다.\n\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main() {\n  int n, m;\n  int v1, v2, d, c;\n  scanf(\"%d %d\", &n, &m);\n\n  vector<pair<int, int> > graph[n+1];\n\n  for (int i=0; i<m+1; i++) {\n    scanf(\"%d %d %d %d\", &v1, &v2, &d, &c);\n    if (d == 0) { // 무방향\n      graph[v1].push_back(make_pair(v2, c));\n      graph[v2].push_back(make_pair(v1, c));\n    } else {\n      graph[v1].push_back(make_pair(v2, c));\n    }\n  }\n}\n```\n\n# 4. 그래프 탐색\n\n- 그래프에서 모든 노드를 방문하고 싶다면?\n  - DFS, BFS 중 아무거나 사용해도 상관없으나 DFS가 좀 더 간단하긴 하다.\n- 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶다면?\n  - BFS가 일반적으로 더 낫다.\n  - DFS는 경로를 찾을 수는 있겠지만 모든 노드를 탐색해야할지도 모르고 최단 경로가 아닐 수도 있다.\n\n## 1) 깊이 우선 탐색(DFS)\n\n> 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 가다가 더 이상 갈 수 없게 되면 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색을 진행하는 방법과 유사하다.\n\n- 순환 호출이나 명시적 스택을 사용한다.\n- 전위 순회를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류다.\n- 그래프 탐색의 경우는 어떤 노드를 방문했었는지 여부를 반드시 검사해야한다. 이를 검사하지 않으면 무한 루프에 빠질 위험이 있다.\n- 정점의 수가 n, 간선의 수가 e인 그래프를 깊이 우선 탐색하는 시간은? (힌트 : 모든 간선을 조사한다.)\n  - 인접리스트 : O(n+e)\n  - 인접행렬 : O(n<sup>2</sup>)\n\n**인접 행렬로 표현된 무방향 그래프 DFS**\n\n```cpp\n#include <iostream>\n#define MAX_V 20; // 정점 최대 값\nusing namespace std;\n\nint n; // 입력받은 정점의 수\n\nvoid dfs(int graph[][MAX_V], int visited[], int v) {\n  visited[v] = true;\n  printf(\"%d\", v);\n  for (int i=0; i<n+1; i++) {\n    if (graph[v][i] == 1 && !visited[i]) dfs(graph, visited, i);\n  }\n}\n```\n\n## 2) 너비 우선 탐색(BFS)\n\n- 큐를 사용한다.\n- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.\n\n**인접 행렬로 표현된 무방향 그래프 BFS**\n\n```cpp\n#include <iostream>\n#include <queue>\n#define MAX_V 20; // 정점 최대 값\nusing namespace std;\n\nint n; // 입력받은 정점의 수\n\nvoid bfs(int graph[][MAX_V], int visited[], int v) {\n  visited[v] = true;\n  queue<int> q;\n  q.push(v);\n\n  while(!q.empty()) {\n    int top = q.front();\n    q.pop();\n    printf(\"%d\", top);\n\n    for (int i=0; i<n+1; i++) {\n      if (graph[v][i] == 1 && !visited[i]) {\n        q.push(i);\n        visited[i] = true;\n      }\n    }\n  }\n\n}\n\n```\n\n## 3) 양방향 탐색\n\n- 출발지와 도착지 사이에 최단 경로를 찾을 때 사용한다.\n- 출발지, 도착지 두 노드에서 동시에 너비 우선 탐색을 수행한 뒤, 두 탐색 지점이 충돌하는 경우에 경로를 찾는 방법이다.\n- 두 탐색 알고리즘이 대략 d/2 단계(s와 t 사이의 중간 지점)에서 충돌하여 각 출발지와 도착지 노드의 방문 노드의 개수는 대략 k<sup>d/2</sup>가 된다. (k : 각 노드의 인접 노드의 개수)\n"}},{"name":"2020-02-27-union-find.md","oid":"476dc1d82d78ebda7412a9be6dbf3ccf0973fbae","content":{"__typename":"GitHub_Blob","text":"# Union-Find란?\n\n- Title : Union-Find란?\n- Date : 2020-02-27\n- Category: Algorithm\n\n## Why?\n\n[1717번: 집합의 표현](https://www.acmicpc.net/problem/1717)\n\n오 쉽네?😁 라고 생각하며 빠르게 풀고 제출했지만 **메모리 초과**가 발생했다. 아무래도 n\\*n 이차원 배열을 자료구조로 선택한 것이 원인인 듯 싶어 일차원 배열로 바꿔서 다시 풀어봤다. n크기의 배열에서 0→n 까지 반복을 돌려서 v[i]가 b면 a로 값을 바꿔주는 식으로 했다. 이번엔 메모리 초과는 안 떴지만 **시간 초과**가 떴다..두둥 😢🤢 어떻게 풀어야 하는 거지?\n\n## Union-Find란?\n\n> 여러 노드가 존재할 때 선택한 두 개의 노드가 같은 그래프에 속하는 지 판별할 때 사용하는 대표적인 그래프 알고리즘으로 합집합 찾기라는 의미를 가진다.\n\nDisjoint Set(디스조인트 셋)을 표현할 때 사용하는 자료구조로 **공통 원소가 없는 부분 집합**들로 나눠진 원소들에 대한 정보를 저장하는 자료구조다. 예를 들어 {1}, {2,3} , {4,5,6}, {7} 와 같이 공통 원소가 없는 부분 집합을 저장할 때 사용한다. 이 상황을 표현하기 위해 초기화, Union(합치기) 연산과 Find(찾기) 연산을 지원해야해서 Union-Find라고 부르게 되었다.\n\n- 초기화: N개의 원소가 각각의 집합에 포함되어 있도록 초기화한다. 예시) N=5면 {0}, {1}, {2}, {3}, {4}, {5} 로 초기화\n- Union연산: 두 원소 a, b가 주어질 때, 이들이 속한 두 집합을 하나로 합친다.\n- Find연산: 어떤 원소 a가 주어질 때, 이 원소가 속한 집합을 반환한다.\n\n## Union-Find 구현\n\n> 실제 구현은 주로 트리구조를 이용한다. 배열은 왜 사용하지 않는지? 트리를 사용할 때의 장점은 무엇인지? 알아보자\n\n### 배열로 표현\n\n1차원 배열로 집합을 표현한다. 예를 들어 Array[i]: i번 원소가 속하는 집합의 번호 라 해보자.\n\n- 초기화: Array[i] = i 로 각각 다른 집합 번호로 초기화한다.\n- Union연산 O(N): 두 집합을 합치기 위해 배열의 모든 원소를 순회하면서 하나의 집합 번호를 나머지 한 개의 집합 번호로 교체한다. 예를 들어 1 2 3 4 5 배열에서 3번 집합을 2번 집합으로 합치면 1 2 2 4 5가 된다. 다시 2번 집합을 1번 집합으로 합친다면 1 1 1 4 5가 된다.\n- Find연산 O(1): Array[i] 값이므로 한 번에 원소가 속하는 집합의 원소를 알 수 있다.\n\n배열로 Union-Find를 구현할 수는 있다. 하지만, Union연산의 시간복잡도는 O(N)으로 N이 커지면 백준 1717문제처럼 시간초과가 날 것이다. 그럼 트리구조를 사용한다면 **맞습니다!** 를 볼 수 있을까?\n\n### ✨트리로 표현하기\n\n- 한 집합에 속하는 원소들은 하나의 트리로 묶인다. 자료구조는 아래 그림과 같이 트리들의 집합으로 표현된다.\n\n![Union%20Find/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-27-img/Untitled.png)\n\n- 트리의 루트 노드가 각 원소가 속한 집합의 번호가 된다.\n- Union 연산을 수행하기 전 두 원소가 같은 집합에 속하는 지 확인한다. 다른 집합에 속했을 때만 Union 연산을 수행한다. 즉, 두 원소의 루트 노드가 다르면 Union 연산을 수행한다.\n- Find 연산을 위해서는 모든 자식 노드가 부모에 대한 포인터 정보를 가지고 있어야 한다. 이렇게 해야 포인터를 따라 올라가 루트 노드를 찾을 수 있게 된다. 단, 부모 노드에서 자식 노드로 내려가는 일은 발생하지 않기 때문에 부모가 자식에 대한 포인터 정보를 가질 필요는 없다.\n\n**구현 방법**\n\n- 초기화: N개의 루트 노드를 생성하고 자기 자신을 가리키는 포인터를 갖도록 설정한다. 각각의 노드가 루트 노드가 된다.\n- Union연산: 각 트리의 루트를 찾은 뒤 루트 노드가 다르면 하나를 다른 한 쪽의 자손으로 넣어 두 트리를 합친다. 시간 복잡도는 루트 노드를 찾기 위해 Find연산을 수행하므로 Find연산 수행 시간이 지배한다.\n\n![Union%20Find/Untitled%201.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-27-img/Untitled%201.png)\n\n- Find연산: 각 노드에 저장된 포인터 정보를 따라 주어진 원소가 포함된 트리의 루트 노드를 찾는다. 트리의 높이와 시간 복잡도가 비례한다.\n\n## ✔백준 문제 풀이\n\n```cpp\n    #include <iostream>\n    #include <string>\n    using namespace std;\n\n    int s[1000001];\n    int n;\n\n    int find(int a) {\n    \tif (s[a] == a) return a;\n    \treturn s[a] = find(s[a]);\n    }\n\n    void fnc_union(int a, int b) {\n    \tif (a == b) return;\n    \ta =\tfind(a);\n    \tb = find(b);\n    \tif (a == b) return;\n    \ts[b] = a;\n    }\n\n\n    int main() {\n    \tint m;\n    \tscanf(\"%d %d\", &n, &m);\n\n    \tfor (int i=0; i<n+1; i++) {\n    \t\ts[i] = i;\n    \t}\n    \twhile (m--) {\n    \t\tint t, a, b;\n    \t\tscanf(\"%d %d %d\", &t, &a, &b);\n    \t\tif (t) {\n    \t\t\tif (find(a) == find(b)) printf(\"YES\\n\");\n    \t\t\telse printf(\"NO\\n\");\n    \t\t}\n    \t\telse fnc_union(a, b);\n    \t}\n    \treturn 0;\n    }\n```\n\n## 👏최적화하기\n\n트리 구조는 최악의 경우 완전히 비대칭적인 트리 즉, 연결리스트 형태가 된다. 예를 들어 두 트리 a, b를 합칠 때 항상 a의 루트 노드에 b의 루트 노드를 자손으로 합친다면 아래 그림과 같이 원소의 개수가 N개일 때, 트리의 높이가 N-1인 연결 리스트 형태가 된다. 최악의 경우 Union, Find 연산의 시간복잡도는 O(N)이 된다는 얘기다.\n\n![Union%20Find/Untitled%202.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-27-img/Untitled%202.png)\n\n해결 방법💊은 트리의 높이가 낮은 트리의 루트 노드에 합치는 것이다. 이렇게 하면 트리의 높이가 크게 높아지는 상황을 방지할 수 있다. 이러한 최적화를 Union-By-Rank 라고 하며 여기서 rank는 트리의 높이를 저장한다.\n\n**구현방법**\n\n- 두 트리를 합칠 때 랭크(높이)가 더 낮은 트리에 합친다.\n- 랭크에는 트리의 높이를 저장한다.\n- 두 트리의 랭크가 동일한 경우에 합쳐진 트리의 랭크를 1 증가시킨다.\n\n> 최적화 과정을 거치면 트리의 랭크는 합쳐진 두 트리의 랭크가 같을 때만 증가한다. 즉 높이 h인 트리는 높이 h-1인 트리 두개가 합쳐져야한다. 높이 h-1인 트리가 최소 x개의 노드를 가져야한다면 높이가 h가 되기 위해서는 2x개의 노드가 필요하다. 최적화를 통해 트리의 높이가 트리에 속한 **노드의 수의 로그에 비례**하는 것을 보장할 수 있게된다.\n\n백준 1717 최적화 코드\n\n```cpp\n    #include <iostream>\n    #include <string>\n    using namespace std;\n\n    int s[1000001];\n    int r[1000001] = {1};\n    int n;\n\n    int find(int a) {\n    \tif (s[a] == a) return a;\n    \treturn s[a] = find(s[a]); // 경로 압축 최적화\n    }\n\n    void fnc_union(int a, int b) {\n    \tif (a == b) return;\n    \ta =\tfind(a);\n    \tb = find(b);\n    \tif (a == b) return;\n    \t// 랭크 최적화 적용\n    \tif (r[a] > r[b]) swap(a, b);\n    \t\ts[a] = b;\n    \tif (r[a] == r[b]) r[b]++;\n    }\n\n\n    int main() {\n    \tint m;\n    \tscanf(\"%d %d\", &n, &m);\n\n    \tfor (int i=0; i<n+1; i++) {\n    \t\ts[i] = i;\n    \t}\n    \twhile (m--) {\n    \t\tint t, a, b;\n    \t\tscanf(\"%d %d %d\", &t, &a, &b);\n    \t\tif (t) {\n    \t\t\tif (find(a) == find(b)) printf(\"YES\\n\");\n    \t\t\telse printf(\"NO\\n\");\n    \t\t}\n    \t\telse fnc_union(a, b);\n    \t}\n    \treturn 0;\n    }\n```\n\n**경로 압축(Path Compression)**\n\n각 원소의 부모 노드를 재귀를 통해 찾아낸 루트 노드로 바꾸면 다음번 동일한 Find연산 수행 시 경로를 따라갈 필요없이 바로 루트를 찾을 수 있다. 재귀적인 구현으로 a에서 루트까지 올라가는 모든 경로 상에 있는 노드들에게 경로 압축 최적화가 자동으로 수행된다.\n\n```cpp\n    int find(int a) {\n    \tif (s[a] == a) return a;\n    \treturn s[a] = find(s[a]); // 경로 압축 최적화\n    }\n```\n\n![Union%20Find/Untitled%203.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-27-img/Untitled%203.png)\n\n위 최적화 과정을 모두 적용하면 연산 수행 시간을 분석하기 어려울 수 있다. 트리의 높이 변화에 따라 Find연산 수행 시간이 달라지기 때문이다. 평균 수행시간은 O(a(N))으로 a(N)은 에커만 함수를 이용해 정의되는 함수다. 거의 모든 크기의 N에 대해 4 이하의 값을 가져서 모든 입력에 대해 상수 시간에 동작한다고 봐도 무관하다.\n\n**관련 문제**\n\n[Disjoint-set](https://www.acmicpc.net/problem/tag/Disjoint-set)\n\n**참고 99.9%**\n\n[[자료구조]Union-Find: Disjoint Set의 표현](https://bowbowbow.tistory.com/26)\n"}},{"name":"2020-02-28-mst.md","oid":"e027d4b137d5f1bb918e6d826d69a9f8803d0228","content":{"__typename":"GitHub_Blob","text":"# MST(최소신장트리)\n\n- Title : MST(최소신장트리)\n- Date : 2020-02-28\n- Category: Algorithm\n\n## Why?\n\n[1922번: 네트워크 연결](https://www.acmicpc.net/problem/1922)\n\n이 문제를 풀면서 MST 이론을 정리해놔야 겠다는 생각이 들었다.\n\n## MST(Minimun spanning tree)란?\n\n신장 트리는 그래프 내의 모든 정점을 포함하는 트리다. 트리의 특수한 형태로 **모든 정점들이 연결**되어 있어야 하고 사이클을 포함해서는 안된다. 따라서 신장 트리는 그래프에 있는 n개의 정점을 정확히 n-1개의 간선으로 연결하게 된다.\n\n하나의 그래프에는 많은 신장 트리가 존재할 수 있는 데 이 중 사용된 간선들의 **가중치 합이 가장 최소인 신장 트리**가 최소 신장 트리가 된다.\n\n## 신장 트리 찾기\n\nDFS나 BFS를 사용하여 탐색 도중에 사용된 간선을 모으면 신장 트리를 만들 수 있다.\n\n**DFS와 큐로 신장트리 찾기**\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #include <queue>\n    #define MAX_NODE 20\n    using namespace std;\n\n    vector<int> graph[MAX_NODE]; // 인접 리스트로 구현한 그래프\n    bool visited[MAX_NODE] = {false}; // 방문 표시\n    queue<int> st; // 신장 트리\n\n    void dfs(int v) { // 시작 노드\n    \tvisited[v] = true;\n    \tst.push(v);\n    \tfor (int i=0; i<graph[v].size(); i++) {\n    \t\tif (!visited[graph[v][i]]) {\n    \t\t\tdfs(graph[v][i]);\n    \t\t}\n    \t}\n    }\n```\n\n## 최소 신장 트리 찾기\n\n> 구하는 방법으로는 Kruskal과 Prime이 제안한 알고리즘이 대표적이다. 이 알고리즘들은 최소 신장 트리가 간선의 가중치의 합이 최소이어야 하고, 반드시 n-1개의 간선만 사용해야 하며, 사이클이 포함되어서는 안 된다는 조건들을 적절히 이용한다.\n\n### Kruskal의 MST 알고리즘\n\n이 알고리즘은 **탐욕적인 방법**을 이용한다. 탐욕적인 방법은 결정을 해야 할때마다 그 순간에 가장 최적이라고 생각되는 것을 선택함으로써 최종적인 해답을 구한다. 최적을 선택했다고 항상 최적의 해답을 주는 건 아니지만 다행히 Kruskal 알고리즘은 최적의 해답을 주는 것으로 증명되어 있다.\n\n- 그래프 e개의 간선들을 가중치의 오름차순으로 정렬한다.\n- 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택하여 현재의 최소 비용 신장 트리의 집합에 추가한다. 만약 사이클을 형성하면 그 간선은 제외된다.\n- 선택된 간선의 개수가 정점의 개수보다 하나 적으면 알고리즘을 종료한다.\n\n**사이클 체크**\n\n간선을 집합에 추가할 때 사이클을 생성하는지를 체크해야 한다. 양 끝 정점이 서로 다른 집합에 속하는 경우 두 정점을 연결하여도 사이클이 형성되지 않는다. Union-Find 알고리즘을 이용하여 간선의 양끝 정점이 같은 집합에 속해 있는지를 검사할 수 있다.\n\n**시간복잡도**\n\nUnion-Find 알고리즘을 이용하면 Kruskal 알고리즘의 시간 복잡도는 간선들을 정렬하는 시간에 좌우된다. 따라서 간선 e개를 퀵 정렬과 같은 효율적인 알고리즘으로 정렬한다면 시간복잡도는 **O(elog₂e)** 다.\n\n✔**백준 문제 풀이**\n\n1922번 문제를 Kruskal 알고리즘을 사용한 풀이\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #include <algorithm>\n\n    using namespace std;\n\n    struct Info {\n    \tint a;\n    \tint b;\n    \tint c;\n    };\n\n    int n;\n    int parent[1001]; // 부모 노드\n    int num[1001]; // 집합의 크기\n\n    void set_init(int n) {\n    \tfor (int i=1; i<n+1; i++) {\n    \t\tparent[i] = i;\n    \t\tnum[i] = 1;\n    \t}\n    }\n    int set_find(int v) {\n    \tif (parent[v] == v) return v;\n    \treturn parent[v] = set_find(parent[v]);\n    }\n\n    bool set_union(int a, int b) {\n    \ta = set_find(a);\n    \tb = set_find(b);\n\n    \tif (a == b) return false;\n\n    \tif (num[a] > num[b]) swap(a, b);\n    \tparent[a] = b;\n    \tif (num[a] == num[b]) num[b]++;\n    \treturn true;\n    }\n\n    bool compare(Info t1, Info t2) {\n    \treturn t1.c < t2.c;\n    }\n    int main() {\n    \tint m, a, b, c;\n    \tscanf(\"%d\", &n);\n    \tscanf(\"%d\", &m);\n    \tvector<Info> edge;\n\n    \twhile (m--) {\n    \t\tscanf(\"%d %d %d\", &a, &b, &c);\n    \t\tedge.push_back({a, b, c});\n    \t}\n\n    \tsort(edge.begin(), edge.end(), compare);\n\n    \tset_init(n);\n\n    \tint count = 0, cost = 0;\n    \tint ra, rb;\n    \tfor (int i=0; i<edge.size(); i++) {\n    \t\tif (set_union(edge[i].a, edge[i].b)) {\n    \t\t\tcost += edge[i].c;\n    \t\t\tif(++count == n-1) break;\n    \t\t}\n    \t}\n\n    \tprintf(\"%d\", cost);\n\n    \treturn 0;\n    }\n```\n\n✔**응용 문제**\n\n백준 4195번\n\n[4195번: 친구 네트워크](https://www.acmicpc.net/problem/4195)\n\n```cpp\n    #include <iostream>\n    #include <string>\n    #include <map>\n    using namespace std;\n\n    map<string, string> parent;\n    map<string, int> num;\n\n    void check_init(string v) {\n    \tif (parent.find(v) == parent.end()) {\n    \t\tparent.insert(make_pair(v, v));\n    \t\tnum.insert(make_pair(v, 1));\n    \t}\n    }\n    string set_find(string v) {\n    \tif(parent[v] == v) return v;\n    \treturn parent[v] = set_find(parent[v]);\n    }\n\n    int set_union(string a, string b) {\n    \ta = set_find(a);\n    \tb = set_find(b);\n    \tif (a == b) return num[a];\n    \tif (num[a] > num[b]) swap(a, b);\n    \tparent[a] = b;\n    \tnum[b] += num[a];\n    \treturn num[b];\n    }\n    int main() {\n    \tios::sync_with_stdio(false);\n    \tcin.tie(0);\n    \tint t, f;\n    \tcin >> t;\n\n    \twhile(t--) {\n    \t\tcin >> f;\n    \t\twhile (f--) {\n    \t\t\tstring a, b;\n    \t\t\tcin >> a;\n    \t\t\tcin >> b;\n\n    \t\t\tcheck_init(a);\n    \t\t\tcheck_init(b);\n\n    \t\t\tcout << set_union(a, b) << \"\\n\";\n    \t\t}\n    \t\tparent.clear();\n    \t\tnum.clear();\n    \t}\n\n    \treturn 0;\n    }\n```\n\n> 다른 사람 풀이보다 시간이 더 걸려서 비교해보니 map<string, int>로 기존 Union-Find 알고리즘을 그대로 사용할 수 있게 이름에 index를 강제 할당시키는 방식이었다. 왜 이런 생각을 못했지.....😢😢 아! 그리고 **ios::sync_with_stdio(false); cin.tie(0);** 를 안했더니 시간 초과가 났었다.\n\n### Prim의 MST 알고리즘\n\nKruskal은 간선 선택을 기반으로 하는 알고리즘인 반면에, Prim의 알고리즘은 **정점 선택**을 기반으로 하는 알고리즘이다. 또한 Kruskal의 알고리즘은 이전 단계에서 만들어진 신장 트리와는 상관없이 무조건 최소 간선만을 선택하는 방법인 데 반하여 Prime의 알고리즘은 이전 단계에서 만들어진 신장 트리를 확장하는 방식이다.\n\n- 시작 단계에는 시작 정점만이 신장 트리 집합에 포함된다.\n- 앞 단계에서 만들어진 신장 트리 집합에 속한 정점들의 인접 정점들 중에서 최소 비용 간선으로 연결된 정점을 선택하여 신장 트리 집합에 포함한다.\n- 트리 집합의 정점 개수가 n개가 될 때까지 이 과정을 반복한다.\n\n아래 그림으로 예를 들어보자.\n\n- 우선 A 정점을 신장 트리 집합에 포함시킨다.\n- A 정점의 인접 정점인 D, B와 연결된 간선 중 가중치가 최소인 D를 선택하여 집합에 포함시킨다.\n- 신장 트리 집합의 정점 개수가 2개{A, D}로 아직 7개가 아니므로 다시 A, D의 인접 정점을 확인한다.\n- A-B, D-B, D-E, D-F 간선 중 가중치가 최소인 정점인 F를 선택하여 집합에 포함시킨다.\n- 반복..\n\n![MST/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-28-img/Untitled.png)\n\n**구현 방법**\n\n- dist[정점개수] 배열이 필요하다. dist는 현재 신장 트리의 정점 집합에서 각 정점까지의 거리를 가지고 있다. A(0)가 시작 정점이면 dist[0]만 값이 0이고 나머지 배열의 값은 무한대를 가진다. 명백하게 처음에는 트리 집합에 아무것도 없으므로 당연하다. 정점들이 트리 집합에 추가되면서 dist 값은 변경된다.\n- 우선순위 큐가 필요하다. 큐에 모든 정점을 삽입하는 데 이 때 우선순위는 dist 배열 값이 된다.\n- while 루프로 큐에서 가장 작은 dist 값을 가지는 정점을 추출한다. 추출된 정점이 트리 집합에 추가된다.\n- 트리 집합에 새로운 정점 u가 추가되었으므로 u에 인접한 정점 v들의 dist 값을 변경시켜준다. 즉, 기존의 dist[v] 값보다 간선(u, v)의 가중치가 적으면 간선 (u, v)의 가중치로 dist[v]를 변경시킨다.\n- 큐가 빌 때까지 반복한다.\n\n**시간복잡도**\n\nPrim의 알고리즘은 배열을 사용하면 주 반복문이 정점의 수 n만큼 반복하고, 내부 반복문이 n번 반복하므로 Prim의 알고리즘의 시간 복잡도는 O(n²)다. 하지만 우선 순위 큐를 사용하면 **O(elongv)** 의 시간복잡도를 가진다.\n\n✔**백준 문제 풀이**\n\n1197번 문제를 Prim의 알고리즘을 사용한 풀이\n\n[1197번: 최소 스패닝 트리](https://www.acmicpc.net/problem/1197)\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #include <queue>\n    using namespace std;\n\n    bool selected[10001] = {false}; // selected[i]: true면 mst 집합의 원소, false면 선택 가능\n    vector<pair<int, int> > edge[100001]; // 인접 리스트로 그래프 자료구조 구현\n\n    int prim() {\n    \tint cost = 0;\n    \t// 우선 순위 큐: 가중치가 적은 정점이 우선 순위로 나오게\n    \tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n    \tpq.push(make_pair(0, 1)); // 가중치:0, 정점: 1\n\n    \twhile (!pq.empty()) {\n    \t\tpair<int, int> p = pq.top();\n    \t\tpq.pop();\n    \t\tif (selected[p.second]) continue; // 이미 선택된 정점이면 작업할 필요가 없다.\n    \t\tselected[p.second] = true;\n    \t\tcost += p.first;\n    \t\tfor (int i=0; i<edge[p.second].size(); i++) {\n    \t\t\tif (!selected[edge[p.second][i].second]) {\n    \t\t\t\tpq.push(edge[p.second][i]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn cost;\n\n    }\n    int main() {\n    \tios::sync_with_stdio(false);\n    \tcin.tie(0);\n\n    \tint v, e;\n    \tcin >> v >> e;\n    \tint t = e;\n    \twhile (t--) {\n    \t\tint a, b, c;\n    \t\tcin >> a >> b >> c;\n    \t\tedge[a].push_back(make_pair(c, b));\n    \t\tedge[b].push_back(make_pair(c, a));\n    \t}\n\n    \tprintf(\"%d\", prim());\n\n    \treturn 0;\n    }\n```\n\n> 우선 순위 큐에 전달할 데이터가 2개 이상일 때, pair로 묶으면 first 값을 1순위, second 값을 2순위로 우선 순위를 정할 수 있다.\n\n**정리**\n\nKruskal 알고리즘은 희박한 그래프를 대상으로 할 경우에 유리하고 밀집한 그래프의 경우에는 Prim의 알고리즘이 적합하다라고 할 수 있다. 밀집 그래프는 간선이 많이 존재하는 그래프, 희소 그래프는 적은 숫자의 간선을 가지는 그래프다.\n\n**참고**\n\n[C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539)\n"}},{"name":"2020-03-01-dijkstra.md","oid":"5219daaeb39e005c6bc68059ba819110107f2daf","content":{"__typename":"GitHub_Blob","text":"# 최단 경로 알고리즘 - Dijkstra\n\n- Title : 최단 경로 알고리즘 - Dijkstra\n- Date : 2020-03-01\n- Category: Algorithm\n\n## Why?\n\n[1753번: 최단경로](https://www.acmicpc.net/problem/1753)\n\n> 최단 경로 문제는 네트워크에서 정점 u와 정점 v를 연결하는 경로 중에서 간선들의 가중치 합이 최소가 되는 경로를 찾는 문제다.\n\n## Dijkstra의 최단 경로 알고리즘\n\n네트워크에서 **하나의** 시작 정점으로부터 **모든** 다른 정점까지의 최단 경로를 찾는 알고리즘이다. 최단 경로는 경로의 길이순으로 구해진다.\n\n- 집합 S는 정점 v로부터의 최단 경로가 이미 발견된 정점들의 집합이다.\n- distance[]는 시작 정점에서 집합 S에 있는 정점을 거쳐서 다른 정점으로 가는 최단 거리를 기록한 배열이다.\n- distance 배열의 초깃값은 시작 정점이 v라면 distance[v] = 0 이고 다른 정점에 대한 distance 값은 v와 해당 정점 간의 가중치가 된다. 정점 v와 w와 직접 간선이 없다면 무한대 값을 저장한다.\n- 알고리즘 매 단계에서 집합 S에 없는 정점 중 가장 distance 값이 작은 정점을 S에 추가한다. 왜냐하면 현재 정점 u에서 x, y, z 중 y의 가중치가 최소라면 u → y가 u → x → y 또는 u → y → x 등 어떤 정점을 거쳐서 y로 가든 u → y 가 최단 경로이기 때문이다.\n- 새로운 정점 x가 S에 추가되면 S에 있지 않은 다른 정점들의 distance 값을 수정한다. 새로 추가된 정점 x를 거쳐 다른 정점까지 가는 거리와 기존의 거리를 비교하여 더 작은 거리로 distance 값을 수정한다. **distance[w] = min(distance[w], distance[x] + weight[x][w])** 식과 같다.\n\n![Dijkstra/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-01-img/Untitled.png)\n\n네트워크에 n개의 정점이 있다면, 다익스트라 최단 경로 알고리즘은 주 반복문을 n번 반복하고 내부 반복문을 2n번 반복하므로 **O(n²)** 의 복잡도를 가진다. distance를 배열이 아닌 **우선순위 큐**를 사용하면 더 빠르게 수행할 수 있다.\n\n### 백준 문제 풀이\n\n**1753번 최단경로**\n\n[1753번: 최단경로](https://www.acmicpc.net/problem/1753)\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #include <queue>\n    #define MAX_W 98765432\n    using namespace std;\n\n    vector<pair<int, int> > graph[20001];\n\n    vector<int> dijkstra (int s, int cv) {\n    \tvector<int> dis(cv, MAX_W);\n    \tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n    \tpq.push(make_pair(0, s));\n    \tdis[s] = 0;\n\n    \twhile (!pq.empty()) {\n    \t\tint cost = pq.top().first;\n    \t\tint v = pq.top().second;\n    \t\tpq.pop();\n    \t\tif (dis[v] < cost) continue;\n\n    \t\tfor (int i=0; i<graph[v].size(); i++) {\n    \t\t\tif (dis[graph[v][i].second] >= cost + graph[v][i].first) {\n    \t\t\t\tpq.push(make_pair(cost + graph[v][i].first, graph[v][i].second));\n    \t\t\t\tdis[graph[v][i].second] = cost + graph[v][i].first;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn dis;\n    }\n    int main() {\n    \tint v, e, s;\n    \tint a, b, c;\n\n    \tscanf(\"%d %d\", &v, &e);\n    \tscanf(\"%d\", &s);\n\n    \twhile (e--) {\n    \t\tscanf(\"%d %d %d\", &a, &b, &c);\n    \t\tgraph[a].push_back(make_pair(c, b));\n    \t}\n\n    \tvector<int> dis = dijkstra(s, v + 1);\n\n    \tfor (int i=1; i<v+1; i++) {\n    \t\tif (dis[i] == MAX_W)\n    \t\t\tprintf(\"INF\\n\");\n    \t\telse\n    \t\t\tprintf(\"%d\\n\", dis[i]);\n    \t}\n\n    \treturn 0;\n    }\n```\n\n**참고**\n\n[C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539)\n"}},{"name":"2020-03-04-floyd.md","oid":"f9911ac03613c935962bb92b556860145926df9d","content":{"__typename":"GitHub_Blob","text":"# 최단 경로 알고리즘 - Floyd\n\n- Title : 최단 경로 알고리즘 - Floyd\n- Date : 2020-03-04\n- Category: Algorithm\n\n## Why?\n\n## Floyd 알고리즘\n\n그래프에 존재하는 **모든** 정점 사이의 최단 경로를 한 번에 **모두** 찾아주는 알고리즘이다. 다익스트라는 모든 정점 사이의 최단 경로를 구하려면 정점의 수만큼 다익스트라 알고리즘을 반복 실행한다.\n\n- 2차원 배열 weight를 이용하여 3중 반복으로 구성되어 있다.\n- 초기 배열 weight에서 i==j 면 weight[i][j] = 0, i j 사이의 직접 간선 없으면 weight[i][j]=INF, i j 사이 간선 있으면 weight[i][j] = 가중치값\n- 정점 0부터 n까지 반복을 돌린다. 정점 0을 거치는 경우..1을 거치는 경우..\n- weight[i][j] = min(weight[i][j], weight[i][k] + weight[k][j])\n\n![Floyd/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-04-img/Untitled.png)\n\n## 백준 문제 풀이\n\n11404번 플로이드\n\n[11404번: 플로이드](https://www.acmicpc.net/problem/11404)\n\n```cpp\n    #include <iostream>\n    #include <algorithm>\n    using namespace std;\n\n    int main() {\n    \tint n, m;\n    \tcin >> n >> m;\n\n    \tint graph[n+1][n+1];\n    \tfill(&graph[1][1], &graph[n][n], 10000001);\n    \tfor (int i=1; i<n+1; i++)\n    \t\tgraph[i][i] = 0;\n\n    \tint a, b, c;\n    \twhile (m--) {\n    \t\tcin >> a >> b >> c;\n    \t\tgraph[a][b] = min(graph[a][b], c);\n    \t}\n\n    \tfor (int k=1; k<n+1; k++) {\n    \t\tfor (int i=1; i<n+1; i++) {\n    \t\t\tif (k == i) continue;\n    \t\t\tfor (int j=1; j<n+1; j++) {\n    \t\t\t\tif (k == j) continue;\n    \t\t\t\tgraph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \tfor (int i=1; i<n+1; i++) {\n    \t\tfor (int j=1; j<n+1; j++) {\n    \t\t\tif (graph[i][j] == 10000001) cout << 0 << \" \";\n    \t\t\telse cout << graph[i][j] << \" \";\n    \t\t}\n\n    \t\tcout << \"\\n\";\n    \t}\n\n    \treturn 0;\n    }\n```\n"}},{"name":"2020-03-06-bellmanford.md","oid":"cb0f5b74980d5a8d75a84ffc8c6e5bcbd54a7dfe","content":{"__typename":"GitHub_Blob","text":"# 최단 경로 알고리즘 - Bellman-Ford\n\n- Title : 최단 경로 알고리즘 - Bellman-Ford\n- Date : 2020-03-06\n- Category: Algorithm\n\n## Why?\n\n[11657번: 타임머신](https://www.acmicpc.net/problem/11657)\n\n다익스트라가 통하지 않았다...😫**음수 가중치** 가 있으면 벨만-포드 알고리즘을 써야한다네...?\n\n## 음수 가중치가 있을 때, 다익스트라가 통하지 않는다. 왜?\n\n다익스트라는 선택된 정점의 집합 S에 없는 정점 중 가중치 값이 가장 작은 정점을 뽑는다. 단 아래의 상황이 만족되는 경우에 적용이 가능하다.\n\n![Bellman%20Ford/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-06-img/Untitled.png)\n\n- 다익스트라에 따르면, 선택된 정점의 집합 S = {1} 일 때, 선택되지않은 정점 {2, 3, 4} ( int[] distance = [0, 5, INF, 6] )중 가장 가중치가 적은 2를 선택한다. 1 → 2는 1→ 4 → 2, 1→ 4 → 3 → 2 보다 적은 가중치를 갖는 것이 증명되기 때문이다.\n\n**그러나, 음수 가중치가 있다면?**\n\n![Bellman%20Ford/Untitled%201.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-06-img/Untitled%201.png)\n\n- 다익스트라에 따르면, 집합 S = {1} 이고 distance가 [0, 5, INF, 6] 이므로 정점 2를 선택한다. 그러나, 1 → 2 가 1 → 4 → 2, 1 → 4 → 3 → 2 보다 적은 가중치를 가지나? **NO!** 음수 가중치에 의해 1에서 2의 최단 경로는 1 → 4 → 3 → 2 가 된다.\n\n그럼 새로운 거리 가중치가 현재의 distance 보다 작으면 바꿀 수 있게 **집합 S에 속한 경우도 탐색하면 되지 않을까?**\n\n- S = {1} , distance = [~~0~~, **5**, INF, 6]\n- S = {1, 2}, distance = [~~0~~, **5**, 9, 6] —> 또 정점 2가 선택되어 **무한루프**를 타버린다.\n\n그러면 **선택된 정점의 현재 distance가 이전에 선택되었을 때의 distance 값과 동일하다면 제외하면 되지 않을까?**\n\n- S = {1, 2}, distance = [~~0~~, 5, 9, **6**] —> 정점 2는 이전에 선택되었을 때와 distance가 같아서 제외하고 그 다음으로 정점 4를 선택\n- S = {1, 2, 4}, distance = [~~0~~, **2**, 4, 6] —> 이전 distance 5보다 적은 가중치이므로 정점 2를 선택\n- S = {1, 2, 4}, distance = [~~0~~, 2, **4**, 6] —> 정점 2는 이전 distance와 같으니깐 정점 3 선택\n- S = {1, 2, 3, 4}, distance = [~~0~~, **1**, 4, 6] —> 정점 2 선택\n- S = {1, 2, 3, 4}, distance = [~~0~~, 1, 4, 6] —> 모두 이전 distance와 같은 상태..\n\n기존 다익스트라보다 복잡하다. **음수 가중치**가 있으면 벨만 포드 알고리즘을 써서 좀 더 간단하게 풀자!\n\n## 벨만 포드 알고리즘\n\n정점 u, v 사이의 최단 경로를 구할 때 그래프 내 **모든 간선에 대해 간선 경감(Edge Relaxation)을 수행**한다. u, v 사이의 최단 경로는 u → v 직접 간선일 수도 있고 u → v를 제외한 모든 노드 → v 일 수도 있다. 따라서 모든 간선에 대해 간선 경감을 **|V| - 1** 회 수행한다. (V : 정점 개수)\n\n![Bellman%20Ford/Untitled%202.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-06-img/Untitled%202.png)\n\n1. **초기화 작업** : 시작 정점을 제외한 모든 정점을 INF 값으로 초기화한다.\n\n![Bellman%20Ford/Untitled%203.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-06-img/Untitled%203.png)\n\n2.  **간선 경감 수행** : 정점 개수 - 1 만큼 간선 경감을 수행한다.\n\n![Bellman%20Ford/Untitled%204.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-06-img/Untitled%204.png)\n\n3.  **사이클 검사**: 음의 가중치가 포함된 사이클이 있는 지 검사한다. 존재하면 false, 존재하지 않으면 true를 반환\n\n> 벨만-포드는 음수 가중치가 사이클을 이루고 있으면 적용할 수 없다. 사이클을 돌면 돌수록 거리 가중치 값이 작아져 최단 경로를 구하는 의미가 없어지기 때문이다. 따라서 2번 과정 수행 후 마지막으로 그래프 모든 엣지에 대해 간선 경감을 1번 수행하여 값이 업데이트하는 지 확인해야한다. 업데이트가 된다면 음수 가중치 사이클이 존재한다는 의미로 결과를 구할 수 없다는 false를 반환하면 된다.\n\n**시간복잡도**\n\n- 시작 정점을 제외한 나머지 정점의 개수(|V| - 1)만큼 간선 경감을 반복한 후 음수 사이클 검사를 위해 그래프의 모든 간선에 대한 탐석을 1번 더 수행한다. O(|V|\\*|E|)\n- 최악(Dense Graph)의 경우 다익스트라는 O(|V|²)의 시간 복잡도를 가지며 벨만-포드는 O(|V|³)의 시간 복잡도를 가진다.\n\n### 백준 문제 풀이\n\n11657 타임머신\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #define INF 2e9\n    using namespace std;\n    vector<pair<int, int> > w[501];\n    int d[501];\n    int n, m;\n\n    bool solve() {\n    \tbool cycle = false;\n    \tfor (int i=1; i<=n+1; i++) {\n    \t\tfor (int j=1; j<n+1; j++) {\n    \t\t\tfor (int k=0; k<w[j].size(); k++) {\n    \t\t\t\tif (d[j] == INF) continue;\n    \t\t\t\tif (d[j] + w[j][k].first < d[w[j][k].second]) {\n    \t\t\t\t\td[w[j][k].second] = d[j] + w[j][k].first;\n    \t\t\t\t\tif (i == n+1) {\n    \t\t\t\t\t\treturn true;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn cycle;\n    }\n    int main() {\n    \tint a, b, c;\n    \tcin >> n >> m;\n\n    \tfill(&d[1], &d[501], INF);\n    \td[1] = 0;\n    \tfor (int i=0; i<m; i++) {\n    \t\tcin >> a >> b >> c;\n    \t\tw[a].push_back({c, b});\n    \t}\n    \tif (solve()) {\n    \t\tcout << \"-1\";\n    \t} else {\n    \t\tfor (int i=2; i<n+1; i++) {\n    \t\t\tif (d[i] == INF) cout << \"-1\" << \"\\n\";\n    \t\t\telse cout << d[i] << \"\\n\";\n    \t\t}\n    \t}\n\n    \treturn 0;\n    }\n```\n\n**참고**\n\n[벨만-포드 알고리즘](https://ratsgo.github.io/data%20structure&algorithm/2017/11/27/bellmanford/)\n"}},{"name":"2020-03-07-eratos.md","oid":"57c3c92534f9c78520f1c8b610b3d22a3d7fb7d8","content":{"__typename":"GitHub_Blob","text":"# 에라토스테네스의 체\n\n- Title : 에라토스테네스의 체\n- Date : 2020-03-07\n- Category: Algorithm\n\n## 에라토스테네스의 체\n\nN보다 작거나 같은 모든 소수를 찾는 알고리즘이다.\n\n- N이 1보다 작거나 같으면 소수가 없다.\n- 2부터 N까지의 모든 수를 나열한다 - 2부터 N까지 N-1 개를 저장할 수 있는 배열을 할당한다. 배열 참조번호와 소수가 일치하도록 배열의 크기는 N+1만큼 할당(인덱스 0, 1은 사용하지 않는다)\n- 검사는 2부터 sqrt(N) 전까지만 하면 된다.\n\n```cpp\n  void Eratos(int n) {\n    if (n <= 1) return;\n    bool arr[n+1];\n    fill(&arr[2], &arr[n+1], true);\n    for (int i=2; i*i<n+1; i++) {\n      if (arr[i]) {\n        for (int j = i*i; j<n+1; j+=i) {\n          arr[j] = false;\n        }\n      }\n    }\n  }\n```\n\n### **백준 문제 풀이**\n\n[2960번: 에라토스테네스의 체](https://www.acmicpc.net/problem/2960)\n\n```cpp\n    #include <iostream>\n    using namespace std;\n\n    int solve(int n, int k) {\n    \tint cnt = 0;\n    \tbool arr[n+1];\n    \tfill(&arr[0], &arr[n+1], true);\n    \tfor (int i=2; i<n+1; i++) {\n    \t\tif (!arr[i]) continue;\n    \t\tfor (int j=i; j<n+1; j=j+i) {\n    \t\t\tif (arr[j]) {\n    \t\t\t\tarr[j] = false;\n    \t\t\t\tif (++cnt == k) return j;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn -1;\n    }\n    int main() {\n    \tint n, k;\n    \tcin >> n >> k;\n    \tcout << solve(n, k);\n    \treturn 0;\n    }\n```\n\n[1644번: 소수의 연속합](https://www.acmicpc.net/problem/1644)\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    using namespace std;\n\n    vector<int> p;\n    int n, ans = 0;\n    void eratos() {\n    \tbool arr[n+1];\n    \tfill(&arr[2], &arr[n+1], true);\n    \tfor (int i=2; i*i<n+1; i++) {\n    \t\tif (arr[i]) {\n    \t\t\tfor (int j=i*i; j<n+1; j+=i) {\n    \t\t\t\tarr[j] = false;\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \tfor (int i=2; i<n+1; i++) {\n    \t\tif (arr[i]) {\n    \t\t\tp.push_back(i);\n    \t\t}\n    \t}\n    }\n\n    void solve() {\n    \tint s = 0, e = 0;\n    \tint sum = 0;\n    \twhile (s < p.size() && e < p.size()) {\n    \t\tsum += p[e++];\n    \t\tif (sum == n) {\n    \t\t\tans++;\n    \t\t}\n    \t\telse if (sum > n) {\n    \t\t\twhile (s < e) {\n    \t\t\t\tsum -= p[s++];\n    \t\t\t\tif (sum <= n) {\n    \t\t\t\t\tif (sum == n) {\n    \t\t\t\t\t\tans++;\n    \t\t\t\t\t}\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    int main() {\n    \tcin >> n;\n    \teratos();\n    \tsolve();\n    \tcout << ans;\n    \treturn 0;\n    }\n```\n\n**참고**\n\n[에라토스테네스의 체](https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4)\n"}},{"name":"2020-03-10-pattern-searching-naive-algorithm.md","oid":"e1d99f9a899dc585ce4b9625b8729cc326c3da77","content":{"__typename":"GitHub_Blob","text":"# Pattern Searching - Naive algorithm\n\n- Title : Pattern Searching - Naive algorithm\n- Date : 2020-03-10\n- Category: Algorithm\n\n## Naive algorithm\n\n문자열 인덱스 0부터 패턴 문자열은 하나씩 비교해가는 방법. 가장 직관적이면서 순수(?)하다.\n\n```cpp\n    #include <iostream>\n    #include <cstring>\n    using namespace std;\n\n    void search(char* pat, char* txt) {\n    \tint M = strlen(pat);\n    \tint N = strlen(txt);\n\n    \tfor (int i=0; i<=N-M; i++) {\n    \t\tint j;\n    \t\tfor (j=0; j<M; j++) {\n    \t\t\tif (txt[i + j] != pat[j]) break;\n    \t\t}\n    \t\tif (j == M)\n    \t\t\tcout << \"Pattern found at index \" << i << endl;\n    \t}\n    }\n    int main() {\n    \tchar txt[] = \"AABAACAADAABAABA\";\n    \tchar pat[] = \"AABA\";\n    \tsearch(pat, txt);\n    \treturn 0;\n    }\n```\n\n## 시간 복잡도\n\n### 최선의 시간 복잡도\n\n- txt[] = \"AABCCAADDEE\"\n- pat[] = \"FAA\"\n\n패턴의 첫번째 문자 'F'가 일치하는 경우가 없어서 `O(n)`의 시간 복잡도를 가진다. n: 탐색 문자열의 길이\n\n### 최악의 시간 복잡도\n\n- txt[] = \"AAAAAAAAAAAAAAAAAA\"\n- pat[] = \"AAAAB\"\n\n패턴의 마지막 문자 'B'만 다를 경우 `O(m*(n-m+1))`의 시간 복잡도를 가진다. m: 패턴 문자열의 길이, n: 탐색 문자열의 길이\n"}},{"name":"2020-03-11-pattern-searching-kmp-algorithm.md","oid":"d4a60dea091fb5b6e0163278ddd1345bb5131c7c","content":{"__typename":"GitHub_Blob","text":"# Pattern Searching - KMP Algorithm\n\n- Title : Pattern Searching - KMP Algorithm\n- Date : 2020-03-11\n- Category: Algorithm\n\n## KMP\n\nkmp 알고리즘은 Pattern Searching - Naive Alogorithm(TIL 알고리즘 파트에서 내용을 볼 수 있음)과 비슷하나 0~N(탐색문자길이) 탐색 중 적절하게 문자를 건너뛴다. 아래 예시로 이해해보자.\n\n- txt[] = ABABCAAA\n- pat[] = ABABD\n\n첫번째 윈도우 탐색 결과 패턴을 찾지는 못했다.\n\n- txt[] = `ABABC`AAA\n- pat[] = `ABABD`\n\nNaive 알고리즘 방식대로 이어서 두번째 윈도우를 탐색해보자.\n\n- txt[] = A`BABCA`AA\n- pat[] = `ABABD`\n\nNaive 알고리즘 방식대로 이어서 세번째 윈도우를 탐색해보자.\n\n- txt[] = AB`ABCAA`A\n- pat[] = `ABABD`\n\n하지만 KMP 알고리즘은 적절하게 문자를 건너뛰어서 첫번째 윈도우 후 다음으로 탐색할 두번째 윈도우는 아래와 같다.\n\n- txt[] = AB`ABCAA`A\n- pat[] = `ABABD`\n\n첫번째 윈도우 탐색 결과 ABAB까지는 패턴과 일치하는 것을 이용한 것이다. 패턴의 부분 문자열이기도한 ABAB는 접두사 AB와 접미사 AB가 일치한다. 다음 패턴의 시작점을 접미사의 시작점으로 할 수가 있는 거다.\n\n## lps[] 란?\n\n- lps 배열의 크기는 패턴의 길이와 같고 패턴 탐색 시 몇 개의 문자를 건너뛸지를 결정한다.\n- lps[i]는 패턴의 0~ i 까지의 부분 문자열에서의 접두어(prefix)와 접미어(suffix)가 같은 부분 문자열 중 가장 긴 것의 길이다. 단 접두어로 전체 문자열은 허용하지않는다.\n\n## Ips[] 예시\n\n\"AAAA\"\n\n- \"A\" : Ips[0] = **0** (prefix는 전체 문자열이 안됨)\n- \"AA\" : lps[1] = **1** ( prefix `A` suffix `A` )\n- \"AAA\" : lps[2] = **2** ( prefix `AA` suffix `AA` )\n- \"AAAA\" : lps[3] = **3** ( prefix `AAA` suffix `AAA` )\n\n\"ABCDE\"\n\n- \"A\" : Ips[0] = **0**\n- \"AB\" : lps[1] = **0**\n- \"ABC\" : lps[2] = **0**\n- \"ABCD\" : lps[3] = **0**\n- \"ABCDE\" : lps[4] = **0**\n\n\"AABAACAABAA\"\n\n- \"A\" : lps[0] = 0\n- \"`A` `A`\" : lps[1] = 1\n- \"AAB\" : lps[2] = 0\n- \"`A`AB`A`\" : lps[3] = 1\n- \"`AA`B`AA`\" : lps[4] = 2\n- \"AABAAC\" : lps[5] = 0\n- \"`A`ABAAC`A`\" : lps[6] = 1\n- \"`AA`BAAC`AA`\" : lps[7] = 2\n- \"`AAB`AAC`AAB`\" : lps[8] = 3\n- \"`AABA`AC`AABA`\" : lps[9] = 4\n- \"`AABAA`C`AABAA`\" : lps[10] = 5\n\n## lps를 이용해 탐색하기\n\n- 현재 txt 윈도우에서 pat[j] j는 0부터 비교를 시작하기\n- txt[i]와 pat[j]가 일치하면 i와 j를 증가하기\n- txt[i]와 pat[j]가 일치하지않으면\n  - 패턴 0~j-1과 탐색문자 i-j~i-1 까지는 일치한다는 것은 알고 있다.\n  - lps[j-1]은 패턴의 0~j-1 부분 문자열의 접두어 접미어가 일치하는 부분 문자열 중 길이가 가장 긴 값이라는 것은 위 정의를 통해 이미 알고 있다.\n  - 현재 윈도우 txt[i-j~i-1]에서 lps[j-1]만큼은 탐색할 필요는 없다.\n\n## C++\n\n\"AABAACAABAA\"\n\n- lps[0] = 0\n- i = 1, len = 0 ⇒ **lps[1] = 1**\n  - pat[1] == pat[0] , len=1, lps[1] = 1, i = 2\n- i = 2, len = 1\n  - pat[2] != pat[1] && len ! = 0, len = lps[1-1] =lps[0] = 0\n- i = 2, len = 0 ⇒ **lps[2] = 0**\n  - pat[2] ≠ pat[0] && len == 0, lps[2] = 0, i = 3\n\n```cpp\n    #include <iostream>\n    #include <cstring>\n    using namespace std;\n\n    void computeLPSArray(char* pat, int M, int *lps) {\n    \t// 현재까지 계산한 lps 중 가장 큰 값\n    \tint len = 0;\n    \t// 부분문자열 길이가 1이면 lps 값은 언제나 0\n    \tlps[0] = 0;\n\n    \t// i ~ M - 1 까지 계산\n    \tint i = 1;\n    \twhile (i < M) {\n    \t\tif (pat[i] == pat[len]) {\n    \t\t\tlen++;\n    \t\t\tlps[i] = len;\n    \t\t\ti++;\n    \t\t} else {\n    \t\t\tif (len != 0) {\n    \t\t\t\tlen = lps[len - 1];\n    \t\t\t} else {\n    \t\t\t\tlps[i] = 0;\n    \t\t\t\ti++;\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    void KMPSearch(char* pat, char* txt) {\n    \tint M = strlen(pat);\n    \tint N = strlen(txt);\n\n    \tint lps[M];\n\n    \tcomputeLPSArray(pat, M, lps);\n\n    \tint i = 0, j = 0;\n    \twhile (i < N) {\n    \t\tif (pat[j] == txt[i]) {\n    \t\t\tj++;\n    \t\t\ti++;\n    \t\t}\n    \t\tif (j == M) {\n    \t\t\tcout << \"Found Pattern at index \" << (i - j) << endl;\n    \t\t\tj = lps[j - 1];\n    \t\t}\n    \t\t// 패턴이 일치하지않으면\n    \t\telse if (i < N && pat[j] != txt[i]) {\n    \t\t\t// 미스매칭이 1~M이면\n    \t\t\tif (j != 0)\n    \t\t\t\tj = lps[j - 1];\n    \t\t\telse // 첫 문자부터 미스매칭\n    \t\t\t\ti = i + 1;\n    \t\t}\n    \t}\n    }\n    int main() {\n    \tchar txt[] = \"AABAACAADAABAABA\";\n    \tchar pat[] = \"AABA\";\n    \tKMPSearch(pat, txt);\n    \treturn 0;\n    }\n```\n"}},{"name":"images","oid":"a48356f13ce6e81027059c123f086d1c72c1d650","content":{"__typename":"GitHub_Tree"}}]}},{"name":"Android","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":"2018-11-30-android-base.md","oid":"577478fb0b78d854a14f939dd2ff68114511aa30","content":{"__typename":"GitHub_Blob","text":"# [안드로이드] 시작하기 앞서 기초 학습\n\n- Title : [안드로이드] 시작하기 앞서 기초 학습\n- Date : 2018-11-30\n- Category: Android\n\n안드로이드 학습을 시작하기 전에 간단히 자바 기본 개념을 정리했습니다.\n\n# 안드로이드 기초\n\n## 안드로이드 4대 구성요소\n\n- 액티비티  \n  화면 하나당 하나의 액티비티 가짐. 여러개의 액티비티 중 하나가 메인 액티비티가 되며 manifest에 정의된다.\n- 리시버  \n  전화&문자 수신, 배터리 부족 등의 브로드캐스트를 수신하는 객체\n- 프로바이더  \n  데이터베이스나 파일 등의 정보를 외부의 앱에 공개하기 위한 객체. ContentProvider 클래스를 상속받아 구현\n- 서비스  \n  백그라운드(음악재생, 파일다운로드)에서 오래 수행되어야 하는 앱. 화면 없음\n\n## 액티비티끼리 데이터를 주고받는 과정\n\n1. A 액티비티에서 startActivityForResult()로 B 액티비티 시작\n2. B 액티비티에서 setResult()로 결과를 A 액티비티로 전달\n3. A 액티비티의 onActivityResult()에서 B 액티비티에서 전달받은 데이터 처리\n\n# 자바 기초 개념\n\n---\n\n## 자바 상속과 인터페이스 개념 정리 [출처]\n\n1. 상속\n\n- 어떤 클래스보다 내용이 구체적인 새로운 클래스가 필요할 때 기존 클래스에서 물려받아 새로운 부분만 추가하거나 수정하려고 만든 개념이다.\n- 상속을 이용하면 슈퍼 클래스(부모)의 필드, 메서드를 상속받으며 서브 클래스(자식)에서 자신만의 필드나 메서드를 추가하여 구체화할 수 있다.\n  물론 상속받은 메서드를 재정의(오버라이딩)하는 것도 가능하다.\n- 상속은 클래스를 선언할 때 extends 키워드를 사용하여 정의한다.\n- 다른 객체지향 언어와 달리 다중 상속을 지원하지 않는다.\n- 다형성 : 슈퍼클래스가 같은 서브 클래스들이 동일한 요청(메서드)을 다르게 처리할 수 있는 특징을 말한다. 메서드를 오버라이딩(재정의)하여 구현한다.\n\n2. 클래스의 기본 구조\n\n- 패키지 : 자바 클래스들을 같은 성격으로 묶어서 관리하는 디렉토리 개념\n- 클래스 : 자바 프로그램의 기본 단위\n- 인스턴스 : 객체지향개념에 따라 클래스는 바로 사용할 수 없고 인스턴스로 사용해야한다. 인스턴스를 이용하여 메서드 호출 등 필요한 작업을 처리한다.\n- 생성자 : 클래스를 생성할 때 제일 먼저 실행되는 특수한 형태의 메서드, 리턴값이 없으며(데이터형 입력하면 안됨) 메서드 이름은 반드시 클래스 이름과 일치해야 한다.\n\n3. 접근 한정자의 종류와 접근 범위\n\n- public : 클래스 내부, 동일 패키지, 하위클래스, 그 외의 영역에서 접근 가능\n- protected : 클래스 내부, 동일 패키지, 하위클래스에서 접근 가능\n- default : 클래스 내부, 동일 패키지에서 접근 가능\n- private : 클래스 내부에서만 접근 가능\n\n4. 일반 한정자의 종류\n\n- static : 클래스 메서드와 클래스 변수를 선언하는 데 사용한다.\n  자바의 정적 영역에 할당되는 리소스를 선언하는 데 사용.\n  동일한 가상머신 상에서 실행 중인 모든 클래스에서 공유한다.\n  인스턴스를 생성하지 않고도 클래스의 메서드나 멤버에 접근할 수 있다.\n- final : 더 이상 변경할 수 없도록 선언하는 한정자. 클래스에서 사용하면 서브 클래스를 만들 수 없다. 메서드에서 사용하면 오버라이딩을 할 수 없다.\n  변수에 사용하면 저장된 값은 변할 수 없으므로 상수의 역할을 한다.\n- abstract : 추상 클래스를 선언하는 데 사용하는 한정사\n\n5. 인스턴스 변수와 클래스 변수\n\n- 인스턴스 변수는 클래스의 인스턴스로만 접근 가능한 변수(일반적인 멤버 변수), 클래스 외부에서 접근 차단하려고 private 키워드를 사용하기도 함.\n- 동일 클래스의 인스턴스라 해도 각 인스턴스의 변수는 값이 서로 다르고 서로에 영향을 주지 않는다.\n- 클래스 변수는 모든 클래스의 인스턴스로 공유되는 변수, static 키워드를 사용하여 선언한다.\n\n6. 자바 가상머신의 메모리 구조\n\n- Heap 영역 : 자바 객체, 인스턴스 변수\n- Stack 영역 : 메서드 파라미터, 지역 변수\n- Method 영역 : 메서드 바이트 코드, 클래스(static) 변수\n\n7. 추상 클래스와 인터페이스\n\n- 추상클래스\n  - 추상 메서드(정의만 한 메서드)를 하나 이상 포함한다, 추상 메서드가 포함된 클래스는 반드시 추상 클래스로 정의해야 한다.\n  - 그 자체를 인스턴스화(객체 생성)에 사용할 수 없다. 추상 클래스를 상속받는 클래스를 만든 후 추상클래스에 선언된 모든 추상 메서드를 오버라이딩해서 구현해야 한다.\n\n8. 인터페이스\n\n- 모두 추상 메서드로만 구성해야 한다.\n- 일반 멤버 필드는 없고, public, static, final로 선언한 상수만 있다.\n- 그 자체를 인스턴스화(객체 생성) 불가. 다른 클래스로 구현할 때는 implements 키워드로 구현을 선언해야한다.\n- 다중 상속 개념 지원하는 형태로 사용 가능\n\n9. 캡슐화\n\n- 외부에서 변수에 직접 접근할 수 없도록 하는 객체지향 프로그래밍 방법이다.\n- 캡슐화된 변수에 접근하려면 getter, setter 메서드를 만들어서 접근해야한다.\n\n[출처]: http://nyebo.net/2016/01/just-java-summary/\n"}},{"name":"2018-12-02-android-adapter.md","oid":"f8ebac2b78438548ddb7207724467420f65eee08","content":{"__typename":"GitHub_Blob","text":"# [안드로이드] 어댑터뷰를 사용해보자\n\n- Title : [안드로이드] 어댑터뷰를 사용해보자\n- Date : 2018-12-02\n- Category: Android\n\n[될때까지 안드로이드] 어댑터뷰 파트의 내용을 정리한 글입니다.\n\nListView 와 GridView\n\n- 반복되고 양이 많은 데이터를 표시하고 싶을 때\n- 이미지와 같이 메모리를 차지하는 리소스를 표시하고 싶을 때\n- 모두 AdapterView 추상클래스를 상속받아 어댑터 패턴을 사용하여 데이터를 뷰에 표시한다.\n- ScrollView의 경우 한번에 모든 컨텐츠를 로드하므로 컨텐츠가 메모리를 많이 사용할 경우 메모리 부족으로 앱이 종료될 수 있다.\n\n# AdapterView\n\n---\n\nAdapterView를 상속받은 뷰들은 화면에 보이는 내용만 로드하는 기법을 사용한다.\n\n## 1. AdapterView의 구현\n\n데이터 준비하기\n\n```java\n//MainActivity.java\nArrayList<Weather> data = new ArrayList<Weather>()\ndata.add(new Weather(\"수원\", \"25도\", \"맑음\"));\ndata.add(new Weather(\"안양\", \"22도\", \"비\"));\ndata.add(new Weather(\"부천\", \"22도\", \"구름\"));\ndata.add(new Weather(\"성남\", \"24도\", \"맑음\"));\ndata.add(new Weather(\"서울\", \"28도\", \"구름\"));\ndata.add(new Weather(\"광주\", \"30도\", \"비\"));\ndata.add(new Weather(\"부산\", \"20도\", \"비\"));\n```\n\n데이터를 뷰에 연결해 줄 어댑터를 준비한다.\n\n```java\n//MainActivity.java\nMyFirstAdapter adapter = new MyFirstAdapter(data);\n```\n\n뷰에 어댑터를 붙인다.\n\n```java\n//MainActivity.java\nListView listView = (ListView) findViewById(R.id.list_view);\nlistView.setAdapter(adapter);\n```\n\n## 2. 클릭 이벤트 구현\n\npublic static interface AdapterView.OnItemClickListener  \n<span class=\"clr-grey\">android.widget.AdapterView.OnItemClickListener : 어댑터뷰의 아이템 클릭시 호출되는 콜백 메서드를 정의한 인터페이스</span>\n\npublic abstract void onItemClick (AdapterView<?> parent, View view, int position, long id)  \n<span class=\"clr-grey\">\nparent : 클릭이 일어난 AdapterView  \nview : AdapterView 안의 클릭된 View = 클릭된 아이템 뷰  \nposition : 클릭된 아이템 뷰의 위치  \nid : 클릭된 아이템 뷰의 row ID\n</span>\n\n```java\nlistView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n  @Override\n  public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n    Toast.makeText(MainActivity.this, position + \" 번째 아이템 선택\", Toast.LENGTH_SHORT).show();\n   }\n});\n```\n\n## 3. 예제 구성\n\n1. Weather.java\n   날씨를 표현하는 모델클래스  \n   <span class=\"clr-grey\"> toString() : 모든 클래스가 가지고 있는 기본메서디로 디버깅이나 로그에서 정보 확인을 위해 toString() 메서드 재정의한다. </span>\n\n2. MyFirstAdapter.java  \n   추상클래스인 BaseAdapter를 상속받는 클래스로 추상 메서드들을 구현해야 한다.  \n   <span class=\"clr-grey\"> Note: BaseAdapter는 어댑터의 기능을 추상화해 둔 추상 클래스, 각 메서드 재정의 필요 </span>\n\n```java\n @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        /**\n         * LayoutInflater 클래스란?\n         * Activity 이외의 클래스에서 Context를 통해 XML로 정의한 레이아웃을 로드하여 View로 반환해주는 클래스\n         */\n        ViewHolder holder;\n        if (convertView == null) {\n            holder = new ViewHolder();\n            convertView = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_weather, parent, false);\n            ImageView weatherImage = (ImageView) convertView.findViewById(R.id.weather_image);\n            TextView cityText = (TextView) convertView.findViewById(R.id.city_text);\n            TextView tempText = (TextView) convertView.findViewById(R.id.temp_text);\n            holder.cityText = cityText;\n            holder.tempText = tempText;\n            holder.weatherImage = weatherImage;\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n\n        Weather weather = mData.get(position);\n        holder.cityText.setText(weather.getCity());\n        holder.tempText.setText(weather.getTemp());\n        holder.weatherImage.setImageResource(mWeatherImageMap.get(weather.getWeather()));\n        return convertView;\n    }\n    static class ViewHolder {\n        ImageView weatherImage;\n        TextView cityText;\n        TextView tempText;\n    }\n```\n\n- 핵심메서드 getView() 작성\n  - 각 아이템이 화면에 표시될 때마다 호출되며, 여기서 화면에 표시할 레이아웃과 데이터를 모두 작성해야한다.\n  - ListView의 각 아이템에 해당되는 View는 화면에 보이는 만큼만 생성되고 스크롤 시에 안쓰이는 아이템은 새로 보이는 아이템의 View로 재사용된다.  \n    <span class=\"clr-grey\"> Note: 두번째 파라미터인 convertView가 재사용 시에 이전에 생성되었던 getView()가 반환했던 View </span>\n- LayoutInflater 추상 클래스\n  - Activity 이외의 클래스에서 Context를 통해 XML로 정의한 레이아웃을 로드하여 View로 반환해주는 클래스\n  - 레이아웃 XML 파일을 View 객체로 반환한다.\n  - LayoutInflater 인스턴스 받는 법 : **Activity.getLayoutInflater()** or **Context.getSystemService(Class)**\n  - Public methods  \n    <span class=\"clr-grey\">\n    -LayoutInflater.from(parent.getContext())  \n     현재 Context로부터 LayoutInflater 인스턴스를 반환받는다._static LayoutInflater_  \n     -LayoutInflater.from(parent.getContext()).inflate(R.layout.item_weather, parent, false);  \n     inflate(int resource, ViewGroup root, boolean attachToRoot)  \n     xml파일 item_weather을 View 객체 형태로 반환한다.\n    </span>\n- ViewHolder\n  자주 사용하는 뷰를 한번 로드하면 재사용하고 표시할 내용만 교체하기 위한 패턴 - View 안에 여러 데이터를 담고 싶을 때, getTag(), setTag()를 사용한다.  \n   <span class=\"clr-grey\">android.view.View, Tag는 Object 타입이라 다양한 용도로 사용가능</span>\n"}},{"name":"2018-12-05-android-recycler.md","oid":"d3243c845434711276363da6e3b2e4b8a276c730","content":{"__typename":"GitHub_Blob","text":"# [안드로이드] RecyclerView를 사용하자\n\n- Title : [안드로이드] RecyclerView를 사용하자\n- Date : 2018-12-05\n- Category: Android\n\n[될 때까지 안드로이드]의 RecyclerView 파트를 정리한 내용입니다.\n\n어댑터 뷰의 성능을 개선한 컴포넌트로 애니메이션을 지원하고 뷰홀더 패턴을 강제한다.  \n대신 이벤트 리스너와 커서를 지원하지 않는 단점이 있다.\n\n## 어댑터 뷰의 단점\n\n1. 빠르게 스크롤 할 때 성능문제와 불필요한 지연 문제가 있다.\n2. 데이터 목록이 변경되었을 때, <code class=\"codetainer\">notifyDataSetChanged()</code> 메서드를 빈번하게 호출하여 전체 아이템을 갱신하는 데 비용이 많이 든다. 이 메서드는 항상 전체 항목을 새로 로드한다.\n\n## 리사이클러 뷰 vs 어댑터 뷰\n\n- 상속 받는 클래스 : RecyclerView.Adapter vs BaseAdapter\n- 리사이클러 뷰는 레이아웃 매니저를 지정해줘야 한다.\n- 리사이클러 뷰는 뷰홀더 패턴을 반드시 구현해야한다.\n\n## 리사이클러 뷰 관련 클래스\n\n1. RecyclerView.Adapter : 어댑터 역할\n2. RecyclerView.ViewHolder : 뷰홀더 클래스가 상속받아야 할 클래스\n3. LayoutManager : 아이템을 어떻게 배치할 것 인가\n\n   - LinearLayoutManager\n   - GridLayoutManager\n   - StaggeredGridLayoutManager\n\n4. RecyclerView.ItemAnimator : 아이템이 추가, 삭제, 재정렬 시 애니메이션 어떻게 할 것인가\n5. RecyclerView.ItemDecoration : 아이템을 세부적으로 어떻게 꾸밀 것인가\n\n## 리사이클러 통지 메서드\n\n- <code class=\"codetainer\">notifyItemInserted(int position)</code> : position 위치의 아이템이 삽입된 것을 통지\n- <code class=\"codetainer\">notifyItemRemoved(int position)</code> : position 위치의 아이템이 삭제된 것을 통지\n\n## 관련 메서드\n\n- <code class=\"codetainer\">void setHasFixedSize (boolean hasFixedSize)</code> : 각 아이템의 변화가 리사이클러 뷰의 전체 크기에 영향을 끼치지 않는다면 true를 사용한다.\n"}},{"name":"2018-12-07-android-fragment.md","oid":"21592a4a75d3f4c8d56813075597b1287f9822f2","content":{"__typename":"GitHub_Blob","text":"# [안드로이드] fragment를 사용하자\n\n- Title : [안드로이드] fragment를 사용하자\n- Date : 2018-12-07\n- Category: Android\n\n[될 때까지 안드로이드]의 fragment 파트를 정리한 내용입니다.\n\n[기본 프래그먼트 구현 예제](https://github.com/devgaram/androidExample/tree/master/fragmentexam).  \n[다이얼로그 프래그먼트 구현 예제](https://github.com/devgaram/androidExample/tree/master/exitdialogfragment).  \n[콜백 구현 예제](https://github.com/devgaram/androidExample/tree/master/callbackexam).\n\n여러 개의 프래그먼트를 하나의 액티비티에 조합하여 창이 여러 개인 UI를 구축할 때 사용할 수 있다.\n\n- 하나의 프래그먼트를 여러 액티비티에서 재사용할 수 있으며,동적으로 추가, 삭제, 교체가 쉽다.\n- 프래그먼트는 자체 수명 주기를 가진다.\n- 프래그먼트는 부모-자식 관계를 가질 수 있다.\n\n---\n\n# 생명주기 (소속 액티비티가 실행 중일 때)\n\n최소한 다음과 같은 수명 주기 메서드를 구현해야한다.\n\n**onCreate()**  \n프래그먼트를 생성할 때 호출되는 콜백 메서드  \n프래그먼트가 일시정지되거나 중지되었다가 재개되었을 때 유지하고자 하는 것을 초기화하는 부분\n\n**onCreateView()**  \n액티비티는 <code class=\"codetainer\">onCreate()</code> 콜백 메서드에서 <code class=\"codetainer\">setContentView()</code> 메서드를 호출하여 View 객체(레이아웃)을 가져온다.  \n프래그먼트는 <code class=\"codetainer\">onCreateView()</code> 콜백 메서드에서 LayoutInflater를 통해 레이아웃을 가져온다.\n\n**onPause()**  \n시스템이 이 메서드를 호출하는 것은 사용자가 프래그먼트를 떠난다는 첫 번째 신호.  \n현재 사용자 세션을 넘어서 지속되어야 하는 변경 사항을 저장하는 부분\n\n프래그먼트 추가  \nonAttach() -> onCreate() -> onCreateView() -> onActivityCreated() -> onStart() -> onResume()\n\n프래그먼트 소멸  \nonPause() -> onStop() -> onDestroyView() -> onDestroy() -> onDetach()\n\n# 실습\n\n## 프래그먼트의 생성자\n\n생성자를 오버로드할 수 없으며, 생성자를 통해 파라미터 전달을 금지하고 있다.  \n재생성 시에 정보를 자동으로 저장 및 복원하기 위한 설계가 이미 되어 있고 그것을 따르기 위한 제약이다.\n프래그먼트의 생성과 동시에 파라미터를 전달하는 방법은 **Bundle 객체**를 활용한다.\n\n```java\npublic class ColorFragment extends Fragment {\n\n    public ColorFragment() {\n        // Required empty public constructor\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.fragment_color, container, false);\n    }\n}\n```\n\n## 프래그먼트 매니저\n\n프래그먼트 조작을 위해 프래그먼트 매니저가 필요하다.  \n프래그먼트 매니저는 액티비티 처럼 백스택을 가지고 있음.\n\n- 액티비티 내 XML에 포함된 프래그먼트를 <code class=\"codetainer\">findFragmentById()</code> 메서드로 가져오기 또는 <code class=\"codetainer\">findFragmentByTag()</code>로 가져오기\n- 액티비티 백스택에서 프래그먼트를 <code class=\"codetainer\">popBackStack()</code>메서드로 빠져나오게 하여 액티비티의 뒤로 가기와 같은 효과를 냄 ( <code class=\"codetainer\">addToBackStack()</code> : 프래그먼트 매니저의 백스택에 프래그먼트 추가하는 메서드 )\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n      ...생략...\n        FragmentManager fragmentManager = getSupportFragmentManager();\n        ColorFragment colorFragment = (ColorFragment) fragmentManager.findFragmentById(R.id.color_fragment);\n        colorFragment.setColor(Color.BLUE);\n    }\n}\n```\n\n## 프래그먼트에서 액티비티에 접근하는 방법\n\n```java\nView listView = getActivity().findViewById(R.id.list);\n```\n\n## 프래그먼트 교체, 삭제, 추가\n\n프래그먼트를 교체하기 위해서는 <fragment<fragment>>를 <FrameLayout<FrameLayout>>과 같은 레이아웃으로 감싸줘야한다.  \n**프래그먼트 트랜지션 수행** add(), remove(), replace() 같은 메서드를 사용하고 commit()을 수행하면 트랜지션이 적용된다.\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n  ...생략....\n\n    public void change(View view) {\n        ColorFragment fragment = new ColorFragment();\n        int red = new Random().nextInt(256);\n        int green = new Random().nextInt(256);\n        int blue = new Random().nextInt(256);\n        fragment.setColor(Color.rgb(red, green, blue));\n        getSupportFragmentManager()\n                .beginTransaction()\n                .replace(R.id.container, fragment)\n                .commit();\n    }\n}\n```\n\n## 프래그먼트와 액티비티 간의 통신\n\n일반적으로 액티비티에서 프래그먼트나 다른 뷰들의 인스턴스를 가지고 있어서 이들의 메서드를 호출하는 식이다. 따라서 프래그먼트의 상태가 변했을 때 액티비티에서 이것을 알아차리려면 계속해서 프래그먼트의 상태 값을 알아내는 메서드를 호출해야한다.\n\n그러나 콜백 인터페이스를 사용하여 프래그먼트의 상태가 변할 때마다 자동으로 액티비티에게 알려줄 수 있다.\nButton의 <code class=\"codetainer\">onClick()</code> 이벤트나 액티비티의 <code class=\"codetainer\">onCreate()</code>가 대표적인 콜백 메서드이며, 호출자 입장에서는 피호출자의 변화를 감시하다가 알아채기 때문에 리스너(Listener) 라고도 불른다.\n"}},{"name":"2019-01-07-android-mvvm.md","oid":"9aacac8dd60a2171340862343e0ee39877fa3df9","content":{"__typename":"GitHub_Blob","text":"# [안드로이드] 안드로이드 MVVM에 대해 알아보자1\n\n- Title : [안드로이드] 안드로이드 MVVM에 대해 알아보자1\n- Date : 2019-01-07\n- Category: Android\n\nCoding in Flow의 Room + ViewModel + LiveData + RecyclerView (MVVM) 튜토리얼을 정리했습니다.\n\n# 파일 구성\n\n- MainActivity.java\n- Note.java\n- NoteAdapter.java\n- NoteDao.interface\n- NoteDatabase.java\n- NoteRepository.java\n- NoteViewModel.java\n\n# MVVM - VIEW와 VIEWMODEL\n\n<span class=\"li-icon\">MainActivity.class : 앱의 시작점으로 RecyclerView 설정 및 ViewModel 생성하는 부분 </span>\n<span class=\"li-icon\">NoteViewModel.class : UI 컴포넌트와 UI 데이터의 분리</span>\n<span class=\"li-icon\">NoteAdapter.class : 리사이클러뷰 어댑터</span>\n<span class=\"li-icon\">NoteRepository.class : 저장소, 도메인과 모델 사이의 중간체 역할?</span>\n\n## 1. 리사이클러뷰 구현\n\n```java\nRecyclerView recyclerView = findViewById(R.id.recycler_view);\nrecyclerView.setLayoutManager(new LinearLayoutManager(this));   // 1)\nrecyclerView.setHasFixedSize(true); // 2)\n\nfinal NoteAdapter adapter = new NoteAdapter();  // 3)\nrecyclerView.setAdapter(adapter);   // 3-1)\n```\n\n1. LayoutManager 클래스, 아이템을 어떻게 배치할 것인가를 결정한다.  \n   <span class=\"clr-grey\">LinearLayoutManager 클래스 : 가로/세로 형태로 아이템을 배열한다.</span>\n\n2. 각 아이템의 변화가 리사이클러 뷰의 전체 크기에 영향을 끼치지 않는다면 true를 사용한다.\n\n3. 데이터를 리사이클러뷰에 연결해 줄 어댑터 객체 생성\n\n3-1) 3)에서 생성한 어댑터 객체를 리사이클러뷰에 붙인다.\n\n<span id=\"viewModel\"></span>\n\n## 2. ViewModel과 LiveData\n\n[뷰모델 개념 익히러가기](/android/android-viewModel/).\n\n```java\nnoteViewModel = ViewModelProviders.of(this).get(NoteViewModel.class);\n```\n\n**ViewModel 객체 요청**  \n보통 ViewModel 생성 요청은 <code class=\"codetainer\">onCreate()</code> 메서드에서 이루어지며, **ViewModelProvider 클래스**를 통해서 ViewModel 객체를 생성한다.\nViewModelProviders 클래스의 <code class=\"codetainer\">of(this)</code> 를 통해 this(UI 컨트롤러) 스코프를 가진 ViewModelProvider 인스턴스가 반환된다.\n리턴된 ViewModelProvider 객체의 메서드 <code class=\"codetainer\">get(NoteViewModel.class)</code> 를 통해 NoteViewModel 인스턴스가 생성된다.\n\n<span class=\"clr-grey\">**NOTE:** get()은 이미 ViewModel 객체가 생성되었을 경우, 그 객체를 리턴한다. </span>\n\n<span id=\"LiveData\"></span>\n**LiveData 사용**  \n[LiveData 개념 익히러가기](/android/android-LiveData/).\n\nnoteViewModel.java\n\n```java\npublic class NoteViewModel extends AndroidViewModel {\n    // ...생략\n    private LiveData<List<Note>> allNotes;\n\n    public NoteViewModel(@NonNull Application application) {\n        super(application);\n        repository = new NoteRepository(application);\n        allNotes = repository.getAllNotes();\n    }\n\n    // ...생략\n    public LiveData<List<Note>> getAllNotes() {\n        return allNotes;\n    }\n}\n```\n\nLiveData는 보통 ViewModel 내에서 함께 쓰인다.\n\nMainActivity.java\n\n```java\nnoteViewModel.getAllNotes().observe(this, new Observer<List<Note>>() {  // 1) LifeCycleOwner, Observer\n    @Override\n    public void onChanged(@Nullable List<Note> notes) { // 2)\n        // update RecyclerView\n        // Toast.makeText(MainActivity.this, \"onchanged\", Toast.LENGTH_SHORT).show();\n        adapter.setNotes(notes);\n    }\n});\n```\n\n1. <code class=\"codetainer\">noteViewModel.getAllNotes()</code>를 통해 LiveData를 리턴받고 <code class=\"codetainer\">observe()</code> 메서드를 통해 Observer를 붙여 감지를 시작한다.\n   <span class=\"clr-grey\">보통 Observer는 프래그먼트나 액티비티 같은 UI 컨트롤러에서 만든다.</span>  \n   <span class=\"clr-note\">LiveData의 data가 변경될 때 LifeCycleOwner가 활성화 되어있는 한 등록된 모든 Observer들 에게 이벤트를 보낸다.</span>\n\n2. Observer는 <code class=\"codetainer\">onChanged()</code> 메서드를 반드시 오버라이드해야하며, <code class=\"codetainer\">onChanged()</code> 메서드에서 UI 업데이트를 한다.\n\n# MVVM - MODEL\n\n<span class=\"li-icon\">NoteDatabase.class</span>\n<span class=\"li-icon\">NoteDao.interface</span>\n<span class=\"li-icon\">Note.class</span>\n\nRoom은 SQLite 추상계층을 감싸고 있으며, 쉽게 데이터베이스에 접근하여 SQLite를 자유롭게 사용할 수 있다. Room에는 세가지 주요한 컴포넌트가 있다.\n\n## 1. Database (NoteDatabase.class)\n\n데이터베이스 홀더를 포함하고, 관계형 데이터베이스에 접근할 수 있는 액세스 포인트를 제공한다.\n\n```java\n@Database(entities = {Note.class}, version = 1, exportSchema = false)   // 1)\npublic abstract class NoteDatabase extends RoomDatabase {\n\n    private static NoteDatabase instance;\n\n    public abstract NoteDao noteDao();  // 3)\n\n    public static synchronized NoteDatabase getInstance(Context context) {\n        if (instance == null) {\n            instance = Room.databaseBuilder(context.getApplicationContext(),    // 4)\n                    NoteDatabase.class, \"note_database\")\n                    .fallbackToDestructiveMigration()\n                    .addCallback(roomCallback)\n                    .build();\n        }\n        return instance;\n    }\n    // ..생략\n}\n```\n\n1. @Database 애노테이션을 클래스에 달아야하며, 데이터베이스와 관련된 Entity들은 애노테이션 인자값으로 포함해야한다.\n2. RoomDatabase를 상속한 abstract class여야 한다.\n3. abstract method 포함해야하는데, 이 메소드에는 인자가 0개이고 reture되는 클래스가 @Dao 애노테이션을 달고 있어야한다.\n4. 런타임때에는 Room.databaseBuilder() 또는 Room.inMemoryDatabaseBuilder()를 통해 Database의 객체를 얻어 낼 수 있다.\n\n<span class=\"clr-grey\">**Note:** RoomDatabase 객체를 인스턴스화 하는 비용은 매우 크므로 인스턴스를 얻는 작업을 싱글톤패턴으로 만드는 게 좋다.</span>\n\n```java\n@Database(entities = {Note.class}, version = 1, exportSchema = false)   // 1)\npublic abstract class NoteDatabase extends RoomDatabase {\n    private static NoteDatabase instance;\n    public abstract NoteDao noteDao();\n    // ..생략\n\n    private static RoomDatabase.Callback roomCallback = new RoomDatabase.Callback() {\n\n        // 데이터베이스가 처음 생성될 때 호출됨, 모든 테이블이 생성된 후 호출됨.\n        @Override\n        public void onCreate(@NonNull SupportSQLiteDatabase db) {\n            super.onCreate(db);\n            new PopulateDbAsyncTask(instance).execute(); // AsyncTask 실행\n        }\n    };\n\n    private static class PopulateDbAsyncTask extends AsyncTask<Void, Void, Void> {\n        private NoteDao noteDao;\n\n        private PopulateDbAsyncTask(NoteDatabase db) {\n            noteDao = db.noteDao();\n        }\n\n        @Override\n        protected Void doInBackground(Void... voids) {\n            noteDao.insert(new Note(\"Title 1\", \"Description 1\", 1));\n            noteDao.insert(new Note(\"Title 2\", \"Description 2\", 2));\n            noteDao.insert(new Note(\"Title 3\", \"Description 3\", 3));\n\n            return null;\n        }\n    }\n}\n```\n\n**AsyncTask클래스**  \n비즈니스 로직과 UI 컴포넌트 조작이 동시에 일어나야 할 때 유용하며, 비교적 오래 걸리지 않는 작업에 적합하다. 또한, task 캔슬이 용이하다.\n\nAsyncTask <Params, Progress, Result> 제너릭 타입\n<span class=\"li-icon\">Params: doInBackground 파라미타 타입이며, execute 메소드의 인자 값이 된다.</span>\n<span class=\"li-icon\">Progress: doInBakcgroud 작업 시 진행 단위의 타입으로 onProgressUpdate 파라미터의 타입이다.</span>\n<span class=\"li-icon\">doInBackground 리턴값으로 onPostExecute 파라미터 타입이다.</span>\n\n<span class=\"clr-grey\">**제네릭스(Generics):** 객체 생성시 타입을 선언하므로 캐스팅할 필요가 없으며, 다른 타입을 할당할 경우 컴파일 단계에서 예외처리가 된다. <T>는 객체(Object) 타입이다.</span>\n\n## 2. Entity (Note.class)\n\nEntity를 사용하여 데이터 구조를 정의하고, 데이터베이스 테이블을 표현한다.\n\n```java\n@Entity(tableName = \"note_table\")   // tableName 속성 : 테이블명을 Note로 사용하고 싶지 않을 때\npublic class Note {\n\n    @PrimaryKey(autoGenerate = true)    // 기본키 정의 필수\n    private int id;\n    @ColumnInfo(name = \"Notetitle\") // name 속성 : 필드명을 다르게 지정하고 싶을 때\n    private String title;\n    private String description;\n    private int priority;\n    @Ignore // 데이터베이스에서 칼럼으로 생성되기를 원치 않을 때\n    Bitmap picture;\n\n    public Note(String title, String description, int priority) {\n        this.title = title;\n        this.description = description;\n        this.priority = priority;\n    }\n\n    // ..생략 (반드시, getter setter 필요)\n}\n```\n\n## 3. DAO (NoteDao.interface)\n\n데이터베이스의 데이터에 접근하기 위해서는 DAO가 필요하다. 직접적인 쿼리를 작성하는 대신 DAO 클래스를 사용하여 데이터베이스에 추상적으로 접근한다. <span class=\"clr-note\">DAO는 interface나 abstract class가 되야한다.</span>\n\n```java\n@Dao\npublic interface NoteDao {\n\n    @Insert\n    void insert(Note note);\n\n    @Update\n    void update(Note note);\n\n    @Delete\n    void delete(Note note);\n\n    @Query(\"DELETE FROM note_table\")\n    void deleteAllNotes();\n\n    @Query(\"SELECT * FROM note_table ORDER BY priority DESC\")\n    LiveData<List<Note>> getAllNotes();\n}\n```\n"}},{"name":"2019-01-07-android-viewModel.md","oid":"e904a40fa0b358c66e6c794f773f77275fcba701","content":{"__typename":"GitHub_Blob","text":"# [안드로이드] 안드로이드 ViewModel에 대해 알아보자\n\n- Title : [안드로이드] 안드로이드 ViewModel에 대해 알아보자\n- Date : 2019-01-07\n- Category: Android\n\n안드로이드 아키텍쳐 중 ViewModel 클래스에 대한 내용입니다.\n\n안드로이드 프레임워크는 액티비티와 프래그먼트와 같은 UI 컨트롤러의 라이프 사이클을 관리한다.\n\n![액티비티가 회전을 거쳐 끝날 때까지의 라이프 사이클](https://raw.githubusercontent.com/devgaram/TIL/master/Android/images/2019-01-07-img/viewmodel-lifecycle.png)  \n[ UI 컨트롤러 라이프 사이클과 ViewModel 스코프]\n\n아래와 같은 구성 변경 발생 시, 안드로이드는 UI 컨트롤러를 종료하거나 재생성한다.\n\n- 런타임에 화면 방향이 전환되는 경우\n- 언어, 글꼴 배율과 같은 기기 구성이 변경되는 경우\n\n이 때 두가지 문제가 발생한다.\n\n## 1) UI에 종속된 데이터 손실\n\n해결1 - 적은 데이터의 경우 <code class=\"codetainer\">OnCreate()</code>에서 <code class=\"codetainer\">onSaveInstanceState()</code> 메서드를 사용하여 번들에서 해당 데이터를 복원할 수 있다.\n<span class=\"clr-grey\">많은 데이터와 비트맵에는 부적절하다.</span>  \n해결2 - UI가 없는 워커 프래그먼트에 UI에 필요한 데이터를 관리하고 프래그먼트를 <code class=\"codetainer\">SetRetainInstance(true)</code>로 설정함으로써 프래그먼트를 메모리에 유지(유보)시킨다.\n\n## 2) 메모리 누수, 리소스 낭비\n\nUI 컨트롤러 재생성 시 다시 데이터를 로드하므로 리소스가 낭비되며, UI 컨트롤러가 비동기 호출을 하고 콜백을 받을 때 해당 컨트롤러가 파괴되었다면 에러가 발생하거나 메모리 누수가 날 수도 있다.\n\n## 문제해결방법\n\nUI 컨트롤러는 아래와 같은 작업을 다루는 경향이 있다.\n\n- UI 데이터 표시\n- 사용자 행동에 반응\n- 권한 요청\n\n그러므로 데이터베이스 또는 네트워크에서 데이터를 요청하고 로드하는 작업은 다른 클래스에 위임하여 UI 컨트롤러 로직에서 뷰 데이터에 대한 소유권을 분리하는 것이 효율적이다.\n\n# ViewModel 클래스 구현\n\n[예제로 바로가기](/android/android-mvvm/#viewModel).\n\nArchitecture Components는 ViewModel 클래스를 제공한다.  \n**ViewModel 클래스의 인스턴스(객체)는 구성 변경에도 데이터를 유지하며, ViewModel 인스턴스는 재생성된 액티비티에서 즉시 사용될 수 있다.**\n소유자가 액티비티를 끝낼 때, 안드로이드는 ViewModel 객체의 <code class=\"codetainer\">onCleared()</code> 메서드를 호출하여 리소스를 정리한다.\n\n<span class=\"clr-note\">\nViewModel 사용 시 ViewModel에 액티비티, 프래그먼트, 뷰에 대한 컨텍스트를 저장해서는 안된다.     \n</span>\n\n<span class=\"clr-grey\">액티비티가 재생성 될 때, ViewModel은 액티비티 생명주기 외부에 존재하기 때문에 UI 컨텍스트를 ViewModel에 저장하면 메모리 락을 발생시키는 직접적인 원인이 된다. 단, Application 컨텍스트(전체 앱의 수명주기)를 저장하는 것은 괜찮다. Application 컨텐스트는 AndroidViewModel 클래스를 통해 받을 수 있다.\n"}},{"name":"2019-01-09-android-LiveData.md","oid":"92b42dd986f3a755361f0a2640d33d0bb9c70fd3","content":{"__typename":"GitHub_Blob","text":"# [안드로이드] 안드로이드 LiveData 대해 알아보자\n\n- Title : [안드로이드] 안드로이드 LiveData 대해 알아보자\n- Date : 2019-01-09\n- Category: Android\n\nLiveData 클래스를 통해 데이터 변경을 감지해보자.\n\n[안드로이드 개발문서-LiveData](https://developer.android.com/topic/libraries/architecture/livedata#java).\n\n# LiveData는 LifecycleOwner의 라이프사이클을 알고있다.\n\nLiveData 객체는 <code class=\"codetainer\">observe()</code> 메서드를 통해 <code class=\"codetainer\">LifecycleOwner</code>와 <code class=\"codetainer\">Observer</code>객체를 페어로 등록한다.  \nObserver 객체는 페어인 LifecycleOwner가 활성상태(<code class=\"codetainer\">STARTED</code> 또는 <code class=\"codetainer\">RESUMED</code>)일 때, 데이터 변화을 관측할 수 있다.\n반대로, LiveData 객체는 LifecycleOwner가 비활성 상태면 LiveData의 변화를 Observer에게 전달하지 않으며, LifecycleOwner가 <code class=\"codetainer\">DESTROYED</code> 상태라면 자동으로 제거된다.\n이러한 LiveData의 라이프사이클의 인지는 메모리 누수에 대한 걱정을 덜어주며, UI 컴포넌트(액티비티, 프래그먼트)를 사용할 때 유용하다.  \n<span class=\"clr-grey\">**Note:** LifecycleOwner의 비활성 상태 예시) 액티비티가 백 스택에 올라가있을 때 </span>\n\n# LiveData 사용시 이점\n\n<span class=\"li-icon\">일반적인 Observable과 달리, LifecycleOwner가 활성 상태일 때, LiveData의 변화를 Observer 객체에 전달함</span>\n<span class=\"li-icon\">충돌방지 : 액티비티가 백스택(비활성)에 있을 때, LiveData의 변화 이벤트를 Observer에게 전달하지 않음</span>\n<span class=\"li-icon\">메모리누수방지 : <code class=\"codetainer\">DESTROYED</code> 시, LiveData 제거</span>\n<span class=\"li-icon\">생명주기 수동으로 관리할 필요 없음</span>\n<span class=\"li-icon\">항상 최신 데이터 유지 가능 : 액티비티가 다시 활성상태로 돌아온 즉시 최신 데이터를 받는다.</span>\n<span class=\"li-icon\">환경변화(예,화면회전)로 UI 컴포넌트 재생성 시, 즉시 최신 데이터를 받는다.</span>\n<span class=\"li-icon\">LiveData를 상속받아 앱에서 자원 공유 가능</span>\n\n# LiveData 사용하기\n\n[예제로 바로가기](/android/android-mvvm/#LiveData).\n\n## 1. LiveData 객체 생성하기\n\nLiveData는 보통 <code class=\"codetainer\">Collections</code> 인터페이스를 구현한 클래스(List, Map, Set)를 사용하며, <code class=\"codetainer\">ViewMoodel</code> 객체 안에 저장된다.\n\n```java\npublic class NameViewModel extends ViewModel {\n  // String 타입의 LiveData 생성\n  private MutableLiveData<String> mCurrentName;\n\n    public MutableLiveData<String> getCurrentName() {\n        if (mCurrentName == null) {\n            mCurrentName = new MutableLiveData<String>();\n        }\n        return mCurrentName;\n    }\n\n// ..생략\n}\n```\n\n## 2. LiveData 객체 관찰하기\n\n<code class=\"codetainer\">onCreate()</code> 메서드에서 LiveData 관찰을 시작하는 것이 좋다.\n<span class=\"li-icon\"><code class=\"codetainer\">onResume()</code> 메서드에서 사용 시 중복 호출이 발생된다.</span>\n<span class=\"li-icon\"><code class=\"codetainer\">STARTED</code> 상태가 되자마자 LiveData 객체의 최신 데이터를 받을 수 있다.</span>\n\n```java\npublic class NameActivity extends AppCompatActivity {\n\n    private NameViewModel mModel;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        // ..생략\n\n        // ViewModel 얻기\n        mModel = ViewModelProviders.of(this).get(NameViewModel.class);\n\n\n        // 옵저버 생성\n        final Observer<String> nameObserver = new Observer<String>() {\n            @Override\n            public void onChanged(@Nullable final String newName) {\n                // Update the UI, in this case, a TextView.\n                mNameTextView.setText(newName);\n            }\n        };\n\n        // LiveData 관찰 시작\n        mModel.getCurrentName().observe(this, nameObserver);\n    }\n}\n```\n\n## 3. LiveData 객체 업데이트하기\n\nLiveData는 데이터를 업데이트 하는 publid 메서드를 가지고 있지 않으므로, LiveData를 상속받은 <code class=\"codetainer\">MutableLiveData</code>를 사용해야한다.\n<code class=\"codetainer\">MutableLiveData</code>는 <code class=\"codetainer\">public setValue(T)</code>와 <code class=\"codetainer\">public postValue(T)</code> 메서드를 가지고 있어서 이를 통해 데이터를 변경할 수 있다.\n\n```java\nmButton.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        String anotherName = \"John Doe\";\n        mModel.getCurrentName().setValue(anotherName);\n    }\n});\n```\n\n<code class=\"codetainer\">setValue(T)</code>와 <code class=\"codetainer\">postValue(T)</code>는 호출 시 Observer의 <code class=\"codetainer\">onChanged()</code> 메서드가 호출되어 UI가 업데이트 된다.\n"}},{"name":"2019-01-16-android-drawable.md","oid":"57a9a023880800c47fc8fb09eb9ea97232df6cad","content":{"__typename":"GitHub_Blob","text":"# [Drawable 리소스] LayerDrawable과 ShapeDrawable을 이용해 둥근모서리와 그림자 있는 배경 만들기.\n\n- Title : [Drawable 리소스] LayerDrawable과 ShapeDrawable을 이용해 둥근모서리와 그림자 있는 배경 만들기.\n- Date : 2019-01-16\n- Category: Android\n\nLayerDrawable과 ShapeDrawable을 이용해 둥근모서리+그림자+투명배경이 있는 디자인을 다른 XML 리소스의 background로 적용하는 방법입니다.\n\n[안드로이드 개발문서-Drawable 바로가기](https://developer.android.com/guide/topics/resources/drawable-resource?hl=ko)\n\n## 드로어블(Drawable) 리소스\n\n앱 화면에 그리고 싶은 것을 XML 파일로 미리 정의할 수 있으며, <code class=\"codetainer\">getDrawable(int)</code>와 같은 API를 사용하여 가져오거나\n<code class=\"codetainer\">android:drawable</code> 및 <code class=\"codetainer\">android:icon</code>과 같은 속성을 사용하여 다른 XML 리소스에 적용할 수 있다.  \n<span class=\"clr-grey\">**Example)** android:background=\"@drawable/custom_layer_resource\"</span>\n\n# LayerDrawable\n\n각 `<item>` 요소는 순서대로 그려지므로, 맨 마지막 `<item>`이 맨 위에 보이게 된다.\n\n<span class=\"li-nonicon\">위치 : res/drawable/filename.xml</span>\n<span class=\"li-nonicon\">Java 리소스 참조 : R.drawable.filename</span>\n<span class=\"li-nonicon\">XML 리소스 참조 : @[package:]drawable/filename</span>\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list\n    xmlns:android=\"http://schemas.android.com/apk/res/android\" ><!-- XML 네임스페이스 정의 필수 -->\n    <item\n        android:drawable=\"@[package:]drawable/drawable_resource\"\n        android:id=\"@[+][package:]id/resource_name\"\n        android:top=\"dimension\"\n        android:right=\"dimension\"\n        android:bottom=\"dimension\"\n        android:left=\"dimension\" />\n</layer-list>\n```\n\n<span class=\"li-icon\"><code class=\"codetainer\">android:top=\"dimension\"</code> top에서 dimension 값만큼 padding</span>\n\n# ShapeDrawable\n\n<span class=\"li-nonicon\">위치 : res/drawable/filename.xml</span>\n<span class=\"li-nonicon\">Java 리소스 참조 : R.drawable.filename</span>\n<span class=\"li-nonicon\">XML 리소스 참조 : @[package:]drawable/filename</span>\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<shape\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:shape=[\"rectangle\" | \"oval\" | \"line\" | \"ring\"] >\n    <corners\n        android:radius=\"integer\"\n        android:topLeftRadius=\"integer\"\n        android:topRightRadius=\"integer\"\n        android:bottomLeftRadius=\"integer\"\n        android:bottomRightRadius=\"integer\" />\n    <gradient\n        android:angle=\"integer\"\n        android:centerX=\"float\"\n        android:centerY=\"float\"\n        android:centerColor=\"integer\"\n        android:endColor=\"color\"\n        android:gradientRadius=\"integer\"\n        android:startColor=\"color\"\n        android:type=[\"linear\" | \"radial\" | \"sweep\"]\n        android:useLevel=[\"true\" | \"false\"] />\n    <padding\n        android:left=\"integer\"\n        android:top=\"integer\"\n        android:right=\"integer\"\n        android:bottom=\"integer\" />\n    <size\n        android:width=\"integer\"\n        android:height=\"integer\" />\n    <solid\n        android:color=\"color\" />\n    <stroke\n        android:width=\"integer\"\n        android:color=\"color\"\n        android:dashWidth=\"integer\"\n        android:dashGap=\"integer\" />\n</shape>\n```\n\n<span class=\"li-icon\"><code class=\"codetainer\">corners : </code>둥근모서리</span>\n<span class=\"li-icon\"><code class=\"codetainer\">gradient : </code>그라데이션 색상</span>\n<span class=\"li-icon\"><code class=\"codetainer\">padding : </code>shape가 아닌 view 요소에 적용할 패딩</span>\n<span class=\"li-icon\"><code class=\"codetainer\">size : </code>shape 크기</span>\n<span class=\"li-icon\"><code class=\"codetainer\">solid : </code>채우기 색상</span>\n<span class=\"li-icon\"><code class=\"codetainer\">stroke : </code>선 속성</span>\n\n# 실전예제\n\n1. 둥근모서리+그림자+투명배경 드로어블 생성하기\n\nres/drawable/round_border.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\" >\n    <item>\n        <shape android:shape=\"rectangle\" >\n            <solid android:color=\"@android:color/darker_gray\" />\n        </shape>\n    </item>\n    <item\n        android:bottom=\"-2dp\"\n        android:left=\"2dp\"\n        android:right=\"2dp\"\n        android:top=\"2dp\">\n        <shape android:shape=\"rectangle\" >\n            <stroke\n                android:width=\"0.75dp\"\n                android:color=\"#f5f5f5\" />\n            <corners\n                android:topLeftRadius=\"10dp\"\n                android:topRightRadius=\"10dp\"/>\n            <solid android:color=\"#3cffffff\" />\n        </shape>\n    </item>\n</layer-list>\n```\n\n2. round_border를 LinearLayout의 배경으로 적용하기\n\n```xml\n<LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"10dp\"\n        android:background=\"@drawable/round_border\">\n</LinearLayout>\n```\n"}},{"name":"2019-01-21-android-animate.md","oid":"5e41146edb49643835d7c14219615e273c6680a1","content":{"__typename":"GitHub_Blob","text":"# 안드로이드에서 이미지 애니메이션 구현 방법\n\n- Title : 안드로이드에서 이미지 애니메이션 구현 방법\n- Date : 2019-01-21\n- Category: Android\n\n이미지 애니메이션 구현 방법에는 다음과 같이 1)Animation Drawable과 2)Animated vector Drawable 두가지 옵션이 있다.\n\n[안드로이드 개발문서-Animate drwable graphics 바로가기](https://developer.android.com/guide/topics/graphics/drawable-animation?hl=ko)\n[Icon Animation 참고 문서](https://www.androiddesignpatterns.com/2016/11/introduction-to-icon-animation-techniques.html)\n\n**Animation Drawable** : 몇 개의 정적 drawable 파일들을 순차적으로 보여주는 방식으로 애니메이션을 구현하고 싶을 때(프레임 애니메이션)  \n**AnimatedVectorDrawable** : 하나의 아이콘이 다른 이미지로 서서히 변화되는(morph) 애니메이션을 구현하고 싶을 때\n\n# AnimationDrawable 사용하기\n\n프레임 애니메이션 구현 [예제](https://github.com/devgaram/AndroidBudgeter/blob/master/app/src/main/res/drawable/ani_emotion.xml)\n\nres/drawable/ani_emotion.xml\n\n```xml\n<animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:oneshot=\"false\">\n    <item android:drawable=\"@drawable/emotion_mouth_1\" android:duration=\"5000\" />\n    <item android:drawable=\"@drawable/emotion_mouth_2\" android:duration=\"5000\" />\n    <item android:drawable=\"@drawable/emotion_mouth_3\" android:duration=\"5000\" />\n    <item android:drawable=\"@drawable/emotion_mouth_4\" android:duration=\"5000\" />\n    <item android:drawable=\"@drawable/emotion_mouth_5\" android:duration=\"5000\" />\n</animation-list>\n```\n\n<span class=\"li-icon\"><code class=\"codetainer\">android:oneshot</code> : true 한번만, false 반복</span>\n\nres/drawable/emotion_mouth_1.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item\n        android:top=\"@dimen/mb_l\">\n        <shape\n            xmlns:android=\"http://schemas.android.com/apk/res/android\"\n            android:shape=\"rectangle\">\n            <size\n                android:width=\"120dp\"\n                android:height=\"60dp\"></size>\n            <solid android:color=\"@color/colorDefaultFont\"/>\n            <corners\n                android:topRightRadius=\"60dp\"\n                android:topLeftRadius=\"60dp\"></corners>\n        </shape>\n    </item>\n</layer-list>\n```\n\n<span class=\"li-icon\">ShapeDrawable로 입모양 그린 XML 파일</span>\n\nres/drawable/activity_main.xml\n\n```xml\n<ImageView\n            android:id=\"@+id/emotion_mouth\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_gravity=\"center\"\n            android:src=\"@drawable/ani_emotion\" />\n```\n\nMainActivity.java\n\n```java\nAnimationDrawable emotionAnimation;\n\npublic void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.main);\n\n  ImageView emotionImage  = (ImageView) findViewById(R.id.emotion_mouth);\n  emotionImage.setImageResource(R.drawable.ani_emotion);\n  emotionAnimation = (AnimationDrawable) emotionImage.getDrawable();\n\n  emotionImage.setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View view) {\n        emotionAnimation.start();\n      }\n  });\n}\n```\n\n<span class=\"clr-note\">**Note:** </span><span class=\"clr-grey\"><code class=\"codetainer\">onCreate()</code> 메서드에선 <code class=\"codetainer\">AnimationDrawable</code>가 완전히 로드되지 않으므로 <code class=\"codetainer\">start()</code> 메서드를 사용할 수 없고,\n만약 애니메이션 즉시 실행을 원한다면 액티비티의 <code class=\"codetainer\">onStart()</code> 메서드에서 <code class=\"codetainer\">start()</code> 메서드를 호출해야한다.</span>\n\n# AnimatedVectorDrawable 사용하기\n\n[안드로이드 개발문서-AnimatedVectorDrawable 바로가기](https://developer.android.com/reference/android/graphics/drawable/AnimatedVectorDrawable?hl=ko)\n\nvectorDrawable은 흐려지거나 픽셀화되는 현상 없이 확장가능한 드로어블 타입이다.  \nvectorDrawable 애니메이션을 구현하기 위해서는 3개의 xml 파일이 필요하다.\n\n## 1) vectorDrawable\n\n| Element Name  | Animatable attribute name                                                                                                      |\n| ------------- | ------------------------------------------------------------------------------------------------------------------------------ |\n| `<vector>`    | alpha                                                                                                                          |\n| `<group>`     | rotation, pivotX, pivotY, scaleX, scaleY, translateX, translateY                                                               |\n| `<path>`      | pathData, fillColor, strokeColor, strokeColor, strokeWidth, strokeAlpha, fillAlpha, trimPathStart, trimPathEnd, trimPathOffset |\n| `<clip-path>` | pathData                                                                                                                       |\n\n```xml\n <!--res/drawable/vectordrawable.xml-->\n <vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n     android:height=\"64dp\"\n     android:width=\"64dp\"\n     android:viewportHeight=\"600\"\n     android:viewportWidth=\"600\" >\n     <group\n         android:name=\"rotationGroup\"\n         android:pivotX=\"300.0\"\n         android:pivotY=\"300.0\"\n         android:rotation=\"45.0\" >\n         <path\n             android:name=\"v\"\n             android:fillColor=\"#000000\"\n             android:pathData=\"M300,70 l 0,-70 70,70 0,0 -70,70z\" />\n     </group>\n </vector>\n```\n\n## 2) AnimatedVectorDrawable\n\n<span class=\"li-nonicon\">한 개의 `android:drawable` 속성과 하나 이상의 `<target>`을 가진다.</span>\n<span class=\"li-nonicon\">`<target>` 은 `android:name` 속성으로 `ObjectAnimator` 또는 `AnimatorSet`의 타겟이 되는 `vectorDrawable`을 명시한다.\n<span class=\"clr-grey\">**Note:** 타겟은 vectorDrawable의 group element 또는 path element가 될 수 있다.</span></span>\n\n```xml\n<!--res/drawable/animatedVector.xml-->\n<animated-vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n     android:drawable=\"@drawable/vectordrawable\" >\n     <target\n         android:name=\"rotationGroup\"\n         android:animation=\"@animator/rotation\" />\n     <target\n         android:name=\"v\"\n         android:animation=\"@animator/path_morph\" />\n </animated-vector>\n```\n\n<span class=\"li-icon\">vectorDrawable에서 rotationGroup 이름 속성을 가진 `<group>` 엘리먼트에 rotation 애니메이션을 적용</span>\n<span class=\"li-icon\">vectorDrawable에서 v 이름 속성을 가진 `<path>` 엘리먼트에 path_morph 애니메이션을 적용</span>\n\n## 3) ObjectAnimator or AnimatorSet 애니메이션 정의\n\n애니메이션은 `ObjectAnimator` 와 `AnimatorSet`으로 정의할 수 있다.\n\n```xml\n<!-- res/animator/rotation.xml -->\n<objectAnimator\n    android:duration=\"6000\"\n    android:propertyName=\"rotation\"\n    android:valueFrom=\"0\"\n    android:valueTo=\"360\" />\n```\n\n6초동안 360도 회전하는 애니메이션\n\n```xml\n<!-- res/animator/path_morph.xml -->\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <objectAnimator\n        android:duration=\"3000\"\n        android:propertyName=\"pathData\"\n        android:valueFrom=\"M300,70 l 0,-70 70,70 0,0   -70,70z\"\n        android:valueTo=\"M300,70 l 0,-70 70,0  0,140 -70,0 z\"\n        android:valueType=\"pathType\" />\n</set>\n```\n\n3초동안 모양 바뀌는 애니메이션(morph)  \n<span class=\"clr-note\">**Note:** `android:valueFrom` 과 `android:valueTo`의 명령 순서와 파라미터 값은 동일해야한다.</span>  \n<span class=\"clr-grey\">**Note:** path 값은 string 리소스에 저장하는 것을 추천한다.</span>\n\n## 4) 3개의 xml을 AAPT 툴의 지원으로 하나의 xml에 정의할 수 있다.\n\n```xml\n <animated-vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n                  xmlns:aapt=\"http://schemas.android.com/aapt\" >\n     <aapt:attr name=\"android:drawable\">\n         <vector\n             android:height=\"64dp\"\n             android:width=\"64dp\"\n             android:viewportHeight=\"600\"\n             android:viewportWidth=\"600\" >\n             <group\n                 android:name=\"rotationGroup\"\n                 android:pivotX=\"300.0\"\n                 android:pivotY=\"300.0\"\n                 android:rotation=\"45.0\" >\n                 <path\n                     android:name=\"v\"\n                     android:fillColor=\"#000000\"\n                     android:pathData=\"M300,70 l 0,-70 70,70 0,0 -70,70z\" />\n             </group>\n         </vector>\n     </aapt:attr>\n\n     <target android:name=\"rotationGroup\"> *\n         <aapt:attr name=\"android:animation\">\n             <objectAnimator\n             android:duration=\"6000\"\n             android:propertyName=\"rotation\"\n             android:valueFrom=\"0\"\n             android:valueTo=\"360\" />\n         </aapt:attr>\n     </target>\n\n     <target android:name=\"v\" >\n         <aapt:attr name=\"android:animation\">\n             <set>\n                 <objectAnimator\n                     android:duration=\"3000\"\n                     android:propertyName=\"pathData\"\n                     android:valueFrom=\"M300,70 l 0,-70 70,70 0,0 -70,70z\"\n                     android:valueTo=\"M300,70 l 0,-70 70,0  0,140 -70,0 z\"\n                     android:valueType=\"pathType\"/>\n             </set>\n         </aapt:attr>\n      </target>\n </animated-vector>\n```\n\n## 5) 정의한 애니메이션 적용하기\n\nres/drawable/activity_main.xml\n\n```xml\n<ImageView\n            android:id=\"@+id/emotion_mouth\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_gravity=\"center\"\n            android:src=\"@drawable/animatedVector\" />\n```\n\nMainActivity.java\n\n```java\n ImageView emotionImage;\n\npublic void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.main);\n\n  emotionImage  = (ImageView) findViewById(R.id.emotion_mouth);\n\n  emotionImage.setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View view) {\n        Drawable drawable = emotionImage.getDrawable();\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n                if (drawable instanceof AnimatedVectorDrawable) {\n                    AnimatedVectorDrawable animatedVectorDrawable = (AnimatedVectorDrawable) drawable;\n                    animatedVectorDrawable.start();\n                }\n            } else {\n                if (drawable instanceof AnimatedVectorDrawableCompat) {\n                    AnimatedVectorDrawableCompat animatedVectorDrawableCompat = (AnimatedVectorDrawableCompat) drawable;\n                    animatedVectorDrawableCompat.start();\n                }\n            }\n      }\n  });\n\n}\n```\n"}},{"name":"2019-03-10-android-error-1.md","oid":"116b6712fdb1d1bdf026420e0835d318758c57da","content":{"__typename":"GitHub_Blob","text":"# 안드로이드 에러 - setText의 파라미터로 숫자를 전달했을 때\n\n- Title : 안드로이드 에러 - setText의 파라미터로 숫자를 전달했을 때\n- Date : 2019-03-10\n- Category: Android\n\nsetText의 파라미터로 숫자를 전달했을 때 발생되는 에러로그\n\n에러로그\n\n```\nandroid.content.res.Resources$NotFoundException: String resource ID #0x1f40\nat android.content.res.Resources.getText(Resources.java:354)\nat android.widget.TextView.setText(TextView.java:6133)\nat org.androidtown.mybudgeter.pager.ExpenditureRecyclerAdapter.onBindViewHolder(ExpenditureRecyclerAdapter.java:30)\nat org.androidtown.mybudgeter.pager.ExpenditureRecyclerAdapter.onBindViewHolder(ExpenditureRecyclerAdapter.java:16)\n....\n```\n\n```java\nexpenditureAmount.setText(currentExpenditure.getAmount());\n```\n\n에러로그는 위와 같은 코드에서 발생된 것으로, setText에 Integer 값을 전달했을 때 경우이다.  \nInteger값을 String으로 변환해주면 에러가 수정된다.\n\n```java\nexpenditureAmount.setText(Integer.toString(currentExpenditure.getAmount()));\n```\n"}},{"name":"images","oid":"a4eaa1b3f62fc6ff075a5b63044aa92685b914c1","content":{"__typename":"GitHub_Tree"}}]}},{"name":"Database","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":"2018-01-26-mssql-tip-1.md","oid":"a4f5ba562def4c89e50365067823859bbeb87faf","content":{"__typename":"GitHub_Blob","text":"# mssql 쿼리 팁 - 여러 행의 데이터를 한 칼럼에 담기\n\n- Title : mssql 쿼리 팁 - 여러 행의 데이터를 한 칼럼에 담기\n- Date : 2018-01-26\n- Category: Database\n\n<table class=\"half\">\n<thead>\n\t<tr><th>IDX</th><th>NAME </th></tr>\n</thead>\n<tbody>\n\t<tr><td>1</td><td>A</td></tr>\n\t<tr><td>1</td><td>B</td></tr>\n\t<tr><td>1</td><td>C</td></tr>\n\t<tr><td>2</td><td>B</td></tr>\n\t<tr><td>2</td><td>D</td></tr>\n</tbody>\n</table>\n\n위 테이블을 아래와 같이 출력하고 싶다.\n\n<table class=\"half\">\n<thead>\n\t<tr><th>IDX</th><th>NAME </th></tr>\n</thead>\n<tbody>\n\t<tr><td>1</td><td>A,B,C</td></tr>\n\t<tr><td>2</td><td>B,D</td></tr>\t\n</tbody>\n</table>\n\n<br/><br/>\n\n```sql\nSELECT\n\tDISTINCT IDX,\n\tSTUFF\n\t( (\n\t\tSELECT ',' + NAME FROM TB_NAME A WHERE A.IDX = B.IDX\n\t\tFOR XML PATH('')\n\t),1,1,'') AS NAME\nFROM TB_NAME B\n```\n\nSTUFF(STRING,1,1,'') - 맨 앞 문자 한개 제거\n\n# STUFF 함수\n\n[참고페이지](https://docs.microsoft.com/ko-kr/sql/t-sql/functions/stuff-transact-sql)\n\nSTUFF ( character_expression , start , length , replaceWith_expression )\n\n<table>\n<thead>\n\t<tr><th>인수</th><th>설명</th></tr>\n</thead>\n<tbody>\n\t<tr><td>start</td><td>삭제 및 삽입 시작 위치, 0, 음수면 NULL이 반환된다.</td></tr>\n\t<tr><td>length</td><td>삭제 할 문자 수 지정, 0, 음수면 NULL이 반환된다.</td></tr>\t\n\t<tr><td>replaceWith_expression </td><td>''이면 아무것도 삽입하지 않고 문자를 제거</td></tr>\t\n</tbody>\n</table>\n"}},{"name":"2019-03-07-mssql-speed-improvement.md","oid":"d17108af7f9cb5a3406d3826c036d4f5719706ee","content":{"__typename":"GitHub_Blob","text":"# mssql 쿼리 팁 - group by 없이 카운트하는 방법 & 페이징 처리를 위한 전체 레코드 갯수 구하기\n\n- Title : mssql 쿼리 팁 - group by 없이 카운트하는 방법 & 페이징 처리를 위한 전체 레코드 갯수 구하기\n- Date : 2019-03-07\n- Category: Database\n\n프로시저 속도 개선하는 과정에서 배웠던 sql 팁으로, group by 없이 칼럼과 함께 갯수를 출력하는 방법과\n페이징 처리에 필요한 전체 레코드 갯수를 구하는 방법에 대한 내용입니다.\n\n관리자 페이지 유지보수 중에 한 프로시저의 실행속도가 굉장히 느린 것을 발견했다.  \n실무자에게 확인해 본 결과 페이지 넘길 때마다 기본 일분은 기다린다는 답을 받았다.  \n이 프로시저는 어떤 정보를 프로시저 내에서 페이징 처리를 하여 조회하는 쿼리로 4개의 left outer join 과 복잡한 case 조건의 where 절을 가졌다.  \n심지어 left join 되는 테이블은 조건과 그룹 처리를 하는 서브쿼리로 구성되었다.\n\n# Group by 없이 칼럼과 함께 갯수 출력하기\n\n<span class=\"clr-grey\">\n처음에는 left join 때문이라고 생각했으나 아니였다.      \n진짜 원인은 select 절에서 각 그룹의 갯수를 조회하는 서브쿼리의 문제였다.    \n이를 left outer join 으로 바꿔봤지만 해결되지 않았고 Group by 처리하자니 조회할 컬럼 값이 너무 많았다.    \n고민하다가 검색을 통해 좋은 방법을 찾았다.  \n</span>\n\n```sql\ncount(yy) over (partition by xx)\n```\n\n위는 Group by 없이 컬럼값들과 함께 갯수를 출력할 수 있는 쿼리이다.\n\n```sql\ncount(seq) over (partition by groupSeq)\n```\n\n이를 참고해 select에서 서브쿼리로 조회하던 방식을 위와 같이 수정했더니 실행시간이 13초에서 3초 정도로 줄었다\n\n# 페이징 처리에 필요한 전체 레코드 갯수를 구하는 방법\n\n[전체갯수구하기 참고 블로그](https://m.blog.naver.com/monkeychoi/220629982940)\n\n<span class=\"clr-grey\">\n하지만 아직 한국인을 만족시킬 속도가 아니였기에 속도를 잡아먹는 또 다른 원인을 찾아보았다.     \n바로 전체 레코드 갯수를 구하는 부분이었다.  페이징처리를 위해서 전체 레코드 갯수를 구하는 건 필수였기에 해당 쿼리를 빼는 거는 불가능했다.   \n</span>\n\n기존 페이징 쿼리\n\n```sql\n;WITH myCTE AS\n(\n\tSELECT\n\t\tCOUNT(*) OVER() AS TOTALCNT,\t-- 이 쿼리때문에 느려짐\n\t\tROW_NUMBER() OVER (ORDER BY GroupSeq DESC, seq ASC) AS ROWNUM,\n\t\t*\n\tFROM DBO.MY_BOARD\n)\nSELECT * FROM myCTE WHERE ROWNUM BETWEEN (@I_PAGE -1) * @I_PAGESIZE) + 1 AND @I_PAGE * @I_PAGESIZE\n```\n\n수정 후 쿼리\n\n```sql\n;WITH myCTE AS\n(\n\tSELECT\n\t\tROW_NUMBER() OVER (ORDER BY GroupSeq DESC, seq ASC) AS ROWNUM,\n\t\t*\n\tFROM DBO.MY_BOARD\n)\nSELECT *, (SELECT COUNT(*) FROM myCTE) AS TOTALCNT\nFROM myCTE WHERE ROWNUM BETWEEN (@I_PAGE -1) * @I_PAGESIZE) + 1 AND @I_PAGE * @I_PAGESIZE\n```\n\n위와 같이 쿼리를 수정한 결과 실행시간이 3초에서 1초로 줄었다.\n"}}]}},{"name":"Etc","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":"2020-04-27-git-rebase.md","oid":"d828d76a01fdf156e30e5cff57c159e3cbf5c5f0","content":{"__typename":"GitHub_Blob","text":"# git rebase\n\nDate: Apr 27, 2020\n\n- Title : git rebase\n- Date : 2020-04-27\n- Category : Git\n\n## git rebase 하기\n\n```bash\ngit checkout develop\n\ngit fetch origin develop\n\ngit checkout feature\n\ngit rebase origin/develop\n\n// conflict 발생 시 충돌 해결 후\ngit add <수정된 파일 이름>\n\ngit rebase --continue\n```\n\n- git fetch origin develop을 하면 로컬의 origin/develop 에 원격저장소 develop의 최신 커밋들이 싱크된다. 그래서 rebase 대상이 develop이 아니라 origin/develop 이다.\n- 충돌 해결 후 파일을 commit 이 아니라 **꼭 add만 해야 한다.**\n\n## git rebase 취소\n\n이미 remote 까지 push 했을 때 rebase 취소하는 방법\n\n```bash\ngit reflog <브랜치명>\n\n// 돌아가고 싶은 커밋 확인\ngit reset --hard <128e6d4>\n\ngit push -f origin <브랜치명>\n```\n\n## 생각하기\n\n### `git rebase origin/develop` 과 `git rebase develop` 의 차이점\n\n### `git fetch origin develop` 과 `git pull origin develop` 의 차이점\n\npull 은 내부적으로 `fetch + merge` 를 실행한 것과 같다. 즉 pull 을 실행하면 원격 저장소의 내용을 가져오고(fetch) 병합작업(merge)를 수행하게 된다. 만약 단순히 원격 저장소의 내용을 확인만 하고 로컬 데이터와 병합은 하고 싶지 않다면 fetch를 수행하면 된다. fetch를 하게되면 최신 커밋들은 로컬에 `FETCH_HEAD` 라는 이름으로 가져오게 된다. 이 상태에서 원격 저장소의 내용을 로컬 저장소에 통합하고 싶다면 `FETCH_HEAD` 브랜치를 merge 하거나 pull 하면 된다.\n"}},{"name":"2020-06-17-git-cherry-pick.md","oid":"1d97f7e13119ff2ba29e19b7c06f0633ab1007fe","content":{"__typename":"GitHub_Blob","text":"# Git cherry-pick으로 필요한 커밋만 골라내기\n\nDate: Jun 17, 2020\n\n- Title : Git cherry-pick으로 필요한 커밋만 골라내기\n- Date : 2020-03-17\n- Category : Git\n\n# Git Cherry-pick\n\n현재 상황\n\n- feature/cherry에 작업한 결과를 Pull Request 보낸 상태\n- 브랜치가 꼬여서 해당 브랜치에서 작업한 커밋 외의 것도 보이는 상태\n\n원하는 결과\n\n- feature/cherry 에서 원하는 커밋만 남긴 후 다시 푸시 하고 싶음(PR 재 요청X)\n\n## 실습\n\n### feature/cherry 브랜치 로그 확인\n\n```bash\ngit log\n```\n\n`결과 예시: commit 4564415dfbdsfgsdgsd (feature/cherry)` \n\n### 커밋들을 저장할 임시 브랜치 생성(base branch에서 새 브랜치 생성)\n\n```bash\ngit checkout -b feature/cherry-correct\n```\n\n### cherry-pick 실행\n\n```bash\ngit cherry-pick 4564415dfbdsfgsdgsd(가져 가고 싶은 커밋넘버)\n```\n\n### feature/cherry 브랜치 reset\n\n```bash\ngit checkout feature/cherry\ngit reset feature/cherry-correct --hard\ngit push origin feature/cherry -f\n```\n\n`--hard` 옵션이 없을 경우 기존 브랜치에서 작업한 내용이 `unstaged`된 채 남아 있으니 필요한 경우가 아니라면 옵션을 추가 하는 것이 좋다.\n\n참고\n\n[https://medium.com/react-native-seoul/git-cherry-pick-사용법-fe1a3346bd27](https://medium.com/react-native-seoul/git-cherry-pick-%EC%82%AC%EC%9A%A9%EB%B2%95-fe1a3346bd27)\n"}}]}},{"name":"Front","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":"2020-03-17-graphql.md","oid":"94ca86fd0ce6c18a378cb92e9a8e202b4974c91f","content":{"__typename":"GitHub_Blob","text":"# GraphQL 알아보기\n\n- Title : GraphQL 알아보기\n- Date : 2020-03-17\n- Category : 프론트\n\n# Why?\n\nTIL 레파지토리의 문서들을 얻기 위해 Github Content API를 이용했다. 루트 폴더들, 각 폴더의 문서들, 문서의 내용 등을 REST API를 사용하여 얻었는 데 아무래도 엔드 포인트가 많다 보니 코드가 복잡해졌다. 또 내가 원하는 데이터만 받고 싶은 데 응답 구조가 정해져있다보니 응답 데이터를 직접 가공하는 수 밖에 없었다. 휴 불편하네~ 😥 불편하다. 생각하던 중 Github이 GraphQL API를 제공한다는 것을 발견했다. 예전에 잠깐 공부했을 때는 REST API보다 왜 편한지 이해를 못했는 데 역시 사람은 몸소 겪어봐야 아나보다. 직접 사용해보니 너무 너무 편했다. 그래서 오늘의 TIL은 GraphQL에 대해 정리해보려한다. \n\n# ✨ GraphQL 이란?\n\nGraphQL(gql)는 API를 위한 쿼리 언어로 API 서버에서 원하는 데이터를 효율적으로 가져올 수 있다. GraphQL을 사용하는 앱은 느린 모바일 네트워크 연결에서도 빠르게 수행할 수 있다고 한다. \n\nGraphQL API 서버는 gql로 작성된 쿼리를 입력으로 받고 쿼리를 처리한 결과를 클라이언트에게 돌려준다. HTTP API 처럼 gql도 특정 데이터베이스나 플랫폼에 종속적이지않다.\n\n네트워크 방식에도 종속적이지 않다. 일반적으로 gql의 인터페이스간 송수신은 네트워크 레이어 L7의 HTTP POST 메서드와 웹 소켓 프로토콜을 활용한다. 필요에 따라서는 L4의 TCP/UDP나 L2의 이더넷 프레임을 활용할 수 있다.\n\n## REST API와 차이점?\n\n- REST API가 여러 URL에서 데이터를 얻는 것과 달리 GraphQL은 모든 데이터를 하나의 엔드 포인트를 통해 가져올 수 있다.\n- REST API는 각 엔드포인트마다 데이터베이스 SQL 쿼리가 달라지고 gql API는 gql 스키마 타입마다 데이터베이스 SQL 쿼리가 달라진다.\n- REST API는 리소스를 URL로 표현하고 GraphQL은 Query로 표현한다고 할 수 있다.\n\n# GraphQL 구조\n\n## 📌 Query\n\nHTTP Method의 `GET` 과 비슷\n\n### **Fields**\n\n    {\n    \tplayers {\n    \t\tname\n    \t}\n    }\n\n    {\n    \t\"data\": {\n    \t\t\"players\": [\n    \t\t\t{\n    \t\t\t   \"name\": \"Pogba\"\n    \t\t\t },\n    \t\t\t {\n    \t\t\t   \"name\": \"Lukaku\"\n    \t\t\t },\n    \t\t\t {\n    \t\t\t   \"name\": \"Rashford\"\n    \t\t\t },\n    \t\t\t {\n    \t\t\t   \"name\": \"Marshal\"\n    \t\t\t }\n    \t\t]\n    \t}\n    }\n\n- 객체에서 원하는 필드만 리턴 받을 수 있다.\n- 쿼리는 한번의 요청으로 객체나 필드를 순회하여 관련된 데이터들도 가져올 수 있다. 이런 작업을 REST API에서 하려면 API 호출을 여러 번 해야한다.\n\n### **Arguments**\n\n    {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \t\"data\": {\n    \t\t\"players\": {\n    \t\t\t\"name\": \"Pogba\",\n    \t\t\t\"kit\": [\n    \t\t\t\t{\n    \t\t\t\t\t\"shirtSize\": \"large\",\n               \"shoeSize\": \"medium\"\n    \t\t\t\t}\t\t\t\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n\n- arguments를 쿼리의 필드 및 중첩된 객체들에 전달하여 원하는 데이터만 얻을 수 있다\n- REST API에서 ?name=Pogba 또는 /Pogba (/:name 형식일 때) 와 같은 목적으로 사용한다.\n\n### Aliases\n\n    {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    \tplayer(id: \"Lukaku\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \tplayer1: player(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    \tplayer2: player(id: \"Lukaku\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \t\"data\": {\n    \t\t\"player1\": {\n    \t\t\t\"name\": \"Pogba\",\n    \t\t\t\"kit\": [\n    \t\t\t\t{\n    \t\t\t\t\t\"shirtSize\": \"large\",\n               \"shoeSize\": \"medium\"\n    \t\t\t\t}\t\t\t\n    \t\t\t]\n    \t\t}\n    \t\t\"player2\": {\n    \t\t\t\"name\": \"Lukaku\",\n    \t\t\t\"kit\": [\n    \t\t\t\t{\n    \t\t\t\t\t\"shirtSize\": \"extralarge\",\n               \"shoeSize\": \"large\"\n    \t\t\t\t}\t\t\t\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n\n- 필드 이름을 겹쳐서 사용할 수는 없기에 왼쪽처럼 할 수 없다. 오른쪽 처럼 별칭을 써서 사용하면 된다.\n\n### Operation name\n\n    query PlayerDetails {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n- Operation Type: query, mutation과 같은 키워드\n- Operation Name: 이 작업이 무슨 일을 하는 지(메소드 명처럼..?)\n\n### Variables\n\n    query PlayerDetails($id: String) {\n    \tplayer(id: $id) {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n- arguments를 동적으로 받고 싶을 때 사용한다.\n- Operation Name 옆에 변수를 $변수이름: 타입 형태로 정의한다. 만약  `String!` 형태로 정의했다면 id는 **반드시** String이어야 한다.\n- 실제 argument로 사용하려면 필드명: $변수이름 형태로 사용하면 된다.\n- 전달된 변수가 없으면 디폴트로 사용할 값을 정의할 수도 있다. `$id: String = \"Pogba\"` 형태로 쓰면 된다.\n\n### Fragments\n\n    {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    \tplayer(id: \"Lukaku\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \tplayer1: player(id: \"Pogba\") {\n    \t\t...playerKit\n    \t}\n    \tplayer2: player(id: \"Lukaku\") {\n    \t\t...playerKit\n    \t}\n    }\n    \n    fragment playerKit on player {\n    \tname,\n    \tkit {\n    \t\tshirtSize,\n    \t\tshoeSize\n    \t}\n    }\n\n- 왼쪽을 보면 name과 kit이 반복된다. 이처럼 동일한 구조의 필드를 가져올 때 fragment 를 이용하면 오른쪽처럼 간편하게 쓸 수 있다.\n\n### Inline Fragments\n\n    query HeroForEpisode($ep: Episode!) {\n      hero(episode: $ep) {\n        name\n        ... on Droid {\n          primaryFunction\n        }\n        ... on Human {\n          height\n        }\n      }\n    }\n\n    {\n      \"data\": {\n        \"hero\": {\n          \"name\": \"R2-D2\",\n          \"primaryFunction\": \"Astromech\"\n        }\n      }\n    }\n\n- 위 쿼리에서 hero 필드는 $ep 인수에 따라 Human 또는 Droid 타입인 Character 인터페이스를 리턴한다.\n- 위 쿼리의 name 필드는 Character 인터페이스에 있는 값이다.\n- Fragment의 타입 질의 기능을 이용하면 Human 타입일 때, Droid 타입일 때 가져올 데이터를 정의할 수 있다.\n- 어떤 필드가 Interface나 union 타입으로 리턴된다면 inline fragment로 원하는 데이터만 받을 수 있다.\n\n    interface Character {\n      id: ID!\n      name: String!\n      friends: [Character]\n      appearsIn: [Episode]!\n    }\n    \n    type Human implements Character {\n      id: ID!\n      name: String!\n      friends: [Character]\n      appearsIn: [Episode]!\n      starships: [Starship]\n      totalCredits: Int\n    }\n    \n    type Droid implements Character {\n      id: ID!\n      name: String!\n      friends: [Character]\n      appearsIn: [Episode]!\n      primaryFunction: String\n    }\n\n### Directives\n\n    query PlayerDetails ($playerShirtDirective: Boolean!){\n        player(id: \"Pogba\") {\n            name,\n            kit {\n                shirtSize @skip(if: $playerShirtDirective)\n                bootSize\n            }\n        }\n    }\n\n- 특정 필드를 포함할 지, 스킵할 지를 정할 수 있다.\n- @skip : true면 스킵\n- @include : true면 포함\n\n## 📌 Mutation\n\nHTTP Method의 `POST` `PATCH` `DELETE` 와 비슷\n\n    mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n      createReview(episode: $ep, review: $review) {\n        stars\n        commentary\n      }\n    }\n\n    {\n      \"ep\": \"JEDI\",\n      \"review\": {\n        \"stars\": 5,\n        \"commentary\": \"This is a great movie!\"\n      }\n    }\n\n    {\n      \"data\": {\n        \"createReview\": {\n          \"stars\": 5,\n          \"commentary\": \"This is a great movie!\"\n        }\n      }\n    }\n\n**참고**\n\n[GraphQL 개념잡기](https://tech.kakao.com/2019/08/01/graphql-basic/)\n\n[Understanding Queries in GraphQL | DigitalOcean](https://www.digitalocean.com/community/tutorials/understanding-queries-in-graphql)"}},{"name":"2020-03-28-html.md","oid":"4f925fc92243abb58588445af492b3fed43f4848","content":{"__typename":"GitHub_Blob","text":"# 가깝고도 먼 HTML 1탄\n\n- Title : 가깝고도 먼 HTML 1탄\n- Date : 2020-03-28\n- Category : 프론트\n\n# WHY?\n\nHTML, 잘 알고 있다고 생각했으나 지식이 구멍이 뻥뻥 뚫려있었다. 그래서 시작한 **가깝고도 먼 HTML!** 오늘부터 GO GO!\n\n# `< !DOCTYPE>` 을 왜 선언할까?\n\n> HTML 문서를 작성할 때 항상 DOCTYPE을 문서의 맨 위에 선언한다. ... 왜 선언할까?\n\n`<html>` 태그 전에 선언되야하며 `<!DOCTYPE>` 을 통해 브라우저가 해당 웹 문서가 어떤 타입(HTML5, HTML, XHTML)의 문서인지 파악할 수 있다. 웹 브라우저에게 HTML 버전을 알려주는 역할을 한다. HTML2 ~ HTML4는 SGML(Standard Generalized Markup Language, HTML 할아버지)에 기반을 두어 만들어져서 `<!DOCTYPE>` 을 통한 DTD 참조가 필요하다. 반면에 HTML5는 SGML에 기반을 두지 않아서 DTD 참조가 필요 없고 표준 모드로 작동되게 하는 역할만 하면 되서`<!DOCTYPE html>` 으로 간단하게 선언할 수 있다. \n\nDTD(Document Type Definition: 문서형 정의)는 마크업 언어를 위한 규칙으로 HTML5, XHTML, HTML 등의 문서 형식을 정의할 수 있다. `<!DOCTYPE>` 과 같은 문법을 사용한다. 기술한 유형에 따라 **마크업 문서의 요소와 속성등을 처리하며 유효성 검사 에 이용**된다. DTD를 생략하는 경우 웹 브라우저가 표준 모드가 아니라 비 표준 모드로 렌더링되어 크로스 브라우징에 어려움을 겪는다.\n\n# head 태그에는 무엇이 있을까? 메타가 있죠.\n\n> 보통 에디터의 자동 완성으로 HTML5 기본 형태를 작성한 후 `<body>` 부터 태그를 작성했다. `<body>` 앞은 신경쓰지도 않았다. 물론 예전에 일할 때 페이지 공유 기능을 위해 메타 태그를 설정한 적이 있었지만, 가물가물하니 다시 정리해보았다.\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <meta charset='utf-8'>\n      <meta http-equiv='X-UA-Compatible' content='IE=edge'>\n      <title>Page Title</title>\n      <meta name='viewport' content='width=device-width, initial-scale=1'>\n      <link rel='stylesheet' type='text/css' media='screen' href='main.css'>\n      <script src='main.js'></script>\n    </head>\n    <body>\n      \n    </body>\n    </html>\n\n## HTML head란?\n\nhead는 페이지를 열 때 브라우저에 표시되지는 않는다. head는 `<title>`, `CSS 링크`, `favicon`(사이트 아이콘), `메타 데이터`(작성자, 중요한 키워드 같은 HTML에 대한 내용)를 포함한다.\n\n## 메타데이터 `<meta>` 요소들\n\n### `<meta charset='utf-8'>`\n\n문서에서 허용하는 encoding에 대해 표시\n\n### Viewport\n\n모바일 브라우저들은 뷰포트로 알려진 가상 window 상에 페이지를 렌더링한다. 데스크탑의 뷰포트는 브라우저 창(visible area)의 뷰포트와 같고 사용자가 창의 크기를 조절하면 뷰포트의 크기도 조절된다. 웹 페이지가 뷰포트보다 크면 스크롤 하여 나머지 영역을 볼 수 있다. 반면에 모바일 뷰포트는 웹 브라우저 창보다 크거나 작을 수 있고 상하좌우로 움직이거나, 더블 탭, 줌인, 줌아웃을 통해 뷰포트의 배율을 변경할 수 있다. \n\n뷰포트를 설정안하면 기본 뷰포트가 980px라 페이지가 작게 보인다. ~~아.. 그래서 예전에 작게 보였었구나..~~\n\n기본 사용법\n\n`<meta name='viewport' content='width=device-width, initial-scale=1'>`\n\n- width : viewport의 가로 크기를 조정한다. 숫자가 들어갈 수도 있다. device-width는 100% 스케일에서 css 픽셀들로 계산된 화면의 폭을 의미한다. 즉 기기의 가로 크기에 맞게 설정된다.\n- initial-scale : 페이지가 처음 로딩될 때 줌 레벨을 조정한다. 값이 1이면 CSS 픽셀과 기기 종속적인 픽셀 간의 1:1 관계를 형성한다.\n\n> 미디어 쿼리(@media) 에서 선언된 width 범위에 따라 css를 적용하는 반응형 웹을 만드려면 `width=device-width`를 설정해야한다.\n\n### IE 문서 모드\n\n같은 웹문서를 IE 버전에 따라 마크업과 CSS를 다르게 렌더링하는 경우가 있다. 이 문제를 해결하기 위해 MS는 호환성 보기(쿼크 모드 == 비표준모드) 기능을 제공한다. 하지만 모든 사용자가 직접 호환성 보기를 설정하는 것은 불가능한 일이라 아래 메타태그가 등장했다.\n\n`<meta http-equiv='X-UA-Compatible' content='IE=edge'>` \n\n`content='IE=edge'` 이 메타 태그를 넣으면 자동으로 호환성 보기 기능이 활성화 된다. IE=edge로 선언하면 IE 버전 중 가장 최신 모드를 기준으로 보여지도록 하겠다는 의미다. 이 때, DOCTYPE 선언과 함께 사용해야 유효하다.\n\n# HTML에 CSS와 Javascript 적용하기\n\n## `<link>` 의 위치\n\n`<link>` 는 현재 문서와 외부 리소스의 관계를 명시할 때 사용한다. 스타일 시트를 연결할 때 제일 많이 사용하지만, 사이트 아이콘 연결 등 여러 가지로 쓰일 수 있다. 항상 문서의 **head** 부분에 위치하며 ret=\"stylesheet\" 와 href=\"경로\" 속성을 가진다. head에 놓아야 화면이 여러번 렌더링되는 것을 줄일 수 있다.\n\n## `<script>` 의 위치\n\n`<script>` 요소는 실행 가능한 코드를 문서에 포함하거나 참조할 때 사용한다. head에 들어갈 필요는 없고 `</body>` 태그 바로 앞, 문서 본문의 맨 끝에 넣는 것이 좋다. 자바스크립트를 적용하기 전에 브라우저가 모든 HTML 내용을 읽었는지 확인하여 자바스크립트가 아직 존재하지 않은 요소에 접근하는 경우를 방지해야 한다.\n\n# `<script>` 요소의 defer, async 속성의 차이점\n\n브라우저는 구문 분석을 진행하다 인라인 스크립트(`<script>` 내부에 코드 작성하는 방식) 또는 `async`, `defer`, `type=\"module\"` 속성이 없는 스크립트에 도달하면 스크립트를 가져온 후 실행하기 전까지 분석을 중단한다. HTML이 화면에 출력되는 시간이 길어져 사용자의 불편을 유발한다.\n\n## async\n\nasync 속성이 있으면 HTML 구문 분석 중에도 스크립트를 비동기적으로 가져올 수 있고 사용이 가능해지는 즉시 수행한다. 실행 순서가 다운로드 완료 시점이므로 실행 순서가 중요한 스크립트들에 async를 사용할 때는 유의해야 한다.\n\n## defer\n\nasync과 마찬가지로 브라우저가 HTML 구문 분석을 수행 중에도 스크립트를 다운로드 할 수 있다. 하지만 구문 분석이 완료된 후, **DOMContentLoaded** 발생 이전에 스크립트가 실행된다. defer 속성을 가진 스크립트는 문서 상의 순서를 따라 실행된다.\n\n> `DOMContentLoaded` 이벤트는 초기 HTML 문서를 완전히 불러오고 분석했을 때 발생한다. 스타일 시트, 이미지, 하위 프레임의 로딩은 기다리지 않는다.\n\n# HTML5의 섹셔닝 요소들\n\n> div로 뼈대를 만들던 시대는 지나갔다. HTML5부터 등장한 구조를 위한 태그들.. 잘 알고 잘 사용하고 있을까?\n\nHTML5 에서는 `<header>` `<nav>` `<aside>` `<article>` `<section>` `<footer>` 등의 섹셔닝 요소가 생겨 좀 더 시멘틱한(의미 있는) 마크업 작업을 할 수 있고 여기에 h1 ~ h6 로 섹션의 제목을 작성하면 좋다. 휴. 이제 `<div>` 로 레이아웃을 만들지 않아도 된다. \n\n![HTML%201/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Front/images/2020-03-28-img/Untitled.png)\n\n[https://www.w3schools.com/html/html5_semantic_elements.asp](https://www.w3schools.com/html/html5_semantic_elements.asp)\n\n### SECTION\n\n`<section>` 은 테마별로 연관된 컨텐츠를 묶어 더 큰 **논리적**인 단위를 형성할 수 있게 돕는다. 하나의 페이지 안에서 **주제가 다른 영역을 구분 짓거나 하나의 글을 부분으로 나누기도 한다.** 주로 heading 요소들과 함께 사용한다. 스타일링이나 스크립트를 위해서 엘리먼트들을 감싸는 요소가 필요하다면 `<section>` 을 사용하지 말고 문서 구조상 특별한 의미가 없는 `<div>` 를 사용해야 한다.\n\n- 예) 홈페이지의 뉴스, 긴 글의 세부 사항과 같은 관련 컨텐츠의 묶음\n\n### ARTICLE\n\n`<article>` 은 문서, 페이지, 애플리케이션, 사이트 안에 들어가는 **독립적**으로 구성할 수 있는 컴포넌트로 별도로 배포하거나 재사용하기 위한 구조다. `<article>` 은 완전히 떼어내 다른 사이트에 붙여도 그 의미를 사용자가 알 수 있는 컨텐츠를 담으면 된다. article 요소 안에 article이 들어간 경우, 밖의 article 요소의 내용과 안쪽의 article 요소의 내용이 관련있다는 것을 의미한다. article 중첩 사용은 피하는 게 좋고 대신 논리적인 부분들을 section 요소로 사용하면 된다.\n\n- 예) 블로그에서 글, 포럼에서 포스팅, 코멘트 등\n\n### NAV\n\n`<nav>`는 사이트 네비게이션(다른 페이지로의 이동) 또는 같은 페이지에서 섹션 이동을 위한 네비게이션 링크 목록을 담는 섹션이다.  페이지 안의 모든 링크 그룹이 nav로 기술될 필요는 없다.\n\n    <nav>\n    \t<h1>메인 내비게이션</h1>\n    \t<ul>\n    \t\t<li>메뉴1</li>\n    \t\t<li>메뉴2</li>\n    \t</ul>\n    </nav>\n\n### ASIDE\n\n`<aside>`  본문 컨텐츠 흐름과 분리되지만 약간의 관련성이 있는 컨텐츠에 사용한다.\n\n- 예) 관련 사이트 링크나 광고, nav 요소의 그룹, 메인 콘텐츠와 별도의 내용이라고 생각되는 것, 사이드바, 글의 발췌, 각주 부분, 글에 대한 정보, 여백을 메우는 추가 정보, 코멘트 세션\n\n### HEADER\n\n`<header>` 는 소개나 내비게이션 기능들의 묶음을 나타낸다. 보통 문서나 section의 최상단에 나타나지만, 꼭 그래야 할 필요는 없으며 여러번 사용 가능하다. 한 섹션의 목차나 검색폼, 관련 로고 등을 감싸는 용도로 사용할 수 있다.\n\n### FOOTER\n\n`<footer>` 는 페이지를 만든 사람, 저작권 정보, 연관된 컨텐츠에 대한 링크, 블로그 포스트 작성자, 발행일시 등에 쓰인다. 이 요소는 가장 가까운 섹션의 푸터를 의미한다. 작성자의 연락처는 footer 안의 `<address>` 로 표현, 저작권은 `<small>`로 표현한다.\n\n### FIGURE\n\n`<figure>` 요소는 이미지와 캡션을 그룹화하여 독립적인 컨텐츠를 표현할 때 사용한다. `<figurecaption>` 요소를 사용해 설명을 붙일 수 있다. \n\n    <figure>\n        <img src=\"/media/examples/elephant-660-480.jpg\"\n             alt=\"Elephant at sunset\">\n        <figcaption>An elephant at sunset</figcaption>\n    </figure>\n\n### MAIN\n\n`<main>` 말 그대로 문서의 메인 컨텐츠를 표현할 때 사용하며 `<main>` 안의 내용은 문서에서 유일해야한다. 여러 문서에서 반복적으로 사용되는 사이드바, 네비게이션, 로고, 검색 폼 등을 포함해서는 안되며 문서에 `<main>`은 한 개 여야 한다.\n\n# `<ul>` `<ol>` `<dl>` 의 차이점\n\n> HTML에서 목록을 표현하는 요소는? 각 요소의 차이점은?\n\n### ul(Unordered List)\n\n순서가 없는 목록을 표현할 때 사용하며 목록 앞에 점이나 사각형 등의 도형이 붙는다. 목록의 내용은 `<li>` 로 만든다.\n\n### ol(Ordered List)\n\n순서가 있는 목록을 표현할 때 사용하며 1, 2, 3... 처럼 차례대로 증가하는 번호가 붙는다. 목록의 내용은 `<li>` 로 만든다.\n\n### dl(Definition List)\n\n용어와 그 뜻을 나열할 때 사용한다. 용어는 `<dt>` , 뜻은 `<dd>` 로 만든다.\n\n참조\n\n[[HTML5] 4-1장 구조를 위한 태그](https://webdir.tistory.com/86?category=607030)"}},{"name":"2020-05-18-css-sr-only.md","oid":"03e73fed3a9d0eacb1704fefb89e8300da18fa23","content":{"__typename":"GitHub_Blob","text":"# 부트스트랩의 sr-only 클래스가 하는 일\n\n- Title : 부트스트랩의 sr-only 클래스가 하는 일\n- Date : 2020-05-18\n- Category : 프론트\n\n이 글은 그저 기억하기 위한 용도로 작성했으니 참고바랍니다.\n\n부트스트랩은 `sr-only` 클래스를 사용하여 원하는 요소를 화면상에서는 사라지게 하는 동시에 웹 접근성을 높인다. 장애를 가진 사람은 스크린 리더기나 점자 타자기와 같은 보조 기구를 통해 웹을 인식하기 때문에 웹 접근성은 신경써야 할 요소 중 하나다. 간단하게 `<img>` 태그의 alt 요소에 이미지를 파악할 수 있는 텍스트를 작성하는 것만으로도 웹 접근성을 높일 수 있다. \n\n나는 체크박스(`<input type=\"checkbox>`)를 커스텀하면서 `sr-only` 를 접하게 되었다. *아마 사수가 아니었으면 웹 접근성을 신경쓰지도 않았을 텐데 덕분에 팁을 얻었다.*  작업에 대해 자세히 말하자면 체크박스를 슬라이드 토글 형태로 커스텀하는 것이었다. 작업 순서는 아래와 같다. 체크 박스에 `sr-only` 클래스를 적용하여 체크 박스를 사라지게 만들기 → `<label><div class=\"circle\"></label>` 로 style 만들기 → 체크박스 `:checked` 일 때 토글 효과 주기\n\n부트스트랩의 `sr-only` 는 다음과 같이 작성되어있다. 이를 이용하여 체크박스를 화면에서 지우면 된다.\n\n```css\n.sr-only {\n\tposition: absolute;\n\toverflow: hidden;\n\twidth: 1px;\n\theight: 1px;\n\tpadding: 0;\n\tmargin: -1px;\n\tborder: 0;\n\tclip: rect(0,0,0,0);\n}\n```\n\n `clip` 속성은 요소의 일부분만 보이게 하고 싶을 때 사용한다. 단, 요소의 `position`이 `absolute` 또는 `fixed`로 적용되어 있어야 작동된다. `sr-only` 에서 `clip` 요소는 `rect(0,0,0,0)` 으로 선언되어있는 데 이는 요소를 노출 시키지 않겠다는 의미다.\n"}},{"name":"2020-08-15-cors.md","oid":"0ccca43f88286fec26b69ffb24385bb7af57d737","content":{"__typename":"GitHub_Blob","text":"# CORS\n\n- Title : CORS\n- Date : 2020-08-15\n- Category : 프론트\n\n# SOP(Same-Origin Policy)\n**동일 출처 정책**으로 한 출처(Origin)에서 로드된 문서나 스크립트가 다른 출처의 자원과 상호 작용을 못하도록 제한하는 것을 말한다. <br/>\n이 정책으로 의해 XMLHttpRequest 객체로 특정 웹 페이지 접근할 때, 해당 페이지와 동일한 출처의 페이지에만 접근이 가능한 것이다.\n\n# 동일 출처(Origin)란?\n`Protocol`, `Host`, `Port` 가 모두 같을 때 동일 출처다.\n\n# CORS(Cross-Origin Resource Sharing)\n다른 출처의 자원과의 상호 작용을 위해 SOP 예외 조건으로 CORS 정책이 생겼다.    \nCORS 정책을 위반하지 않는 다면 다른 출처의 리소스를 공유할 수 있다.\n\n## 어떻게 CORS 정책을 위반했는 지 판단할까?\n출처를 비교하는 로직은 서버가 아닌 **브라우저**에 구현되어 있다.    \nCORS 정책에 위반하는 리소스 요청을 하면 서버가 같은 출처만 받겠다는 로직이 있는 경우가 아니면 서버는 정상적인 응답을 하고,\n이후 브라우저가 응답 헤더를 분석하여 CORS 정책 위반이라고 판단되면 그 응답을 사용하지 않는다.\n\n1. HTTP 프로토콜을 사용하여 리소스 요청을 한다.\n2. 이 때 브라우저는 요청 헤더의 Origin 필드에 출처를 담아 보낸다.\n3. 서버는 응답 헤더의 Access-Control-Allow-Origin 필드에 해당 리소스에 대한 접근이 허용된 출처를 담아 응답한다.\n4. 브라우저는 응답의 Access-Control-Allow-Origin 과 요청 헤더의 Origin을 비교하여 응답이 유효한 지 판단한다.\n\n# CORS, SOP 정책 존재 이유는?\n다른 출처의 애플리케이션이 서로 통신하는 것에 대해 아무런 제약도 존재하지 않으면 \n해커가 `CSRF(Cross-Site Request Forgery)`나 `XSS(Cross-Site Scripting)`와 같은 방법으로 앱 코드가 실행된 것처럼 꾸며 \n사용자의 정보를 탈취하기 쉬워진다. 또 개발자가 신경써야 할 일이 늘어난다.\n\n# Preflight, Simple, Credential Request 에서 CORS\n## 1. Preflight Request\npreflight는 브라우저가 본 요청을 보내기 전에 보내는 예비 요청을 말하며 HTTP METHOD 중 OPTIONS를 사용한다.    \n예비 요청은 본 요청을 보내기 전에 브라우저 스스로 안전한 요청인지 확인하는 과정이다.\n\n## 2. Simple Request\n예비 요청 없이 바로 본 요청을 보내는 경우로 발생 조건이 까다로워 해당 요청이 발생하는 경우는 드물다.\n- 요청 메소드: GET, HEAD, POST 중 하나만 사용 가능\n- Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width를 제외한 헤더를 사용 불가\n- 만약 Content-Type를 사용하는 경우에는 application/x-www-form-urlencoded, multipart/form-data, text/plain만 허용\n\n## 3. Credentialed Request\n다른 출처 간 통신에서 좀 더 보안을 강화하고 싶을 때 사용한다.\n\n```javascript\nfetch(url, {\n  credentials: 'include', // 요청에 인증과 관련된 정보를 포함하겠다.\n});\n```\n위와 같이 설정하면 요청 시 브라우저의 쿠키 정보가 함께 보내진다.\n\n단, `credentials: include`를 사용하면 브라우저는 `Access-Control-Allow-Origin: *` 처럼 와일드 문자를 허용하지 않게 된다.\n인증 정보가 담겨있는 상태에서 다른 출처에 요청을 하고 싶다면 아래 두가지를 추가해야 CORS 정책 위반을 피할 수 있다.\n\n- `Access-Control-Allow-Origin`에는 *를 사용할 수 없으며, 명시적인 URL이어야한다.\n- 응답 헤더에는 반드시 `Allow-Control-Allow-Credentials: true`가 존재해야한다.\n\n# CORS 해결 방법\n1. 서버에서 Access-Control-Allow-Origin 헤더에 알맞은 값 세팅하기\n2. Webpack Dev Server로 리버스 프록싱\n\n```javascript\nmodule.exports = {\n  devServer: {\n    proxy: {\n      '/api': {\n        target: 'https://api.evan.com',\n        changeOrigin: true,\n        pathRewrite: { '^/api': '' },\n      },\n    }\n  }\n}\n```\n"}},{"name":"2020-08-22-SSR-CSR-SPA.md","oid":"966ea5b2cd8e89dbab1723a18bec85539cbfa10a","content":{"__typename":"GitHub_Blob","text":"# SPA, SSR vs CSR\n- Title : SSR vs CSR vs SPA\n- Date : 2020-08-22\n- Category : 프론트\n# SPA(Single Page Application)\n\n- 앱에 필요한 모든 정적 리소스를 **최초 한번만** 받아 오고 이후에는 동적으로 DOM을 구성하여 렌더링 되는 화면만 바꾼다.\n- 페이지가 한번 로딩된 이후 데이터를 수정하거나 조회할 때, 페이지가 새로 고침되거나 다른 페이지로 넘어가지 않는다.\n- 클라이언트 렌더링 방식을 채택\n\n**장점**\n- 전체적인 트래픽을 감소시킨다.\n- 새로고침이 발생하지 않아 네이티브 앱과 유사한 사용자 경험을 제공한다. -> **모바일 퍼스트** 전략에 적합\n\n**단점**\n- 모든 정적 리소스를 최초에 한번 다운로드하기 때문에 초기 구동 속도가 상대적으로 느리다. -> 최초 첫 페이지(어느 정도 그려진)를 서버로부터 받는 SSR을 진행하여 속도를 개선할 수 있다.\n- SEO(검색엔진 최적화) 문제 -> SPA 프레임워크(앵귤러, 리액트..)에서 SSR을 지원하여 SEO에 대응할 수 있다.\n\n**전통적 Link Tag와 차이**\n- Link tag는 새로운 페이지를 요청할 때마다 정적 리소스를 다운 받고 전체 페이지를 다시 렌더링한다.   \n- 새로고침이 매번 발생되어 사용성이 좋지 않고 변경이 필요 없는 부분을 포함하여 전체 페이지를 갱식하므로 비효율적이다.\n\n# SSR(Server Side Rendering)\n**서버**가 사용자에게 보여줄 페이지를 모두 구성하여 사용자에게 페이지를 보여주는 방식이다.\n\n1. 브라우저가 서버에 페이지 요청한다.\n2. 서버는 DB에서 데이터를 가져오든 뭐든, 필요한 데이터를 모두 매핑시킨 HTML을 만들어 브라우저에 응답한다.\n3. 브라우저는 응답 받은 페이지를 렌더링한다. 이 때부터 **사용자는 페이지를 볼 수 있다.** 동시에 브라우저는 필요한 JS 파일들을 다운 받는다. [Viewable]\n4. 브라우저가 React를 실행한다.\n5. 드디어 페이지가 사용자와 상호 작용 할 수 있게 된다. [Interactable]\n\n# CSR(Client Side Rendering)\n데이터 없는 빈 HTML 파일을 받아오고 데이터는 문서와 여러 static 파일들이 로드된 후에 요청해서 받아오는 방식\n\n1. 서버가 아래와 같은 빈 HTML을 보내준다.\n\n```html\n<html>\n  <head>\n    <script src=\"client-side-framework.js\"></script>\n    <script src=\"app.js\"></script>\n  </head>\n  <body>\n    <div class=\"container\"></div>\n  </body>\n</html>\n```\n\n2. 브라우저는 JS 파일을 다운로드 받는다.\n3. 브라우저가 리액트를 실행한다.\n4. 드디어 사용자가 페이지를 볼 수 있고 상호 작용할 수 있다. [Viewable & Interactable]\n"}},{"name":"images","oid":"8e67c34b14db9e3fe77381e2d4be29feeb823a17","content":{"__typename":"GitHub_Tree"}}]}},{"name":"Infra","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":"2020-02-19-aws.md","oid":"baf3d7f1d92d3ddf097652b4412ef8feb523af76","content":{"__typename":"GitHub_Blob","text":"# 완전 초보를 위한 가상화 개념\n\n- Title : 완전 초보를 위한 가상화 개념\n- Date : 2020-02-19\n- Category: Infra\n\n이 포스팅은 완전 초보를 위한 글로 \"무슨 이거까지 설명해?\" 라는 생각이 들 수 있어요. 초보가 정리한 거라 오류가 있을 수도 있으니 발견하시면 코멘트 주세요! 😊\n\n> Windows 운영체제 위에서 Linux를 사용하기 위해 가상머신을 설치해본 적이 있나요? 주로 VM웨어사가 만든 하이퍼바이저 기반 가상머신 소프트웨어인 VM웨어 워크스테이션을 사용했을 거예요. 이처럼 하이퍼바이저(hypervisor)는 호스트 컴퓨터(여기선 윈도우 환경)에서 리눅스와 같은 다수의 운영체제를 동시에 실행할 수 있는 플랫폼을 제공해줘요.\n\n위 글에서 언급된 **가상화**, **가상머신**, **하이퍼바이저**를 설명할 수 있나요? 있다면, 고수네요. 부럽..🤣 초보인 저와 또 다른 초보를 위해 차근차근 정리해볼게요.\n\n<br/>\n\n---\n\n<br/>\n\n## 1. 가상화(virtualization)\n\n가상화는 컴퓨팅 리소스(서버, 데이터베이스, 스토리지, 애플리케이션 등)를 **추상화**하여 다수의 운영 체제 또는 애플리케이션 이미지를 하나의 물리적 서버에서 공유할 수 있도록 하는 프로세스예요. 물리적 컴퓨터 수를 줄일 수 있어 **비용 절감**에 효과적인데요. 대부분의 서버는 단지 용량의 10~15%만 사용하는 데 가상화를 통해 서버 효용률을 70% 이상으로 올릴 수 있기 때문이죠.\n\n## 2. 가상 머신(virtual machine, VM)\n\n**가상머신**은 컴퓨팅 환경을 소프트웨어로 구현한 것으로 컴퓨터를 **에뮬레이션**하는 소프트웨어예요.\n에뮬레이터 역할을 하는 거죠. 가상 머신은 CPU를 포함한 모든 하드웨어를 가상화하여 가상머신상에서 운영체제나 응용 프로그램을 설치하고 실행할 수 있게 해요.\n\n<span class=\"clr-grey\">에뮬레이션은 한 시스템을 복제하여 그 시스템을 흉내 내는 것으로 가상화 구현에서는 CPU를 포함한 모든 하드웨어를 가상화하는 것을 말해요. 즉, 옵코드가 달라도 실행 가능하죠. PC에서 실행되는 수많은 게임 에뮬레이터도 이런 가상화 기술 중 하나예요. 느리다는 단점이 있긴 하죠.</span>\n\n## 3. 하이퍼바이저(hypervisor)\n\n호스트 컴퓨터에서 다수의 게스트 OS를 동시에 실행할 수 있게 하는 소프트웨어로 가상화 머신 모니터 또는 가상화 머신 매니저라고 불러요. 하이퍼바이저는 아래와 같이 2가지 타입으로 나눠져요.\n<br/><br/>\n\n<div style=\"text-align:center\">\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-19-img/Hyperviseur.png)\n<br/>\n<span class=\"clr-grey\">위키피디아 하이퍼바이저</span>\n\n</div>\n<br/>\n\n### 타입 2 (호스트형)\n\n일반 프로그램과 같이 하이퍼바이저는 호스트 OS 위에서 실행돼요. VM 내부에서 동작되는 게스트 OS는 하드웨어에서 3번째 수준으로 실행되는 거죠. 타입1에 비해 오버헤드가 크지만, 게스트 OS 종류에 대한 제약이 없고 데스크탑, 노트북에서도 운영할 수 있어요.\n\n<BR/>\n\n### 타입 1 (native 또는 bare-metal)\n\n타입2와 달리 **호스트 OS 없이** 하드웨어 위에 하이퍼바이저가 바로 위치해요. 별도의 호스트 OS가 없기에 오버헤드가 적고 하드웨어를 직접 제어하기 때문에 효율적으로 리소스를 사용할 수 있어요. 하지만 여러 하드웨어 드라이버를 세팅해야 하므로 설치가 어려워요. VM 내부의 게스트 OS는 하드웨어 위에서 2번째 수준으로 실행되는 거죠.\n\n<span class=\"clr-grey\">네이티브형 하이퍼바이저는 전가상화, 반가상화 방식으로 세분화할 수 있어요. 하이퍼바이저를 통해 가상 머신 내의 게스트 OS가 호스트 시스템을 활용한다는 점을 같지만, 하드웨어와 인터랙션하는 방식에 차이가 있어요.</span>\n\n**1) 전가상화(Full-virtualization, Native-virtualization)**\n\n동일한 아키텍처에서 실행되는 게스트 OS를 **수정없이** 그대로 띄워주는데 필요한 하드웨어를 모두 에뮬레이션 하는 형식으로 가상화해요.\n\n- 게스트 OS는 하드웨어에 직접 액세스 하는 것으로 인식해요. 사실 이 하드웨어는 하이퍼 바이저가 하드웨어를 에뮬레이션한 복제품이죠. 그래서 게스트 OS는 하드웨어를 자신이 소유하고 있는 걸로 인식해요.\n- 하이퍼바이저는 게스트 OS가 하드웨어에 주는 명령을 감시해 \"하드웨어를 독점\"하는 명령이 발생하면 별도로 핸들링 해줘야 해요. 즉, 하이퍼바이저가 게스트 OS와 하드웨어 사이의 **중재자** 역할을 하죠. 그 전에 모든 게스트 OS는 \"DOM 0\"이라는 관리 머신을 거쳐 하이퍼바이저와 통신해요\n- 매번 하이퍼바이저와 통신하므로 CPU와 RAM처럼 I/O가 잦은 자원을 컨트롤 하기에는 번거롭기에 아래의 반가상화 방식이 출현했어요.\n\n**2) 반가상화(Para-virtualization)**\n\n하드웨어 에뮬레이션 없이 하이퍼바이저를 통해 하이퍼바이저가 제공하는 API를 이용한 OS를 실행할 수 있는 가상화해요. **게스트 OS를 하이퍼바이저의 API를 이용할 수 있도록 수정**해야해요. 게스트 OS를 수정해야 하므로 좀 번거롭죠.\n\n- 게스트 OS는 하드웨어에 하이퍼바이저가 제공한 API를 통해서 엑세스할 수 있어요.\n- 게스트 OS 입장에선 하드웨어를 소유하고 있지 않다는 것을 알고 있으므로 하드웨어를 독점하는 명령을 하지 않아요.\n- 각각의 게스트 OS는 필요한 자원을 직접 API를 통해 요청할 수 있으므로 모든 요청을 \"DOM 0\"가 한꺼번에 처리하여 하드웨어를 제어하는 전가상화 방식에 비해 성능이 좋아요.\n\n## 4. 컨테이너 기반의 가상화(도커) - 추후 추가예정\n\nOS레벨 가상화(OperatingSystem-level virtualization)는 OS상에서 같은 OS를 하나 더 사용하는것 처럼 꾸며주는 가상화로 가상화로 인한 속도저하가 없다고 생각해도 무방해요. 특히 OS레벨 가상화는 요즘 가장 핫한 방식인데, Container 를 사용해 SaaS, PaaS를 제공하는 Docker 와, 수많은 Container 관리를 용이하게 해주는 Kubernetes가 그 중심에 있다.\n"}},{"name":"2020-02-24-how-to-use-aws.md","oid":"a235f572d3b9bbda67147d2603cbeadcb82d0eda","content":{"__typename":"GitHub_Blob","text":"# AWS 연습하자 1탄 - AWS EC2 인스턴스에 Jenkins 서버 구축하기\n\n- Title : AWS 연습하자 1탄 - AWS EC2 인스턴스에 Jenkins 서버 구축하기\n- Date : 2020-02-24\n- Category: Infra\n\nAWS 연습하기 1탄에서는 AWS EC2에 인스턴스를 생성하고 Jenkins를 구축하는 과정을 다뤄보겠습니다. AWS에서 제공하는 [가이드](https://d1.awsstatic.com/Projects/P5505030/aws-project_Jenkins-build-server.pdf)를 참고하여 실습을 진행했습니다.\n\n# AWS EC2 인스턴스를 생성하기\n\n먼저 [Amazon EC2 console](https://console.aws.amazon.com/ec2/)로 이동해서 우측 상단의 Region을 서울로 설정합니다.\n\n인스턴스 생성에 앞서 키 페어부터 생성하도록 하겠습니다.\n왼쪽 네비게이션 바에서 **네트워크 및 보안 -> 키 페어 -> 키 페어 생성** 을 클릭합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/1.PNG)\n\n이름을 입력 후 파일 형식은 pem을 선택하고 키 페어 생성 버튼을 누르면 .pem 파일 형식의 개인키가 다운로드됩니다. 인스턴스 생성, 연결 시 필요하므로 **꼭 잘 보관해두세요**.\n\n> 윈도우 10은 openssh가 내장되어있어 ssh 명령어를 사용할 수 있습니다. ssh를 지원하지않는 경우라면 ppk를 사용하시면 됩니다.\n\n이제 인스턴스를 생성하겠습니다. **EC2 대시보드 -> 인스턴스 시작 섹션 -> 인스턴스 시작** 을 선택합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/2.PNG)\n\n**단계 1: AMI 선택** 에서 Amazon Linux AMI 프리 티어 사용 가능한 AMI를 선택하세요.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/3.PNG)\n\n**단계 2: 인스턴스 유형 선택** 에서 디폴트로 선택된 t2.micro를 선택한 후 다음: 인스턴스 세부 정보 구성을 선택합니다.\n\n**단계 3: 인스턴스 세부 정보 구성** 에서 디폴트 값을 그대로 사용하겠습니다. 다음:스토리지 추가를 선택합니다.\n\n**단계 4: 스토리지 추가** 에서 프리티어는 최대 30GB의 EBS 범용(SSD) 또는 마그네틱 스토리지를 사용할 수 있습니다. 크기 항목에 8로 되어있는 것을 30으로 수정한 후 다음:태그 추가를 클릭합니다.\n\n**단계 5: 태그 추가** 에서 여러 인스턴스를 태그로 검색이나 그룹짓기 위해 아래와 같이 태그를 추가합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/4.PNG)\n\n**단계 6: 보안 그룹 구성** 에서 인스턴스 방화벽 역할을 하는 보안 그룹을 설정하겠습니다. 보안그룹에서 인바운드와 아웃바운드 트래픽을 인스턴스 레벨에서 컨트롤할 수 있습니다.\n\n우선 디폴트로 있는 SSH 유형의 소스를 내 IP로 변경합니다. SSH의 소스를 모든 IPv4(0.0.0.0/0)으로 설정하는 것은 보안상 추천하지않습니다.\n\nHTTP, HTTPS 유형을 추가하고 소스를 0.0.0.0/0으로 설정합니다. 외부에서 이 서버로 접속하려면 꼭 설정해야합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/5.PNG)\n\n**검토 및 시작 -> 시작 -> 기존 키 페어 선택 또는 새 키 페어 생성 모달** 을 띄웁니다. 앞에서 키 my-key-pair 이름으로 키 페어를 생성해놨던 것을 여기서 사용할 것입니다. 아래와 같이 선택한 후 인스턴스 시작을 클릭합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/6.PNG)\n\n인스턴스 상태가 running이 되면 정상적으로 인스턴스 생성 및 실행이 완료된 것입니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/7.PNG)\n\n# Jenkins 설치하기\n\n방금 생성한 ec2 인스턴스에 젠킨스를 구축하려면 보안 그룹을 편집해야합니다.\n\n보안그룹에서 HTTPS 프로토콜을 제거하고 사용자 지정 TCP 규칙을 추가하겠습니다.\n\n스크롤을 오른쪽으로 해보면 보안그룹이 보입니다. 바로 밑의 링크를 클릭하여 인스턴스 보안그룹으로 이동합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/8.PNG)\n\n아래 사진과 같이 EC2 인스턴스를 생성할 때 설정한 보안 그룹의 내용을 확인할 수 있습니다. 이제 편집 버튼을 눌러서 수정하겠습니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/9.PNG)\n\nHTTPS 프로토콜을 삭제하고 사용자 지정 TCP 규칙을 추가 후 포트 범위로는 8080을 입력합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/10.PNG)\n\n본격적으로 젠킨스를 설치하고 환경을 설정하겠습니다.\n\n윈도우10에서 cmd 창을 킨 다음 my-key-pair.pem이 있는 폴더로 이동합니다.\n\n```\nC:\\Users\\USER>cd C:\\Users\\USER\\github\\project\\devrami-blog\\aws\n```\n\n개인키 my-key-pair.pem을 가지고 인스턴스에 접속하겠습니다.\n\n```\nssh -i my-key-pair.pem ec2-user@퍼블릭DNS\n```\n\n**Are you sure you want to continue connecting\n(yes/no)?** 가 뜨면 yes를 입력한 후 엔터를 누릅니다.\n\n아래와 같은 문구를 보게되면 인스턴스에 성공적으로 접속된 것입니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/images/2020-02-24-img/11.PNG)\n\n다음과 같이 커맨드를 입력합니다.\n\n```\nsudo yum update –y\n```\n\n> - Yum은 RPM 기반의 시스템을 위한 자동 업데이트 겸 패키지 설치/제거 도구\n> - RPM은 원래 레드햇에서 사용되었던 패키지 파일이었지만 현재는 많은 RPM 기반 배포판(RPM 패키지, RPM 패키지 관리 도구)이 사용되고 있습니다. 즉, RPM을 사용하면 각종 소프트웨어의 설치 및 업데이트를 굉장히 편하게 할 수 있습니다.\n\nAWS는 기본적으로 OS 설치시 타임존이 UTC로 맞춰져있어서 한국 시간에 맞추기위해 다음 작업을 추가로 하겠습니다.\n\n```\n# 날짜확인\ndate\n\nsudo rm /etc/localtime\nsudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime\n\n```\n\nyum이 젠킨스 설치 위치를 알 수 있도록 젠킨스 레파지토리를 추가합니다.\n\n```\nsudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo\n```\n\n패키지를 설치할 수 있게 젠킨스 키 파일을 rpm에 추가한다.\n\n```\n sudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key\n```\n\n> rpm 포맷은 전자서명을 첨부하여 위변조 여부를 확인할 수 있습니다. rpm 패키지가 위변조 되면 에러가 발생합니다. 다른 제조사가 서명했는데 서명자의 검증용 키가 없을 경우도 검증이 실패하게 되는 데 이럴 경우 --import 옵션을 이용하여 검증용 키를 rpm에 추가하면 됩니다.\n\n젠킨스를 설치하겠습니다.\n\n```\nsudo yum install jenkins -y\n```\n\n젠킨스 서버를 시작합니다.\n\n```\n sudo service jenkins start\n```\n\n> 다음과 같은 에러가 발생하면 자바 버전 문제로 자바8로 재 설치한 후 다시 서버를 시작하시면 됩니다.  \n> **Starting jenkins (via systemctl): Job for jenkins.service failed because the control process exited with error code. See \"systemctl status jenkins.service\" and \"journalctl -xe\" for details.**\n>\n> ```\n> sudo yum remove java-1.7.0-openjdk\n> sudo yum install java-1.8.0\n> ```\n\n# Jenkins 설정하기\n\n브라우저에서 http://퍼블릭DNS:8080 로 접속하면 아래와 같은 화면이 보일 것입니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/12.PNG)\n\n근데 매번 8080 포트 입력하기 귀찮죠? Nginx를 프록시로 사용해서 80포트로 들어오면 8080으로 연결되게 추가 설정을 진행하도록 하겠습니다.\n\n우선 Nginx를 설치해줍니다. nginx는 yum으로 설치할 수 없어서 아래처럼 설치해줍니다.\n\n```\nsudo amazon-linux-extras install nginx1\n```\n\nnginx 서비스를 시작합니다.\n\n```\nsudo service nginx start\n```\n\n이제 포트없이 퍼블릭 도메인으로 들어가보면 아래 화면처럼 보일 것입니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/17.PNG)\n\n자! 그럼 젠킨스 서버로 프록시하기위해 추가 설정을 하도록하겠습니다.\n\nnginx 설정 파일에서 location에 proxy_pass 정보를 추가하겠습니다.\n\n```\nsudo vi /etc/nginx/nginx.conf\n```\n\n다음과 같이 입력하면됩니다.\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/18.PNG)\n\n저장 후 nginx 서비스를 재시작하면 처음에 8080포트로 들어갔을 때 봤던 화면이 포트없이 접속해도 잘 보이는 것을 확인할 수 있을 것입니다.\n\n```\nsudo service nginx restart\n```\n\n이제 젠킨스 내부에서 설정을 해보겠습니다.\n\n접속을 위해 **/var/lib/jenkins/secrets/initialAdminPassword** 에 있는 패스워드를 찾습니다.\n\n```\n sudo cat /var/lib/jenkins/secrets/initialAdminPassword\n```\n\n위 커맨드로 나오는 내용을 복사하여 Administrator password에 입력한 후 continue 버튼을 클릭합니다.\n\nCustomize Jenkins 페이지에서 **Install suggested plugins** 를 선택합니다. 플러그인 설치가 완료되면 Create First Admin User 페이지에서 관리자 계정을 생성합니다. 여기까지 완료했으면 이 페이지를 볼 수 있을 것입니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/13.PNG)\n\n[AWS 연습하자 2탄 - Jenkins와 Github 연동하기](/post/2020-02-25-how-to-use-aws) 로 이어집니다.\n"}},{"name":"2020-02-25-how-to-use-aws.md","oid":"5a30bac6bb7fcaecb510c9cd70735f33591e0b4c","content":{"__typename":"GitHub_Blob","text":"# AWS 연습하자 2탄 - Jenkins와 Github 연동\n\n- Title : AWS 연습하자 2탄 - Jenkins와 Github 연동\n- Date : 2020-02-25\n- Category: Infra\n\n> AWS 연습하자 시리즈\n>\n> - [AWS 연습하자 1탄 - AWS EC2 인스턴스에 Jenkins 서버 구축하기](/post/2020-02-24-how-to-use-aws)\n\nAWS 연습하기 2탄에서는 추가 설정과 Jenkins와 Github을 연동하는 과정을 다뤄보겠습니다.\n\n# Git 설치\n\n연동에 앞서 Jenkins 서버에 git을 설치해두겠습니다.\n\n```\nsudo yum install git\n```\n\n# SSH 키 생성 및 등록\n\n젠킨스와 깃허브를 연동하는 작업은 [기억보다 기록을 - Jenkins로 Beanstalk + Multi Module 배포하기 - Jenkins와 Github 연동하기](https://jojoldu.tistory.com/291?category=777282)를 99% 참고하여 진행했습니다.\n\nssh 키를 생성합니다.\n\n```\nsudo ssh-keygen -t rsa -f id_rsa\n```\n\n아래 커맨드를 이용해 id_rsa 내용을 확인한 후 복사해둡니다.\n\n```\nsudo cat id_rsa\n```\n\n그 다음 다시 젠킨스 페이지로 돌아와서 **Credentials -> System -> Global credentials -> Add Credentials**를 선택합니다.\n\n아래와 같이 설정한 후 저장합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/19.PNG)\n\n이제 공개키(id_rsa.pub)를 Github에 등록하겠습니다.\nJenkins로 관리할 Github 프로젝트로 이동한 뒤 **Settings탭 -> Deploy keys -> Add deploy key** 를 차례로 클릭합니다.\n\nTitle에는 Jenkins 입력, key에는 아래 커맨드를 실행한 결과 값을 붙여넣습니다.\n\n```\nsudo cat id_rsa.pub\n```\n\nAllow write access는 체크 해제한 후 Add Key를 클릭합니다.\n\n이 작업만 해도 Build, Test, Code Clone 등을 다 할 수 있긴 합니다. PUSH 발생시에도 젠킨스가 PUSH 이벤트를 받을 수 있도록 Webhooks를 추가하겠습니다.\n\n**Settings 탭 -> Webhooks -> Add webhook** 을 클릭합니다.\n\nPayload URL에 http://Jenkins도메인/github-webhook/ 을 입력하고 Content type은 **application/json** 으로 변경해줍니다. Add webhook을 클릭하여 추가를 완료합니다.\n\n# Nodejs 설정\n\n제가 연결할 프로젝트는 express 프레임워크가 적용된 nodejs 서버입니다. 우선 Node.js 툴을 설치해줘야합니다. **메인페이지 -> Jenkins 관리 -> 플러그인 관리 -> 설치가능 탭** 을 클릭한 후 검색 창에 **nodejs** 라고 입력합니다. 리스트에서 NodeJS Plugin이 보이면 체크박스 선택 후 재시작없이 설치하기를 클릭합니다. 설치가 완료되면 다시 메인 페이지로 돌아갑니다.\n\n이제 Node.js 툴 설정을 진행하겠습니다. **Jenkins 관리 -> Global Tool Confituration** 을 선택합니다.\n\n**NodeJS 섹션 -> NodeJS installations..** 를 클릭합니다.\n\n아래와 같이 입력한 후 저장합니다.\n저는 로컬에서 노드 버전이 12.14.1 여서 다음과 같이 선택했습니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/16.PNG)\n\n# Item 생성 및 파이프라인 작성\n\n**새로운 Item -> 적당한 이름 입력 -> Pipeline** 선택 후 OK를 눌러줍니다.\n\nBuild Triggers가 Github hook과 연동되도록 다음과 같이 선택합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/20.PNG)\n\nPipeline 섹션에 Definition은 Pipeline script로 한 후 아래와 같이 입력하고 저장합니다. Pipeline 스크립트를 jenkinsfile로 관리하는 것은 뒤에서 다루도록 하겠습니다.\n\n```\npipeline {\n   agent any\n\n   tools {\n      nodejs \"node\"\n   }\n\n   stages {\n      stage('Build') {\n         steps {\n            git 'https://github.com/devgaram/express-project-blog.git'\n         }\n      }\n\n      stage('Install dependencies') {\n          steps {\n              sh 'npm install -g yarn'\n              sh 'yarn install'\n          }\n      }\n      stage('Test') {\n          steps {\n              echo 'test..'\n              // yarn test\n          }\n      }\n      stage('Upload S3') {\n          steps {\n              echo 'upload s3'\n          }\n      }\n      stage('Deploy') {\n          steps {\n              echo 'deploy'\n          }\n      }\n   }\n   post {\n        success {\n            echo 'successed'\n        }\n        failure {\n            echo 'failed'\n        }\n   }\n}\n\n```\n\n생성된 아이템으로 이동한 후 Build Now 버튼을 눌렀을 때 에러없이 완료되면 Github 연동은 성공적으로 된 것입니다.\n\n[AWS 연습하자 3탄 - Jenkins와 S3 버킷 & AWS codeDeploy 연동으로 배포하기](/post/2020-02-26-how-to-use-aws) 으로 이어집니다.\n\n[참고 블로그](https://medium.com/@gustavo.guss/jenkins-starting-with-pipeline-doing-a-node-js-test-72c6057b67d4)\n"}},{"name":"2020-02-26-how-to-use-aws.md","oid":"780e861698b99b29b1cd69f14ca08ded2b5349b5","content":{"__typename":"GitHub_Blob","text":"# AWS 연습하자 3탄 - Jenkins와 S3 버킷 & AWS codeDeploy 연동으로 배포하기\n\n- Title : AWS 연습하자 3탄 - Jenkins와 S3 버킷 & AWS codeDeploy 연동으로 배포하기\n- Date : 2020-02-26\n- Category: Infra\n\n> AWS 연습하자 시리즈\n>\n> - [AWS 연습하자 1탄 - AWS EC2 인스턴스에 Jenkins 서버 구축하기](/post/2020-02-24-how-to-use-aws)\n> - [AWS 연습하자 2탄 - Jenkins와 Github 연동](/post/2020-02-25-how-to-use-aws)\n\nAWS 연습하기 3탄에서는 AWS S3와 Aws Codedeploy로 자동 배포 환경을 구축하는 과정을 다루겠습니다.\n\n# 배포 서버인 EC2 인스턴스 생성\n\n[AWS 연습하자 1탄](/post/2020-02-24-how-to-use-aws)의 AWS EC2 인스턴스 생성하기 부분을 진행하여 인스턴스를 생성하고 오세요! 저는 Name 태그에 blog-server로 인스턴스를 생성했습니다.\n\n# AWS Code Deploy 계정 생성\n\n여기서 생성한 계정을 가지고 Jenkins와 blog-server 인스턴스에서 설정을 진행할 것입니다.\n\n**[AWS IAM 콘솔](https://console.aws.amazon.com/iam/) -> 사용자 탭 -> 사용자 추가** 를 클릭합니다.\n\n사용자 이름을 입력하고 액세스 유형은 프로그래밍 방식 액세스를 선택합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/29.PNG)\n\n해당 계정이 사용할 수 있는 정책으로는 CodeDeploy와 S3 권한을 할당 받겠습니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/30.PNG)\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/31.PNG)\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/32.PNG)\n\n.csv 다운로드 버튼을 클릭하여 비밀키를 잘 보관해둡니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/33.PNG)\n\n# AWS S3 버킷 생성\n\n**[AWS S3 콘솔](https://s3.console.aws.amazon.com/s3/) -> 버킷 만들기** 를 클릭합니다.\n\n버킷 이름이 blog-server-bucket으로 하고 리전이 서울인지 확인합니다. 추가 옵션 없이 다음을 계속하여 버킷 생성을 완료합니다.\n\n# IAM Role 생성\n\nblog-server EC2와 CodeDeploy에게 신뢰할 수 있는 권한을 설정하여 젠킨스가 정상적으로 배포할 수 있게 하겠습니다.\n\n> CodeDeploy가 EC2 접근할 수 있도록 설정하는 것!\n\n**[AWS IAM 콘솔](https://console.aws.amazon.com/iam/) -> 역할 -> 역할 만들기** 를 클릭합니다.\n\nAWS 서비스를 누른 후 이 역할을 사용할 서비스 선택에서 **EC2**를 선택합니다. 권한 정책으로 **AmazonEC2RoleforAWSCodeDeploy** 를 체크한 후 다음: 태그로 넘어갑니다. 태그는 건너 뛰고 역할 이름은 **blog-server-EC2CodeDeployRole**을 입력한 후 역할 만들기를 클릭하겠습니다.\n\n지금 만든 역할은 blog-server EC2에 IAM 역할로 설정할 것입니다.\n\n마찬가지로 CodeDeploy도 역할을 생성하겠습니다.\n\n**[AWS IAM 콘솔](https://console.aws.amazon.com/iam/) -> 역할 -> 역할 만들기** 를 클릭합니다.\n\nAWS 서비스를 누른 후 이 역할을 사용할 서비스 선택에서 **CodeDeploy**를 선택합니다. 사용 사례 선택 섹션에서도 **CodeDeploy**를 선택합니다. 권한 정책으로 **AWSCodeDeployRole** 를 하나이므로 그냥 확인하고 다음: 태그로 넘어갑니다. 태그는 건너 뛰고 역할 이름은 **blog-server-CodeDeployServiceRole**을 입력한 후 역할 만들기를 클릭하겠습니다.\n\n# EC2에 AWS 역할 적용하기\n\nEC2 콘솔로 이동한 후 아래와 같이 IAM 역할 연결/바꾸기 를 선택합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/34.PNG)\n\n아까만든 **blog-server-EC2CodeDeployRole** 을 선택한 후 적용합니다.\n\n# EC2 AWS CodeDeploy Agent 설치 및 설정\n\n이제 blog-server 인스턴스에 CodeDeploy Agent를 설치하겠습니다.\n\n인스턴스로 접속한 후 패키지 업데이트를 수행합니다.\n\n```\nssh -i my-key-pair.pem ec2-user@퍼블릭DNS\nsudo yum update -y\n```\n\naws cli를 설치하겠습니다.\n\n```\nsudo yum install awscli\n```\n\n에이전트 설치 후 aws 설정을 하겠습니다.\n\n```\nsudo aws configure\n```\n\nAWS Access Key ID, AWS Secret Acecess Key ID는 사용자 생성할 때 받은 CSV를 보고 입력합니다.\n\n추가 정보는 아래와 같이 입력 후 엔터칩니다.\nDefault region name: ap-northeast-2\nDefault output format: json\n\n계속 설치를 진행하겠습니다.\n\n```\ncd /home/ec2-user\n\n# agent 파일 다운로드\naws s3 cp s3://aws-codedeploy-ap-northeast-2/latest/install . --region ap-northeast-2\n\n# 실행권한 추가\nchmod +x ./install\n\n# 설치 진행\nsudo ./install auto\n\n# agent가 실행 중인지 확인 PID가 나오면 정상적으로 실행 중인 상태입니다.\nsudo service codedeploy-agent status\n```\n\n만약 **sudo ./install auto** 커맨드 실행 결과 **/usr/bin/env: ruby: No such file or directory**가 나온다면 루비를 설치해야합니다. 아래와 같이 실행 후 다시 설치를 진행합니다.\n\n```\nsudo yum install ruby -y\n```\n\n추가로 재 부팅시 자동으로 code deploy agent가 실행될 수 있도록 스크립트를 생성하고 권한을 주겠습니다.\n\n```\n# 아래 스크립트를 입력합니다.\nsudo vim /etc/init.d/codedeploy-startup.sh\n\nsudo chmod +x /etc/init.d/codedeploy-startup.sh\n```\n\n> #!/bin/bash  \n> echo 'Starting codedeploy-agent'  \n> sudo service codedeploy-agent restart\n\n# nginx와 Docker로 무중단 배포하기\n\n## 1) 도커, 도커컴포즈 설치 및 프로젝트 파일 생성\n\n도커 컨테이너 위에서 애플리케이션을 구동하기위해서 ec2에 도커와 도커컴포즈를 설치합니다.\n\n```\nsudo yum install docker\n\n# 도커 컴포즈 다운로드\n$ sudo curl -L \"https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n\n# 실행 권한 주기\n$ sudo chmod +x /usr/local/bin/docker-compose\n\n# 설치 완료됐는 지 확인하기\n$ docker-compose --version\n\n# bash: docker-compose: command not found 문구가 나오면 아래 커맨드 실행하기\n$ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n```\n\n잠시 배포에 대해 짚고 넘어가겠습니다. 뒤에서 실습을 진행하겠지만, AWS Code Deploy에서 배포한 파일은 /home/ec2-user/build 에 복사되게 할 것입니다.\n\n배포 후 /home/ec2-user/build 이 폴더에는 Dockerfile 과 docker-compose.yml 파일이 존재할것이고 이를 이용해 컨테이너에 서버를 올릴 것입니다.\n\n혹시 docker ps 해봤더니 **Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?** 에러가 떴다면 docker service가 실행이 안된 것이므로 아래와 같이 명령을 내리겠습니다. [도커 설치 가이드](https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user)를 참고했습니다.\n\n```\nsudo groupadd docker\nsudo usermod -aG docker $USER\nsudo newgrp docker\n\n# 아래 커맨드 실행 결과 상태가 active여야 정상적인 것!\nsudo systemctl status docker\nsudo systemctl start docker\nsudo systemctl enable docker\n```\n\n이제 프로젝트에 Dockerfile과 docker-compose 파일을 작성하겠습니다.\n\n> 도커에 대해 기본지식이 필요합니다. 나중에 도커 관련 포스팅도 작성하겠습니다..!\n\n프로젝트 루트에 다음과 같이 Dockerfile을 작성합니다.\n\n```\n# 로컬과 같은 버전\nFROM node:12.14\n\n# 도커 이미지 만든 사람\nLABEL maintainer=\"joingaram@gmail.com\"\n\n# 3000포트로 도커 데몬에 연결\nEXPOSE 3000\n\n# 작업 디렉토리 & 자동으로 작업 디렉토리로 현재 위치 변경\nWORKDIR /usr/src/app\n\nCOPY package.json .\nCOPY yarn.lock .\nRUN yarn cache clean & yarn install --network-timeout 100000\nCOPY . .\n\nCMD [\"yarn\", \"start\"]\n\n```\n\n프로젝트 루트에 docker-compose.blue.yml 파일과 docker-compose.green.yml 파일을 생성한 후 아래와 같이 입력합니다. 포트만 3001, 3002로 다릅니다.\n\ndocker-compose.blue.yml\n\n```\nversion: \"3.7\"\nservices:\n  blog-server:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    volumes:\n      - .:/usr/src/app\n    ports:\n      - \"3001:3000\"\n```\n\ndocker-compose.green.yml\n\n```\nversion: \"3.7\"\nservices:\n  blog-server:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    volumes:\n      - .:/usr/src/app\n    ports:\n      - \"3002:3000\"\n```\n\n## 2) nginx로 로드밸런싱 설정\n\n우선 nginx를 설치합니다. 프록시 서버로 두 개의 도커 컨테이너를 로드밸런싱하는 역할을 담당할 것입니다.\n\n```\nsudo amazon-linux-extras install nginx1\nsudo service nginx start\n\n# 잘 실행되었는지 확인\nps -ef | grep nginx\n```\n\n이제 **nginx 설정 파일 수정** 작업을 하겠습니다.\n\n```\nsudo vi /etc/nginx/nginx.conf\n```\n\n다음과 같이 수정한 후 저장합니다.\n\n```\n# Load Balancing\nupstream blog-server {\n  least_conn;\n  server 127.0.0.1:3001 weight=5 max_fails=3 fail_timeout=10s;\n  server 127.0.0.1:3002 weight=10 max_fails=3 fail_timeout=10s;\n}\n\nserver {\n  listen 80;\n  server_name 서버 아이피; # 세미콜론 붙여주셔야 합니다.\n  location / {\n    proxy_pass http://blog-server;\n  }\n}\n```\n\n잘 설정했는 지 확인하고 nginx를 재시작합니다.\n\n```\n\nsudo nginx -t\nsudo service nginx restart\n```\n\n> [생활코딩nginx](https://opentutorials.org/module/384/4328)\n>\n> - Nginx는 4개의 로드밸런싱 메서드를 제공합니다. 그중 least_conn 은 연결이 가장 작은 서버로 요청을 보냅니다.\n> - weight=n : 업스트림 서버의 비중을 나타냅니다. 이 값을 2로 설정하면 그렇지 않은 서버에 비해 두배 더 자주 선택됩니다.\n> - max_fails=n : n으로 지정한 횟수만큼 실패가 일어나면 서버가 죽은 것으로 간주합니다.\n> - fail_timeout=n : max_fails가 지정된 상태에서 이 값이 설정만큼 서버가 응답하지 않으면 죽은 것으로 간주합니다.\n\n# Jenkins 배포 설정\n\n우선 Pipeline AWS STEP과 AWS Codedeploy 플러그인을 설치해줍니다. Pipeline AWS STEP은 S3로 소스 전송할 때, AWS Codedeploy로는 S3 버킷의 코드를 인스턴스에 배포하도록 설정하겠습니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/22.PNG)\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/25.PNG)\n\n각 플러그인 사용방법\n\n- [Pipeline AWS STEP](https://github.com/jenkinsci/pipeline-aws-plugin#deployapi)\n- [AWS Codedeploy](https://github.com/jenkinsci/aws-codedeploy-plugin)\n\n## 1) S3 UPLOAD 작성\n\n먼저 AWS 접근을 위한 설정을 하겠습니다.\n\n**젠킨스 메인 -> Credentials -> System -> Global credentials -> Add Credentials** 를 차례로 클릭합니다.\n\nKind는 AWS Credentials를 선택하고 Access key와 secret key는 위에서 생성한 csv 파일을 보고 입력합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/23.PNG)\n\nOK 클릭 후 클릭해보면 아래와 같이 ID를 볼수 있습니다. 파이프라인 작성 시에 사용해야하므로 저장해둡니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/24.PNG)\n\nAWS 연습하기 2탄에서 작업했던 파이프라인을 아래와 같이 수정합니다.\n\n- credentials에는 위에서 복사한 ID를 입력합니다.\n- Bucket에는 아까 생성한 S3 버킷 입력을 입력합니다.\n\n```\npipeline {\n   agent any\n\n   environment {\n       S3PATH = \"${env.JOB_NAME}\"\n   }\n   tools {\n      nodejs \"node\"\n   }\n\n   stages {\n      stage('Build') {\n         steps {\n            git 'https://github.com/devgaram/express-project-blog.git'\n         }\n      }\n\n      stage('Install dependencies') {\n          steps {\n              sh 'npm install -g yarn'\n              sh 'yarn install'\n          }\n      }\n      stage('Test') {\n          steps {\n              echo 'test..'\n              // yarn test\n          }\n      }\n      stage('Upload S3') {\n          steps {\n              echo 'Upload S3'\n              withAWS(credentials: '667cec8d-baa7-497f-b2db-2d424c121a22') {\n                s3Upload(file: '.', bucket: 'blog-server-bucket', path: \"${S3PATH}\", excludePathPattern: '**/node_modules/**, **/.git/**')\n              }\n          }\n      }\n      stage('Deploy') {\n          steps {\n              echo 'deploy'\n          }\n      }\n   }\n   post {\n        success {\n            echo 'successed'\n        }\n        failure {\n            echo 'failed'\n        }\n   }\n}\n```\n\n**Apply -> 저장 -> Build Now** 를 클릭하면 잘 실행될 것입니다.\n\n## 2) AWS CodeDeploy 설정\n\n**Jenkins 메인 -> blog-server 아이템 -> Pipeline Syntax -> Snippet Generator**를 선택합니다.\n\nSnippet Generators는 파이프라인 스크립트 생성에 도움을 주는 녀석입니다. 얘를 이용해 AWS CodeDeploy를 이용한 배포를 설정하겠습니다.\n\n**Steps 섹션 -> Sample Step - step:General Build Step 선택 -> Build Step - Deploy an application to AWS CodeDeploy 선택** 을 진행합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/26.PNG)\n\n- AWS CodeDeploy Application Name: EC2 인스턴스 이름\n- AWS CodeDeploy Deployment Group: CodeDeploy 그룹 명\n- AWS CodeDeploy Deployment Config: 배포 환경, 여기선 CodeDeployDefault.OneAtATime\n- AWS Region: AP_NORTHEAST_2\n- S3 Bucket: S3 버킷 이름\n\nUse Access/Secret keys 라디오 버튼을 선택하여 csv로 저장했던 내용을 입력해줍니다.\n\n마지막으로 Generate Pipeline Script 버튼을 클릭하면 나오는 텍스트를 복사합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/27.PNG)\n\n최종적으로 파이프라인을 아래와 같이 구성됩니다.\n\n```\npipeline {\n   agent any\n\n   environment {\n       S3PATH = \"${env.JOB_NAME}\"\n       AWS_SECRET_ACCESS_KEY = \"${env.AWS_SECRET_ACCESS_KEY}\"\n   }\n   tools {\n      nodejs \"node\"\n   }\n\n   stages {\n      stage('Build') {\n         steps {\n            git 'https://github.com/devgaram/express-project-blog.git'\n         }\n      }\n\n      stage('Install dependencies') {\n          steps {\n              sh 'npm install -g yarn'\n              sh 'yarn install'\n          }\n      }\n      stage('Test') {\n          steps {\n              echo 'test..'\n              // yarn test\n          }\n      }\n      stage('Upload S3') {\n          steps {\n              echo 'Upload S3'\n              withAWS(credentials: '667cec8d-baa7-497f-b2db-2d424c121a22') {\n                s3Upload(file: '.', bucket: 'blog-server-bucket', path: \"${S3PATH}\", excludePathPattern: '**/node_modules/**, **/.git/**')\n              }\n          }\n      }\n      stage('Deploy') {\n          steps {\n              echo 'deploy'\n              step([$class: 'AWSCodeDeployPublisher', applicationName: 'blog-server', awsAccessKey: 'AKIASDBC2NNSJWD4F76B', awsSecretKey: \"${AWS_SECRET_ACCESS_KEY}\", credentials: 'awsAccessKey', deploymentConfig: 'CodeDeployDefault.OneAtATime', deploymentGroupAppspec: false, deploymentGroupName: 'blog-server-CodeDeploy-group', excludes: '', iamRoleArn: '', includes: '**', proxyHost: '', proxyPort: 0, region: 'ap-northeast-2', s3bucket: 'blog-server-bucket', s3prefix: '', subdirectory: '', versionFileName: '', waitForCompletion: false])\n          }\n      }\n   }\n   post {\n        success {\n            echo 'successed'\n        }\n        failure {\n            echo 'failed'\n        }\n   }\n}\n\n\n```\n\n## 3) AWS Deploy 설정 파일\n\nAWS CodeDeploy는 프로젝트 루트에 있는 appspec.yml를 이용하여 배포를 진행합니다. 자세한 내용은 [aws 가이드](https://docs.aws.amazon.com/ko_kr/codedeploy/latest/userguide/reference-appspec-file.html#appspec-reference-server)에서 확인하세요.\n\n프로젝트 루트에 appspec.yml 파일 생성 후 아래와 같이 입력합니다. AWS CodeDeploy가 ec2의 /home/ec2-user/build/ 위치에 S3 버킷에 있는 코드를 옮기도록 설정했습니다. 배포 후에는 execute-deploy.sh 작업을 통해 도커 컨테이너를 올릴 것입니다.\n\n```\nversion: 0.0\nos: linux\nfiles:\n  - source:  /\n    destination: /home/ec2-user/build/\nhooks:\n  AfterInstall: # 배포 후\n    - location: execute-deploy.sh\n      timeout: 180\n```\n\nexecute-deploy.sh\n\n```\n#!/bin/bash\ncd /home/ec2-user/build\nchmod +x ./deploy.sh\n./deploy.sh > /dev/null 2> /dev/null < /dev/null &\n```\n\n현재 블루 컨테이너가 돌고 있다면 그린 컨테이너를 구동한 후 블루 컨테이너를 종료합니다. 이 방법을 통해 무중단 배포를 할 수 있는 것입니다. 아래와 같이 작성합니다.\n\ndeploy.sh\n\n```\n#!/bin/bash\n\nDOCKER_APP_NAME=blog-server\n\nEXIST_BLUE=$(docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml ps | grep Up)\n\nif [ -z \"$EXIST_BLUE\" ]; then\n\techo \"blue up\"\n\tdocker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml up -d\n\n\tsleep 10\n\n\tdocker-compose -p ${DOCKER_APP_NAME}-green -f docker-compose.green.yml down\nelse\n\techo \"green up\"\n\tdocker-compose -p ${DOCKER_APP_NAME}-green -f docker-compose.green.yml up -d\n\n\tsleep 10\n\n\tdocker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml down\nfi\n```\n\n자 이제 실제로 커밋 푸시하면 배포까지 완료되는 것을 볼 수 있습니다!\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/28.PNG)\n\n> 추가로 해야할 것\n>\n> - S3에 왜 node_modules랑 .git도 올라가는 거지..? 분명 제외시켰는 데..\n\n참고\n\n- [기억보단 기록을](https://jojoldu.tistory.com/265)\n- https://velog.io/@jeff0720/Travis-CI-AWS-CodeDeploy-Docker-%EB%A1%9C-%EB%B0%B0%ED%8F%AC-%EC%9E%90%EB%8F%99%ED%99%94-%EB%B0%8F-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EB%B0%B0%ED%8F%AC-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0-2\n- https://medium.com/faun/create-a-continuous-delivery-pipeline-using-jenkins-gitlab-github-and-deploy-on-aws-ec2-with-3aaadf073196\n"}},{"name":"2020-03-30-travis-mongo-heroku.md","oid":"f25955ea62ff44f6182d7c5afe657bb1472e9cb6","content":{"__typename":"GitHub_Blob","text":"# Travis에서 MongoDB 사용하기 & Heroku 배포하기\n\n- Title : Travis에서 MongoDB 사용하기\n- Date : 2020-03-30\n- Category : Infra\n\n# WHY?\n\nTravis에서 MongoDB Altas 연결이 실패하여 테스트 실패하는 현상이 계속 발생하였다. 로컬에서는 잘되는 데 왜 travis에서는 안될까? 해결 방법은 간단했다. travis 내에서 로컬 MongoDB를 돌려주는 거였고 이는 Travis가 아주 편리하게 제공하고 있었다.\n\n# SOLVE\n\n1. .travis.yml 에 아래 코드를 추가해준다.\n\n    services:\n      – mongodb\n\n2. travis → setting → 변수 설정에서 이름은 각자 코드 내에서 쓰는 환경 변수 이름을 적고 값은 `mongodb://localhost:27017/mydb_test` 로 하면 된다.\n\ntravis에서 mongodb를 사용할 때는 따로 데이터베이스 만들 필요가 없고 로컬 호스트(127.0.0.1)로 바인딩되므로 위와 같이 쓰면 된다.\n\n# WHY?\n\n헤로쿠로 자동 배포되게 하는 거 까먹어서 기록 + Node.js 앱 배포\n\n[Travis CI Documentation](https://docs.travis-ci.com/user/deployment/heroku/)\n\n# SOLVE\n\n1. .travis.yml에 아래와 같이 작성한다.\n\n    deploy:\n      provider: heroku\n      api_key:\n        secure: <암호화한 heroku api token>\n      app: express-project-blog\n\n- app은 헤로쿠 앱 이름을 적으면 된다. 안 적어도 되긴 함\n\n2. secure 키 구하기\n\n- Heroku CI를 깔고 token 얻기. 아래 명령어를 치면 나오는 토큰을 복사해놓는다.\n\n    heroku auth:token\n\n- 윈도우인 경우 ruby cmd창에 travis CI를 깔고 아래 명령어 입력. 이 때 명령어 실행 위치에 .travis.yml 파일이 있어야한다. 따로 repo 설정을 안해줘서 —repo 옵션으로 github 위치 적어주면 travis.yml 파일에 알아서 암호화된 api_key가 생김\n\n    travis encrypt <복사한 TOKEN> --add deploy.api_key --pro --repo=devgaram/express-mongo-rest-api\n\n> [travis-ci.com](http://travis-ci.com/) 에서 빌드할 경우 —pro 옵션과 함께 암호화해야 정상적으로 인증할 수 있음..\n\n3. 헤로쿠 설정\n\n- 빌드팩에 nodejs 추가하기\n\n![Travis%20MongoDB%20Heroku/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-03-30-img/Untitled.png)\n\n- 프로젝트에서 es6를 사용하기 위해 babel을 이용해 빌드하는 경우가 있는 데, 이 때는 환경변수를 따로 설정해줘야 devdependencies도 설치되서 babel을 실행할 수 가 있다.\n\n![Travis%20MongoDB%20Heroku/Untitled%201.png](Travis%20MongoDB%20Heroku/Untitled%201.png)"}},{"name":"images","oid":"85f7d7de170767137163813db2e13b6c4ddcf4e3","content":{"__typename":"GitHub_Tree"}}]}},{"name":"Java","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":"2019-06-27-java-api-1.md","oid":"c30c7b633b6e2cf9a63592eefd001cac75a67c14","content":{"__typename":"GitHub_Blob","text":"# 자바 API 정리\n\n- Title : 자바 API 정리\n- Date : 2019-06-27\n- Category: Java\n\nJAVA 공부하면서 알게 된 API 정리한 글 입니다.\n\n# java.lang.String\n\n## compareTo\n\n```java\npublic int compareTo(String anotherString)\n```\n\n두 개의 String을 사전적으로 비교하는 함수다.\n\n- 내부적으로\n\n```java\nthis.charAt(k) - anotherString.charAt(k)\n```\n\nString을 구성하는 char의 유니코드 값으로 비교를 한다.\n\n```java\nthis.length()-anotherString.length()\n```\n\n각 String의 각 char index의 값이 모두 동일하면, 길이가 더 짧은 스트링이 사전적으로 앞선다.\n\n**사용법**\n\n```java\nint returnVal = string1.compareTo(string2);\n```\n\nreturnVal = 0, string1 == string2  \nreturnVal > 0, string1 > string2 사전적으로 string1이 string2보다 뒤에 있다는 뜻.  \nreturnVal < 0, string1 < string2 사전적으로 string1이 string2보다 앞에 있다는 뜻.\n\n---\n"}},{"name":"2019-10-16-java-jvm-memory.md","oid":"b98232c7cb9b2f596542f32029a4d9e3db9cc08c","content":{"__typename":"GitHub_Blob","text":"# JVM 메모리 구조\n\n- Title : JVM 메모리 구조\n- Date : 2019-10-16\n- Category: Java\n\n예전 면접에서 JVM 메모리 구조에 관한 질문을 받은 적이 있었다...  \n횡설수설하며 대답하긴 했지만 좀 더 깔끔한 답변을 위해 정리해야할 필요성을 느꼈다..!!!\n\n우선, JVM이 뭘까?\n\nJVM(Java Virtual Machine) 은 자바로 작성된 애플리케이션을 실행하기 위해서 반드시 필요한 가상머신이다!\n\n![1](https://raw.githubusercontent.com/devgaram/TIL/master/Java/images/2019-10-16-img/memory01.png) <br/>\n\n위 그림을 보면 일반 애플리케이션 코드는 OS만 거치고 하드웨어로 전달되지만 자바 애플리케이션은 JVM을 한번 더 거친다.\n그래서 자바는 속도가 느린 단점이 있다고 한다.\n\n왜??? 이유를 알기 위해 잠시 자바 응용 프로그램의 실행되는 과정을 살펴볼 필요가 있다.\n\n1. 응용프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.\n2. javac.exe (자바 컴파일러)가 자바소스를 바이트 코드(\\*.class)로 컴파일한다.\n3. Class Loader가 JVM에 클래스 파일을 로드시킨다.\n4. java.exe (자바인터프리터, 실행엔진)이 컴파일된 바이트 코드를 해석한다.\n5. 해석된 바이트 코드는 Runtime Data Areas에 배치되어 실행된다.\n\n위와 같이 하드웨어에 맞게 완전히 컴파일된 상태가 아닌 바이트 코드로 컴파일된 상태고 실행 시에 해석되기 때문에 느리다.\n그래도 요즘엔 바이트 코드를 하드웨어의 기계어로 바로 변환해주는 JIT 컴파일러와 향상된 최적화 기술이 적용되어서 속도 문제가 많이 개선되었다고 한다.\n\n장점으로는 JVM 덕분에 자바 애플리케이션은 OS에 종속되지 않는 점이 있다.  \n그래도 JVM은 OS에 종속되니깐 OS에 맞는 JVM이 필요하다.\n\n## JVM 메모리 구조\n\n![1](https://raw.githubusercontent.com/devgaram/TIL/master/Java/images/2019-10-16-img/JvmSpec7.png) <br/>\n[JVM스펙](https://ko.wikipedia.org/wiki/자바_가상_머신)\n\n이 중 3가지 주요 영역에 대해 알아보자.\n\n## 메서드 영역\n\n메서드 영역(Method area = static area = Class area)은 JVM이 \\*.class을 해석하여 얻은 클래스 정보(클래스 데이터)가 저장되는 공간이다. 이 때, 클래스 변수(static 멤버변수)도 같이 저장된다.  \n클래스정보에는 멤버변수의 이름/데이터 타입/접근 제어자 정보, 메소드의 이름/리턴 타입/매개변수/접근제어자 정보, 클래스인지 인터페이스인지 여부, 전체이름들이 해당된다.\n\n## 힙\n\n힙(Heap) 영역은 프로그램 실행 중에 생성되는 인스턴스(객체)가 저장되는 공간이다.  \n즉 new 키워드로 생성된 객체와 배열을 저장한다. 물론 인스턴스 변수도 같이 저장된다.\n\n## 호출스택\n\n호출 스택(call stack 또는 execution stack)은 호출된 메서드를 위한 메모리가 할당되는 곳으로 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함), 연산의 중간 결과, 리턴 값들을 저장하는 데 사용한다. 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워진다.\n\n참고서적) 자바의 정석  \n참고블로그) [https://asfirstalways.tistory.com/158](https://asfirstalways.tistory.com/158)\n"}},{"name":"2019-10-18-java-compare.md","oid":"2570d25c403b748053bcd53d0ff0e32d37cc4697","content":{"__typename":"GitHub_Blob","text":"# Java Comparator과 Comparable\n\n- Title : Java Comparator과 Comparable\n- Date : 2019-10-18\n- Category: Java\n\nPS 문제를 풀다가 Arrays.sort()와 Collections.sort()를 오름차순(디폴트)이 아닌 다른 기준으로 정렬하고 싶을 때가 있었다. 찾아보니 Comparator 또는 Comparable을 사용하면 된다고 한다. 음.. 알아본 김에 잊어버리지않게 기록을 해야겠다!\n\n# 컬렉션을 입맛대로 정렬하고 싶다면?\n\n내맘대로 컬렉션의 정렬 기준을 정하고 싶다면 `Comparator`과 `Comparable` 인터페이스를 사용하면 된다.\n\n```java\nimport java.util.Comparator;\npublic interface Comparator {\n    int compare(Object o1, Object o2);\n    boolean equals(Object obj);\n}\n```\n\n<br/>\n\n```java\nimport java.lang.Comparable;\npublic interface Comparable {\n    public int compareTo(Object o); // 양수 : 내림차순, 음수 : 오름차순\n}\n```\n\n# 그럼 둘의 차이는 무엇일까?\n\nComparable을 구현한 클래스들은 기본적으로 오름차순으로 정렬되도록 구현되어있다.  \nInteger, Character와 같은 `wrapper` 클래스(int, long, float, double 등을 객체화한 클래스)와 `String, Date, File`과 같은 것이 Comparable을 구현한 대표적 클래스이다. 그 외 Java API 문서에서 클래스 목록을 확인할 수 있다.  \n그래서 우리가 `Arrays.sort(정렬대상)` 로 오름차순 정렬을 할 수 있는 것이다. 아하!\n\n```java\npublic final class Integer extends Number implements Comparable {\n    ...\n    public int compareTo(Object o) {\n        return compareTo((Integer) o);\n    }\n\n    public int compareTo(Integer anotherInteger) {\n        int thisVal = this.value;\n        int anotherVal = anotherInteger.value;\n        return (thisVal < anotherVal ? -1 : (thisVal ==anotherVal ? 0 : 1));\n    }\n}\n```\n\n실제 Integer 클래스의 일부이다.  \n보이는 것 처럼 Comparable 인터페이스를 구현하고 compareTo 메서드에서 오름차순으로 정렬되도록 정의해놓았다.\n\nComparator 인터페이스는 Comparable로 구현된 클래스를, 또는 커스텀 클래스를 기본 정렬 기준 외에 다른 기준으로 정렬하고자 할 때 사용하면 된다.  \n아래는 실제 예제로 백준 16236 아기 상어 문제를 풀 때 우선순위큐의 정렬기준을 Comparator을 이용해 정의한 것이다.\n\n```java\nPriorityQueue<Point> pq = new PriorityQueue<>(new Comparator<Point>() {\n\t@Override\n\tpublic int compare(Point o1, Point o2) {\n\t\tif (o1.dis != o2.dis) return o1.dis-o2.dis;\n\t\tif (o1.row != o2.row) return o1.row-o2.row;\n\t\treturn o1.col-o2.col;\n\t}\n});\n```\n\n또는 책의 예제를 보면 따로 클래스를 정의해서 사용할 수 있다.  \n이 예제는 Comparable을 구현한 클래스 String의 정렬 방식을 내림차순으로 바꾸는 방법이다.  \n단순히 -1을 곱해 반대의 값을 반환하게 구현했다.\n\n```java\n\nArrays.sort(strArr, new Descending());\n\nClass Descending implements Comparator {\n    public int compareTo(Object o1, Object o2) {\n        if (o1 instanceof Comparable && o2 instanceof Comparable) {\n            Comparable c1 = (Comparable) o1;\n            Comparable c2 = (Comparable) o2;\n            return c1.compareTo(c2) * -1;\n        }\n    }\n}\n```\n\n이제 내맘대로 정렬할 수 있게 되었담!!!!\n\n자바의 정석 책을 참고했습니다.\n"}},{"name":"images","oid":"5b2e879232fb1f2504496163675aaeea342f323f","content":{"__typename":"GitHub_Tree"}}]}},{"name":"Javascript","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":".DS_Store","oid":"e168a4db79259b30f63a6c9f23f8806832ac1c12","content":{"__typename":"GitHub_Blob","text":null}},{"name":"2018-01-08-javascript-callapply.md","oid":"f2032027a41318246789d128d0d9c7c3692f528d","content":{"__typename":"GitHub_Blob","text":"# call()과 apply()\n\n- Title : call()과 apply()\n- Date : 2018-01-08\n- Category: Javascript\n\ncall() 과 apply() 메서드를 이용하여 명시적으로 this에 바인딩할 수 있습니다.\n\n모든 함수의 부모 객체인 Function.prototype 객체의 메서드라서 모든 함수에서 호출 가능합니다.\n\n## Function.prototype.apply()\n\n```javascript\nfun.apply(thisArg, [argArray]);\n```\n\nfun 메서드를 호출할 때, fun 내부의 this를 매개변수인 thisArg로 바인딩 시킵니다.\nargArray는 fun 메서드에서 인자로 사용됩니다.  \n<span class=\"clr-grey\">argArray : 배열리터럴, Array 객체</span>\n\n## Function.prototype.call()\n\n```javascript\nfun.call(thisArg[,arg1[,arg2[,....]]])\n```\n\napply와 기능이 같으며, 배열형태가 아닌 각각의 하나의 인자형태로 값을 넘긴다는 차이점이 있습니다.\n\n# 추가 개념\n\n## 객체의 메서드를 호출할 때, 객체 메서드 내부의 this는?\n\n해당 메서드를 호출한 객체\n\n## 함수를 호출할 때, 함수 내부의 this는?\n\n전역객체에 바인딩 된다. window \\*내부함수를 호출했을 때도, 내부 this는 window!\n\n## 생성자 함수를 호출할 때, 생성자 함수 내부의 this는?\n\n생성자 함수 코드가 실행되기 전 생성되는 빈 객체  \n이 객체는 부모인 프로토타입과 연결되어있으므로 부모의 프로퍼티와 메서드를 사용할 수 있다.\n\n```javascript\nfunction Person() {\n  this.age = 0; // (1)\n  setInterval(function growUp() {\n    this.age++; // (2)\n  }, 1000);\n}\nvar p = new Person();\n```\n\n(1)의 this는 생성자 함수를 호출하면서 만들어지는 빈 객체  \n(2)의 this는 window 전역객체를 가르킨다.\n\n그래서, 위의 코드는 1초마다 나이가 1씩 증가하는 결과를 얻을 수 없다.\n\n그렇다면, (2)가 Person 생성자로 만들어진 객체로 바인딩되게 하고 싶으며 어떻게 해야할까?\n\n아래 코드와 같이 비전역 변수에 할당하여 해결할 수 있다.\n\n```javascript\nfunction Person() {\n  var that = this;\n  that.age = 0;\n\n  setInterval(function growUp() {\n    that.age++;\n  }, 1000);\n}\n```\n\nES6의 화살표 함수를 이용하면 비전역 변수를 이용하지 않고도 생성자 객체에 바인딩 시킬 수 있다.  \n화살표 함수는 자신만의 this를 생성하지 않기 때문이다!!\n\n```javascript\nfunction Person() {\n  this.age = 0;\n\n  setInterval(() => {\n    this.age++;\n  }, 1000);\n}\n```\n\n위 화살표 함수 내 this는 정확히 Person() 생성자를 통해 생성된 객체를 가리키게 된다!\n\n[출처](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98)\n"}},{"name":"2018-01-09-javascript-opentutorials-1.md","oid":"ce15b2faaa11ddc0a404c2e65bec3c53a4496c9f","content":{"__typename":"GitHub_Blob","text":"# [생활코딩] Javascript 입문1\n\n- Title : [생활코딩] Javascript 입문1\n- Date : 2018-01-09\n- Category: Javascript\n\n생활코딩 URL : https://opentutorials.org/course/743  \n생활코딩 강의에서 기억하고 싶었던 내용을 포스팅해보았다.\n\n# 변수의 효용을 이해하자.\n\n- 필요에 의해서 변할 수 있는 영역과 변하지 않는 영역을 구분해서 코딩해야한다.\n- 재활용 가능해진다. 유지보수 용이해진다.\n\n# 비교\n\n```javascript\nalert(1 === \"1\"); //false    데이터타입[형식]도 동일해야함.**이걸쓰자!\nalert(1 == \"1\"); //true     버그발생 가능성 높음..\n\nvar a;\nalert(a); //undefined 값이 정의되지 않음\nalert(undefined == null); //true\nalert(undefined === null); //false\nalert(true == 1); //true **숫자 1은 true로 간주, 그 외는 false로.\nalert(true === 1); //false\nalert(NaN === NaN); //false\n```\n\n## [데이터타입]\n\nundefined : 값이 정의되지 않은 상태, 프로그래머가 의도하지 않음 false로 간주  \nnull : 값이 없는 상태, 프로그래머가 의도함. false로 간주  \nNaN : 0/0 계산할 수 없음. false로 간주\n\n# 조건문\n\nif('') alert('빈문자열'); //false 빈문자열은 false/ 문자열있으면 true로 간주\n"}},{"name":"2018-01-10-javascript-opentutorials-2.md","oid":"caadcde4519259454e8b2f41abe2fe9483478818","content":{"__typename":"GitHub_Blob","text":"# [생활코딩] Javascript 입문2\n\n- Title : [생활코딩] Javascript 입문2\n- Date : 2018-01-10\n- Category: Javascript\n\n생활코딩 URL https://opentutorials.org/course/743/  \n반복문, 함수 정의방법, 배열, 객체\n\n# 반복문\n\n```javascript\nfor (var i = 0; i < 10; i++) {\n  if (i === 5) break; // 그 즉시, for문 중단 - coding1~4 까지만 출력됨\n  if (i === 5) continue; // 실행을 중단하고 반복문 이어서 함. - coding1~4/6~9까지 출력됨.\n  document.write(\"coding\" + i + \"\");\n}\n```\n\n# 함수 정의 방법\n\n```javascript\n// [첫번째 방법]\nfunction numbering(arg) {\n  //statement\n}\n\n// [두번째 방법]\nvar numbering = (function() {\n  //statement\n})(\n  // [세번째 방법-익명함수]\n  function() {\n    //statement\n  }\n)();\n//*일회성 함수\n```\n\n# 배열\n\n```javascript\nvar member = [\"a\", \"b\", \"c\"]; //생성\nalert(member[0]); // 'a'\n\nfor (var i = 0; i < member.length; i++) {\n  // 배열의 크기만큼 반복\n  document.write(member[i].toUpperCase()) + \"\";\n}\n/*배열의 원소 추가하는 방법*/\nmember.push(\"f\"); // a,b,c,f - 배열의 맨 뒤에 삽입\nmember.concat([\"e\", \"f\"]); // a,b,c,f,e,f - 복수의 원소 추가\nmember.unshift(\"g\"); // g,a,b,c,f,e,f - 배열의 맨 앞에 삽입\nmember.splice(2, 0, \"B\"); // g,a,B,b,c,f,e,f - 배열의 2번째 인덱스 0(앞에) B를 추가\n\n/*배열의 원소 삭제하는 방법 및 정렬 */\nmember.shift(); // 배열의 첫번째 원소 삭제\nmember.pop(); // 배열의 마지막 원소 삭제\nmember.sort(); // 오름차순 정렬\nmember.reverse(); // 내림차순 정렬\n```\n\n## 배열의 함수. splice\n\n- 배열의 특정구간을 추출하거나, 특정 구간에 특정 배열을 추가한다.\n- array.splice( index, howmany, [element1...N])  \n  <span class=\"clr-grey\">\n  index : 배열의 위치  \n  howmany : index에서부터 제거될 원소의 수로, 1이면 index 값만 제거되어 값이 추가된다.  \n  0일 때는 삭제 없이 인덱스 앞쪽에 값이 추가됨. 없으면 배열 끝까지(길이)  \n  element1...N : 추가될 Value\n  </span>\n\n## 배열의 정렬. sort - 사용자정의가능\n\n```javascript\nfunction sortNumber(a,b){\n    return a-b;    //리턴값이 음수, 양수, 0인지에 따라 순서 정함.\n}\nvar numbers = [20 ,10 8, 15]\nnumbers.sort(sortNumber); // 8,10,15,20\n```\n\n# 객체\n\n배열 - 자동으로 색인 추가[number], 순서존재  \n객체 - 인덱스의 값을 숫자 뿐만 아니라 문자 등 원하는 이름으로 지정 가능 (데이터타입 : 연관배열, 맵, 딕셔너리), 순서존재X\n\n```javascript\n/*객체의 생성*/\nvar grades = {'aa':10, 'bb':6, 'cc': 80};    //객체의 생성\nvar grades = {};    //비어있는 객체의 생성\nvar grades = new object();    //비어있는 객체의 생성\n\n/*객체의 할당*/\ngrades['aa'] = 10;\ngrades['bb'] = 6;\ngrades['cc'] = 80;\n\n/*객체의 접근 key/value*/\ngrades['bb']    //6\ngrades.bb       //6\ngrades['b'+'b'] //6\ngrades.'b'+'b';  //에러 남\n\n/*객체의 값 가져오기*/\nfor(var key in grades){    //객체를 구성하는 값들의 키값만 하나씩 가져옴\n document.write(\"key : \"+key+\" value : \"+grades[key] + \"\");\n}\n\n/*객체지향 프로그래밍 - 서로 연관된 데이터, 처리를 하나의 그릇안에 그룹핑 한것*/\nvar grades = {\n 'list' : {'aa':10, 'bb':6, 'cc': 80},\n 'show' : function(){\n      alert(\"hello world\");\n  },\n'show2' : function(){\n      console.log(this.list);     //this란? 함수가 속해있는 객체를 가리킨다. 여기선 grades를 가리킴.\n },\n'show_list' : function(){\n  for(var name in this.list){\n   console.log(name,  this.list[name]);\n  }\n }\n}\nalert(grades['list]['aa']); //10\ngrades['show']();       //객체의 함수호출. alert창 뜸.\ngrades.show_list();    //객체의 함수호출 aa,10 bb,6 cc,80 출력\n```\n"}},{"name":"2018-01-11-javascript-opentutorials-3.md","oid":"c29af323a257c5fcf1c5044662e2eb8af4c2b08d","content":{"__typename":"GitHub_Blob","text":"# [생활코딩] Javascript 입문3\n\n- Title : [생활코딩] Javascript 입문3\n- Date : 2018-01-11\n- Category: Javascript\n\n생활코딩 javscript 과정 중 정규표현식 내용을 정리했습니다.\n\n# 정규표현식(Regular Expression)\n\n- 문자열에서 특정 문자를 찾을 때 사용 .. \\* 나중에 생활코딩 정규표현식 강의도 듣기!! & 전화번호 때 사용했던 경험 넣기\n- 컴파일 -> 실행 단계로 이뤄진다.\n- 컴파일 : 찾고 싶은 패턴을 만듬.\n- 실행 : 문자열에서 패턴을 추출.\n\n## 정규표현식 객체를 만드는 방법\n\n1. var pattern = /a/\n2. var pattern = new RegExp('a');\n\n## 패턴 추출\n\n1. pattern.exec('abcdef') // [\"a\"]; a배열 추출\n2. pattern.exec('bcdefg') // null a가 없어서.\n3. pattern.test('abcdef') // true\n4. pattern.test('bcdefg') // false\n\n## 문자열 객체의 메소드에서 정규표현식 사용하기\n\nString.match()  \nString.replace()\n\n```javascript\n\"abcdef\".match(pattern); // [\"a\"]\n\"bcdefg\".match(pattern); // null\n\"abcdef\".replace(pattern, \"A\"); // Abcdef\n```\n\n## 옵션\n\ni 대소문자 구분 안함\n\n```javascript\nvar oi = /a/i;\n\"Abcdef\".match(oi); //[\"A\"]\n```\n\ng 검색된 모든 결과 리턴\n\n```\nvar og = /a/g;\n\"abcdea\".match(og);    //[\"a\",\"a\"]\n```\n\n## 치환\n\n```\nvar pattern = /(\\w+)\\s(\\w+)/;    //()는 그룹, \\s는 공백, +는 1개이상, \\w는 문자(0-9,a-z,A-Z)\nvar str = \"coding everybody\";\nvar result = str.replace(pattern, \"$2, $1\");    //$N는 N번째 그룹.\nconsole.log(result);\n```\n"}},{"name":"2018-01-11-javascript-opentutorials-function-1.md","oid":"44697f284e26d813ce79450c2a5dbdfef4955f6d","content":{"__typename":"GitHub_Blob","text":"# [생활코딩] javascript 함수지향1\n\n- Title : [생활코딩] javascript 함수지향1\n- Date : 2018-01-11\n- Category: Javascript\n\n생활코딩 함수지향 파트 중 변수의 유효범위에 대한 내용을 정리했습니다.\n\n# 변수의 유효범위\n\n예제1) 지역변수와 전역변수의 구분1\n\n```javascript\nvar vscope = \"global\"; //전역변수\nfunction fscope() {\n  alert(vscope);\n}\nfscope(); //global\n```\n\n<span class=\"clr-grey\">\n**Note:** 전역변수 : 애플리케이션 전역에서 접근 가능한 변수    \n**Note:** 지역변수 : 함수 내에서만 접근 가능한 변수    \n*변수에 접근할 때, 지역변수를 우선적으로 찾는다.\n</span>\n\n</br>\n예제2) 지역변수와 전역변수의 구분2\n```javascript\nvar vscope = 'global';   \nfunction fscope(){\n   var vscope = 'local';    //지역변수\n   var lv = 'local value';   //지역변수\n   alert(vscope);\n}\nfscope();    //local\nalert(lv);    //undefined\n```\n\n예제3) 지역변수와 전역변수의 구분3\n\n```javascript\nfunction a() {\n  i = 0;\n}\nfor (var i = 0; i < 5; i++) {\n  // i는 전역변수\n  a();\n  document.write(i);\n}\n```\n\nfor문의 i는 전역변수기 때문에 해당 코드는 계속 실행되다가 브라우저가 멈춘다.\n\n예제4) 전역변수 안쓰는 방법1\n\n```javascript\nvar MYAPP = {};\nMYAPP.calculator = {\n  //객체의 속성(calculator)에도 객체를 생성.\n  left: null,\n  right: null\n};\nMYAPP.coordinate = {\n  left: null,\n  right: null\n};\n\nMYAPP.calculator.left = 10;\nMYAPP.calculator.right = 20;\nfunction sum() {\n  return MYAPP.calculator.left + MYAPP.calculator.right;\n}\ndocument.write(sum()); //30\n```\n\nMYAPP 전역변수 하나만 생성하고, 그 안에 필요한 전역변수를 정의한다.\n\n예제5) 전역변수 안쓰는 방법2\n\n```javascript\n(function() {\n  var MYAPP = {};\n  MYAPP.calculator = {\n    //객체의 속성(calculator)에도 객체를 생성.\n    left: null,\n    right: null\n  };\n  MYAPP.coordinate = {\n    left: null,\n    right: null\n  };\n\n  MYAPP.calculator.left = 10;\n  MYAPP.calculator.right = 20;\n  function sum() {\n    return MYAPP.calculator.left + MYAPP.calculator.right;\n  }\n  document.write(sum()); //30\n})(); //익명함수\n```\n\n전역변수가 절대 존재하지 않게 개발할 때, 익명함수. 일회성함수를 이용한다.  \nJquery와 같은 라이브러리에서 모듈화 기법으로 많이 사용한다.\n\n예제6) 자바와의 차이점. for문 안에서의 변수.\n\n```javascript\nfor (var i = 0; i < 1; i++) {\n  var name = \"local no!\";\n}\nalert(name); //local no!\n```\n\n자바는 반복문, 조건문 안에서 선언된 변수를 지역변수 취급하기 때문에 위와 같은 로직으로 실행시키면 에러가 난다.  \n그러나 자바스크립트에서 해당 변수는 전역변수이다.\n\n예제7) 정적 유효범위\n\n```javascript\nvar i = 5;\nfunction a() {\n  var i = 10;\n  b();\n}\nfunction b() {\n  document.write(i); //누구의 i일까?\n}\na(); //5가 출력된다!\n```\n\n함수에서 변수를 찾을 때, 함수 내 지역변수를 먼저 찾고. 전역변수를 찾는다.  \n<span class=\"clr-note\">\n\\*\\*사용(호출)될 때가 아니라 정의될 때의 전역변수가 사용된다. -> 정적 유효범위\n</span>\n"}},{"name":"2018-01-13-javascript-opentutorials-function-2.md","oid":"116d87bf74c4c19e11740085d22550d499c73a9d","content":{"__typename":"GitHub_Blob","text":"# [생활코딩] javascript 함수지향2\n\n- Title : [생활코딩] javascript 함수지향2\n- Date : 2018-01-13\n- Category: Javascript\n\n생활코딩 함수지향 파트 중 값으로서의 함수와 콜백에 대한 내용을 정리했습니다.\n\n# 1. 값으로서 함수\n\n예제1) 자바스크립트에서는 함수도 객체이며, 함수도 값이 될 수 있다.\n\n```javascript\nfunction a() {} //함수는 a라는 변수에 담겨진 값.\nvar a = function() {};\n```\n\n예제2) 함수는 객체 안에 저장될 수 있다.\n\n```javascript\na = {\n  b: function() {}\n};\n```\n\nb는 key, 객체 안에서 변수 역할(어떤 값을 저장하고 있기 때문) = 속성(property)  \n속성에 저장된 값이 함수면 메소드라 부름.  \n즉, a라는 객체에 b라는 속성이 있는데, 이 속성의 값은 함수(메소드)다.\n\n예제3) 함수는 변수, 객체에 저장될 수 있고 인자로도 사용할 수 있다.\n\n```javascript\nfunction cal (func, num){\n   return func(num)\n}\n\nfunction increase (num){\n   return num+1;\n}\nalert (cal (increase, 1) );\n\n// 위 코드는 아래와 같이 해석될 수 있다.\nfunction cal ( func, num){\n   var func = increase (num){\n       return num+1\n   }\n}\n// 즉, func(1) => 2가 출력됨.\n```\n\n예제4) 함수를 리턴 값으로도 사용할 수 있다.\n\n```javascript\nfunction cal (mode){\n val funcs = {\n  'plus' : function (left, right) { return left + right },\n  'minus' : function (left, right) { return left - right }\n }\n return funcs[mode];\n}\nalert (cal('plus')(2,1));\n```\n\nreturn funcs['plus'] 는 funcs 객체의 plus 속성의 값인 function(left, right) {return left+right} 메소드를 리턴시킨다.  \ncal('plus')(2,1)은 cal('plus')함수의 인자 값으로 2, 1을 전달하겠다는 의미이다.  \ncal('plus')는 function(left, right) {return left+right} 이므로 알럿창에 3이 뜬다.\n\n예제5) 함수를 배열의 값으로 사용할 수 있다.\n\n```javascript\nvar process = [\n  function(input) {\n    return input + 10;\n  },\n  function(input) {\n    return input * input;\n  },\n  function(input) {\n    return input / 2;\n  }\n];\nvar input = 1;\nfor (var i = 0; i < process.length; i++) input = process[i](input);\n\nalert(input); //60.5\n```\n\n# 2. 콜백\n\n```javascript\nvar numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];\nnumbers.sort(); // numbers는 배열객체, sort()는 메소드(내장메소드)\nconsole.log(numbers); // 1, 10, 2, 20, 3, 4, 5, 6, 7, 8, 9 - 문자 기준으로 정렬한 듯.\n```\n\n<span class=\"clr-grey\">\nsort()    \narray.sort (sortfunc)    \n반환값 : 정렬된 배열\n</span>\n\n```javascript\nvar numbers = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];\nvar sortfunc = function(a, b) {\n  if (a > b) return 1;\n  else if (a < b) return -1;\n  else return 0;\n};\nvar sortfunc = function(a, b) {\n  return a - b; //역순은 return b-a;\n};\nnumbers.sort(sortfunc); // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20\n```\n\nsortfunc가 콜백함수가 된다.  \n함수는 값으로서 사용할 수 있기 때문에 sortfunc를 sort에 인자로 전달함으로서 sort 메소드를 사용자가 원하는 방식으로 바꿀 수 있다.\n\n<span class=\"clr-note\">\\*\\*콜백은 비동기처리에서 유용하게 사용된다.</span>\n"}},{"name":"2018-01-13-javascript-opentutorials-function-3.md","oid":"82bfa87848bd4512f9dba35b6b23b9234a890615","content":{"__typename":"GitHub_Blob","text":"# [생활코딩] javascript 함수지향3\n\n- Title : [생활코딩] javascript 함수지향3\n- Date : 2018-01-13\n- Category: Javascript\n\n생활코딩 함수지향 파트 중 클로저에 대한 내용을 정리했습니다.\n\n# 1. 클로저의 개념\n\n```javascript\nfunction outter() {\n  var title = \"coding everybody\";\n  return function() {\n    alert(title);\n  };\n}\ninner = outter();\ninner();\n```\n\n함수 outter의 리턴 값은 내부함수이며 변수 inner에 내부함수가 값으로 저장된다.  \noutter 호출이 종료된 순간, outter는 사라진다.  \n하지만, inner()를 실행했을 때 알럿창에 coding everybody가 보인다.\n\n왜?  \n<span class=\"clr-note\">내부함수는 외부함수가 종료되도 외부함수에 접근할 수 있다.</span>\n\n# 2. private variable\n\n```javascript\nfunction factory_movie(title) {\n  return {\n    get_title: function() {\n      return title;\n    },\n    set_tile: function(_title) {\n      if (typeof _title === \"String\") {\n        title = _title;\n      } else {\n        alert(\"제목은 문자열이여야 합니다.\");\n      }\n    }\n  };\n}\nghost = factory_movie(\"Ghost in the shell\");\nmatrix = factory_movie(\"Matrix\");\nalert(ghost.get_title()); //Ghost in the shell\nalert(matrix.get_tiel()); //Matrix\n```\n\nfactory_movie의 리턴 값은 get_title, set_title 메소드를 속성으로 가지고 있는 객체이다.  \nghost, matrix 변수는 객체를 담게된다.  \nfactory_movie 호출 후, 함수의 생이 종료되어도 ghost, matrix를 통해 함수의 지역변수인 title에 접근할 수 있다.\n\n왜 private variable을 사용해야 하는가?  \n<span class=\"clr-note\">외부에서 title 변수를 수정해도 ghost, matrix가 가진 title의 맥락에는 영향을 주지 않는다. 즉, 데이터의 수정과 저장을 안전하게 할 수 있다.</span>\n\n# 3. 클로저의 응용\n\n```javascript\nvar arr = [];\nfor (var i = 0; i < 5; i++) {\n  arr[i] = function() {\n    console.log(i);\n  };\n}\n\nfor (var index in arr) {\n  console.log(arr[index]());\n}\n//결과는 5 5 5 5 5\n```\n\n함수가 실행되는 시점의 변수가 내부함수에 저장된다.  \n두번째 반목문에서 배열객체의 함수를 실행하는 순간의 i가 콘솔에 찍히게 된다.  \n그러나, i는 첫번째 포문에 의해 이미 5가 되어버린 상태이므로 5만 다섯번 찍히게 된다.\n\n```javascript\nvar arr = [];\nfor (var i = 0; i < 5; i++) {\n  arr[i] = (function(id) {\n    return function() {\n      return id;\n    };\n  })(i);\n}\n\nfor (var index in arr) {\n  console.log(arr[index]());\n}\n//결과는 0,1,2,3,4\n```\n\n외부함수의 인자 값으로 i가 전달되고, 내부함수는 이 시점의 i를 저장한다.  \n첫번째 포문에서 외부함수가 i를 인자값으로 하면서 실행되는 시점에서 내부함수가 정의된다.\n"}},{"name":"2018-01-13-javascript-opentutorials-function-4.md","oid":"c7d22f03e4e8b75fb048d360874988a191610a79","content":{"__typename":"GitHub_Blob","text":"# [생활코딩] javascript 함수지향4\n\n- Title : [생활코딩] javascript 함수지향4\n- Date : 2018-01-13\n- Category: Javascript\n\n생활코딩 함수지향 파트 중 arguments와 apply()에 대한 내용을 정리했습니다.\n\n# 1. arguments\n\n```javascript\nfunction sum(){\n    var i, _sum = 0;\n    for( i=0; i< arguments.length; i++){\n        document.write(i +  \":\" + arguments[i] + <'br/>');\n        _sum += arguments[i];\n    }\n    return _sum;\n}\ndocument.write('result : ' + sum(1,2,3,4));\n```\n\narguments는 사용자가 전달한 인자들이 담겨있는 객체다.\n\n- .length를 통해 함수가 몇개의 인자 전달 받았는 지를 알 수 있다.\n- arguments[i] 를 통해 각 자리의 인자 값을 알 수 있다.\n\n자바스크립트는 매개변수의 수가 함수의 정의와 달라도 에러가 발생하지 않는다.\n\n```javascript\nfunction one(arg1) {\n  console.log(\n    \"one.length\",\n    one.length, //1\n    \"arguments\",\n    arguments.length //2\n  );\n}\none(\"val1\", \"val2\");\n```\n\n위의 차이점을 이용해보면. 함수에 정의된 매개변수의 갯수와 실제 전달받는 인자의 갯수를 비교해서 대상 함수가 올바르게 사용되었는 지를 체크 할 수 있다.\n\n# 2. apply() 내장함수\n\n```javascript\nfunction sum(arg1, arg2) {\n  return arg1 + arg2;\n}\nsum(1, 2); //3\nsum.apply; //function apply(){[native code]}     native code : 내장함수란 뜻\nsum.apply(null, [1, 2]); //3     -첫번째 인자가 null로 들어갈 때는, 쓰지않기.\n```\n\n왜 사용할까?\n\n```javascript\no1 = { val1: 1, val2: 2, val3: 3 };\no2 = { v1: 10, v2: 50, v3: 100, v4: 25 };\nfunction sum() {\n  var _sum = 0;\n  for (name in this) {\n    _sum += this[name];\n  }\n  return _sum;\n}\nalert(sum.apply(o1)); //6\nalert(sum.apply(o2)); //185\n```\n\no1 객체를 sum의 인자 값으로 전달한다.  \nthis는 var this = o1; 과 암시적으로 같다.  \n실행되는 그 순간에는 o1이라는 객체의 메소드 sum이 된다는 것.  \n즉, o1 = { va1 : 1, val2 : 2, val3 : 3, sum : sum} 에 o1.sum()과 같다.\n"}},{"name":"2018-01-13-javascript-opentutorials-object-1.md","oid":"803f4d7096343a90d391862bb2f929d76497a8e8","content":{"__typename":"GitHub_Blob","text":"# [생활코딩] javascript 객체지향1\n\n- Title : [생활코딩] javascript 객체지향1\n- Date : 2018-01-13\n- Category: Javascript\n\n생활코딩 객체지향에 대한 내용을 정리했습니다.\n\n객체(object)는 연관되어 있는 것(변수, 메소드)들을 그룹화한 것, 각 그룹화된 것은 독립성을 가지는 부품이 된다.\n\n# 1. 객체의 생성 방법\n\nthis는 함수가 속해있는 객체인 person을 가리킨다.\n\n```javascript\nvar person = {};\nperson.name = \"egoing\";\nperson.introduce = function() {\n  return \"My name is\" + this.name;\n};\ndocument.write(person.introduce());\n```\n\n```javascript\nvar person = {\n  name: \"egoing\",\n  introduce: function() {\n    return \"My name is\" + this.name;\n  }\n};\n```\n\n# 2. 생성자와 new\n\n생성자는 객체를 만드는 역할을 하는 함수.\n\n```javascript\nfunction Person() {}\nvar p0 = Person(); //undefined\nvar p = new Person(); //Person{} 비어있는 객체\n```\n\nnew Person()  \nPerson() 함수가 객체의 참조자가 될 수 있다.\n\n자바는 클래스 안에 생성자가 있고, 클래스의 객체를 만든다.  \n자바스크립트에서는 생성자가 함수일 뿐, 어디에 속해있지 않다.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n  this.introduce = function() {\n    return \"My name is \" + this.name;\n  };\n}\n\nvar p1 = new Person(\"egoing\");\nvar p2 = new Person(\"leezche\");\n\ndocument.write(p1.introduce()); //My name is egoing\ndocument.write(p2.introduce()); //My name is leezche\n```\n\n생성자 Person이라는 함수를 정의했다.  \nPerson 앞에 new가 존재하기 때문에 함수가 아닌 생성자가 된다.  \n생성자 함수가 하는 일은 객체의 초기화이며, 객체가 가지고 있는 정보, 객체가 할 수 있는 일을 정의하게 된다.  \n덕분에 코드의 재사용성이 높아진다.\n\n# 3. 함수와 this\n\n전역변수와 전역함수는 모두 window라는 전역객체의 속성과 메소드다.  \n<span class=\"clr-grey\">node.js에서 전역객체는 global이다.</span>\n\n## 1) 메소드와 this\n\nthis는 함수를 어떻게 호출하느냐에 따라 this를 가리키는 대상이 달라진다.\n\n전역함수의 this는 window와 같다.\n\n```javascript\nfunction func() {\n  if (window === this) {\n    console.log(\"window === this\");\n  }\n}\nfunc(); //window === this\n```\n\n객체의 소속인 메소드의 this는 그 객체를 가르킨다.\n\n```javascript\nvar o = {\n  func: function() {\n    if (o === this) {\n      document.write(\"o === this\");\n    }\n  }\n};\no.func(); //o===this\n```\n\n## 2) 생성자와 this\n\n```javascript\nvar funcThis = null;\nfunction Func() {\n  funcThis = this;\n}\n\nvar o1 = Func();\nif (funcThis === window) {\n  document.write(\"window\");\n}\n\nvar o2 = new Func();\nif (funcThis === o2) {\n  document.write(\"o2 </br>\");\n}\n// window, o2 둘다 출력됨.\n```\n\nFunc를 생성자로 사용되면 this는 객체를 가리키고, 함수로 사용되면 this는 window는 가리킨다.\n\n## 3) 객체로서 함수\n\n```javascript\nfunction sum(x, y) {\n  return x + y;\n}\nvar sum2 = new Function(\"x\", \"y\", \"return x+y\");\n```\n\nsum이라는 함수는 sum이라는 객체를 만든 것이다.  \n<span class=\"clr-grey\">\nfunction sum(){} 함수 리터럴  \nvar o ={} 객체리터럴  \nvar a = [0,1,2] 배열 리터럴  \n편리하게 값을 만들 수 있는 문법적인 체계를 리터럴이라고 한다.\n</span>\n\n## 4) apply와 this\n\n```javascript\nvar o = {};\nvar p = {};\n\nfunction func() {\n  switch (this) {\n    case o:\n      document.write(\"o\");\n      break;\n    case p:\n      document.write(\"p\");\n      break;\n    case window:\n      document.write(\"window\");\n      break;\n  }\n}\n\nfunc(); //window\nfunc.apply(o); //o\nfunc.apply(p); //p\n```\n\n자바스크립트의 this는 변화무쌍하다.\n"}},{"name":"2018-01-13-javascript-opentutorials-object-2.md","oid":"e8be63527de9580685e34fc4299ba081b8713fe7","content":{"__typename":"GitHub_Blob","text":"# [생활코딩] javascript 객체지향2\n\n- Title : [생활코딩] javascript 객체지향2\n- Date : 2018-01-13\n- Category: Javascript\n\n생활코딩 객체지향 파트 중 상속과 프로토타입에 대한 내용을 정리했습니다.\n\n# 1. 상속\n\n상속을 하기 위한 준비 작업\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.name = null;\nPerson.prototype.introduce = function() {\n  return \"My name is\" + this.name;\n};\n\nvar p1 = new Person(\"egoing\");\ndocument.write(p1.introduce()); //My name is egoing\n```\n\n객체의 프로퍼티 정의 방법은 생성자를 이용하는 것과 프로토타입을 이용하는 것이 있다.  \nPerson 객체에는 prototype이라는 속성이 있는 데 그 안에는 어떤 객체가 있다.  \n.name을 통해 그 객체에 값을 줄 수 있다.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.name = null;\nPerson.prototype.introduce = function() {\n  return \"My name is\" + this.name;\n};\nfunction Programmer(name) {\n  this.name = name;\n}\nfunction Designer(name) {\n  this.name = name;\n}\n\n/**상속방법**/\nDesigner.prototype = new Person();\nDesigner.prototype.design = function() {\n  return \"beautiful!\";\n};\nProgrammer.prototype = new Person();\nProgrammer.prototype.coding = function() {\n  return \"hello world!\";\n};\n\nvar p1 = new Programmer(\"egoing\");\ndocument.write(p1.introduce() + \"\"); //My name is egoing이 출력됨\ndocument.write(p1.coding() + \"\"); //hello world!\n\nvar p2 = new Desiner(\"leezche\");\ndocument.write(p2.design() + \"\"); //beautiful!\n```\n\nProgrammer에는 introduce 속성이 정의되어 있지않은데 어떻게 사용할 수 있었을까?  \nPerson의 introduce를 상속받았기 때문이다.\n\n객체를 생성할 때, 자바스크립트는 생성자 함수가 prototype라는 프로퍼티를 갖고 있는 지 확인한다.  \n그리고 생성자 함수에 들어있는 객체와 똑같은 객체를 만들어서 생성자의 결과로 리턴을 해준다.\n\nname과 introduce라는 프로퍼티가 prototype이라는 객체가 가지고 있다.  \n즉, prototype이라는 객체를 리턴한다?  \n그래서 Programmer의 prototype이라는 프로퍼티에 저장된다.\n\n<span class=\"clr-note\">\n*생성자의 prototype에 상속받을 객체를 new 한다.    \n*Programmer.prototype = new Person()\n</span>\n\n기본적으로 가지고있는 property를 가진 객체를 생성하기 위해서 객체 리터럴 대신, new라는 키워드를 사용한다.\n\n# 2. prototype\n\n```javascript\nfunction Ultra() {}\nUltra.prototype.ultraProp = true;\n\nfunction Super() {}\nSuper.prototype = new Ultra();\n\nfunction sub() {}\nSub.prototype = new Super();\n\nvar o = new Sub();\nconsole.log(o.ultraProp); //true출력됨.\n\n//1)\no.ultraProp = 1;\nconsole.log(o.ultraProp); //1\n```\n\no.ultraProp o라는 객체가 ultraProp를 가지고 있는지 찾는다. 그래서 1이 출력됨.\n\n```javascript\nfunction Ultra() {}\nUltra.prototype.ultraProp = true;\n\nfunction Super() {}\nSuper.prototype = new Ultra();\n\nfunction sub() {}\nSub.prototype = new Super();\nSub.prototype.ultraProp = 2;\n\nvar o = new Sub();\nconsole.log(o.ultraProp); //2가 출력됨\n```\n\no객체에 ultraProp 프로퍼티를 찾는다. 없으면 o라는 객체의 생성자를 알아 낸후, 이 생성자의 프로토타입 객체를 뒤져서 그 객체의 propery에 ultraProp가 있는 지 찾는다.\n\n```javascript\nfunction Ultra() {}\nUltra.prototype.ultraProp = true;\n\nfunction Super() {}\nSuper.prototype = new Ultra();\n\nfunction sub() {}\nvar s = new Super();\ns.ultraProp = 3;\nSub.prototype = s;\n\nvar o = new Sub();\nconsole.log(o.ultraProp); //3이 출력됨\n```\n"}},{"name":"2019-12-09-javascript.md","oid":"67bc7c019b3bd9c9383545a07d1976ba5bc817a9","content":{"__typename":"GitHub_Blob","text":"# 자바스크립트의 실행 컨텍스트\n\n- Title : 자바스크립트의 실행 컨텍스트\n- Date : 2019-12-09\n- Category: Javascript\n\n인사이드 자바스크립트를 정리하며 작성한 포스팅입니다.  \n이 포스팅은 실행 컨텍스트의 개념과 생성 과정에 대해 정리한 내용이며 실행 컨텍스트 이해를 위한 필수 개념인 스코프 체인과 this 바인딩에 대해서는 추후 정리할 예정입니다.\n\n# 실행 컨텍스트란?\n\n콜 스택에 쌓이는 각각의 정보들이 하나의 실행 컨텍스트라고 생각하며 아래의 문구를 읽어보자.\n\n- ECMAScript는 **실행 가능한 코드를 형상화하고 구분하는 추상적인 개념**으로 정의한다.\n- **실행 가능한 자바스크립트 코드 블록이 실행되는 환경**으로 코드 블록 안에는 변수, 객체, 실행 가능한 코드가 들어있다.\n- 스택의 TOP에 위치하는 실행 컨텍스트가 **현재 실행되는 컨텍스트**다.\n- 현재 실행되는 컨텍스트와 관련 없는 코드 블록이 실행되면 새로운 실행 컨텍스트가 생성되어 스택에 쌓이고 제어권이 생성된 컨텍스트로 이동한다.\n\n그렇다면 실행 컨텍스트가 형성되는 경우는 언제일까?  \nECMAScript에서 실행 컨텍스트가 형성되는 경우를 다음과 같이 규정하고 있다.\n\n- 전역 코드\n- eval() 함수로 실행되는 코드\n- **함수 안의 코드를 실행하는 경우** (대부분의 경우)\n\n# 실행 컨텍스트 생성 과정\n\n자바스크립트에서 함수를 실행하여 실행 컨텍스트를 생성하면 자바스크립트 엔진은 다음 순서대로 작업을 실행한다.\n\n## 1. 활성 객체 생성\n\n실행 컨텍스트가 생성되면 엔진은 이 컨텍스트가 접근 할 수 있는 활성 객체를 생성하며 활성 객체에 앞으로 사용할 매개변수, 사용자 정의 변수 및 객체를 저장한다.\n\n## 2. arguments 객체 생성\n\n2단계에서는 arguments 객체를 생성하며 앞서 만들어진 활성 객체는 이 arguments 객체를 참조한다.\n\n잠깐 arguments 객체에 대해 알아보고 넘어가자\n\n```javascript\nfunction func(arg1, arg2) {\n  console.log(arg1, arg2);\n}\n\nfunc(); // undefined undefined\nfunc(1); // 1 undefined\nfunc(1, 2); // 1 2\nfunc(1, 2, 3); // 1 2\n```\n\n자바스크립트에서는 위 예제와 같이 함수 형식에 맞춰 인자 값을 넘겨주지 않아도 에러가 발생하지 않는다. 넘겨지지 않은 인자에는 **undefined**값이 할당되고, 초과된 인수는 무시된다.\n\n이러한 자바스크립트 특성 때문에 함수 코드를 작성할 때, 런타임 시에 호출된 인자의 개수를 확인하고 이에 따라 동작을 다르게 해줘야 할 경우가 있는 데, 이를 가능케 하는 게 바로 **arguments 객체**다.\n\n자바스크립트에서는 함수를 호출할 때 인수들과 함께 암묵적으로 arguments 객체가 함수 내부로 전달되며 arguments 객체에 넘긴 인자들이 배열형태로 저장된다. 단, 실제 배열이 아닌 **유사 배열 객체**다. 유사 배열 객체는 length 프로퍼티가 있어서 배열과 유사하게 동작하지만, 배열 메서드를 사용할 경우 에러가 발생한다.\n\n만약 arguments 객체에서 배열 메서드를 사용하고 싶다면 명시적으로 this를 바인딩 하면 된다.\ncall과 apply 메서드를 이용하여 this를 바인딩 할 수 있고, ES6 부터는 Arrays.from() 메서드와 전개 연산자를 사용할 수 있다.\n\n```javascript\nvar args = Array.prototype.slice.apply(arguments); // Array.prototype.slice() 메서드를 호출한다. 단, this는 arguments 객체로 바인딩한다.\n\n// ES6 이후\nvar args = Array.from(arguments);\nvar args = [...arguments];\n```\n\n## 3. 스코프 정보 생성\n\n현재 컨텍스트의 유효 범위를 나타내는 **스코프 정보**를 생성한다.  \n스코프 정보는 현재 실행 중인 실행 컨텍스트 안에서 **연결 리스트**와 유사한 형식으로 만들어진다.  \n현재 컨텍스트에서 특정 변수에 접근해야 할 경우, 이 리스트를 사용하며 현재 컨텍스트의 변수뿐 아니라 상위 실행 컨텍스트의 변수도 접근이 가능하다. 이 리스트에서 변수를 찾지 못하면 정의되지 않은 변수로 판단하여 에러를 검출한다. 이 때, 활성 객체는 리스트의 맨 앞에 추가된다.\n\n스코프 체인이 어떻게 만들어지는 지는 추후에 포스팅할 예정이다.\n\n## 4. 변수 생성\n\n실행 컨텍스트 내부에서 사용되는 **지역 변수**의 생성이 이루어진다. 여기서 생성되는 변수는 변수 객체에 저장되며 변수 객체는 앞서 생성한 활성 객체다.\n\n- 지역 변수나 내부 함수를 메모리에 생성하고 지역 변수에는undefined를 할당한다.\n- 인자를 생성하고 값을 할당한다. 인자값이 넘겨지지 않았다면 undefined를 할당한다.\n- 메모리에 생성할 뿐, **초기화**는 이루어지지 않는다.\n\n## 5. this 바인딩\n\n함수 호출 패턴에 따라 this는 다른 객체를 참조(바인딩)하며, this가 참조하는 객체가 없으면 전역 객체를 참조한다. this 함수 호출 패턴은 중요한 개념이므로 추후에 포스팅할 예정이다.\n\n## 6. 코드 실행\n\n코드 블록의 여러 가지 표현식이 실행되면서 변수의 초기화 및 연산, 또 다른 함수 실행 등이 이루어진다.\n\n**참고**  \n전역 실행 컨텍스트는 일반적인 실행 컨텍스트와 약간 다르다.\n\n- arguments 객체가 없다.\n- 스코프 체인은 전역 객체 하나만을 포함한다.\n- 전역 코드가 실행될 때 생성되는 컨텍스트다.\n- 전역 실행 컨텍스트의 **변수 객체는 전역 객체(window)다.** 따라서 전역적으로 선언된 함수와 변수는 전역 객체의 프로퍼티가 된다.\n\n```javascript\nvar a = 10;\nconsole.log(window.a); // 10\n```\n"}},{"name":"2019-12-17-javascript-es6.md","oid":"45928151f5549a4a93a02b2feceeba608babf1aa","content":{"__typename":"GitHub_Blob","text":"# ES6를 모르면 React 배우기가 어려워요.\n\n- Title : ES6를 모르면 React 배우기가 어려워요.\n- Date : 2019-12-17\n- Category: Javascript\n\nReact를 배워볼까? 하고 두근거리는 마음으로 React 공식 문서에 방문해서 자습서부터 차근차근 읽어본 적이 있습니다.  \n그런데, 으잉? 이건 대체 뭐지? 제게 커다란 장벽이 나타났습니다. 그 것은 바로 바로... **ES6 문법!!!**  \n그래서 준비했습니다. <span class=\"clr-note\">\"ES6를 모르면 React 배우기가 어려워요!\"</span> 지금부터 저와 함께 ES6 최신 문법을 정리해봅시다!\n\n# 변수 선언하기\n\n## 1. const\n\n블록(중괄호 {}) 유효 범위의 상수를 선언하며 재할당 및 재선언이 불가능합니다.\n\n```javascript\nconst number = 42;\n\ntry {\n  number = 99;\n} catch (err) {\n  console.log(err); // TypeError: Assignment to constant variable.\n}\n\nconsole.log(number); // 42\n```\n\n## 2. let\n\n<code class=\"codetainer\">let</code> 키워드를 사용하면 변수의 유효 범위를 블록 {} 안으로 한정시킬 수 있고 글로벌 변수의 값을 보호할 수 있습니다.\n\n```javascript\nvar topic = \"js\";\nif (topic) {\n  var topic = \"리액트\";\n  console.log(\"블록\", topic); // 블록 리액트\n}\nconsole.log(\"글로벌\", topic); // 글로벌 리액트\n```\n\n위 예제의 if 블록 안의 topic 변수와 if 블록 밖의 topic 변수는 같은 변수입니다.  \n<code class=\"codetainer\">var</code> 키워드는 함수 유효 범위를 가지기 때문입니다. 자바스크립트의 호이스팅에 의해 함수 안에 정의된 변수는 함수의 맨 앞에서 정의되고 <code class=\"codetainer\">undefined</code>로 초기화되기 때문에 두 topic 변수가 사실상 같은 변수가 됩니다.\n<br/><br/>\n\n```javascript\nvar topic = \"js\";\nif (topic) {\n  let topic = \"리액트\";\n  console.log(\"블록\", topic); // 블록 리액트\n}\nconsole.log(\"글로벌\", topic); // 글로벌 js\n```\n\nif 블록 안의 변수가 if 블록 밖의 변수에 영향을 끼치지 않게 하려면 <code class=\"codetainer\">let</code> 키워드를 사용하면 됩니다. <code class=\"codetainer\">let</code>은 블록 유효 범위이므로 호이스팅 시 블록의 맨 앞에서 정의되고 초기화 됩니다.\n<br/><br/>\n\n```javascript\nconsole.log(name); // Uncaught ReferenceError: Cannot access 'name' before initialization\nlet name = \"lee\";\n\nconsole.log(age); // undefined\nvar age = \"20\";\n```\n\n단, var로 선언된 변수는 선언과 초기화가 동시에 진행되고 let을 선언된 변수는 호이스팅되어 선언 단계가 이뤄지나 초기화 단계는 실제 let이 사용된 코드에 도착할 때 이루어집니다. 그래서 let 키워드로 선언한 변수를 초기화 단계 이전에 접근하면 reference 에러가 발생합니다.\n\n## 3. 템플릿 문자열\n\n템플릿 문자열 덕분에 더하기 기호 + 없이 편하게 문자열과 변수를 이어 붙인 string을 생성할 수 있습니다.  \n<code class=\"codetainer\">\\${}</code> 안에는 자바스크립트 변수, 식 어떤 것이든 가능하며 템플릿 문자열은 공백, 탭, 개행 문자를 사용할 수 있습니다.\n\n```javascript\nconsole.log(`${lastName}, ${firstName} ${middleName}`);\n```\n\n<span class=\"clr-grey\"></span>\n<span class=\"clr-note\"></span>\n\n## 4. 디폴트 파라미터\n\n이제 함수를 호출 시 인자 값이 넘어오지 않았다면 디폴트 값을 사용할 수 있습니다.\n\n```javascript\nfunction func(name = \"lee\", age = \"20\") {\n  console.log(`${name} : ${age}`);\n}\nfunc(); // lee : 20\n```\n\n함수 호출 시 인자 넘기지 않아도 디폴트 값을 사용해 함수가 정상적으로 실행됩니다. 문자열뿐 아니라 객체 등 다양한 타입의 값을 디폴트로 사용할 수 있습니다.\n\n# 화살표 함수 =>\n\n화살표 함수를 사용하면 function 키워드 없이도 함수를 만들 수 있고 return을 사용하지 않아도 식을 계산한 값이 자동으로 반환됩니다.\n\n```javascript\nvar materials = [\"Hydrogen\", \"Helium\", \"Lithium\", \"Beryllium\"];\nmaterials.map(({ length }) => length); // [8, 6, 7, 9]\n```\n\n<br/>\n또한, <span class=\"clr-note\">화살표 함수는 this를 새로 바인딩 하지 않습니다.</span> 대신 코드에서 바로 바깥의 함수(혹은 class)의 this 값을 사용합니다. 뿐만 아니라 <code class=\"codetainer\">arguments, super, new.target</code>을 바인딩 하지 않습니다.\n\n```javascript\nvar obj = {\n  i: 10,\n  b: () => console.log(this.i, this),\n  c: function() {\n    console.log(this.i, this);\n  }\n};\nobj.b(); // prints undefined, Window\nobj.c(); // prints 10, Object {...}\n```\n\n<br/>\nthis를 바인딩 하지 않기 때문에 메소드 함수에는 사용하지 않아야 하며 생성자로서도 사용할 수 없기 때문에 <code class=\"codetainer\">new</code>와 함께 사용하면 오류가 발생합니다.\n\n```javascript\nvar Foo = () => {};\nvar foo = new Foo(); // TypeError: Foo is not a constructor\n```\n\n# ES6 객체와 배열\n\n## 1. 구조 분해(Destructuring)\n\n구조 분해를 사용하면 객체의 필드를 원하는 변수에 대입할 수 있습니다.\n\n다음은 sandwich를 분해해서 bread와 meat 필드를 같은 이름의 변수에 넣어주는 코드입니다. 두 변수의 값은 sandwich에 있는 같은 이름의 필드 값으로 초기화되지만, 두 변수를 변경해도 원래의 필드 값은 바뀌지는 않습니다.\n\n```javascript\nvar sandwich = {\n  bread: \"크런치\",\n  meat: \"참치\",\n  cheese: \"스위스\",\n  toppings: [\"상추\", \"토마토\", \"머스타드\"]\n};\n\nvar { bread, meat } = sandwich;\n\nconsole.log(bread, meat); // 크런치 참치\n```\n\n객체를 분해해서 함수의 인자로 넘길 수 있습니다.\n\n```javascript\nvar func = ({ firstName }) => {\n  console.log(`이름은 ${firstName}`);\n};\n\nfunc({\n  firstName: \"garam\",\n  lastName: \"lee\"\n}); // 이름은 lee\n```\n\n배열의 경우도 비슷합니다.\n\n```javascript\nvar x = [1, 2, 3, 4, 5];\nvar [y, z] = x;\nconsole.log(y, z); // 1 2\n```\n\n변수 선언이 분리되어도 값 할딩이 가능합니다.\n\n```javascript\nvar a, b;\n[a, b] = [1, 2];\nconsole.log(a, b); // 1 2\n```\n\n기본값을 할당하여 분해한 값이 undefined면 기본 값을 사용합니다.\n\n```javascript\nvar a, b;\n[a = 5, b = 7] = [1];\nconsole.log(a); // 1\nconsole.log(b); // 7\n```\n\n두 변수 값 교환이 가능합니다.\n\n```javascript\nvar a = 1;\nvar b = 3;\n\n[a, b] = [b, a];\nconsole.log(a); // 3\nconsole.log(b); // 1\n```\n\n불필요한 값을 콤마를 사용해 생략하는 리스트 매칭을 사용할 수 있습니다. 무시하고 싶은 원소 위치에 콤마를 넣으면 리스트 매칭이 됩니다.\n\n```javascript\nvar [, , third] = [\"a\", \"b\", \"c\"];\nconsole.log(third); // c\n```\n\n## 2. 객체 리터럴 개선\n\n구조 분해의 반대라고 할 수 있으며 객체 리터럴 개선을 사용하면 현재 영역에 있는 변수를 객체의 필드로 묶을 수 있습니다.\n\n```javascript\nvar name = \"lee\";\nvar age = \"20\";\nvar print = function() {\n  console.log(`${this.name} : ${this.age}`);\n};\nvar person = { name, age, print };\nperson.print(); // lee : 20\n```\n\n객체 리터럴 개선으로 변수를 객체의 필드로 대입할 수 있으며 function 키워드를 입력하지 않고 메서드를 정의할 수 있다.\n\n```javascript\n// 예전 방식\nvar obj = {\n  name: name,\n  age: age,\n  print: function() {\n    console.log(`${name} : ${age}`);\n  }\n};\n\n// 개선된 방식\nconst obj = {\n  name,\n  age,\n  print() {\n    console.log(`${name} : ${age}`);\n  }\n};\n```\n\n## 3. 스프레드 연산자\n\n스프레드 연산자는 세 개의 점(...)으로 이루어진 연산자로,\n<code class=\"codetainer\">함수호출, 배열 리터럴과 문자열, 객체 리터럴</code>에서 사용할 수 있습니다.\n\n이전에는 두 배열의 모든 원소가 들어간 새로운 배열을 만들기 위해서 <code class=\"codetainer\">push(), splice(), concat() </code> 등을 사용해야 했습니다. 이제 스프레드 연산자를 통해 쉽게 만들 수 있습니다.\n\n```javascript\n// 이전 방식\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\narr1 = arr1.concat(arr2);\n\n// 전개 방식\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\narr1 = [...arr1, ...arr2]; // arr1은 [0,1,2,3,4,5]\n\n// 새로운 배열 생성\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\nvar arr3 = [...arr1, ...arr2]; // [0,1,2,3,4,5]\n\n// 중간 조합도 가능\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, ...arr1, 4, 5]; // 3,0,1,2,4,5\n\n// 나머지 원소 얻기 가능\nvar arr1 = [0, 1, 2, 3];\nvar [first, ...rest] = arr1;\nconsole.log(rest); // 1,2,3\n```\n\n스프레드 연산자는 원본 배열을 변경하지 않고 복사본을 만듭니다.  \n다음 예제를 통해 실제로 확인해보자. arr1 배열의 마지막 원소를 변수에 담으려고 <code class=\"codetainer\">Array.reverse</code>를 이용해 배열을 뒤집고 첫번째 원소를 변수에 넣는 예제입니다.\n\n```javascript\n// 원본 배열이 변경된다.\nvar arr1 = [0, 1, 2];\nvar [last] = arr1.reverse();\nconsole.log(last); // 2\nconsole.log(arr1); // 2 1 0\n\n// 전개 연산을 통해 원본 배열 유지하기\nvar arr1 = [0, 1, 2];\nvar [last] = [...arr1].reverse();\nconsole.log(last); // 2\nconsole.log(arr1); // 0,1,2\n```\n\n객체에 사용할 수도 있습니다. 사용법은 배열과 유사합니다.\n\n```javascript\nvar obj1 = { foo: \"bar\", x: 42 };\nvar obj2 = { foo: \"baz\", y: 13 };\nvar obj3 = \"obj\";\nvar mergedObj = { ...obj1, ...obj2, obj3 };\nconsole.log(mergedObj); // { foo: \"baz\", x: 42, y: 13, obj3: \"obj\" }\n```\n\n함수 호출할 때도 사용할 수 있어서 배열의 엘리먼트를 함수의 인자로 사용하고자 할 때<code class=\"codetainer\">Function.prototype.apply()</code>를 대체할 수 있습니다.\n\n```javascript\n// 이전 방식\nfunction myFunction(x, y, z) {}\nvar args = [0, 1, 2];\nmyFunction.apply(null, args);\n\n// 전개 방식\nfunction myFunction(x, y, z) {}\nvar args = [0, 1, 2];\nmyFunction(...args);\n\n// new 키워드와 함께 사용할 수 있습니다.\nvar dateFields = [1970, 0, 1]; // 1 Jan 1970\nvar d = new Date(...dateFields);\n```\n\n# 클래스\n\n이전에는 공식적으로 클래스가 없어서 타입을 함수로 정의하고 그 함수 객체에 있는 프로토타입을 사용해 메서드를 정의했습니다. ES6부터 클래스 선언이 추가되어서 쉽게 클래스 패턴 생성이 가능해졌습니다.\n\n```javascript\nvar Foo = class {\n  constructor() {}\n  bar() {\n    return \"Hello World!\";\n  }\n};\n\nvar instance = new Foo();\ninstance.bar(); // \"Hello World!\"\nFoo.name; // \"\"\n```\n\nclass 키워드를 사용하더라도 내부적으로는 자바스크립트의 프로토타입 상속을 사용하고 있습니다. <code class=\"codetainer\">Foo.prototype</code>을 콘솔에 찍어보면 프로토타입에 생성자와 bar 메서드가 있는 것을 확인할 수 있을 것입니다.\n\n# ES6 모듈\n\n모듈은 다른 자바스크립트 파일의 코드를 쉽게 불러서 활용할 수 있는 재사용 가능한 코드 조각입니다. <code class=\"codetainer\">export</code>와 <code class=\"codetainer\">import</code> 키워드를 이용하면 됩니다.\n\n<code class=\"codetainer\">export</code>를 사용해 다른 모듈에서 활용할 수 있도록 이름(함수, 객체, 변수, 상수 등)을 외부에 익스포트할 수 있습니다.\n\n```javascript\n// export_1.js\n// print, log 함수를 외부에 export\n// 로컬 선언됨\nexport const print(message) => log(message, new Date())\nexport const log(message, timestamp) => console.log(`${timestamp.toString()} : ${message}`)\n\n// export_2.js\n// 단 하나의 이름만 외부에 export 하고 싶다면 export default 사용\nconst freel = new Date();\nexport default freel;\n```\n\n<code class=\"codetainer\">import</code>를 사용해 다른 자바스크립트 파일을 불러와 사용할 수 있습니다. 임포트 시 객체 구조 분해를 사용할 수 있으며, <code class=\"codetainer\">export default</code>를 사용한 경우 구조분해 없이 한 이름으로 부를 수 있습니다.\n\n```javascript\nimport { print, log } from ./export_1\nimport freel from ./export_2\n\n// import * 를 사용하여 다른 모듈에서 가져온 모든 이름을 사용자가 정한 로컬 이름 공간 안에 가둘 수 있음\nimport * from fns from ./export_1\n```\n\n# 커먼JS\n\n모든 버전의 노드에서 지원하는 일반적인 모듈 패턴입니다. 커먼 JS를 사용하여 객체를 <code class=\"codetainer\">module.exports</code>를 사용해 익스포트할 수 있습니다.\n\n```javascript\n//export.js\nconst print(message) => log(message, new Date())\nconst log(message, timestamp) => console.log(`${timestamp.toString()} : ${message}`)\n\nmodule.exports = {print, log}\n```\n\n```javascript\nconst { print, log } = require(\"./export\");\n```\n\n# ES6에서 비동기 프로그래밍\n\n나중에 따로 정리할 예정.\n\n## 1. promises\n\n## 2. 제너레이터\n"}},{"name":"2020-03-20-event-delegation.md","oid":"aca141df670b8b9c9474fa873d833730c6d80a8f","content":{"__typename":"GitHub_Blob","text":"# [자바스크립트] 이벤트 위임(Event delegation)\n\n- Title : [자바스크립트] 이벤트 위임(event delegation)\n- Date : 2020-03-20\n- Category : Javascript\n\n# Why?\n\n웹 개발자라면 이벤트 핸들러를 등록할 때 **캡처링**과 **버블링**을 적절하게 선택할 수 있어야 하지 않을까?\n```javascript\n    // 이벤트 캡처\n    element1.addEventListener('click',doSomething2,true)\n    // 이벤트 버블링\n    element2.addEventListener('click',doSomething,false)\n```\n> 🔊 익명함수로 이벤트 핸들러를 정의할 수 있는 데 이 때 화살표 함수의 this 컨텍스트는 event.currentTarget이 아님을 알고 있어야 한다. function (e) {} 형태로 정의해야 this 컨텍스트가 event.currentTarget이 된다.\n\n# addEventListener 동작 방식\n\naddEventListener() 메서드의 마지막 argument의 값으로 이벤트 전파 방식을 지정할 수 있다. true면 캡쳐, false(기본값)면 버블링으로 이벤트가 전파된다. 아래 예시로 이해를 어떤식으로 전파되는 지 이해해보자.\n```html\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <meta charset=\"utf-8\">\n      <meta name=\"viewport\" content=\"width=device-width\">\n      <title>JS Bin</title>\n    </head>\n    <body>\n      <div id=\"element1\">\n        element1\n        <div id=\"element2\">\n           element2\n          <div id=\"element3\">element3</div\n        </div>\n      </div>\n    </body>\n    </html>\n```\n```javascript\n    var element1 = document.getElementById(\"element1\");\n    var element2 = document.getElementById(\"element2\");\n    var element3 = document.getElementById(\"element3\");\n    function doSomething1(){\n      console.log(\"doSomething1\");\n    }\n    function doSomething2(){\n      console.log(\"doSomething2\");\n    }\n    function doSomething3(){\n      console.log(\"doSomething3\");\n    }\n```\n🎈 3개의 element가 버블링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,false)\n    element3.addEventListener('click',doSomething3,false)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething2`→ `doSomething1`\n- element3 클릭시 출력 :  `doSomething3`→ `doSomething2` -> `doSomething1`\n\n🎈 3개의 element가 캡처링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,true)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,true)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething1`→ `doSomething2`\n- element3 클릭시 출력 :  `doSomething1`→ `doSomething2` -> `doSomething3`\n\n🎈 맨 밖의 엘리먼트는 버블링 내부 엘리먼트는 캡처링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,true)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething2`→ `doSomething1`\n- element3 클릭시 출력 :  `doSomething2`→ `doSomething3` -> `doSomething1`\n\n🎈 섞여있으면..?\n```javascript\n    document.body.addEventListener('click',doSomething0,true)\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,false)\n```\nelement3 클릭시 출력 :  `doSomething0`→ `doSomething2` -> `doSomething3` → `doSomething1`\n\n### 테스트 결과\n\n- 이벤트 타켓에 이벤트가 발생하면 이벤트가 다른 이벤트 타켓(이벤트 핸들러가 등록된)으로 전파된다.\n- 이벤트 캡처는 이벤트 타켓의 최상위 요소(단, 이벤트 핸들러가 등록된)부터 이벤트 타켓까지 이벤트 핸들러를 처리한다.\n- 이벤트 버블링은 캡처와 반대로 이벤트 타켓부터 최상위 요소까지 이벤트 핸들러를 처리한다.\n- 섞여있으면 캡처링 우선인 이벤트 타켓부터 처리한 후 버블링을 수행한\n\n# 이벤트 버블링과 캡쳐\n\n아래 사진은 DOM 트리에서 일어나는 이벤트 전파 방법이다.\n\n[UI Events](https://www.w3.org/TR/DOM-Level-3-Events/#event-flow)\n\n![Event%20delegation/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/Untitled.png)\n\n캡처와 버블링은 두 요소(엘리먼트)가 해당 이벤트에 대한 핸들(함수)를 등록한 경우, 다른 요소 내에 중첩된 요소에서 발생하는 이벤트를 전파하는 방법이다. 이벤트 전파 모드로 요소가 이벤트를 수신하는 순서를 판별한다.\n\n## 이벤트 전파..? 신경쓰기 싫어!\n\n현재 이벤트 이후의 이벤트 전파(캡처링, 버블링)를 막고 싶다면 **`event.stopPropagation()`** 메서드를 사용하면 된다.\n\n## 이벤트는 취소하고 전파는 하고 싶어!\n\n**`event.preventDefault()`** 는 이벤트를 취소하지만 이벤트 전파를 막지 않는다. 전파를 막으려면 `event.stopPropagation()`을 사용해야한다.  주로 `a` 태그나 `submit` 태그 등 고유의 동작을 막고 원하는 이벤트 핸들러를 실행할 때 사용한다.\n\n## 메모리 이슈\n\n루프의 각 반복마다 새로운 익명 행들러 함수가 생성되는 방식으로 이벤트를 등록하지 말자. 따로 이벤트 핸들러를 생성한 후 등록하는 방식을 사용해야 메모리 소비가 줄고 `removeEventListener()`를 호출할 수 있다. 익명 함수는 참조가 유지되지않기에 이벤트 리스너를 제거할 수 없다.\n\n# 이벤트 위임(Event delegation)\n\n이벤트 발생 시 document 레벨까지 버블링 되어 올라가는 것을 활용하는 것으로 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식이다.\n\n- 동적인 엘리먼트에 대한 이벤트 처리 수월\n- 하위 엘리먼트는 자유롭게 추가 삭제 가능\n- 동일한 이벤트를 한 곳에서 관리할 수 있고 이벤트 핸들러 관리 쉽다.\n- 생성되는 이벤트 핸들러 함수가 줄어 메모리 사용량이 줄고 메모리 누수 가능성이 감소된다.\n\n참조\n\n[왜 이벤트 위임(delegation)을 해야 하는가?](https://ui.toast.com/weekly-pick/ko_20160826/)\n\n[EventTarget.addEventListener()](https://developer.mozilla.org/ko/docs/Web/API/EventTarget/addEventListener)"}},{"name":"2020-03-31-thread-queue-setTimeout.md","oid":"d40dfa460c3404882d4c862ecddb0374d3a40df0","content":{"__typename":"GitHub_Blob","text":"# 자바스크립트 동작 방식 - 스레드 큐와 setTimeout()\n\nDate: Mar 31, 2020\n\n- Title : 자바스크립트 동작 방식 - 스레드 큐와 setTimeout()\n- Date : 2020-03-31\n- Category : Javascript\n\n# WHY?\n\n자바스크립트가 단일 스레드 환경에서 돌아간다는 것은 대부분의 사람들이 알고 있을 것이다. 하지만 어떻게 동작하는 지는 모르는 사람이 있다.. ~~바로..나처럼..?~~ 그런 이유로 자바스크립트가 어떻게 돌아가는 지 낱낱이 파헤쳐 봐야지!\n\n# 스레드 큐(태스크 큐)\n\n스레드 큐는 단일 스레드 환경에서 어떠한 순서로 함수나 기능을 수행할지 결정하는 목록으로 FIFO(First-In First-Out)의 정책을 가진다. 스레드 큐 덕분에 지연이 발생하더라도 들어온 순서대로 요청을 처리할 수 있다. \n\n> ✨ 여기서 말하는 지연이란? 자바스크립트는 사용자와 상호작용하는 이벤트 기반 언어라, 비동기로 동작하거나 현재 소스가 실행 중에 사용자의 입력이 들어오면 지연이 발생할 수 있다.\n\n# setTimeOut() 파헤치기\n\n🎉아래 코드에서 `buttonAddItem.onclick`, `divItems.appendChild()`, `inputCloneItem.focus()` 가 스레드 큐에 어떤 순서로 들어갈지 생각해보자.\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n      </head>\n      <body>\n        <button id=\"addItem\">Add New Input</button>\n        <div id=\"items\"></div>\n        <script>\n          (function() {\n            const divItems = document.getElementById(\"items\"),\n              buttonAddItem = document.getElementById(\"addItem\"),\n              inputItem = document.createElement(\"input\");\n            buttonAddItem.onclick = () => {\n              const inputCloneItem = inputItem.cloneNode(true);\n              inputCloneItem.value = \"Give me focus\";\n    \n              divItems.appendChild(inputCloneItem);\n              setTimeout(() => {\n                inputCloneItem.focus();\n              }, 0);\n            };\n          }());\n        </script>\n      </body>\n    </html>\n\n`setTimeout()` 함수의 두번째 파라미타를 0으로 했으니깐 버튼을 클릭하면 `divItems.appendChild(inputCloneItem)` 보다 `inputCloneItem.focus()` 가 먼저 들어가있을거라고 생각했다면...? 땡땡!!😂😂 정답은 아래와 같다. `setTimeout()` 함수를 0초 후에 호출되도록 설정하면 호출하자마자 실행되는 것이 아니라 UI 업데이트가 이루어지고 나서 호출된다. 즉, setTimeout() 함수는 특정 시간이 되면 콜백 함수를 호출하도록 실행 큐 뒤에 해당 함수를 넣는 거지 함수 자체를 호출한다는 의미가 아니다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled.png)\n\n🎉 다음 예제를 통해 `setTimeout()` 함수와 단일 스레드 환경을 명확하게 이해해보자. 방금 예제와 비슷하지만 `setTimeout()`은 버튼이 클릭되고 2초 뒤에 콜백함수로 호출하도록 했고 `sleep()` 함수를 추가해서 10초동안 while 문이 돌아가게 했다. 자, 그럼 `setTimeout()`의 콜백함수는 언제 실행될까?\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n      </head>\n      <body>\n        <button id=\"addItem\">Add New Input</button>\n        <div id=\"items\"></div>\n        <script>\n          (function() {\n            const divItems = document.getElementById(\"items\"),\n              buttonAddItem = document.getElementById(\"addItem\"),\n              inputItem = document.createElement(\"input\"),\n              divLog = document.getElementById(\"log\");\n            buttonAddItem.onclick = () => {\n              const inputCloneItem = inputItem.cloneNode(true),\n                    waitSeconds = 10;\n              \n              inputCloneItem.value = \"Give me focus\";\n    \n              divItems.appendChild(inputCloneItem);\n    \n              console.log(\"Execute setTimeout at: \\t\" + Date.now());\n              setTimeout(() => {\n                inputCloneItem.focus();\n                console.log(\"Execute setTimeout at: \\t\" + Date.now());\n              }, 2000);\n    \n              sleep(waitSeconds * 1000);\n            };\n    \n            function sleep(waitSeconds) {\n              const waitUntil = Date.now() + waitSeconds;\n              while (Date.now() < waitUntil);\n            }\n          }());\n        </script>\n      </body>\n    </html>\n\n아래의 실행결과를 보면 setTimeout() 안의 콜백함수는 2초 뒤에 실행되지않고 10초 뒤에 실행된다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%201.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%201.png)\n\nsetTimeout()의 콜백함수는 버튼 클릭 2초 후 스레드 큐에 등록되지만 버튼 클릭 핸들러 내 sleep() 함수가 다 실행되어야 순서대로 처리되기 때문에 10초보다 뒤에 실행된다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%202.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%202.png)\n\n🎉 위 예제에서 버튼 클릭 시 setTimeout() 함수를 두번 호출하도록 코드를 수정해보고 실행이 어떤식으로 되는 지 알아보자.\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n      </head>\n      <body>\n        <button id=\"addItem\">Add New Input</button>\n        <div id=\"items\"></div>\n        <script>\n          (function() {\n            const divItems = document.getElementById(\"items\"),\n              buttonAddItem = document.getElementById(\"addItem\"),\n              inputItem = document.createElement(\"input\"),\n              divLog = document.getElementById(\"log\");\n            buttonAddItem.onclick = () => {\n              const inputCloneItem = inputItem.cloneNode(true),\n                    waitSeconds = 10;\n              \n              inputCloneItem.value = \"Give me focus\";\n    \n              divItems.appendChild(inputCloneItem);\n    \n              console.log(\"onclick function invoked at: \\t\" + Date.now());\n              setTimeout(() => {\n                console.log(\"1st Execute setTimeout at: \\t\" + Date.now());\n                sleep(waitSeconds * 1000);\n              }, 2000);\n              setTimeout(() => {\n                inputCloneItem.focus();\n                console.log(\"2 Execute setTimeout at: \\t\" + Date.now());\n              }, 2000);\n    \n              sleep(waitSeconds * 1000);\n            };\n    \n            function sleep(waitSeconds) {\n              const waitUntil = Date.now() + waitSeconds;\n              while (Date.now() < waitUntil);\n            }\n          }());\n        </script>\n      </body>\n    </html>\n\n클릭 이벤트가 발생하면 setTimeout() 함수의 콜백 이벤트를 등록하고 2초 뒤에는 등록한 2개의 setTimeout() 함수가 호출된다(스레드 큐에 콜백함수가 들어간다) 이때 스레드 큐에서는 10초간 sleep()을 수행하기때문이 sleep()이 끝나고 UI 업데이트가 이루어진 후 첫번째 콜백이 실행된다. 콜백 안에 또 sleep()이 있어서 10초 뒤에 두번째 콜백이 수행된다. 즉, 두번째 setTimeout 콜백은 20초 뒤에나 실행된다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%203.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%203.png)\n\n스레드 큐는 아래와 같다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%204.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%204.png)\n\n# 결론\n\nsetTimeout() 뿐만 아니라 모든 XMLHttpRequest나 다른 콜백 이벤트가 발생했다고 해서 바로바로 현재의 스레드에 인터럽트를 걸고 실행하는 것이 아니라, **현재 실행하고 있는 스레드 큐가 끝나고 자신의 차리가 와야 실행된다**. 즉, 처리가 오래 걸리는 자바스크립트 함수가 있을 때는 호출이 이루어져야 하는 시간이 되어도 그 함수의 처리가 끝날 때까지 스레드 큐에서 대기한다."}},{"name":"2020-05-23-iterator-generator.md","oid":"925c932c741ff2a153eedb35c2a39a5860255566","content":{"__typename":"GitHub_Blob","text":"# 자바스크립트의 iterable, iterator 프로토콜과 generator\n\n- Title : 자바스크립트의 iterable, iterator 프로토콜과 generator\n- Date : 2020-05-23\n- Category : Javascript\n\n# iterable 프로토콜\n\n- iterable 프로토콜은 반복 가능한 객체를 정의하는 방법(규약)으로 `for..of` 를 통해 value를 반복할 수 있다.\n- 반복 가능한 내장 객체로 `Array`, `Map`, `Set`, `String` 등이 있으며 객체는`[Symbol.iterator]` 속성 키를 가진다. *이 객체 들의 프로토타입 객체들이 `@@iterator` 메소드를 가지기 때문에 반복이 가능하다.*\n- `Promise.all(iterable)`, `Array.from()` 도 iterable을 허용한다.\n- 반복 가능한 객체를 만들고 싶다면 객체의 `[Symbol.iterator]` 속성에 `@@iterator` 메소드를 구현 하면 된다. 이 메소드는 iterator 프로토콜을 따르며 인수 없이 호출 되고 iterator 객체를 반환한다.\n\n반복 가능한 객체(iterable)는 `for-of` , `spread operator`, `yield*`, `구조 분해 할당`에 함께 사용된다.\n\n```java\nfor(let value of ['a', 'b', 'c']){\n    console.log(value)\n}\n// \"a\"\n// \"b\"\n// \"c\"\n\n[...'abc'] // [\"a\", \"b\", \"c\"]\n\nfunction* gen(){\n  yield* ['a', 'b', 'c']\n}\n\ngen().next() // { value:\"a\", done:false }\n\n[a, b, c] = new Set(['a', 'b', 'c'])\na // \"a\"\n```\n\nString은 반복 가능한 내장 객체로 `[Symbol.iterator]` 속성에 `@@iterator` 메소드가 있다.\n\n```java\nconst someString = \"hi\";\ntypeof someString[Symbol.iterator]; // function\nconst iterator = someString[Symbol.iterator](); // StringIterator {}\niterator + \"\" // [Object String Iterator]\n\niterator.next(); // { value: \"h\", done: false }\niterator.next(); // { value: \"i\", done: false }\niterator.next(); // { value: undefined, done: true }\n\n[...someString] // [ \"h\", \"i\" ]\n```\n\n반면에 일반 객체는 `@@iterator` 없어서 `undefined` 값을 반환한다. *물론 정의가 가능하다.*\n\n```java\nconst testObject = new Object();\ntypeof testObject[Symbol.iterator] // undefined\n```\n\n# iterator 프로토콜\n\n- 반복 가능한 객체의 value들을 시퀀스(어떠한 일련의 순서)대로 처리하는 방법(규약)이다.\n\n### iterator 객체 구현 규칙\n\n- `next()` 메소드가 있어야 한다. 이 메소드는 `done`, `value` 속성을 가진 객체를 반환한다.\n    - `done`(boolean): iterator가 마지막 반복 작업을 끝내면 true, 작업이 남아 있으면 false다. *done이 true이면 반환되는 객체의 value 프로퍼티의 값은 undefined다.*\n    - `value`: iterator에서 반환되는 값으로 done이 true면 생략될 수 있다.\n\n아래 코드는 문자를 하나씩 반환하는 String의 `@@iterator` 메소드를  \"bye\" 만 반환하고 끝내도록 재 정의한 예제다.\n\n```java\nconst someString = new String(\"hi\");\n\nsomeString[Symbol.iteraror] = function() {\n\treturn { // iterator 객체를 리턴\n\t\tnext: function() {\n\t\t\tif (this._first) {\n\t\t\t\tthis._first = false;\n\t\t\t\treturn { value: \"bye\", done: false };\n\t\t\t} else {\n\t\t\t\treturn { done: true };\n\t\t\t}\n\t\t},\n\t\t_first: true\n\t};\n};\n```\n\n# Generator\n\n## Generator 함수\n\n- 실행이 연속적이지 않는 작업을 iterator 처럼 사용할 수 있게 해준다.\n- `function*` 키워드를 통해 선언되는 Generator 함수는 호출 되어도 즉시 실행되지 않고, 대신 함수를 위한 Iterator 객체(Generator 객체)가 반환됩니다\n- `next()` 메소드를 호출하면 Generator 함수가 실행되어 `yield` 문을 만날 때까지 진행하고, 해당 yield가 반환하는 객체를 리턴 한다.  반환하는 객체는 yield문이 반환할 값(yielded value)을 나타내는 `value` 속성과, Generator 함수 안의 모든 yield 문의 실행 여부를 표시하는 boolean 타입의 `done` 속성을 갖는다.\n\n> `yield*`: 다른 generator 또는 iterable 객체에 yield를 위임할 때 쓰이며 `yield [iterable 객체를 반환하는 표현식]` 방식으로 사용한다.\n\n## Generator 객체\n\n- generator function에서 반환된 값으로 iterator, iterable 프로토콜을 준수한다.\n- `Generator.prototype.next()`: `yield` 표현을 통해 yield된 값을 반환\n- `Generator.prototype.return()`: 주어진 값을 반환하고 Generator 종료\n- `Generator.prototype.throw()`:  Generator의 실행을 재개시키고 Generator 함수의 실행 문맥 속으로 error를 주입하며 done, value 프로퍼티를 가진 객체를 반환한다.\n\n```java\nfunction* gen() {\n\twhile(true) {\n\t\ttry {\n\t\t  yield 1;\n\t\t  yield 2;\n\t\t  yield 3;\n\t\t} catch(e) {\n\t\t\tconsole.log('Error caught!');\n\t\t}\n\t}\n}\n\nvar g = gen(); // \"Generator { }\"\n\ng.next();        // { value: 1, done: false }\ng.throw(new Error(\"Something went wrong\"));\n// \"Error caught!\"\n// { value: 1, done: false }\ng.return(\"foo\"); // { value: \"foo\", done: true }\ng.next();        // { value: undefined, done: true }\n```\n\n반복 가능한 객체를 만들기 위해 `[Symbol.iterator]` 속성에 Generator 객체를 아래와 같이 정의할 수 있다.\n\n```java\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n[...myIterable]; // [1, 2, 3]\n```\n\n무한 iterable 객체 만드는 방법\n\n```java\nfunction* idMaker(){\n    var index = 0;\n    while(true)\n        yield index++;\n}\n\nvar gen = idMaker(); // \"Generator { }\"\n\nconsole.log(gen.next().value); // 0\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\n```\n"}},{"name":"2020-05-30-promise-await.md","oid":"0dfe7484013b534a57d77a03dafae8490bb0d27b","content":{"__typename":"GitHub_Blob","text":"# 자바스크립트 async, await, promise\n\n- Title : 자바스크립트 async, await, promise\n- Date : 2020-05-20\n- Category : Javascript\n\n# Rules for Promise\n\n1. 비 동기나 블로킹 코드 작업을 하고 싶을 때 `Promise`를 사용하자.\n2. `resolve`는 `then`과  `reject`는  `catch` 와 맵핑된다.\n3. `.catch` `.then` 메소드를 사용하자.\n4. 꼭 실행 해야 할 코드가 있다면 `.finally` 를 사용하자.\n5. 여러 개의 `Promise`가 모두 완료 되었을 때 작업을 진행하고 싶다면 `Promise.all(iterable)`를 사용하자. `Promise.all`은 배열 내 모든 프로미스의 이행(또는  첫 번째 거부)를 기다린다.\n\n    ```jsx\n    const p1 = Promise.resolve(3);\n    const p2 = 1337;\n    const p3 = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        resolve(\"foo\");\n      }, 100);\n    }); \n\n    // p2는 프로미스가 아니지만 이행 결과 배열에는 포함된다.\n    Promise.all([p1, p2, p3]).then(values => { \n      console.log(values); // [3, 1337, \"foo\"] \n    });\n\n    // 매개변수 배열이 빈 것과 동일하게 취급하므로 이행함\n    const p4 = Promise.all([1,2,3]); // Promise {<resolved>: Array(3)} [1, 2, 3]\n\n    // 프로미스 거부됨\n    const p5 = Promise.all([1,2,3, Promise.reject(555)]); // Uncaught (in promise) 555\n    ```\n\n# Rules for async-await\n\n1. `async function` 은 `Promise`를 리턴한다.\n2. 코드에서 직접 `Promise`를 직접 리턴하지않았어도 async 함수는 Promise를 리턴한다는 것을 기억하자.\n3. `await` 블록은 `async` 함수 안에 위치한다.\n4. `async` 함수에는 두 개 이상의 `await` 구문을 사용할 수 있다.\n5. `async await`를 사용할 때, `try~catch`로 에러 핸들링을 하자.\n6. `iterator`과 `loop`에서 `await`를 사용하며 코드가 순차적으로 실행될 것 같지만 사실은 동시에 실행된다.\n7. `await`는 하나의 `Promise`를 위해서만 사용하자.\n8. `await` 블록은 항상 `async` 함수 내에 있다. `promise`가 `resolve`되면 다음 코드가 실행된다는 것을 기억하자. \n\n# Promise vs async-await\n\n1. `async` 함수는 `promise`를 반환하고 반대도 성립된다. 즉, `promise`를 반환하는 모든 함수는 `async` 함수로 사용할 수 있다.\n2. function2의 아웃풋이 function1의 아웃풋에 따라 달라진다면 `await`를 사용하자.\n3. 두 개의 함수가 순차적으로 실행될 필요가 없다면 `await`를 쓸 필요가 없다.\n4. Promise를 동시에 실행시키고 싶다면 `Promise.all`을 사용하자\n5. `await`는 `blocking code`를 만든다는 사실을 잊지 말자.\n6. 많은 await 구문이 있는 async 함수를 사용하는 것보다는 여러 개의 async 함수로 쪼개서 사용하자.\n    - 너무 많은 `blocking code`는 좋지 않다.\n    - 비동기 코드가 수평적으로 실행된다는 것을 강조할 수 있다.\n\n[JavaScript: Promises or async-await](https://medium.com/better-programming/should-i-use-promises-or-async-await-126ab5c98789)\n\n# Symbol\n\n```jsx\n// 위 코드는 매 번 새로운 심볼을 생성한다.\nconst sym1 = Symbol();\nconst sym2 = Symbol(\"foo\");\nconst sym3 = Symbol(\"foo\");\n```\n\n1. 이름 충돌의 위험 없이 **속성의 키**로 쓰기 위해 생성하고 사용할 수 있는 값이다.\n2. Boolean, String, Number 같이 원시 데이터 형의 일종이다.\n3. `Symbol()` 로 부터 반환되는 모든 심볼 값은 고유하다.\n4. 객체 속성에 대한 `식별자`로 사용할 수 있다.\n5. `Object.getOwnPropertySymbols()` 메서드를 이용하여 객체의 심볼 속성을 찾을 수 있다. 모든 객체는 심볼 속성이 없는 상태로 초기화 되기 때문에 해당 객체에 심볼 속성을 설정하기 전까지는 빈 배열을 반환한다는 점에 유의하자.\n"}},{"name":"2020-06-06-destructuring-assignment.md","oid":"3de93d97b060a371fac7a45301b7aad6da6295fb","content":{"__typename":"GitHub_Blob","text":"# Destructuring assignment\n\n- Title : destructuring assignment\n- Date : 2020-06-06\n- Category : Javascript\n\n# 구조 분해 할당\n\n## 1. 배열 구조 분해 할당\n\n```jsx\nlet arr = ['garam', 'lee']\n\n// let firstName = arr[0]\n// let lastName = arr[1]\n// 위와 같은 작업을 구조 분해 할당으로 간단히 할 수 있다.\n\nlet [firstName, lastName] = arr;\n```\n\n`split` 메소드처럼 배열을 리턴하는 함수를 사용할 때 구조 분해 할당을 사용하면 좋다.\n\n```jsx\nlet [firstName, lastName] = 'garam lee'.split(' ');\n```\n\n### 1) 원본 배열에 영향을 주지 않는다.\n\n구조 분해 할당은 원본 배열을 복사해서 각 변수에 할당하여 원본 배열에 영향이 없다.\n\n```jsx\nlet arr = ['garam', 'lee'];\nlet [firstName, lastName] = arr;\nconsole.log(arr); // [\"garam\", \"lee\"]\n```\n\n### 2) `,`를 사용하여 배열의 요소를 생략할 수 있다.\n\n```jsx\nlet [firstName, , title] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\nconsole.log(firstName, title); // Julius Consul\n```\n\n### 3) 배열이 아닌 **iterable 가능한 객체**들도 구조 분해 할당을 할 수 있다.\n\n```jsx\nlet [a, b, c] = \"abc\"; // [\"a\", \"b\", \"c\"];\nlet [one, two, three] = new Set([1, 2, 3]); // [1, 2, 3]\n```\n\n### 4) 객체의 속성에도 할당을 할 수 있다.\n\n```jsx\nlet user = {};\n[user.firstName, user.lastName] = \"garam lee\".split(\" \");\nconsole.log(user); // {firstName: \"garam\", lastName: \"lee\"}\n```\n\n### 5) 객체의 key-value 로 루프를 돌릴 때 구조 분해 할당을 함께 사용할 수 있다.\n\n```jsx\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\nfor (let [key, value] of Object.entries(user)) {\n  console.log(`${key}:${value}`); // name:John, then age:30\n}\n\nlet user2 = new Map();\nuser2.set(\"name\", \"John\");\nuser2.set(\"age\", \"30\");\n\nfor (let [key, value] of user2) {\n  console.log(`${key}:${value}`); // name:John, then age:30\n}\n```\n\n### 6) 변수를 SWAP할 때 사용할 수 있다.\n\n두 변수에 대한 배열을 생성한 후에 구조 분해 할당을 하기 때문에 swap이 가능하다.\n\n```jsx\nlet guest = \"Jane\";\nlet admin = \"Pete\";\n\n[guest, admin] = [admin, guest];\nconsole.log(guest, admin); // Pete Jane\n```\n\n### 7)  `...` 를 사용하여 배열의 남은 요소를 할당할 수 있다.\n\n```jsx\nlet [name1, name2, ...rest] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\nconsole.log(name1, name2); // Julius Caesar\nconsole.log(rest, rest.length); // [\"Consul\", \"of the Roman Republic\"] 2\n```\n\n### 8) default value 할당하기\n\n할당될 값이 없을 때 default value로 설정한 값이 변수에 할당된다.\n\n```jsx\nlet [firstName, surname] = []; // undefined, undefined\nlet [firstName = \"Guest\", surname = \"Anonymous\"] = []; // Guest, Anonymous\n```\n\n## 2. 객체 구조 분해 할당\n\n```jsx\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\nlet {title, width, height} = options;\n```\n\n### 1) `{ 객체의 프로퍼티: 변수 이름 }` 과 같은 형식으로 변수 이름을 변경할 수 있다.\n\n```jsx\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\nlet {width: w, height: h, title} = options;\nconsole.log(w, h, title); // 100, 200, \"Menu\"\n```\n\n### 2) `=` 을 이용하여 default value 할당할 수 있다.\n\n```jsx\nlet options = {\n  title: \"Menu\"\n};\n\nlet {width = 100, height = 200, title} = options;\nconsole.log(width, height, title); // 100, 200, \"Menu\"\n\n// 이름 변경도 동시에 가능\nlet {width: w = 100, height: h = 200, title} = options;\n```\n\n### 3) rest 패턴을 사용할 수 있다.\n\n```jsx\nlet options = {\n  title: \"Menu\",\n  height: 200,\n  width: 100\n};\n\nlet {title, ...rest} = options;\n\nconsole.log(title, rest.height, rest.width); // \"Menu\" 200 100\n```\n\n## 3. 중첩 구조 분해\n\n```jsx\nlet options = {\n  size: {\n    width: 100,\n    height: 200\n  },\n  items: [\"Cake\", \"Donut\"],\n  extra: true\n};\n\nlet { size: { width, height}, items: [item1, item2], title = \"Menu\" } = options\n/*\n size, items: is not defined\n width: 100\n height: 200\n item1: Cake\n item2: Donut\n title: Menu\n*/\n\n```\n\n## 4. 함수의 파라미타에 구조 분해 할당을 사용하자\n\n아래 함수의 경우는 파라미타의 순서를 기억 해야 한다는 단점이 있다. 더 많은 파라미타를 다뤄야 한다면..?\n\n```jsx\nfunction showMenu(title = \"Untitled\", width = 200, height = 100, items = []) {\n  // ...\n}\nshowMenu(\"My Menu\", undefined, undefined, [\"Item1\", \"Item2\"])\n```\n\n이 때 구조 분해 할당을 사용하면 좋다.\n\n```jsx\nlet options = {\n  title: \"My menu\",\n  items: [\"Item1\", \"Item2\"]\n};\n\nfunction showMenu({title = \"Untitled\", width = 200, height = 100, items = []}) {\n  alert( `${title} ${width} ${height}` ); // My Menu 200 100\n  alert( items ); // Item1, Item2\n}\n\nshowMenu(options);\n```\n\n만약 파라미타로 아무 값도 넘기고 싶지 않다면 아래와 같이 코드를 작성하면 된다.\n\n```jsx\nshowMenu({}); // 빈 객체를 보내면 된다. 하지만, 정말 아무 것도 보내고 싶지않다면?\nshowMenu(); // Error 발생\n```\n\n전체 argument 객체의 디폴트 객체로 {} 를 할당하면 에러를 잡을 수 있다.\n\n```jsx\nfunction showMenu({title = \"Untitled\", width = 200, height = 100, items = []} = {}) {\n  alert( `${title} ${width} ${height}` ); // My Menu 200 100\n  alert( items ); // Item1, Item2\n}\n\nshowMenu(); // 이제 에러가 발생하지 않는다.\n```\n\n참고\n[Destructuring assignment](https://javascript.info/destructuring-assignment)\n"}},{"name":"2020-06-07-rest-parameter-spread-syntax.md","oid":"b61a327c14326b17c25c930f6dee46d5be66b268","content":{"__typename":"GitHub_Blob","text":"# Rest 파라미터와 Spread 연산자\n\n- Title : Rest 파라미터와 Spread 연산자\n- Date : 2020-06-07\n- Category : Javascript\n\n# Rest 파라미터 `...`\n\n함수의 `arguments` 객체로 인해 유발되는 보일러 플레이트 코드를 줄일 목적으로 `Rest 파라미터` 가 도입되었다. `Rest 파라미터`는 함수의 마지막 파라미터 앞에 `...` 를 붙여 사용한다. 단 마지막에 한번만 사용해야 한다.\n\n아래 예제를 보면 arguments 객체 대신 rest 파라미터를 사용해야 하는 이유를 알 수 있다.\n\n```jsx\n// Rest 파라미터 이전에, \"arguments\" 는 다음을 사용해 일반적인 배열로 변환될 수 있음\nfunction f(a, b) {\n\n  var normalArray = Array.prototype.slice.call(arguments);\n  // -- 또는 --\n  var normalArray = [].slice.call(arguments);\n  // -- 또는 --\n  var normalArray = Array.from(arguments);\n\n  var first = normalArray.shift(); // OK, 첫 번째 인수를 반환\n  var first = arguments.shift(); // ERROR (arguments 가 일반적인 배열이 아님)\n\n}\n\n// 이제 rest 파라미터를 사용해 쉽게 일반적인 배열에 접근할 수 있음\n\nfunction f(...args) {\n  var normalArray = args;\n  var first = normalArray.shift(); // OK, 첫 번째 인수를 반환\n}\n```\n\n## 1. `Rest` 파라미터와 `arguments` 객체의 차이를 자세히 알아보자.\n\n- arguments 객체는 함수로 전달된 모든 인수를 포함한다. 즉 Rest 파라미터처럼 부분적으로 얻을 수 없다.\n- arguments 객체는 배열 형태의 객체라 Array에 있는 sort, map, forEach, pop 과 같은 메서드를 사용할 수 없다. 반면에 Rest는 표준 배열이라 해당 메서드를 사용할 수 있다.\n\n> 배열 형태의 객체는 length 속성과 더불어 0부터 인덱스 된 다른 속성을 가지고 있지만, Array의 forEach, map과 같은 내장 메서드를 가지고 있지 않다.\n\n> 화살표 함수는 arguments 객체가 없다. 만약 화살표 함수에서 arguments 객체에 접근한다면 스코프 체인을 따라 일반 함수의 arguments 값을 가져오게 된다. 뿐만 아니라 화살표 함수는 자체 this가 없다.\n\n## 2. 인자의 개수가 유동적일 때 Rest Parameter가 유용하다.\n\n아래 예제는 인자로 전달되는 숫자들의 합을 구하는 함수다. 만약 Rest Parameter를 쓰지 않았다면?..\n\n```jsx\nfunction sum(...theArgs) {\n  return theArgs.reduce((previous, current) => {\n    return previous + current;\n  });\n}\n\nconsole.log(sum(1, 2, 3));\n// expected output: 6\n\nconsole.log(sum(1, 2, 3, 4));\n// expected output: 10\n```\n\n## 3. Rest 파라미터는 배열로만 해체할 수 있다.\n\n```jsx\nfunction f(...[a, b, c]) {\n  return a + b + c;\n}\n\nf(1)          // NaN (b 와 c 는 undefined)\nf(1, 2, 3)    // 6\nf(1, 2, 3, 4) // 6 (4번 째 파라미터는 해체되지 않음)\n```\n\n## 4. 객체 구조 분해에서 Rest\n\n객체 구조 분해에서 rest 속성은 구조 분해 패턴으로 걸러 지지 않은 열거형 속성의 키를 가진 나머지 항목을 모은다.\n\n```jsx\nconst obj = { foo:1, bar: 2, baz: 3 };\nconst { foo, ...rest } = obj;\n```\n\nrest operator는 최대 한번만 사용 가능하며 객체 리터럴의 마지막에 나타나야 한다.\n\n```jsx\nconst {...rest, foo} = obj; // SyntaxError\nconst {foo, ...rest1, ...rest2} = obj; // SyntaxError\n```\n\n단, 중첩 구조 분해 할당을 할 경우에는 rest 연산자가 여러 번 나올 수 있다.\n\n```jsx\nconst obj = {\n    foo: {\n        a: 1,\n        b: 2,\n        c: 3,\n    },\n    bar: 4,\n    baz: 5,\n};\nconst {foo: {a, ...rest1}, ...rest2} = obj;\n\n// Same as:\n// const a = 1;\n// const rest1 = {b: 2, c: 3};\n// const rest2 = {bar: 4, baz: 5};\n```\n\n# Spread Syntax\n\n위에서는 파라미터 리스트에서 배열을 얻었다. 그럼 반대로 배열을 분해하여 리스트를 얻을 수도 있을까? spread 연산자를 사용하면 가능하다.\n\n## 1. 스프레드 연산자로 두 배열을 합쳐보기\n\n```jsx\nlet arr = [3, 5, 1];\nlet arr2 = [8, 9, 15];\n\nlet merged = [0, ...arr, 2, ...arr2]; // [0, 3, 5, 1, 2, 8, 9, 15];\n```\n\n## 2. 객체 리터럴에서 스프레드 연산자 사용하기\n\n객체 리터럴에서 스프레드 연산자는 객체의 모든 열거 가능한 속성들을 객체 리터럴에 넣는다.\n\n```jsx\nconst obj = {foo: 1, bar: 2, baz: 3};\nconst newObj = {...obj, qux: 4}; // {foo: 1, bar: 2, baz: 3, qux: 4}\n```\n\n키가 충돌되면 어떻게 될까? 나중에 나온 value 값이 키 값이 된다.\n\n```jsx\nconst obj = {foo: 1, bar: 2, baz: 3};\nconst newObj = { ...obj, foo: true }; //{foo: true, bar: 2, baz: 3}\nconst newObj2 = { foo: true, ...obj }; // {foo: 1, bar: 2, baz: 3}\n```\n\n## 3. `Math.max`의 인자로 배열의 값들을 전달하고 싶을 때\n\n```jsx\nlet arr = [3, 5, 1];\nconsole.log(Math.max(arr)); // NaN\nconsole.log(Math.max(arr[0], arr[1], arr[2]); // 5\n```\n\n배열의 요소가 많아질 때마다 arr[3], arr[4] ... 호출하는 건 좋은 코드가 아닐 거다. 이럴 때 스프레드 연산자를 사용한다. 스프레드 연산자는 배열을 분해하여 인자로 보낸다.\n\n```jsx\nlet arr = [3, 5, 1];\nconsole.log(Math.max(...arr)); // 5\n```\n\n## 4. iterable 객체는 구조 분해 될 수 있다.\n\n대표적으로 String 객체를 구조 분해한 예제를 살펴보자. \n\n```jsx\nlet str = \"Hello\";\nconsole.log([...str]); // [H, e, l, l, o]\nconsole.log(Array.from(str)) // [H, e, l, l, o]\n```\n\n1. 이 코드는 스프레드 연산자를 이용하여 str(String 객체 === iterable 객체)를 구조 분해한 후 배열을 초기화 하는 작업을 한다. 스프레드 연산자는 내부적으로 `iterator`을 사용하기 때문에 `for...of` 와 동작이 같다.\n2. 위 결과를 보면 `Array.from(str)`의 결과와 `[...str]`의 결과가 같다는 것을 알 수 있다. 하지만 작은 차이점이 있다. 스프레드 연산자는 오직 `iterable` 객체에만 적용될 수 있는 반면 `Array.from`은 `iterable` 객체 뿐만 아니라 배열 형태의 객체 에도 적용할 수 있다. 이러한 특성 때문에 `Array.from`을 더 선호하는 경향이 있다.\n\n# 정리\n\n`...` 는 Rest 파라미터 또는 Spread 구문 일 수 있다.\n\nRest Parameter\n\n- 함수의 마지막 인자에 `...`를 사용한다.\n- 함수의 인자들을 하나의 배열로 모은다.\n- 인자의 개수가 유동적인 함수를 만들 때 주로 사용한다.\n\nSpread syntax\n\n- `...` 를 함수를 호출할 때나 그 밖에 사용할 경우\n- 배열을 리스트로 분해하는 용도로 사용된다.\n- 일반적으로 많은 인자들을 요구하는 함수에 배열을 보낼 때 사용한다.\n\n참고\n\n[Rest parameters and spread syntax](https://javascript.info/rest-parameters-spread)\n"}},{"name":"2020-06-13-strict-mode.md","oid":"3c7c4a385e5202b5904a3a48543da5209ff30efa","content":{"__typename":"GitHub_Blob","text":"# Strict Mode\n\nDate: Jun 13, 2020\n\n- Title : Strict Mode\n- Date : 2020-06-13\n- Category : Javascript\n\n# Strict mode\n\n- Javscript ES5 이후로 권장하는 코딩 스타일 중 하나는 `Strict mode`를 사용하는 것이다.\n- Javascript 언어의 문법을 보다 엄격히 적용하여 기존에는 **무시 되던 오류를 발생**시킬 가능성이 높거나 Javascript **엔진의 최적화 작업에 문제**를 일으킬 수 있는 코드에 대해 **명시적인 에러**를 발생시킨다.\n- Strict mode는 ES5에 정의되어 있으며 브라우저가 Strict mode를 지원하지 않아도 실행하는 데 전혀 무관하니 Strict mode로 설정해서 개발하는 것이 좋다.\n- Strict mode를 지원하지 않는 IE9 이전 버전에서는 문자열로 무시되고 일반 모드로 실행된다.\n\n전역 strict mode 사용 방법(전역에 적용하는 것은 피하자!)\n\n```javascript\n\"use strict\";\n```\n\n파일 상단에 키워드를 넣으면 전체 소스 파일에 대해서 엄격 모드로 실행된다.\n\n함수 내부에서 strict mode 사용 방법\n\n```javascript\n(function() {\n\t\"use strict\";\n}());\n```\n\n즉시 실행 함수로 스크립트 전체를 감싸서 스코프를 구분하고 즉시 실행 함수의 선두에 strict mode를 적용한다.\n\n## 예시\n\nvar, const, let 없이 변수를 사용할 때 레퍼런스 오류 발생\n\n```javascript\n(function(){\n\t\"use strict\";\n\tx = 1;\n\tconsole.log(x); // Uncaught ReferenceError: x is not defined\n}());\n```\n\n변수나 함수를 삭제하려고 하면 문법 오류 발생\n\n```javascript\n(function(){\n\t\"use strict\";\n\tlet x = 1;\n\tfunction fun() {}\n\n\tdelete x;\n\tdelete fun;\n\t// SyntaxError: Delete of an unqualified identifier in strict mode.\n\n}());\n```\n\n중복되는 파라미터명이 있을 때 문법 오류 발생\n\n```javascript\n(function(win, doc, doc){\n\t\"use strict\";\n\tconsole.log(doc); // SyntaxError: Duplicate parameter name not allowed in this context\n}(window, document));\n```\n\nargument를 설정하려고 하면 문법 오류 발생\n\n```javascript\n(function(win, doc, doc){\n\t\"use strict\";\n\targuments = [1, 2, 3];\n\tconsole.log(arguments); // SyntaxError: Unexpected eval or arguments in strict mode\n}(window, document));\n```\n"}},{"name":"2020-06-14-arrow-function.md","oid":"9314008e272f99650c004f6f321831099ce9a243","content":{"__typename":"GitHub_Blob","text":"# Arrow function\n\nDate: Jun 14, 2020\n\n- Title : Arrow function\n- Date : 2020-06-14\n- Category : Javascript\n\n# 화살표 함수\n\nES6에 익명 함수를 간단하게 표현할 수 있는 화살표 표현식이 추가되었다.\n\n## 기존 익명 함수 vs 화살표 함수\n\n콜백 함수로 실행될 때 기존의 익명 함수는 글로벌 컨텍스트에 접근 하였으나, 함수 화살표 표현식은 콜백 함수를 할당한 당시의 컨텍스트를 그대로 활용한다. \n\n```javascript\nvar name = 'global';\nfunction Person() {\n\tthis.name = 'garam';\n\n\tsetTimeout(() => alert(`my name is ${this.name}`), 100); //garam\n\tsetTimeout(function() {\n\t\talert(`Global name is ${this.name}`); // global\n\t}, 100);\n}\n\nlet person = new Person();\n```\n\n화살표 함수는 함수 선언 시 this가 바인딩 할 객체가 **정적**으로 결정된다. 즉 일반 함수와 달리 화살표 함수는 항상 **상위 스코프의 this**를 가리킨다. 이를 `Lexical this`라고 한다.\n\n> 자바 스크립트는 함수 호출 시 this가 바인딩 할 객체가 **동적**으로 결정된다. 함수 선언 시 this에 바인딩 할 객체가 정적으로 결정되는 것이 아니라 **함수를 호출할 때 함수가 어떻게 호출 되었는지에 따라 this가 바인딩할 객체를 동적**으로 결정한다.\n\n```javascript\nconst test = {\n  name: 'test object',\n  createAnonFunction: function() {\n    return function() {\n      console.log(this.name);\n      console.log(arguments);\n    };\n  },\n\n  createArrowFunction: function() {\n    return () => {\n      console.log(this.name);\n      console.log(arguments);\n    };\n  }\n};\n\nconst anon = test.createAnonFunction('hello', 'world'); \n// undefined\n// {}\nconst arrow = test.createArrowFunction('hello', 'world');\n// test object\n// { '0': 'hello', '1': 'world' }\n```\n\n기존 익명 함수는 함수가 호출 되었을 때의 컨텍스트를 가진다. 즉 `test.createAnonFunction`이 글로벌 컨텍스트에서 호출 되었기에 `this.name`과 `arguments` 객체를 얻을 수 없다. \n\n## 화살표 함수 언제 쓰지 말아야 할까?\n\n### 객체의 메소드를 정의할 때\n\n```javascript\nconst calculate = {\n  array: [1, 2, 3],\n  sum: () => {\n    console.log(this === window); // => true\n    return this.array.reduce((result, item) => result + item);\n  }\n};\nconsole.log(this === window); // => true\n// Throws \"TypeError: Cannot read property 'reduce' of undefined\"\ncalculate.sum();\n```\n\n메소드로 정의한 화살표 함수 내부의 this는 메소드를 소유한 객체를 가리키지 않고 상위 컨텍스트인 `window`를 가리킨다. 아래와 같이 사용 해야 한다.\n\n```javascript\nconst calculate = {  \n  array: [1, 2, 3],\n  sum() {\n    console.log(this === calculate); // => true\n    return this.array.reduce((result, item) => result + item);\n  }\n};\ncalculate.sum(); // => 6\n```\n\n### 프로토타입 방식으로 객체 메소드 정의할 때\n\n```javascript\nfunction MyCat(name) {\n  this.catName = name;\n}\nMyCat.prototype.sayCatName = () => {\n  console.log(this === window); // => true\n  return this.catName;\n};\nconst cat = new MyCat('Mew');\ncat.sayCatName(); // => undefined\n```\n\n```javascript\nfunction MyCat(name) {\n  this.catName = name;\n}\nMyCat.prototype.sayCatName = function() {\n  console.log(this === cat); // => true\n  return this.catName;\n};\nconst cat = new MyCat('Mew');\ncat.sayCatName(); // => 'Mew'\n```\n\n### 이벤트 리스너 콜백함수\n\n```javascript\nconst button = document.getElementById('myButton');\nbutton.addEventListener('click', () => {\n  console.log(this === window); // => true\n  this.innerHTML = 'Clicked button';\n});\n```\n\n`this`는 글로벌 컨텍스트에 바인딩 된다. 클릭 이벤트가 발생하면 브라우저는 버튼 컨텍스트와 함께 핸들러 함수를 실행 시킨다. 화살표 표현식으로 정의된 함수의 경우는 정적으로 `this`가 바인딩 되기 때문에 `this`가 동적으로 변경되는 이벤트 콜백 함수로 적절하지 않다.\n\n```javascript\nconst button = document.getElementById('myButton');\nbutton.addEventListener('click', function() {\n  console.log(this === button); // => true\n  this.innerHTML = 'Clicked button';\n});\n```\n\n기존 익명 함수는 타켓 엘리먼트에 의존하여 this를 바꾸는 것을 허용한다.\n\n### 생성자 함수\n\n모든 객체는 자신의 `prototype`으로 부터 `constructor` 속성을 상속하기 때문에 `prototype` 속성을 가지고 있어야 한다. 하지만 화살표 표현식으로 정의된 함수는 `prototype` 속성이 없어서 생성자 함수로 사용될 수 없다.\n\n```javascript\nconst Foo = () => {};\n\n// 화살표 함수는 prototype 프로퍼티가 없다\nconsole.log(Foo.hasOwnProperty('prototype')); // false\n\nconst foo = new Foo(); // TypeError: Foo is not a constructor\n```\n"}},{"name":"2020-06-20-module.md","oid":"1a0d75577712c0855f91cf05f5e12d0107fd92c5","content":{"__typename":"GitHub_Blob","text":"# Javascript module\n\nDate: Jun 20, 2020\n\n- Title : Javascript module\n- Date : 2020-06-20\n- Category : Javascript\n\n# ES6 module 등장 배경\n\n클라이언트 사이드 자바스크립트는 파일을 여러 개로 분리하여 `script` 태그로 로드 하여도 분리된 자바스크립트 파일들이 결국 하나의 자바스크립트 파일 내에 있는 것처럼 **하나의 전역 객체를 공유**한다. \n\n이런 상황을 해결하고자`CommonJS`와 `AMD` 가 등장했고 자바스크립트의 모듈화는 크게 `CommonJS`와 `AMD` 진영으로 나뉘게 되었다. 브라우저에서 모듈을 사용하기 위해서는 `CommonJS` 또는 `AMD`를 구현한 모듈 로더 라이브러리를 사용해야 했다.\n\n이러한 상황에서 ES6는 클라이언트 사이드 자바스크립트에서도 동작하는 모듈 기능을 추가하였다.  `<script>` 태그에 `type=\"module\"` 요소를 추가하면 로드 된 자바스크립트 파일은 모듈로서 동작하여 **모듈 스코프**를 갖는다. 추가적으로 ES6는 모듈의 파일 확장자를 `mjs`로 설정 하기를  권장하고 있다.\n\n```bash\n<script type=\"module\" src=\"main.mjs\"></script>\n```\n\n하지만 IE를 포함한 구형 브라우저의 경우는 ES6 모듈을 지원하지 않아서 사용하더라도 트랜스 파일링이나 번들링이 필요하다. 이러한 이유로 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 웹팩, 바벨 같은 모듈 기반 시스템을 사용한다.\n\n# Module\n\n- ES6 모듈은 명시적으로 `use strict` 를 쓰지 않아도 엄격 모드로 코드가 실행된다.\n- `import`와 `export` 문은 모듈 내에서만 사용할 수 있다. HTML에서 모듈을 사용하려면 아래와 같이 `<script>` 요소에 `type=\"module\"` 을 포함시켜야 한다.\n- 모듈 스크립트를 불러올 때 자동으로 `defer`로 설정된다.\n\n    > 브라우저는 `script` 태그를 만나면 우선 해당 스크립트를 받아 해석하고 실행할 때까지 웹 문서의 HTML 코드 파싱 작업을 잠시 미룬다. 따라서 용량이 큰 스크립트를 문서 해석 초기에 만나게 되면 해당 페이지를 불러오는 속도가 지체된다. 이러한 병목 현상을 막기 위해 `script` 태그의 `async`와 `defer`속성을 사용한다. `script`가 문서를 직접 만지고 조작하거나 서로 간 로딩 순서가 중요할 때에는 `defer` 속성을 쓰고, 그렇지 않다면 `async`속성을 써서 웹 페이지 로딩 속도를 줄일 수 있다.\n\n    ![Untitled](https://user-images.githubusercontent.com/34448538/85366790-01836700-b563-11ea-8163-c324bce13a66.png)\n\n## 실습\n\n### export\n\n```jsx\n// square.js\n\n// ...randowSquare 정의\n\nexport default randomSquare;\n\nexport const name = 'square';\n\nexport function draw(ctx, length, x, y, color) {\n  ctx.fillStyle = color;\n  ctx.fillRect(x, y, length, length);\n\n  return {\n    length: length,\n    x: x,\n    y: y,\n    color: color\n  };\n}\n```\n\n### import\n\n```jsx\n// main.js\nimport randomSquare, { name, draw } from './modules/square.js';\n```\n\n### default export 이름 변경\n\n```jsx\nimport {default as randomSquare} from './modules/square.js';\n```\n\n### named export 이름 변경\n\n```jsx\n// inside module.js\nexport {\n  function1 as newFunctionName,\n  function2 as anotherNewFunctionName\n};\n\n// inside main.js\nimport { newFunctionName, anotherNewFunctionName } from './modules/module.js';\n```\n\n```jsx\n// inside module.js\nexport { function1, function2 };\n\n// inside main.js\nimport { function1 as newFunctionName,\n         function2 as anotherNewFunctionName } from './modules/module.js';\n```\n\n참고\n\n[Module | PoiemaWeb](https://poiemaweb.com/es6-module)\n\n[script 태그의 async와 defer 속성](https://appletree.or.kr/blog/web-development/javascript/script-%ED%83%9C%EA%B7%B8%EC%9D%98-async%EC%99%80-defer-%EC%86%8D%EC%84%B1/)\n"}},{"name":"2020-07-01-engine-eventloop.md","oid":"3a69a280df0251492517e4cdc764f4c0e0040854","content":{"__typename":"GitHub_Blob","text":"# 자바스크립트 엔진과 이벤트 루프\n\nDate: Jul 1, 2020\n\n- Title : 자바스크립트 엔진과 이벤트 루프\n- Date : 2020-07-01\n- Category : Javascript\n\n![Untitled](https://user-images.githubusercontent.com/34448538/87217780-f49aac00-c387-11ea-9c33-5a77863c7f28.png)\n\n## V8 엔진\n\n자바 스크립트 엔진 중 하나로 구글이 개발한 오픈 소스다. C++로 개발되어 있으며 크롬과 NodeJS에서 사용된다.\n\n**V8 엔진은 크게 두 부분으로 구성된다.**\n\n- 메모리 힙 (Memory Heap) : 메모리 할당이 이루어지는 곳\n- 콜 스택 (Call Stack) : 코드가 실행 되면서 스택 프레임이 쌓이는 곳\n\n### 메모리 힙\n\n객체나 동적 데이터(배열, 객체...)가 저장되는 공간으로 메모리 영역에서 가장 큰 블록이면서 가비지 컬렉션(GC)가 발생하는 곳이다. 힙 메모리 전체에서 가비지 컬렉션이 실행되는 것은 아니고 Young과 Old 영역에서만 실행된다.\n\n### 콜 스택\n\n메서드, 함수 프레임, 원시 값, 객체 포인터를 포함한 정적 데이터가 저장되는 곳이다.\n자바 스크립트는 콜 스택을 하나만 가지고 있는 싱글 스레드 언어이다.\n\n> **스택 트레이스?**\n예외가 발생했을 때의 콜 스택의 상태\n**스택 날림(Blowing the stack)?**\n스택 프레임이 콜 스택의 최대 크기까지 쌓였을 때\n\n### V8 메모리 사용 (스택 vs 힙)\n\n```jsx\nclass Employee {\n    constructor(name, salary, sales) {\n        this.name = name;\n        this.salary = salary;\n        this.sales = sales;\n    }\n}\n\nconst BONUS_PERCENTAGE = 10;\n\nfunction getBonusPercentage(salary) {\n    const percentage = (salary * BONUS_PERCENTAGE) / 100;\n    return percentage;\n}\n\nfunction findEmployeeBonus(salary, noOfSales) {\n    const bonusPercentage = getBonusPercentage(salary);\n    const bonus = bonusPercentage * noOfSales;\n    return bonus;\n}\n\nlet john = new Employee(\"John\", 5000, 5);\njohn.bonus = findEmployeeBonus(john.salary, john.sales);\nconsole.log(john.bonus);\n```\n\n![stackheap](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-07-01-img/stack-heap.gif)\n\n# 이벤트 루프와 비동기 프로그래밍\n\n자바 스크립트는 스레드(콜 스택이 하나)가 하나라 수행 시간이 긴 코드를 실행하게 되면 브라우저는 아무 것도 할 수 없게 된다. 하지만 실제 자바 스크립트가 사용 되는 환경을 생각해보면 많은 작업이 동시에 처리되고 있다. 예를 들면, 웹 브라우저는 애니메이션 효과를 보여주면서 마우스 입력을 받아서 처리하고, NodeJs 기반의 웹 서버에서는 동시에 여러 개의 HTTP 요청을 처리 하기도 한다. \n\n싱글 스레드인데 어떻게 이런 일이 가능할까? 자바 스크립트는 어떻게 동시성(Concurrency)을 지원할까? 이에 대한 답은 `자바 스크립트는 이벤트 루프 기반의 비동기 방식으로 동시성을 지원 한다`로 정리할 수 있다.\n\n## Web APIs\n\n브라우저가 제공하는 웹 API로 DOM Events, XMLHttpRequest, setTimeout, addEventListener 등이 포함된다.\n\n## 이벤트 루프와 태스크 큐\n\nWeb API 중 하나인 `setTimeout` 함수는 태스크 큐에서 대기하고 있다가 이벤트 루프를 통해 실행된다.\n태스크 큐는 말 그대로 콜백 함수들이 대기하는 큐(FIFO) 형태의 배열이라 할 수 있고 이벤트 루프는 콜 스택이 비어질 때마다 큐에서 콜백 함수를 꺼내 와서 실행하는 역할을 한다.\n\n```jsx\nsetTimeout(baz, 10); // (1)\nfoo();\n```\n\n위의 예시의 코드가 처음 실행되면 `setTimeout` 함수는 브라우저에게 타이머 이벤트를 요청한 후 바로 콜 스택에서 제거된다. 그 후에 `foo` 함수가 콜 스택에 추가된다. 10ms가 지나면 브라우저의 타이머는 `baz` 함수를 태스크 큐에 추가한다. 이벤트 루프는 `foo` 함수가 실행을 마치고 콜 스택에서 사라지면 태스크 큐에서 대기 중인 `baz`를 실행하여 콜 스택에 추가한다.\n\n![image](https://user-images.githubusercontent.com/34448538/87217762-c74dfe00-c387-11ea-920e-87d0761c4fff.png)\n\n정리하자면 이벤트 루프는 **현재 실행 중인 태스크가 없는 지**와 **태스크 큐에 태스크가 있는지**를 반복적으로 확인하여 **현재 실행 중인 태스크가 없을 때**(주로 호출 스택이 비워졌을 때) 태스크 큐의 첫번째 태스크를 가져와 실행한다. 참고로 모든 브라우저의 비동기 API들은 작업이 완료되면 콜백 함수를 태스크 큐에 추가한다.\n\n### 마이크로 태스크\n\n일반 태스크보다 더 높은 우선 순위를 갖는 태스크로 태스크 큐에 대기 중인 태스크가 있더라도 마이크로 태스크가 먼저 실행된다. \n\n```jsx\nsetTimeout(function() { // (A)\n    console.log('A');\n}, 0);\nPromise.resolve().then(function() { // (B)\n    console.log('B');\n}).then(function() { // (C)\n    console.log('C');\n});\n```\n\nPromise 콜백 함수는 마이크로 태스크 큐에 추가되고 setTimeout 콜백 함수는 일반 태스크 큐에 추가되기에 이벤트 루프는 마이크로 태스크 큐에 있는 작업을 먼저 실행한 후 태스크 큐의 태스크를 실행한다. 즉 B → C → A 순으로 실행된다.\n\n \n참고\n[https://vimeo.com/96425312](https://vimeo.com/96425312)\n\n[https://meetup.toast.com/posts/89](https://meetup.toast.com/posts/89)\n\n[https://engineering.huiseoul.com/자바스크립트는-어떻게-작동하는가-v8-엔진의-내부-최적화된-코드를-작성을-위한-다섯-가지-팁-6c6f9832c1d9](https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-v8-%EC%97%94%EC%A7%84%EC%9D%98-%EB%82%B4%EB%B6%80-%EC%B5%9C%EC%A0%81%ED%99%94%EB%90%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%8B%A4%EC%84%AF-%EA%B0%80%EC%A7%80-%ED%8C%81-6c6f9832c1d9)\n"}},{"name":"2020-07-11-context.md","oid":"a21d94a6b96cfbfbce523c164d6e7bd377c5c4b7","content":{"__typename":"GitHub_Blob","text":"# 자바스크립트의 실행 컨텍스트\n\nDate: Jul 11, 2020\n\n- Title : 실행 컨텍스트\n- Date : 2020-07-11\n- Category : Javascript\n\n이 글은 코어 자바스크립트 책의 실행 컨텍스트 부분을 정리한 내용입니다.\n\n# 실행 컨텍스트\n\n- 실행할 코드에 제공할 환경 정보들을 모아 놓은 객체다.\n- 자바 스크립트는 동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하여 콜 스택에 올린다. 가장 위에 쌓인 컨텍스트와 관련 코드를 실행하는 방법을 통해 전체 코드의 환경과 순서를 보장한다.\n- 실행 컨텍스트를 구성하는 방법은 `전역 공간`, `eval() 함수`, `함수` 등이 있다. `전역 공간`은 자동으로 생성되고 `eval()` 함수는 악마로 취급 되므로 **컨텍스트를 구성하기 위해 함수를 실행하는 방법을 흔히 사용**한다.\n\n## 실행 컨텍스트를 코드로 이해하기\n\n```jsx\n// (1)\nvar a = 1;\nfunction outer() {\n  function inner() {\n\t  console.log(a); // undefined\n\t  var a = 3;\n  }\n  inner(); // (2)\n  console.log(a); // 1\n}\nouter(); // (3)\nconsole.log(a); // 1\n```\n\n1. 처음 자바 스크립트 코드가 실행하는 순간(1) 전역 컨텍스트가 콜 스택에 담긴다.\n\n    참고로 전역 컨텍스트는 일반 실행 컨텍스트와 달리 함수가 아닌 전역 공간이기 때문에 arguments가 없고 전역 공간을 둘러싼 외부 스코프가 존재할 수 없기 때문에 스코프 체인 상에는 전역 스코프 하나만 존재한다.\n\n2. 콜 스택에 전역 컨텍스트 외에 다른 프레임이 없으므로 전역 컨텐스트와 관련된 코드들을 순차로 진행하다가 (3)에서 outer 함수를 호출하면 엔진은 outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성한 후 콜 스택에 담는다.\n3. 콜 스택의 맨 위에 outer 실행 컨텍스트가 놓인 상태이므로 전역 컨텍스트와 관련된 코드 실행을 일시 중단하고 outer 실행 컨텍스트와 관련된 코드(outer 함수 내부 코드)를 순차로 실행한다.\n4. (2)에서 inner 함수의 실행 컨텍스트가 콜 스택 가장 위에 담기면 outer 컨텍스트와 관련된 코드 실행을 중단하고 inner 함수 내부의 코드를 순서대로 실행한다.\n5. inner 함수의 실행이 종료되면 inner 실행 컨텍스트가 콜 스택에서 제거된다.\n6. outer 실행 컨텍스트가 콜 스택에 맨 위에 존재하게 되므로 중단했던 (2)의 다음 줄부터 이어서 실행한다.\n7. outer 함수의 실행이 종료되어 콜 스택에서 제거되면 전역 컨텍스트의 코드들을 실행하게 된다. 더 이상 실행할 코드가 남아 있지 않으면 전역 컨텍스트도 제거되어 콜 스택에는 아무 것도 남지 않은 상태로 종료된다.\n\n# 실행 컨텍스트에 담기는 정보들\n\n- VariableEnvironment: 현재 컨텍스트 내의 식별자에 대한 정보 + 외부 환경 정보, 선언 시점의 LexicalEnvironment의 스냅샷으로 변경 사항은 반영되지 않음\n- LexicalEnvironment: 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨\n- ThisBinding: this 식별자가 바라봐야 할 대상 객체\n\n## VariableEnvironment\n\nLexicalEnvironment에 담기는 내용과 같지만 VariableEnvironment는 **최초 실행 시의 스냅샷을 유지**한다는 점이 다르다. 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음 이를 그대로 복사해서 LexicalEnvironment를 만들고 이후에는 LexicalEnvironment를 주로 활용하게 된다.\n\n## LexicalEnvironment\n\n내부 구성\n\n- environmentRecode: 매개 변수의 이름, 함수 선언, 변수명 등이 담김\n- outerEnvironmentReference: 바로 직전 컨텍스트의 LexicalEnvironment 정보를 참조\n\n### environmentRecode\n\n컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어 나가며 순서대로 현재 컨텍스트와 관련된 코드의 식별자 정보들을 저장한다. 매개변수 식별자, 선언한 함수가 있을 경우 그 함수 자체(함수 선언문), var로 선언된 변수의 식별자가 식별자 정보에 해당된다.\n\n코드가 실행되기 전임에도 자바스크립트 엔진은 해당 컨텍스트에 속한 변수 명들을 모두 알고 있다. 즉, 자바스크립트 엔진은 **식별자들을 최 상단으로 끌어 올려 놓은 다음 실제 코드를 실행한다**라고 생각해도 된다. 여기서 호이스팅의 개념이 등장한다.\n\n자바 스크립트 엔진은 변수 선언과 값 할당이 동시에 이뤄진 문장은 **선언부**만을 호이스팅하고 할당 과정은 원래 자리에 둔다. 따라서 함수 선언문은 함수 전체가 호이스팅 되지만 함수 표현식은 변수 선언부만 호이스팅 된다.\n\n### outerEnvironmentReference\n\nouterEnvironmentReference는 **현재 호출된 함수가 선언될 당시**의 LexicalEnvironment를 참조하기 때문에 우리는 스코프 체인을 할 수 있다. \n\n코드 상에서 어떤 변수에 접근하려고 하면 현재 컨텍스트의 LexicalEnvironment를 탐색한다. 변수 값을 발견하면 그 값을 반환 하지만 발견하지 못하면 outerEnvironmentReference에 담긴 LexicalEnvironment를 탐색하는 과정을 거친다. 전역 컨텍스트의 LexicalEnvironment까지 탐색 해도 해당 변수를 찾지 못하면 undefined를 반환한다.\n\n> 스코프는 식별자에 대한 유효 범위로, 어떤 경계 A의 외부에서 선언한 변수는 A의 외부 뿐 아니라 A의 내부에서도 접근이 가능하지만, A의 내부에서 선언한 변수는 오직 A 내부에서만 접근할 수 있다는 개념으로 이해하면 된다. 이러한 식별자 유효 범위를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라고 한다.\n\n"}},{"name":"images","oid":"1c0f33cf70e29e0a37f1a85601eb2c20cd4221bb","content":{"__typename":"GitHub_Tree"}}]}},{"name":"Jekyll","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":"2019-01-05-jekyll-js-custom.md","oid":"f3c739a9f9af2d42a8f59bed45bd78959efdcd6e","content":{"__typename":"GitHub_Blob","text":"# jekyll의 minimal-mistakes에서 자바스크립트 커스텀하는 방법\n\n- Title : jekyll의 minimal-mistakes에서 자바스크립트 커스텀하는 방법\n- Date : 2019-01-05\n- Category: Jekyll\n\nminimal-mistakes 테마를 적용한 jekyll 블로그를 커스텀하는 과정에서 자바스크립트 코드를 추가하는 방법입니다.  \nminimal-mistakes 문서에 자바스크립트 커스텀 방법이 잘 정리되어있습니다.\n[공식문서 바로가기](https://mmistakes.github.io/minimal-mistakes/docs/javascript/).\n\n---\n\n우리가 수정해야 할 파일은 /assets/js/ 에 위치한 \\_main.js 파일입니다.  \n하지만, jekyll은 \\_main.js 파일이 아닌 main.min.js 파일을 컴파일하여 화면에 반영합니다.  \nmain.min.js 는 \\_main.js 자바스크립트 코드를 압축화하고 난독화한 파일로 npm 패키지 중 하나인 uglify를 이용하여 만들 수 있습니다.\n\n## 1. npm 셋팅\n\n```\n> npm init\n```\n\n블로그 프로젝트 디렉토리 위치에서 위 코드를 실행시키면 package.json 파일이 생성됩니다.\n\n## 2. package.json 파일 수정\n\nhttps://github.com/mmistakes/minimal-mistakes/blob/master/package.json\npackage.json 파일을 아래와 같이 수정합니다.\n\n```json\n{\n  \"name\": \"minimal-mistakes\",\n  \"version\": \"4.14.2\",\n  \"description\": \"Minimal Mistakes 2 column Jekyll theme.\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/mmistakes/minimal-mistakes.git\"\n  },\n  \"keywords\": [\"jekyll\", \"theme\", \"minimal\"],\n  \"author\": \"Michael Rose\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mmistakes/minimal-mistakes/issues\"\n  },\n  \"homepage\": \"https://mmistakes.github.io/minimal-mistakes/\",\n  \"engines\": {\n    \"node\": \">= 0.10.0\"\n  },\n  \"devDependencies\": {\n    \"npm-run-all\": \"^4.1.5\",\n    \"onchange\": \"^5.1.3\",\n    \"uglify-js\": \"^3.4.9\"\n  },\n  \"scripts\": {\n    \"uglify\": \"uglifyjs assets/js/vendor/jquery/jquery-3.3.1.min.js assets/js/plugins/jquery.fitvids.js assets/js/plugins/jquery.greedy-navigation.js assets/js/plugins/jquery.magnific-popup.js assets/js/plugins/jquery.smooth-scroll.min.js assets/js/_main.js -c -m -o assets/js/main.min.js\",\n    \"add-banner\": \"node banner.js\",\n    \"watch:js\": \"onchange \\\"assets/js/**/*.js\\\" -e \\\"assets/js/main.min.js\\\" -- npm run build:js\",\n    \"build:js\": \"npm run uglify && npm run add-banner\"\n  }\n}\n```\n\n## 3. uglify 설치 및 실행\n\nuglify-js 패키지 설치\n\n```\n> npm install uglify-js\n```\n\npackage.json의 scripts 부분을 보면 build:js 스크립트 실행시 **npm run uglify && npm run add-banner** 를 실행하도로 되어있습니다.\n이를 참고하여 cmd에서 <code class=\"codetainer\">npm run build:js</code>를 실행해봅시다. 정상적으로 \\_main.js 파일이 main.min.js로 압축된 것을 확인할 수 있을 것입니다.\n\n## 4. jekyll serve 실행\n\n이미 서버가 실행되어있다면 자동으로 반영됩니다.  \n그렇지 않다면 다시 **jekyll serve** 를 통해 서버를 실행해주면 커스텀한 자바스크립트 코드가 반영된 것을 확인할 수 있습니다.\n"}},{"name":"2019-03-05-liquid-site.md","oid":"e4b0c00bcef7f5a64f4941b849fa6cb2fec43752","content":{"__typename":"GitHub_Blob","text":"# Liquid 문법\n\n- Title : Liquid 문법\n- Date : 2019-03-05\n- Category: Jekyll\n\njekyll 블로그 운영시 알아야할 필수 liquid 문법\n\n[liquid 문법 정리된 사이트](https://shopify.github.io/liquid/basics/types/)\n\n## Liquid\n\n<table>\n<thead>\n\t<tr><th>category</th><th>Input</th><th>Output</th></tr>\n</thead>\n<tbody>\n\t<tr>\n\t\t<td>Objects</td>\n\t\t<td>\n\t\t{ { page.title } }\t\n\t\t</td>\n\t\t<td>Introduction</td>\n\t</tr>\n\t<tr>\n\t\t<td>Tags</td>\n\t\t<td>\n\t\t{ % if user % } <br/>\n\t\t  &nbsp;&nbsp;Hello { { user.name } }! <br/>\n\t\t{ % endif % }\n\t\t</td>\n\t\t<td>Hello Adam!</td>\n\t</tr>\n\t<tr>\n\t\t<td>Filters</td>\n\t\t<td>\n\t\t{ { \"/my/fancy/url\" | append: \".html\" } }\n\t\t</td>\n\t\t<td>/my/fancy/url.html</td>\n\t</tr>\n\t<tr>\n\t\t<td>Filters</td>\n\t\t<td>\n\t\t{ { \"adam!\" | capitalize | prepend: \"Hello \" } }\n\t\t</td>\n\t\t<td>Hello Adam!</td>\n\t</tr>\n\t<tr>\n\t\t<td>assing String</td>\n\t\t<td>\n\t\t{ % assign my_string = \"Hello World!\" % }\n\t\t</td>\n\t\t<td>String 타입</td>\n\t</tr>\n\t<tr>\n\t\t<td>assing Number</td>\n\t\t<td>\n\t\t{ % assign my_int = 25 % }\n\t\t</td>\n\t\t<td>Number 타입</td>\n\t</tr>\n\t<tr>\n\t\t<td>assing Boolean</td>\n\t\t<td>\n\t\t{ % assign foo = true % }\n\t\t</td>\n\t\t<td>Boolean 타입</td>\n\t</tr>\n\t<tr>\n\t\t<td>Nil (empty)</td>\n\t\t<td>\n\t\tThe current user is { { user.name } }\n\t\t</td>\n\t\t<td>The current user is</td>\n\t</tr>\n\t<tr>\n\t\t<td>Array</td>\n\t\t<td>\n\t\t{ % for user in site.users % }<br/>\n\t\t  &nbsp;&nbsp; { { user } }<br/>\n\t\t{ % endfor % }\n\t\t</td>\n\t\t<td>Tobi Laura Tetsuro Adam</td>\n\t</tr>\n\t<tr>\n\t\t<td>Array</td>\n\t\t<td>\n\t\t{ { site.users[0] } }<br/>\n\t\t{ { site.users[1] } }<br/>\n\t\t{ { site.users[3] } }\n\t\t</td>\n\t\t<td>Tobi <br/>\n\t\tLaura <br/>\n\t\tAdam</td>\n\t</tr>\n\t<tr>\n\t\t<td>plus</td>\n\t\t<td>\n\t\t{ { 4 | plus: 2 } }\n\t\t</td>\n\t\t<td>6</td>\n\t</tr>\n\t<tr>\n\t\t<td>limit</td>\n\t\t<td>\n\t\t{ % for item in array limit:2 % }<br/>\n\t       &nbsp;&nbsp; { { item } }<br/>\n\t\t{ % endfor % }\n\t\t</td>\n\t\t<td>limit를 통해 2개까지만 반복문을 돌린다.</td>\n\t</tr>\n</tbody>\n</table>\n"}}]}},{"name":"Nodejs","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":"2018-01-27-mocha-unittest.md","oid":"43c62d138aba5719c8fa3bc79ecccce9865fb59c","content":{"__typename":"GitHub_Blob","text":"# 자바스크립트 단위테스트 시작하기\n\n- Title : 자바스크립트 단위테스트 시작하기\n- Date : 2018-01-27\n- Category: Nodejs\n\nmocha 자바스크립트 테스트 프레임워크로 단위테스트 시작하는 방법입니다.\n\n# 단위테스트(Unit Test)가 필요한 이유?\n\n프로그램을 작은 단위로 쪼개서 내가 짠 프로그램이 내가 원하는 결과대로 동작하는 지 테스트할 수 있다.  \n단위테스트를 거치면 프로그램의 안정성이 높아지며, 단위테스트를 믿고 리팩토링을 할 수 있다.\n\n자바스크립트로 짜여진 프로그램에서 오류를 찾을 때, 단위테스트를 거치지 않은 프로그램의 경우는 전체 흐름을 파악해가며 원인을 찾아야한다.  \n원인을 찾아 수정한다해도 이 결과가 어떤 이펙트를 가져올지 예상하기가 어려울 수 있다.\n\n# mocha 자바스크립트 테스트 프레임워크\n\n## 1. 셋팅하기 (Windows8)\n\nmocha는 node.js가 기반인 프레임워크이기 때문에 node.js가 설치되어있어야 한다.  \n설치 후 cmd 창에 node --version 이라고 쳐서 버전 정보가 제대로 나오면 설치가 잘 된 것이다.\n\ncmd 창에 아래와 같이 입력하면 mocha 사용 준비 완료!\n\n```\n$npm install -g mocha\n```\n\n그리고 Assertion Library인 Chai를 추가해보자. 작업 디렉토리에서 아래를 cmd 창에서 실행한다.\n\n```\n$nbm install chai\n```\n\n그 결과, node_moduls 폴더가 생성된다.\n\n## 2. 사용하기\n\n[InspiredJW님의 티스토리 블로그를 참고했습니다!](http://inspiredjw.com/entry/Mocha-%EB%A1%9C-%ED%95%98%EB%8A%94-JavaScript-Testing).\n\n모카는 test 디렉토리에 있는 파일을 실행하기 때문에, 테스트 코드는 이 디렉토리 안에 위치시켜야한다.\n\nJsStudy/JsStudy.js\n\n```javascript\n\"use strict\";\nexports.foo = (a, b) => {\n  if (typeof a !== \"number\" || typeof b !== \"number\") return false;\n  return a * b;\n};\nexports.bar = callback => {};\n```\n\nJsStudy/test/JsStudyTest.js\n\n```javascript\n\"use strict\";\n\nlet chai = require(\"chai\");\nlet should = chai.should();\nlet foo = require(\"../JsStudy\").foo;\n\ndescribe(\"Function Foo\", () => {\n  describe(\"with two number params\", () => {\n    it(\"should return product\", () => {\n      let result = foo(3, 4);\n      result.should.be.a(\"number\");\n      result.should.equal(12);\n    });\n  });\n});\n\ndescribe(\"with non-number params\", () => {\n  it(\"should return false\", () => {\n    let result = foo(3, null);\n    result.should.be.false;\n  });\n});\n```\n\n테스트 실행방법은 cmd 창에서 JsStudy 폴더로 이동한후, mocha 실행하기\n\n```\n$mocha\n```\n\n<span class=\"clr-grey\">\nAPI    \n- describe() : 테이스틔 이름을 지정하며, 중첩하여 사용할 수 있다. 테스트를 구분하는 section이며, 단위테스트 부분을 콜백으로 넘겨준다.\n- it() : 단위테스트의 이름을 작성하고 실제 실행되는 코드를 콜백(done)으로 넘겨준다.\n- befor() : 테스트 코드가 실행되기 전 한번 실행된다.\n- after() : 모든 테스트 코드가 실행된 후 한 번 실행된다.\n- beforeEach() : (테스트 코드가 여러개일 경우) 각각의 테스트 코드가 실행되기 전마다 실행된다.\n- afterEach() : (테스트코드가 여러개일 경우) 각각의 테스트 코드가 실행된 후마다 실행된다.\n- .a(type[,msg]) : 지정된 타입과 동일한지 리턴.\n- .equal(val[,msg]) : === var과 주어진 타켓이 같은지.\n- .false : 타켓 === false\n</span>\n"}},{"name":"2018-04-11-npmstart1.md","oid":"5c020cb338a81a219b4f92989a7d45ac5bdfe3e6","content":{"__typename":"GitHub_Blob","text":"# npm 시작하기\n\n- Title : npm 시작하기\n- Date : 2018-04-11\n- Category: Nodejs\n\n# 1. npm이란?\n\n## npm은 어떻게 구성되어있을까?\n\nnpm은 세 개의 컴포넌트로 구성되어있습니다.\n\n- the website - 패키지 탐색, 프로파일 설정, 개인 npm histoty 관리\n- CLI ( the Command Line Interface ) - 개발자와 npm이 소통하는 방법으로 터미널에서 동작\n- the registry - 자바스크립트 소프트웨어의 공용 데이터베이스 및 메타 정보\n\n## npm은 언제 사용할까?\n\n- 앱에 패키지를 적용시키거나, 통합시키고 싶을 때\n- 바로 사용할 수 있는 독립된 툴을 다운받고싶을 때\n- npx를 사용하여 다운로드받는 것 없이 패키지를 실행하고 싶을 때\n- 조직을 만들어서 유지보수, 개발 협업하고 싶을 때\n- 어디서든 npm 사용자와 코드를 공유하고 싶을 때\n- 코드 활용을 특정 개발자들로만 제한하고 싶을 때\n- 버전 및 코드 의존성 관리하고 싶을 때\n- 근본적인 코드가 업데이트될 때, 애플리케이션도 쉽게 업데이트되게 하고 싶을 때\n- 같은 문제를 해결하는 다양한 방법을 찾고싶을 때\n- 비슷한 프로젝트를 진행하는 개발자를 찾고 싶을 때\n\n# 2. 패키지는 어떻게 찾을까?\n\n패키지를 찾기위해서 npm의 검색창을 활용해야합니다. 그럼, 당신의 앱에 바코드(QR code) 기능을 넣고 싶다면 검색창에 QR code라고 입력해봅시다. QR Code와 관련된 패키지들이 조회되고, 패키지 선택에 도움을 줄 수 있는 랭킹 정보를 볼 수 있습니다.\n\n그렇다면 비슷한 패키지들 중, 우리는 어떤 패키지를 선택하면 될까요?\n\n## 각각의 패키지들은 npm 분석기에 의해 다음의 4가지로 랭킹되고있습니다.\n\n- Optimal - 아래 세가지 기준을 의미있게 조합하여 순위를 지정합니다.\n- Populary - 패키지가 다운로드된 횟수로 패키지 순위를 지정하며, 유용하고 안정적인 패키지가 해당됩니다.\n- Quality - readme 파일 존재여부, 안정성, 테스트, 최신 의존성주입, 사용자정의 웹사이트, 코드 복잡성등을 고려합니다.\n- Maintenance - 개발자가 관심을 기울이며, 보다 자주 유지보수되는 패키지를 순위로 지정합니다.\n\n## 패키지를 선택해서 들어가보면 패키지 정보와 사용 방법등의 다양한 정보를 얻을 수 있습니다.\n\n- Readme - 개발자가 생성한 readme 파일로 패키지의 목적과 사용방법에 대해 설명되어있습니다.\n- Dependencies - 대부분의 패키지들은 다른 패키지들로 만들어집니다. 이 패키지가 의존하고 있는 패키지들의 정보를 보여줍니다.\n- Dependents - 이 패키지를 의존하고 있는 패키지들을 보여줍니다.\n- Versions - 패키지 업데이트 정보를 보여줍니다.\n\n# 3. npm 시작하기\n\nnpm은 Node.js로 개발되었기에 npm을 사용하기 위해서는 Node.js를 설치해야합니다.  \nWindows의 경우, 반드시 LTS 버전을 설치해야합니다.\n\n```\n> node -v\n```\n\n설치가 완료되면 다음과 같이 노드의 버전을 확인해봅시다. 정상적으로 출력된다면 설치가 완료된 것입니다.  \nNode.js를 설치할 때, npm은 자동적으로 설치됩니다. 하지만, npm은 Node.js보다 더 자주 업데이트되기때문에 최신 버전으로 업데이트하는 방법을 알아야합니다.\n\n```\n> npm -v\n#npm 버전을 확인합니다.\n>npm install npm@latest -g\n#최신버전으로 업데이트합니다.\n```\n"}},{"name":"2018-04-13-npmstart2.md","oid":"c636b7749da7503e1608b5aa12d6ee7b06881fa5","content":{"__typename":"GitHub_Blob","text":"# npm 로컬 패키지 설치하기\n\n- Title : npm 로컬 패키지 설치하기\n- Date : 2018-04-13\n- Category: Nodejs\n\n# 4. 로컬에 패키지를 설치해보자\n\n패키지를 어떤 방식으로 사용하는지에 따라 우리는 로컬 또는 전역에 npm 패키지를 설치할 수 있습니다.\n\n- Node.js의 require을 사용하여 당신의 모듈에서 패키지를 사용하려면 로컬로 설치하면 됩니다. 이는 npm 설치의 기본 동작입니다.\n- 패키지를 CLI와 같은 커맨드 라인 툴에서 사용하려면 전역으로 설치하면 됩니다.\n\n## 패키지 다운로드하기\n\n```\n> npm install <package_name>\n```\n\n명령어를 실행하면 현재 디렉토리에 node_modules 디렉토리가 생성됩니다. (node_modules 디렉토리가 없을 경우)\n그리고 node_modules 디렉토리 안에 다운로드 받은 패키지가 존재하게됩니다.\n\n## 설치된 패키지 어떤 버전일까?\n\n로컬 디렉토리에 package.json 파일이 없다면, 가장 최신 버전의 패키지가 설치됩니다. package.json 파일이 있으면 npm은 package.json 파일에 선언된 semver rule을 만족하는 최신버전을 설치합니다.\n\n예) package.json\n\n```\n...\n\"dependencies\" : {\n\"lodash\" : \"~1.0.4\"\n}\n....\n```\n\nnpm은 package.json에 따라 1.0.4 버전의 lodash 패키지를 설치하게됩니다.\n\n## 패키지를 어떻게 사용할까?\n\n일단 node_modules 디렉토리에 패키지가 있다면, 우리의 코드에서 패키지를 사용할 수 있습니다.\n\n예) index.js 파일\n\n```\nvar lodash = require('lodash');\nvar output = lodash.without([1,2,3],1);\nconsole.log(output);    // 결과 : [2,3]\n```\n\n만약 lodash 패키지가 설치되지않았다면 Error : Cannot find module 'lodash' 에러를 보게될 것 입니다.\n\n# 7. 로컬에 설치된 패키지 삭제해보자\n\nnode_modules 디렉토리의 패키지를 삭제하는 명령어\n\n```\n> npm uninstall lodash\n```\n\npackage.json의 dependecies에서 패키지를 제거하려면 save 플래그를 사용해야합니다.\n\n```\n> npm uninstall --save lodash\n```\n\n**Note:** 패키지가 devDependency로 설치된 경우, package.json에서 제거하는 방법은 다음과 같습니다.\n\n```\n> npm uninstall --save-dev lodash\n```\n\nnode_modules 디렉토리에 해당 패키지가 없다면 삭제가 정상적으로 된 것입니다.\n\n# 8~10. 전역에 패키지를 설치/업데이트/삭제 해보기\n\n패키지 설치\n\n```\n> npm install -g jshint\n```\n\n패키지업데이트\n\n```\n> npm update -g jshint\n```\n\n패키지 삭제\n\n```\n> npm uninstall -g jshint\n```\n"}},{"name":"2018-04-16-npmstart3.md","oid":"1915e03780a46a3344b4cdf3bc8284ba7af6804e","content":{"__typename":"GitHub_Blob","text":"# npm Working with package.json\n\n- Title : npm Working with package.json\n- Date : 2018-04-16\n- Category: Nodejs\n\n# 5. Working with package.json\n\n로컬에 설치된 npm 패키지를 관리하는 최상의 방법은 package.json 파일을 생성하는 것입니다.\n\npackage.json 파일은 :\n\n- 프로젝트가 의존하고 있는 패키지들의 리스트를 보여줍니다.\n- semantic versioning rule에 따라 프로젝트에 의존한 패키지들의 버전을 설정할 수 있습니다.\n- 빌드를 재현할 수 있으므로, 좀 더 쉽게 다른 개발자와 공유할 수 있습니다.\n\n## 요구사항\n\npackage.json 파일이 반드시 가져야하는 것\n\n- \"name\"\n  - 소문자\n  - 한단어, 띄어쓰기 허용X\n  - -(dashes) 와 \\_ (underscores) 허용O\n- \"version\"\n  - x.x.x 형태\n  - semver spec을 따름\n\n```\n{\n \"name\" : \"my-awesome-package\",\n \"version\" : \"1.0.0\"\n}\n```\n\n## package.json 파일 생성하기\n\n```\n> npm init\n또는\n> npm init --yes\n#--yes === -y\n```\n\n위 명령어는 현재 디렉토리로부터 정보를 추출해서 해당 package.json 파일을 생성합니다.\n\n```\n{\n  \"name\": \"my_package\",\n  \"description\": \"\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/ashleygwilliams/my_package.git\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/ashleygwilliams/my_package/issues\"\n  },\n  \"homepage\": \"https://github.com/ashleygwilliams/my_package\"\n}\n```\n\n- name : 현재 디렉토리 이름\n- version : 항상 1.0.0\n- description : readme 정보 또는 \"\"\n- main : 항상 index.js\n- scripts : 기존적으로 빈 테스트 스크립트를 만든다.\n- keywords : empty\n- author : empty\n- license : ISC\n- bugs : 현재 디렉토리의 정보\n- homepage : 현재 디렉토리의 정보\n\n다음과 같이 명령어 실행시 옵션을 설정할 수 있습니다.\n\n```\n> npm set init.author.email \"wombat@npmjs.com\"\n> npm set init.author.name \"ag_dubs\"\n> npm set init.license \"MIT\"\n```\n\n## Dependencies 지정하기\n\n프로젝트가 의존하는 패키지를 지정하려면 package.json 파일에 사용할 패키지들을 나열해야합니다. 그리고 패키지들은 두 개의 타입으로 나열될 수 있습니다.\n\n- \"dependencies\" : 프로젝트 배포 시\n- \"devDependencies\" : 프로젝트 개발 또는 테스트 시\n\npackage.jsondp dependencies를 추가하는 더 쉬운 방법은 npm install 명령어 실행시 --save 또는 --save-dev 플래그를 사용하는 것 입니다.\n\n```\n> npm install <package_name> --save\n> npm install <package_name> --save-dev\n```\n"}},{"name":"koa-1.md","oid":"932dabc45fc6e6a76d7adfeaaaf283051305af67","content":{"__typename":"GitHub_Blob","text":"---\ntitle: Koa 가이드 \ndate: 2020-01-04\ntags: koa\ncategory: nodejs\n---\n\n> 원본 [Koa user guide](https://github.com/koajs/koa/blob/master/docs/guide.md)\n\n---\n\n# 가이드\n\n이 가이드는 미들웨어 사용법과 애플리케이션 구조에 대해서 다룬다.\n예제의 미들웨어에서는 async 함수를 사용한다. 물론 commonFunction 또는 generatorFunction을 사용할 수도 있다.\n\n## 목차\n\n- [미들웨어 사용법](#미들웨어-사용법)\n- [미들웨어 표준 사용법](#미들웨어-표준-사용법)\n  - [미들웨어 옵션들](#미들웨어-옵션들)\n  - [미들웨어 이름 지정](#미들웨어-이름-지정)\n  - [koa-compose를 통해 다양한 미들웨어 조합하기](#koa-compose를-통해-다양한-미들웨어-조합하기)\n  - [미들웨어 Response](#미들웨어-Response)\n- [Async operations](#async-operations)\n- [Debugging Koa](#debugging-koa)\n\n# 미들웨어 사용법\n\n  Koa 미들웨어는 (ctx, next) 같은 파라미터를 가진 `MiddlewareFunction` 반환하는 간단한 함수다. 미들웨어가 동작할 때, 반드시 `next()` 를 통해 다음 미들웨어로 갈 수 있다. \n\n만약 Koa를 통해 전파되는 request 소요 시간을 추적하고 싶다면 다음과 같이 `X-Response-Time`  헤더에 시간을 셋팅하면 된다.\n\n```js\nasync function responseTime(ctx, next) {\n  const start = Date.now();\n  await next();\n  const ms = Date.now() - start;\n  ctx.set('X-Response-Time', `${ms}ms`);\n}\n\napp.use(responseTime);\n```\n\n프론트엔드 개발자는 `next()` 전의 코드를 \"capture\" 단계로 `next()` 후의 코드를 \"bubble\" 단계로 생각할 수 있다.  아래의 이미지는 어떻게 async 함수로 request, reponse 구현을 스택 플로우로 활용할 수 있는 지 설명해준다.\n\n![Koa middleware](/assets/images/2020-01-04-img/middleware.gif)\n\n   1. response time 생성\n   2. Await를 통해 다음 미들웨어로\n   3. 소요시간 계산을 위해 또 다른 time을 생성\n   4. Await를 통해 다음 미들웨어로\n   5. response body에 \"Hello World\" 셋팅\n   6. 소요시간 계산\n   7. 로그로 출력\n   8. 응답시간 계산\n   9. `X-Response-Time`  헤더 필드에 값 셋팅\n   10. Koa로 이동하여 response 전달 \n\n이제 우리는 Koa 미들웨어를 생성하는 방법에 대해 알아볼 것이다.\n\n## 미들웨어 표준 사용법\n\n이 섹션은 미들웨어 옵션, 디버깅 등을 위한 미들웨어 사용 방법에 대해 다룬다.\n\n### 미들웨어 옵션들\n\n공용 미들웨어를 생성할 때 옵션을 허용하여 편리하게 함수를 확장하여 미들웨어를 랩핑할 수 있다.  미들웨어에서 옵션을 허용하지 않을 수도 있는 데, 이는 좋은 표준이기도 하다.\n\n여기 `logger` 미들웨어는 커스텀을 위해 `format`을 이용하여 값을 셋팅 후 문자열로 리턴한다.\n\n```js\nfunction logger(format) {\n  format = format || ':method \":url\"';\n\n  return async function (ctx, next) {\n    const str = format\n      .replace(':method', ctx.method)\n      .replace(':url', ctx.url);\n\n    console.log(str);\n\n    await next();\n  };\n}\n\napp.use(logger());\napp.use(logger(':method :url'));\n```\n\n### 미들웨어 이름 지정\n\n미들웨어의 이름을 지정하는 것은 선택사항이나 이름을 사용하면 디버깅 목적으로 사용할 때 유용하다.\n\n```js\nfunction logger(format) {\n  return async function logger(ctx, next) {\n\n  };\n}\n```\n\n### koa-compose를 통해 다양한 미들웨어 조합하기\n\n[koa-compose](https://github.com/koajs/compose) 를 사용하면 여러 개의 미들웨어를 조립하여 하나의 미들웨어로 사용할 수 있다. 미들웨어를 재사용하거나 export할 때 유리하다. \n\n```js\nconst compose = require('koa-compose');\n\nasync function random(ctx, next) {\n  if ('/random' == ctx.path) {\n    ctx.body = Math.floor(Math.random() * 10);\n  } else {\n    await next();\n  }\n};\n\nasync function backwards(ctx, next) {\n  if ('/backwards' == ctx.path) {\n    ctx.body = 'sdrawkcab';\n  } else {\n    await next();\n  }\n}\n\nasync function pi(ctx, next) {\n  if ('/pi' == ctx.path) {\n    ctx.body = String(Math.PI);\n  } else {\n    await next();\n  }\n}\n\nconst all = compose([random, backwards, pi]);\n\napp.use(all);\n```\n\n### 미들웨어 Response\n\n미들웨어는 요청에 대한 응답을 위해 `next()`를 생략할지도 모른다. 일반적으로 `next()`는 미들웨어의 라우팅을 결정하나 다음과 같은 작업을 한다.\n예를 들어 아래의 코드는 요청에 대해 \"two\"를 응답하나 3개의 미들웨어 모두 실행된다. 3개의 미들웨어에 response를 조작할 수 있는 기회가 주어지는 것이다.\n\n```js\napp.use(async function (ctx, next) {\n  console.log('>> one');\n  await next();\n  console.log('<< one');\n});\n\napp.use(async function (ctx, next) {\n  console.log('>> two');\n  ctx.body = 'two';\n  await next();\n  console.log('<< two');\n});\n\napp.use(async function (ctx, next) {\n  console.log('>> three');\n  await next();\n  console.log('<< three');\n});\n```\n  \n  아래의 코드는 두번째 미들웨어에서 `next()`를 생략했고 response로 \"two\"를 셋팅하여 세번째 미들웨어는 무시될 것이다.\n\n```js\napp.use(async function (ctx, next) {\n  console.log('>> one');\n  await next();\n  console.log('<< one');\n});\n\napp.use(async function (ctx, next) {\n  console.log('>> two');\n  ctx.body = 'two';\n  console.log('<< two');\n});\n\napp.use(async function (ctx, next) {\n  console.log('>> three');\n  await next();\n  console.log('<< three');\n});\n```\n\n가장 마지막 미들웨어에서 `next()`를 실행하면 noop function, 아무 동작을 하지 않으며 미들웨어가 스택의 어느 곳에서나 올바르게 구성할 수 있다.\n\n## Async operations\n\nAsync 함수와 promise 기반인 Koa는 non-blocking sequential code를 허용한다. 예를 들어 이 미들웨어는 `./docs` 디렉토리에서 파일 이름들을 읽어온 후  parallel, 병렬로 각각의 마크다운 파일 형태의 내용을 읽어 body에 결과를 join 하여 셋팅한다.\n\n> non-blocking이란, 어떤 쓰레드에서 오류가 발생하거나 멈추었을 때 다른 쓰레드에게 영향을 끼치지 않도록 만드는 방법들을 말한다.\n\n> parallel, 병렬이라는 뜻처럼 데이터를 한번에 여러 개를 전송한다\n\n```js\nconst fs = require('mz/fs');\n\napp.use(async function (ctx, next) {\n  const paths = await fs.readdir('docs');\n  const files = await Promise.all(paths.map(path => fs.readFile(`docs/${path}`, 'utf8')));\n\n  ctx.type = 'markdown';\n  ctx.body = files.join('');\n});\n```\n\n## Koa 디버깅하기\n\n  Koa along with many of the libraries it's built with support the __DEBUG__ environment variable from [debug](https://github.com/visionmedia/debug) which provides simple conditional logging.\n\n  For example\n  to see all Koa-specific debugging information just pass `DEBUG=koa*` and upon boot you'll see the list of middleware used, among other things.\n\n```\n$ DEBUG=koa* node --harmony examples/simple\n  koa:application use responseTime +0ms\n  koa:application use logger +4ms\n  koa:application use contentLength +0ms\n  koa:application use notfound +0ms\n  koa:application use response +0ms\n  koa:application listen +0ms\n```\n\n  Since JavaScript does not allow defining function names at\n  runtime, you can also set a middleware's name as `._name`.\n  This is useful when you don't have control of a middleware's name.\n  For example:\n\n```js\nconst path = require('path');\nconst serve = require('koa-static');\n\nconst publicFiles = serve(path.join(__dirname, 'public'));\npublicFiles._name = 'static /public';\n\napp.use(publicFiles);\n```\n\n  Now, instead of just seeing \"serve\" when debugging, you will see:\n\n```\n  koa:application use static /public +0ms\n```\n"}}]}},{"name":"OperatingSystem","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":"2019-12-23-operating system-1.md","oid":"7597906a0b776c9b2fe7ef84398e8890c40f630f","content":{"__typename":"GitHub_Blob","text":"# 운영체제 서론 - 운영체제의 정의와 역할\n\n- Title : 운영체제 서론 - 운영체제의 정의와 역할\n- Date : 2019-12-23\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # 운영체제가 없는 컴퓨터의 전원을 키면 어떤 일이 일어날까??\n\n운영체제가 하는 일을 알면 운영체제가 없는 PC에서 어떤 일이 일어나는 지 알 수 있다. 결론부터 말하자면, 컴퓨터는 **한 마디로 야.생.마.** 가 되어 제어할 수 없게 된다. 아래에서 운영체제의 역할을 살펴보며 왜 야생마가 되는 지 알아보자.\n\n## 알아보기 전, 간단히 컴퓨터 구조를 살펴보자!\n\n컴퓨터에는 <code class=\"codetainer\">프로세스(처리기)</code>와 <code class=\"codetainer\">메인 메모리</code>가 있다. 우리는 어떤 프로그램을 실행하기 전에 메모리에 명령들(Instructions)을 기록하는 데 이 명령어의 집합을 <code class=\"codetainer\">프로그램</code>이라고 한다. 이렇게 프로그램을 미리 내장해놓고 실행하며 이런 구조의 컴퓨터를 프로그램 내장형 컴퓨터라고 한다. 정리하자면, 전원을 키면 프로세스는 메인 메모리에서 명령어를 가져와서 실행하고 또 그 다음 명령어를 가져와서 실행한다.\n\n## 운영체제가 없는 PC의 전원을 켰을 때, 메인 메모리의 상태는??\n\n멋대로의, 임의의 값이 들어있기에 프로세스가 하는 일이 의미가 없다. 마치 전혀 제어가 안되는 야생마와 같다.\n\n## 운영체제는 프로그램을 어떻게 실행시킬까??\n\n<span class=\"clr-note\">프로그램은 컴퓨터의 하드디스크 안에 실행 파일 형태로 모여있으며 이 파일이 메모리에 올라가야 실제로 실행될 수 있다.</span> 하드디스크의 실행 파일을 메모리에 올리는 것은 운영체제가 담당하기 때문에 운영체제가 없으면 실행 파일을 메모리에 올릴 수가 없다. 메인 메모리에 여러 개의 프로그램이 동시에 올라가있고 프로세스는 한 개 라면 동시에 어떻게 실행시킬까? 사실 이 것도 운영체제가 처리해준다.\n\n## 그 외에\n\n<span class=\"clr-note\">프린터에 인쇄 명령, 하드 디스크에 저장</span> 등 <span class=\"clr-grey\">(즉, 하드웨어 관리)</span>도 운영체제가 처리해준다. 따라서 운영체제가 없으면 위에 언급한 내용들을 처리할 수 없어서 컴퓨터를 제대로 사용할 수가 없다.\n\n## 정리하자면!\n\n운영체제는 컴퓨터의 하드웨어(프로세스, 메모리, 디스크, 키보드, 마우스, 모니터, 네트워크, 스피커, 마이크, GPS..) 등을 잘 관리하여 성능을 높이고 사용자에게 편의성을 제공하는 역할을 담당한다.\n\n# # 부팅(Booting)\n\n## 알아보기 전, 메모리에 대해 간단히 살펴보자!\n\n메인 메모리는 일반적으로 <code class=\"codetainer\">RAM</code>과 <code class=\"codetainer\">ROM</code>으로 나눠지는 데 ROM은 극히 일부분을 차지하고 대부분은 RAM이다. RAM은 휘발성 메모리라서 전원을 껐다 키면 내용이 사라지지만 ROM과 하드디스크는 전원 상관 없이 내용이 유지된다.\n\n## 극히 일부분인 ROM이 하는 일은 무엇일까??\n\n전원을 키면 프로세스는 제일 먼저 <code class=\"codetainer\">ROM</code>의 명령어를 읽어와서 실행한다. <span class=\"clr-grey\">ROM은 전원을 처음 켰을 때 한번만 필요.</span> ROM의 프로그램 중, <code class=\"codetainer\">POST(Power-On Self-Test: 컴퓨터가 환경 설정이 제대로 되어 있는지, 프린터 키보드 연결 여부 및 메인 메모리 크기 등을 테스트)</code>를 제일 먼저 실행하고 그 다음 <code class=\"codetainer\">부트로더(Boot loader)</code>를 실행한다.\n\n## ROM의 부트로더가 하는 일은??\n\n부트로더는 하드디스크에 있는 OS를 메인 메모리에 올리는 역할을 한다. OS가 메인 메모리에 올라가면 ROM은 필요가 없다.\n\n## 그 후의 이야기..\n\nOS가 메인 메모리에 올라오면 윈도우즈라면 윈도우즈 초기화면이 나타나고 리눅스는 로그인 프롬트가 나타난다. 즉 <span class=\"clr-note\">OS가 메인 메모리에 상주되어 모든 명령어를 받아드릴 준비가 된다.</span> OS는 다른 프로그램과 달리 전원을 끌 때까지 메모리에 상주한다.\n\n# # 커널(kernel) vs 명령 해석기(shell, command interpreter)\n\n운영체제는 여러가지 하드웨어 장치를 관리하는 프로그램으로 OS 중 핵심 부분을 <code class=\"codetainer\">커널(kernel)</code>이라고 한다. 반대로 <code class=\"codetainer\">명령 해석기(shell, command interpreter)</code>는 os의 껍질로 사용자로부터 명령을 받고 그 명령을 해석하여 결과를 보여주는 역할을 한다. 예를 들어, 리눅스에서 <code class=\"codetainer\">\\$who</code>라는 명령을 내려 사용자 목록을 보여주는 데, 이 것을 쉘이 담당한다.\n\n## 하드웨어 > 운영체제 > 애플리케이션\n\n하드웨어 위에 운영체제, 운영체제 위에서 애플리케이션이 실행된다.\n"}},{"name":"2019-12-23-operating system-2.md","oid":"57230c4640ec299d7d03355c2e48f3f78fad5edf","content":{"__typename":"GitHub_Blob","text":"# 운영체제의 역사 - 일괄처리부터 시분할시스템까지 운영체제 변천의 역사\n\n- Title : 운영체제의 역사 - 일괄처리부터 시분할시스템까지 운영체제 변천의 역사\n- Date : 2019-12-23\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # Batch processing system(일괄처리)\n\n최초의 운영체제로 과거 오퍼레이터가 했던 일련의 작업들을 <span class=\"clr-note\">메모리에 상주시켜 일괄처리</span>한다. 메모리에 상주시킨 작은 프로그램을 <code class=\"codetainer\">레지던트 모니터(resident monitor)</code>라고 한다.\n\n# # Multiprogramming system(다중프로그래밍)\n\n## 멀티프로그래밍 시스템 등장 배경은??\n\n배치 프로세싱 시스템은 메모리에 운영체제와 **하나의** 사용자 프로그램(컴파일러, 게임 등..)만 올릴 수 있다. 하나만 올린다는 건 비싼 컴퓨터를 낭비하는 일이다. 예를 들어 +, \\*와 같은 연산 작업(CPU)과 화면에 입/출력하는 작업(I/O)을 하는 간단한 C 프로그램을 생각해보자. 프로그램을 실행하면 연산 작업에서는 빠른 CPU를 사용하고 입/출력 작업에서 느린 I/O를 사용한다. 즉, I/O 작업 중에는 CPU가 놀게 되는 것이다. 비싼 CPU를 쉬게 만든다니 너무나 아까운 일이다. 그래서 메모리에 여러 프로그램을 올리는 다중 프로그래밍 시스템이 등장하게 된 것이다.\n\n## 동작 방식은??\n\n이제 메모리에 여러 개의 사용자 프로그램이 올라갈 수 있게 된다. user1, user2, user3 프로그램이 메모리에 올라가있고 user1을 실행 중이라고 가정해보자. user1이 연산작업을 위해 CPU를 사용하다가 I/O를 사용하게 되면 바로 user2 프로그램을 실행한다. user2에서도 CPU를 사용하다가 I/O를 사용하게 되면 user3를 실행한다. 이렇게 프로그램이 I/O 작업을 하는 동안 또 다른 프로그램을 실행시켜 CPU를 사용하게 만들어 CPU 낭비를 줄인다.\n\n## 다중 프로그래밍에서 생각해야할 점이 있는데??\n\n바로 <span class=\"clr-note\">CPU scheduling, 메모리 관리, 보호</span>이다. 성능을 위해 각 사용자 프로그램을 최적의 순서로 실행해야하는 데 이를 <code class=\"codetainer\">CPU 스케줄링</code>이라고 한다. 이는 나중에 배운다. 또한, 각 사용자 프로그램을 메모리에 어떻게 배치하고 관리<code class=\"codetainer\">(메모리 관리)</code>할지도 고민해야하며 다른 프로그램 영역을 침범하는 경우를 막아야 한다.<code class=\"codetainer\">(보호)</code>\n\n# # Time-sharing system(시공유 시스템)\n\n## 시공유 시스템 등장 배경은??\n\n모니터와 키보드가 나오면서 대화형(Interactive system) 컴퓨터가 등장했고 컴퓨터 하나에 여러 개의 단말기(terminal)를 연결하여 여러 사람이 동시에 컴퓨터를 사용할 수 있게 되었다. 그런데 다중 프로그래밍 운영체제로는 동시에 컴퓨터를 사용할 수가 없다. user1 프로그램이 실행되는 동안 user2 프로그램을 실행할 수 없다는 것을 생각해보면 이해가 될 것이다. 시공유 시스템이 등장하게 된 배경이 바로 여기에 있다.\n\n## 동작 방식은??\n\n간단하게 1/100(초)마다 user1, user2, user3 프로그램을 스위칭한다고 생각하면 된다. 1/100(초) 동안 user1을 실행하고 그 다음 1/100(초) 동안 user2를 실행한다. 다중 프로그래밍이 I/O에 스위칭하는 것과 달리 시공유 시스템은 특정 시간마다 강제 전환한다. 더 나아가 1초를 기준으로 생각해보자. 1초동안 스위칭이 100번 일어나고 세 개의 프로그램이 메모리에 올라가있으므로 각 프로그램은 1초동안 33번 CPU에 할당된다. 워낙 빠르게 스위칭되어 여러 사용자가 하나의 컴퓨터를 사용하고 있음에도 혼자서 컴퓨터를 사용하는 것처럼 느껴진다.\n\n## 생각해봐야할 점은??\n\n바로 <span class=\"clr-note\">프로세스간 통신, 동기화, 가상 메모리</span>다. 하나의 컴퓨터를 여러명이 사용하다보면 서로 간에 데이터를 주고 받고 싶어진다. <code class=\"codetainer\">프로세스간 통신</code>의 등장 이유다. 또, user1, user2, user3가 거의 동시에 실행되므로 누가 앞서서 실행되는 지를 정해야하는 데 이를 <code class=\"codetainer\">동기화</code>라고 한다. 마지막으로 유저가 많아지면 메모리에 올린 프로그램이 많아져 메인 메모리가 부족해지는 경우가 생긴다. 이러한 문제를 해결하기 위해 하드디스크의 일부를 메인 메모리처럼 사용하는 <code class=\"codetainer\">가상 메모리 기술</code>이 등장했다.\n\n위에서 언급된 cpu 스케줄링, 프로세스간 통신 등은 뒤에서 상세히 공부할 예정이다.\n"}},{"name":"2019-12-23-operating-system-3.md","oid":"f7b2c7b228ce7a27b8514b7c18d789d9be5fc783","content":{"__typename":"GitHub_Blob","text":"# 운영체제 - 인터럽트 기반 운영체제\n\n- Title : 운영체제 - 인터럽트 기반 운영체제\n- Date : 2019-12-23\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # 인터럽트 기반 시스템(Interrupt-Based System)\n\n현대 운영체제는 인터럽트 기반 시스템이다.\n\n## 전원을 키면?\n\n메인메모리가 비워져 있는 상태에서 CPU가 ROM의 부트로더를 실행하면 하드디스크의 운영체제가 메인 메모리에 올라가게 된다. 운영체제가 메인 메모리에 올라간 것을 <code class=\"codetainer\">부팅</code>이라고 부른다.\n\n## 부팅 끝난 후 운영체제의 상태는?\n\n부팅이 끝나면 운영체제는 메모리에 상주하게 되고 이벤트(인터럽트)를 기다리는 대기 상태가 된다. 이 운영체제에는 여러 개의 코드가 있고 이 코드는 인터럽트(하드웨어, 소프트웨어, 내부)가 발생할 때 실행된다.\n\n## 하드웨어 인터럽트 - 키보드, 마우스..\n\n마우스로 예를 들어 보자. 우리가 마우스를 움직이면 마우스에서 전기 신호가 발생하여 그 신호가 CPU의 인터럽트 선으로 전달된다. <span class=\"clr-note\">CPU는 인터럽트 신호를 받으면 지금 하던 일을 중지하고 운영체제에 있는 인터럽트 서비스 루틴(ISR)을 실행시킨다.</span> <code class=\"codetainer\">인터럽트 서비스 루틴</code>은 해당 인터럽트가 오면 어떤 일을 수행할 지 코드해놓은 프로그램이다. 우리는 이 인터럽트와 인터럽트 서비스 루틴 덕분에 마우스를 움직이면 화면의 마우스 커서가 움직이게 할 수 있는 것이다. 다른 예시로 hwp 아이콘을 더블 클릭하는 경우를 생각해보자. 더블 클릭으로 인터럽트가 발생하면 CPU는 OS의 더블클릭 ISR을 실행한다. 더블 클릭 인터럽트 서비스 루틴은 하드디스크의 HWP 실행 파일을 메인 메모리에 올려서 CPU가 실행할 수 있도록 한다.\n\n## 소프트웨어 인터럽트\n\nhwp 프로그램 실행 중 memo.hwp 파일을 읽어오고 싶은 경우를 생각해보자. 하드디스크를 뒤져서 memo.hwp를 메모리에 올려야하는 데 이 작업은 hwp 프로그램이 직접 수행하지않는다. 인터럽트를 발생시켜 운영체제의 ISR을 실행하여 메모리에 올리는 것이다. ISR이 실행되어 memo.hwp를 다 읽으면 다시 hwp 프로그램으로 돌아온다. <span class=\"clr-note\">정리하자면, 사용자 프로그램에서 소프트웨어 인터럽트를 걸면 운영체제 안의 특정 코드(ISR)를 실행하고 이 코드 실행이 끝나면 다시 사용자 프로그램으로 돌아온다.</span>\n\n## 내부 인터럽트\n\n하나의 예시로 <span class=\"clr-note\">divide by zero</span>를 들 수 있다. <code class=\"codetainer\">int i=5, j=0; i=i/j;</code> 다음과 같이 0으로 나누는 연산을 하면 i에 값을 저장할 수 없게 된다. 이는 곧 그 다음 코드를 실행할 수 없다는 의미다. 컴퓨터는 이러한 경우, 프로그램을 강제 종료시키고 싶어진다. 그래서 CPU는 내부적으로 인터럽트를 발생한 것으로 인식하여 프로그램을 종료시키는 ISR을 실행시킨다.\n"}},{"name":"2019-12-25-operating-system-4.md","oid":"492e9413883721c4edee853633cd2b4713e6aade","content":{"__typename":"GitHub_Blob","text":"# 운영체제 - 이중모드, 하드웨어 보호\n\n- Title : 운영체제 - 이중모드, 하드웨어 보호\n- Date : 2019-12-25\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # 이중모드(Dual Mode)\n\n## 이중모드의 등장 배경은?\n\n하나의 서버 컴퓨터를 여러 사람이 동시에 사용하는 또는 한 사람이 여러 개의 프로그램을 동시에 사용하는 환경에서 한 사람의 고의/실수 프로그램은 전체에 영향을 끼치게 된다. 예를 들어, 한 사용자 프로그램에서 <code class=\"codetainer\">STOP, HALT, RESET, SET_TIMER, SET_HW</code>등의 명령을 실행한다면 컴퓨터 전체가 영향을 받는다. 즉, <span class=\"clr-note\">시스템에 치명적인 명령은 관리자만 실행할 수 있도록</span> 하기 위해 이중모드(사용자모드, 관리자모드)가 등장하게 된 것이다.\n\n## 이중모드란?\n\n<code class=\"codetainer\">시스템(system) 모드 = 관리자(supervisor) 모드 = 모니터(monitor) 모드 = 특권(priviliged) 모드</code> 와 <code class=\"codetainer\">사용자 모드</code>가 있다. 시스템 모드일 때, <code class=\"codetainer\">STOP, HALT</code> 와 같은 <code class=\"codetainer\">특권 명령</code>을 내릴 수 있고 사용자 프로그램에서는 치명적 명령을 사용 못하게 막는다.\n\n## 이중모드는 어떻게 동작할까?\n\nCPU에 있는 <code class=\"codetainer\">레지스터</code>는 비트를 가지고 있으며 각 비트는 <code class=\"codetainer\">carry, negative, zero, overflow</code> 발생을 알려주는 플래그 역할을 한다. 여기에 이중모드를 위한 비트를 추가하여 <span class=\"clr-note\">시스템 모드면 1</span>을 <span class=\"clr-note\">사용자 모드면 0</span>으로 표시한다. <br/><br/>\n![이중모드](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-25-img/dual-mode.png)<br/>\n\n- 운영체제 서비스를 실행될 때는 <span class=\"clr-note\">관리자 모드</span>\n- 사용자 프로그램 실행될 때는 <span class=\"clr-note\">사용자 모드</span>\n- 하드웨어/소프트웨어 인터럽트 발생하면 <span class=\"clr-note\">관리자 모드</span>\n- 운영체제 서비스가 끝나면 다시 <span class=\"clr-note\">사용자 모드</span>\n\n## 이중모드 예시\n\n전원을 켰을 때 하드 디스크에 있는 운영체제가 메인 메모리에 올라가는 것은 **시스템 모드**에서 동작한다. 부팅이 끝나면 **사용자 모드**가 된다. 게임 아이콘을 더블클릭하여 인터럽트가 발생하면 다시 **시스템 모드**가 되어 인터럽트 서비스 루틴이 게임을 메인 메모리에 올리고 cpu가 실행할 수 있도록 한다. 다시 **사용자 모드**로 돌아오고 열심히 게임을 한다. 이제 게임 스코어를 하드디스크에 저장해보자. 게임 프로그램이 직접 하드디스크에 저장하는 것이 아니라 소프트웨어 인터럽트를 걸어 CPU가 지금 하던 일을 멈추고 운영체제의 ISR로 점프해서 실행하도록 한다. 이 때는 **시스템 모드**이다. ISR이 완료되면 레지스터 비트를 0으로 하여 **사용자 모드**로 만들고 다시 게임으로 돌아오게 된다.\n\n하드웨어 인터럽트도 마찬가지다. **사용자 모드**에서 마우스를 움직이게 되면 CPU로 인터럽트를 보내 **시스템 모드**로 바꾼 후 ISR을 실행한다. 완료되면 다시 **사용자 모드**가 된다. 즉, <span class=\"clr-note\">하나의 프로그램이 실행되는 동안 사용자 모드, 시스템 모드가 계속 반복된다.</span>\n\n## 만약 사용자 프로그램에서 특권 명령을 내리면?\n\nCPU는 레지스터의 모니터 비트를 확인하여 특권 명령이 사용자 모드일 때 내려지면 인터럽트를 발생시킨다. 운영체제의 인터럽트 서비스 루틴이 실행되고 이 ISR은 잘못된 시도를 한 프로그램을 강제 종료시켜 메모리에서 사라지게 한다.\n\n# # 하드웨어 보호\n\n## 입출력 장치 보호\n\n사용자 A가 프린터를 사용 중인 상황에서 사용자 B가 프린트 출력 명령을 내리면 어떻게 될까? 운영체제가 없다면 A 사용자꺼 한 줄, B 사용자꺼 한 줄..식으로 출력이 될 것이다. 이같은 프린트 혼선, 리셋 등의 상황이 적절한가? 다른 예시로 하드디스크에 저장된 A의 정보를 B가 마음대로 읽고 쓰는 상황을 생각해보자. 이 것도 적절한가? 답은 <span class=\"clr-note\">NO!!</span>\n\n**어떻게 해야할까?** 컴퓨터는 바로 이렇게 해결했다.\n\n입출력 명령인 <code class=\"codetainer\">IN, OUT</code>을 특권 명령으로 하여 사용자가 직접 입출력 명령을 내릴 수 없도록 했다. 만약 사용자가 직접 내리면 <code class=\"codetainer\">Privileged instruction violation</code>이기에 강제로 프로그램을 종료시킨다. 즉, 사용자가 입출력을 하기 위해서는 <code class=\"codetainer\">소프트웨어 인터럽트</code>를 발생시켜 운영체제에 요청해야한다. 인터럽트에 의해 CPU가 시스템 모드로 전환하고 운영체제의 ISR을 실행하면 운영체제가 입출력을 대행한다. ISR에는 요청이 적절한 지를 확인하는 코드가 있어 올바른 요청에만 실행된다. 만약, 올바른 요청이 아니면 운영체제는 이를 거부한다. ISR이 완료되면 다시 사용자 모드로 복귀된다.\n\n## 메모리 보호\n\n메인 메모리에는 운영체제와 여러 개의 사용자 프로그램이 동시에 있기 때문에 다른 사용자 메모리 또는 운영체제에 접근하는 것을 막아야 한다. 보호하지 않으면 다른 사용자 정보나 프로그램을 해킹하거나 운영체제를 해킹하는 경우가 생긴다.\n\n**어떻게 메모리를 보호할까?** 컴퓨터는 바로 이렇게 해결했다.\n\nCPU와 메인 메모리 사이는 Bus로 연결되어있고 CPU -> 메모리는 <code class=\"codetainer\">Address Bus</code>, 메모리 -> CPU는 <code class=\"codetainer\">Data Bus</code>로 부른다. 컴퓨터는 다른 메모리 영역의 침범을 막기 위해 Address Bus에 <code class=\"codetainer\">MMU(Memory Management Unit)</code>을 두었고 문지기 역할을 하도록 했다. MMU에는 <code class=\"codetainer\">Base, Limit</code>가 있고 값 설정은 특권 명령으로 운영체제만 바꿀 수 있다. MMU는 Base~Limit 사이면 통과시키고 범위 밖이면 CPU로 인터럽트 신호를 발생시켜 해당 명령을 내린 프로그램을 종료시킨다. 이처럼 다른 사용자 또는 운영체제 영역 메모리에 접근하려는 것을 <code class=\"codetainer\">Segment Violation</code> 이라고 한다.\n\n## cpu 보호\n\n한 사용자가 <code class=\"codetainer\">while(n = 1)</code> 과 같은 명령을 실행하면 CPU를 계속 독점하여 다른 사용자의 프로그램을 실행할 수 없게 된다. 이를 막기 위해 CPU 보호가 필요한 것이다. <span class=\"clr-note\">컴퓨터는 Timer를 두어 일정 시간 경과 시 타이머 인터럽트를 발생시키는 방법으로 해결했다.</span> 일정 신호 주기로 타이머가 CPU에 인터럽트를 걸게 되면 CPU는 ISR을 실행시켜 프로그램이 CPU를 너무 오랜 시간 독점하고 있는 지를 확인한다. 독점하고 있다고 판단되면 CPU를 강제 전환시켜 다른 프로그램을 실행토록 한다.\n"}},{"name":"2019-12-25-operating-system-5.md","oid":"222f530a5cea814f9af2afcc2e90f0d55d3d0902","content":{"__typename":"GitHub_Blob","text":"# 운영체제 - 운영체제 주요 서비스 간략하게!\n\n- Title : 운영체제 - 운영체제 주요 서비스 간략하게!\n- Date : 2019-12-25\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # 운영체제의 주요 서비스\n\n- 프로세스 관리\n- 주 기억장치 관리(메인 메모리 관리)\n- 파일 관리(하드디스크의 파일)\n- 보조기억장치 관리\n- 입출력 장치 관리(프린트, 키보드, 마우스..)\n- 네트워킹\n- 보호\n- 기타..\n\n## 프로세스 관리\n\n메인 메모리에서 실행 중인 프로그램을 프로세스라고 한다.\n\n- 프로세스의 생성, 소멸(creation, deletion)\n- 프로세스 활동 일시 중지, 활동 재개(suspend, resume)\n- 프로세스간 통신(interprocess communication: IPC)\n- 프로세스간 동기화(synchromization)\n- 교착 상태 처리(deadlock handling)\n\n## 주기억장치관리(메인메모리)\n\n- 프로세스에게 메모리 공간 할당 (allocation)\n- 메모리의 어느 부분이 어느 프로세스에게 할당되었는가 추적 및 감시\n- 프로세스 종료 시 메모리 회수 (deallocation)\n- 메모리의 효과적 사용\n- 가상 메모리: 물리적 실제 메모리보다 큰 용량 갖도록\n\n## 파일 관리\n\n원래 디스크는 판 위의 Track과 sector의 집합이지만 파일이라는 논리적 관점으로 볼 수 있게 운영체제가 처리해준다.\n\n- 파일의 생성과 삭제 (file creation & deletion)\n- 디렉토리(directory)의 생성과 삭제 (또는 폴더 folder)- 기본동작지원: open, close, read, write, create, delete\n- Track/sector – file 간의 매핑(mapping) – 백업(backup)\n\n## 보조기억장치 관리\n\n하드디스크, 플래시 메모리.\n\n- 빈 공간 관리 (free space management) - 포맷 후 비워져있는 Block(섹터/트랙 집합)은 사용하다보면 비워져있는 공간, 사용되고 있는 공간으로 나눠진다. 이 공간을 관리하는 것\n- 저장공간 할당 (storage allocation)\n- 디스크 스케쥴링 (disk scheduling) : 어떻게 하면 헤더를 적게 움직이면서 원하는 트랙이나 섹터를 읽을 수 있을까?\n\n## 입출력 장치 관리\n\n- 장치 드라이브\n- 입출력 장치의 성능 향상 : <span class=\"clr-note\">buffering</span>(입출력 장치에서 읽은 내용을 일단 메모리에 가져오는 것, 한번 메모리에 가져오면 일단 빠르게 읽을 수 있음), <span class=\"clr-note\">caching</span>, <span class=\"clr-note\">spooling</span>(메모리 대신에 하드디스크를 중간 매체로 사용하는 것, 프린트로 출력할 내용을 디스크에 저장해서 cpu가 다른 일 할 수 있게)\n\n## 시스템 콜\n\n운영체제 서비스를 받기 위한 호출\n\n- <span class=\"clr-note\">Process</span>: end, abort, load, execute, create, terminate, get/set\n  attributes, wait event, signal event\n- <span class=\"clr-note\">Memory</span>: allocate, free\n- <span class=\"clr-note\">File</span>: create, delete, open, close, read, write, get/set attributes\n- <span class=\"clr-note\">Device</span>: request, release, read, write, get/set attributes,\n  attach/detache devices\n- <span class=\"clr-note\">Information</span>: get/set time, get/set system data\n- <span class=\"clr-note\">Communication</span>: socket, send, receive\n"}},{"name":"2019-12-25-operating-system-6.md","oid":"f6cb269db79cf2dc5897ed2c1c5e4e7e9526daf8","content":{"__typename":"GitHub_Blob","text":"# 운영체제 - 프로세스 관리\n\n- Title : 운영체제 - 프로세스 관리\n- Date : 2019-12-25\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # 프로세스\n\n## 프로그램 vs 프로세스\n\n<code class=\"codetainer\">Process = task = job</code>  \n게임 프로그램이 하드디스크에 있으면 아무 것도 할 수 없다. 게임을 하기 위해 더블 클릭하면 게임 프로그램이 메인 메모리에 올라와서 실행 된다. 이렇게 실행 중인 프로그램을 <code class=\"codetainer\">프로세스</code>라고 한다\n\n## 프로세스 상태\n\n하나의 컴퓨터는 여러 개의 프로세스를 돌리고 CPU는 일정 시간을 나눠주어 이 프로세스들을 관리한다. 이 때, 프로세스는 <code class=\"codetainer\">new, ready, running, waiting, terminated</code> 상태를 겪게 된다.\n\n![프로세스 상태](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-25-img/process.png)<br/>\n\n- new : 하드디스크의 프로그램이 메인 메모리에 올라왔을 때\n- ready : 모든 초기화를 끝내고 실행 준비가 되었을 때\n- running : 실제로 CPU에서 실행하고 있을 때\n- waiting : 다시 CPU 할당 받을 때까지 기다릴 때\n- terminated : 프로세스가 종료된 상태\n\n- (1) : 프린트 출력 같은 I/O 발생 시 Waiting으로 감\n- (2) : I/O 완료되면 다시 Ready로 감\n- (3) : Time sharing system 에서는 일정 주기마다 프로세스 전환 인터럽트가 발생하는 데, 프로세스에게 주어진 CPU 사용 시간이 지나면 자동으로 이 프로세스는 Ready 상태로 가고 다른 프로세스가 running 상태가 된다.\n\n# # PCB(Process Control Block)\n\n사람으로 비유하면 주민등록증과 같고 프로세스를 잘 관리하기 위해서 PCB가 필요하다.\n\n- 하나의 프로세스에 하나의 PCB가 있다.(PCB는 운영체제의 프로세스 관리 부서에 있음)\n- <span class=\"clr-note\">Task Control Block(TCB)</span> 라고도 한다.\n- 프로세스에 대한 모든 정보가 들어있다.\n- <span class=\"clr-note\">process state(running, ready, waiting, …)</span>\n- <span class=\"clr-note\">PC</span> : 다시 CPU 돌아왔을 때, 그 당시의 PC 값이 필요하다.\n- <span class=\"clr-note\">registers</span> : CPU가 다른 프로그램 실행하다가 다시 돌아왔을 때, 어디서부터 다시 실행할 건지 알아야 한다.\n- <span class=\"clr-note\">MMU info (base, limit)</span> : 프로세스 스위칭 할 때마다 값을 바꿔줘야 한다\n- <span class=\"clr-note\">CPU time</span> : 현재까지 이 프로세스가 CPU 얼마나 사용했는 지\n- <span class=\"clr-note\">process id</span> : PID 프로세스마다 번호를 붙임\n- <span class=\"clr-note\">list of open files</span> : 프로세스가 지금 어떤 파일들을 사용하고 있는 지\n- 등...\n\n# # Queues\n\n## Job Queue\n\n하드디스크에 비해 메인 메모리 크기는 너무나 작아서 바로 메인 메모리에 못 올라가는 경우가 생긴다. 이 때 잡들은 큐에 줄 서게 되는 데, 이 것은 <code class=\"codetainer\">Job Queue</code> 라고 한다. 큐에 있는 작업들을 어떤 순서대로 실행할 지를 정하는 것을 <code class=\"codetainer\">Job scheduler(Long-term scheduler)</code> 라고 한다.\n\n## Ready Queue\n\n메인 메모리에 올라왔다고 바로 CPU 서비스 받는 것은 아니다. 또 <code class=\"codetainer\">Ready Queue</code>에 줄 서야 한다. 여기의 잡들도 <code class=\"codetainer\">CPU scheduler(short-term scheduler)</code>에 의해 순서가 정해진다.\n\n## Device Queue\n\nI/O, 하드 디스크 사용을 위해서도 <code class=\"codetainer\">Device Queue</code>에 줄 선다. 여기 잡을 관리하는 것은 <code class=\"codetainer\">Device scheduler</code>다.\n\n# # Multiprogramming\n\n## Degree of multiprogramming\n\n메인 메모리에 몇 개의 프로세스가 올라가 있는 지.\n\n## I/O-bound vs CPU-bound process\n\n프로세스는 크게 <code class=\"codetainer\">I/O-bound process</code>와 <code class=\"codetainer\">CPU-bound process</code>로 나눌 수 있다. I/O-bound는 주로 입출력 작업을 하는 프로세스로 문서편집 프로그램이 대표적이다. CPU-bound는 연산 작업이 많아 주로 CPU를 사용하는 경우며 예시로 슈퍼 컴퓨터 쓰는 일기 예보 프로그램을 들 수 있다.\n\n## Medium-term scheduler\n\nshort-term 보다는 적게 long-term 보다는 많게 일어난다. 운영체제는 메인 메모리를 감시하여 메모리에는 올라와있지만 아무 활동을 안하는 프로세스를 디스크에 쫒아낸다. 빈 메모리에는 새로운 프로그램을 올리거나 다른 프로세스에게 할당해준다. 이렇게 프로세스 이미지를 디스크로 쫒아내는 것을 <code class=\"codetainer\">Swapping Out</code> 이라고 하며 반대로 다시 프로세스를 사용하기 위해 메인 메모리에 올리면 <code class=\"codetainer\">Swapping In</code> 이라고 한다. 디스크를 프로세스 이미지를 쫒아내는 목적으로 사용하면 이를 <code class=\"codetainer\">Swap</code> 이라고 한다.\n\n## Context switching(문맥전환)\n\nCPU는 메인 메모리의 여러 프로세스를 동시에 서비스할 수 없어서 Process1을 사용하다가 Process2로 넘어가야한다. 이처럼 프로세스를 전환하는 것을 문맥전환이라고 한다.\n\n- <span class=\"clr-note\">Scheduler</span> : 큐에서 기다리는 잡 중에 무엇을 선택해서 작업할 지\n- <span class=\"clr-note\">Dispatcher</span> : CPU가 프로세스1을 서비스하다가 스케줄러에 의해 프로세스2로 문맥전환을 하려는 상황을 생각해보자. 운영체제는 안전한 문맥전환을 위해 Dispatcher 프로그램을 통해 다음의 2가지 일을 한다. 첫째로, 프로세스1의 현재 상태와 MMU(BASE, LIMIT) 정보를 프로세스1을 위한 PCB에 저장한다. 그 다음, 프로세스2의 정보를 복원하여 이전에 중지된 위치에서 재개할 수 있게 한다.\n- <span class=\"clr-note\">Context switching overhead</span> : 정보를 저장하고 복원하는 과정에서 오버헤드(부담)가 생기기 마련이다. 컴퓨터는 이를 Context switching overhead라고 부른다.\n"}},{"name":"2019-12-26-operating-system-7.md","oid":"8793d0abc3d1f564012b2736421ca0daed848670","content":{"__typename":"GitHub_Blob","text":"# 운영체제 - CPU Scheduling\n\n- Title : 운영체제 - CPU Scheduling\n- Date : 2019-12-26\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # CPU 스케줄링 관련 용어 정리\n\n## <span class=\"clr-note\">Preemptive(선점) vs Non-preemptive(비선점)</span>\n\n<code class=\"codetainer\">Preemptive(선점)</code>은 I/O 인터럽트, 프로세스 실행 완료의 경우가 아님에도 CPU 서비스를 받고 있는 프로세스를 강제로 쫒아내 다른 프로세스를 실행하는 것을 말한다. <span class=\"clr-grey\">예) 응급실에서 응급 환자를 우선 치료하는 것</span>\n\n<code class=\"codetainer\">Non-preemptive(비선점)</code>은 프로세스 실행 중 I/O 인터럽트가 발생하거나 프로세스 실행 완료되기 전에는 절대 문맥전환 일어나지 않는 것을 말한다. <span class=\"clr-grey\">예) 은행 </span>\n\n## <span class=\"clr-note\">Scheduling criteria</span>\n\n스케줄링의 성능 판단을 위한 척도\n\n- CPU Utilization (CPU 이용률, %): CPU가 얼마나 쉬지 않고 일하는 가?\n- Throughput (처리율, jobs/sec) : 시간 당 몇개의 작업을 처리하는 가?\n- Turnaround time (반환시간, sec) : 프로세스의 실행 시작 후, 완전히 종료되기까지의 시간. 프로세스는 보통 한번에 실행이 완료되지 않고 문맥전환이 발생한다는 사실을 기억해두고 반환시간을 이해하자.\n- Waiting time (대기시간, sec) : CPU 서비스 받기 위해 <code class=\"codetainer\">Ready Queue</code>에서 얼마나 기다렸나?\n- Response time (응답시간, sec) : 대화형 시스템에서 가장 중요한 척도로 명령을 내렸을 때, 처음 응답이 나오는 데까지 걸린 시간이다\n\n# # CPU 스케쥴링 알고리즘\n\n## <span class=\"clr-note\">1. First-Come, First-Served (FCFS)</span>\n\n![FCFS](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/1.png)<br/>\n**AWT = (0+24+27)/3 = 17 msec**<br/>\n**최적은 3 msec!**\n<br/><br/><br/>\n\n- 먼저 들어온 순서대로 서비스 받는다(단순, 공평)\n- Average Waiting Time(AWT) 면에서 좋지 않을 수 있다.\n- Convoy Effect (호위효과) : <code class=\"codetainer\">CPU Burst Time</code>이 긴 프로그램이 앞에 있으면 뒤 프로그램이 영향을 크게 받음\n- Non-preemptive(비선점)스케줄링이다.\n\n## <span class=\"clr-note\">2. Shortest-Job-First (SJF)</span>\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/2.png)<br/>\n**AWT = (3+16+9+0)/4 = 7 msec**\n<br/><br/><br/>\nAWT 줄이는 면에서는 제일 좋지만 비현실적이다. 실제로 프로세스가 CPU를 얼마나 썼는 지 계산하려면 과거에 CPU를 얼마나 사용했는 지를 기억하고 있어야 하고 미래는 이정도 쓰겠다 계산하여 예측해야한다. 또, 이 예측이 맞는 지 일일이 계산해야한다. 실제로는 문맥 전환이 잦기 때문에 이런 작업은 <span class=\"clr-note\">오버헤드를 증가시킨다.</span>\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/3.png)<br/>\n**Preemptive: AWT = (9+0+15+2)/4 = 26/4 = 6.5 msec**<br/>\n**Nonpreemptive: 7.75 msec**\n<br/><br/><br/>\nSJF 정책은 Preemptive(선점)과 Non-preemptive(비선점) 두 가지로 만들 수 있고 Preemptive SJF는 <code class=\"codetainer\">Shortest-Remaining-Time-First (최소잔여시간 우선)</code> 라고도 한다.\n\n## <span class=\"clr-note\">3. Priority Scheduling</span>\n\n정수 값으로 우선 순위를 정하고 우선 순위가 높을 프로세스를 먼저 서비스 해주는 방법이다. 일반적으로 값이 낮을 수록 높은 우선 순위를 가진다.\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/4.png)<br/>\n**AWT = 8.2 msec**\n<br/><br/>\n\n1. 우선순위 정하는 방법<br/>\n\n내부적\n\n- time limit : time limit 짧은 프로세스\n- memory requirement: 메모리 작게 차지하는 프로세스\n- i/o to CPU burst : I/O 처리 시간 길고 CPU 처리 시간 짧은 프로세스\n\n외부적\n\n- amount of funds being paid : 돈 많이 낸 프로세스 <span class=\"clr-grey\">예) 컴퓨터를 여러 학과가 쓴다면 등록금 많이 낸 학과가 우선순위</span>\n- political factors : 정치적 요소 <span class=\"clr-grey\">예) 학생</span>\n\n2. Preemptive, Nonpreemptive 둘다 가능하다.<br/>\n\n3. 문제점 - starvation (기아) <br/>\n\n어떤 프로세스의 우선 순위가 너무 낮아서 아무리 기다려도 CPU 서비스를 받지 못하는 상황을 <code class=\"codetainer\">starvation(기아)</code>라고 한다. 외부에서 그 프로세스보다 우선 순위가 높은 프로세스가 계속 들어올 경우에 발생한다. 해결법으로 <code class=\"codetainer\">againg</code>을 쓰는 데, 이는 운영체제가 주기적으로 Ready Queue를 조사해서 어떤 JOB이 너무 오래 기다리고 있다면 점진적으로 우선순위를 높여주는 방법이다.\n\n## <span class=\"clr-note\">4. Round-Robin</span>\n\n- Time-sharing system (시분할/시공유 시스템)에서 쓴다.\n- Time quantum 시간양자 = time slice (10 ~ 100msec) 주기로 메인 메모리의 프로세스를 실행한다. 만약 Time quantum이 100msec면 1초에 100번 문맥전환이 일어난다는 것\n- 오직 Preemptive scheduling 정책만 있다.\n- Time quantum에 의존적이므로 좋은 성능을 위해서는 Time quantum의 크기를 잘 고려해야한다.\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/5.png)<br/>\n\n위와 같이 Time quantum을 무한대로 하면 FCFS 알고리즘과 같아진다. 반대로 0으로 수렴시키면 Process sharing이라고 하는 데, 이는 스위칭이 빈번하게 일어나 프로세스들이 거의 동시에 도는 것처럼 느껴진다. 문맥전환이 빈번하므로 Context switching overhead가 크다.\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/6.png)<br/>\n위와 같이 Time quantum 크기에 따라 Average turnaround time (ATT)가 어떻게 되는 지 계산을 해보라.\n\n## <span class=\"clr-note\">5. Multilevel Queue Scheduling</span>\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/7.png)<br/>\n\n프로세스를 성격에 따라 그룹화하여 여러 개의 큐에 그룹별로 JOB을 줄 세우는 방법이다. 각 큐는 절대적 우선 순위를 가지고 있으며 CPU 시간을 큐에 차등으로 배분한다. 또한, 각 큐는 독립된 스케줄링 정책을 가진다.\n\n## <span class=\"clr-note\">6. Multilevel Feedback Queue Scheduling</span>\n\n![SJF](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-26-img/8.png)<br/>\n\n복수 개의 큐를 둔다는 점은 Multilevel Queue Scheduling와 비슷하나 모든 프로세스가 하나의 입구로 진입한다는 차이점이 있다. 프로세스가 너무 많은 CPU를 사용하면 다른 큐에 줄 세우고 기아 상태가 우려되는 JOB이 있다면 우선순위가 높은 큐에 다시 줄 세우는 방식이다.\n"}},{"name":"2019-12-27-operating-system-8.md","oid":"98d190815eccc3f8e3445b39df9139a4209a3f5c","content":{"__typename":"GitHub_Blob","text":"# 운영체제 - 프로세스 생성과 종료 및 쓰레드\n\n- Title : 운영체제 - 프로세스 생성과 종료 및 쓰레드\n- Date : 2019-12-27\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # Process Creation(프로세스 생성)\n\n## 프로세스는 프로세스에 의해 만들어진다!\n\n부팅 후 OS가 프로세스를 만들면 그 프로세스에 자식 프로세스가 만들어지고 또 자식의 자식 프로세스가 만들어진다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-27-img/1.png)<br/>\n\n- 부모 프로세스(Parent process)\n- 자식 프로세스(Child process)\n- 형제 프로세스(Sibling process) : 부모가 같은 프로세스\n- 프로세스 트리 (process tree) = 족보, 가계도\n\n## Process Identifier (PID)\n\n프로세스의 유니크 번호로 주민등록번호와 비슷한 개념이다. 절대 PID 중복되면 안됀다. cf) PPID : 부모 프로세스의 PID\n\n## 프로세스 생성\n\n- fork() system call – 부모 프로세스 복사해서 새로운 프로그램을 만든다.\n- exec() – 새로 만들어진 프로그램의 실행파일을 메모리로 가져온다.\n\n# # Process Termination(프로세스 종료)\n\n- exit() system call - 프로세스를 종료시킨다. 해당 프로세스가 가졌던 모든 자원(메모리, 열었던 파일, 프린터같은 입출력 장치 등)을 회수해서 O/S에게 반환한다.\n\n# # 쓰레드(Thread)\n\n쓰레드란? <span class=\"clr-note\">프로그램 내부의 흐름, 맥</span>이다.\n\n```java\nclass Test {\n  public static void main(String[] args) {\n    int n = 0;\n    int m = 6;\n    System.out.println(n+m);\n    while (n < m) n++;\n    System.out.println(\"Bye\");\n  }\n```\n\n이처럼 하나의 프로그램에는 보통 맥(쓰레드)이 하나 있으나 어떤 프로그램은 맥(쓰레드)이 여러 개가 있다. 하나의 프로그램에 2개 이상의 맥이 있으면 <span class=\"clr-note\">다중 쓰레드 (Multithreads)</span>라고 한다. 맥이 빠른 시간 간격으로 스위칭되기 때문에 여러 맥이 동시에 실행되는 것처럼 보인다.(=<code class=\"codetainer\">Concurrent</code> 동시성) cf) <code class=\"codetainer\">simultaneous</code>는 진짜로 동시에 실행되는 경우를 말하며 CPU가 하나면 일어날 수 없는 일이다.\n\n## 예시\n\nWeb browser(화면 출력하는 쓰레드 + 데이터 읽어오는 쓰레드), Word processor(화면 출력하는 쓰레드 + 키보드 입력 받는 쓰레드 + 철자/문법\n오류 확인 쓰레드), 음악 연주기, 동영상 플레이어, Eclipse IDE\n\n우리가 이전 포스팅에서는 <code class=\"codetainer\">Process1 -> Process2 -> Process3...</code>로 프로세스가 스위칭된다고 했지만 사실 운영체제는 다중 스레드를 지원하고 있어서 다음과 같은 흐름을 가진다. <code class=\"codetainer\">Thread1 of Process1 -> Thread2 of Process1 -> Thread1 of Process2 -> Thread2 of Process2 -> Thread3 of Process2 .....</code>\n\n## 쓰레드 구조\n\n![process](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-27-img/2.JPG)<br/>\n\n- 프로세스의 메모리 공간 공유 (code, data)\n- 프로세스의 자원 공유 (file, i/o, …)\n- 비공유: 개별적인 PC(program counter), SP(stack pointer), registers, stack\n\n![process](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-27-img/3.JPG)<br/>\n\n**vs 프로세스** <br/>\n프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받는다. 즉, 각 프로세스는 별도의 주소 공간에서 실행되고 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다. 다른 프로세스의 자원에 접근하려면 <code class=\"codetainer\">프로세스 간의 통신(IPC, inter-process communication, 파일, 소켓, 파이프...)</code>을 사용해야 한다.\n\n# # 잠깐 컴퓨터 구조 지식을 채워보자.\n\n## Register(레지스터)\n\nCPU 내부에서 처리할 명령어나 연산의 중간 결과값 등을 일시적으로 기억하는 임시 기억장소다.\n\n- 데이터 레지스터(data register) : CPU가 처리하는 데이터를 임시로 저장\n- <code class=\"codetainer\">주소 레지스터(address register)</code> : 기억장치를 액세스할 주소를 저장하며 포인터(Pointer)라고도 한다. 스택 포인터(SP, Stack Pointer), 베이스 포인터(BP, Base Pointer), 인덱스 포인터(IX, Index Pointer)가 있다.\n- 범용 레지스터(GPR) :주소 레지스터 혹은 데이터 레지스터로 사용될 수 있는 레지스터\n\n## PC\n\n프로그램 카운터(Program counter, PC)는 마이크로프로세서(중앙 처리 장치) 내부에 있는 레지스터 중의 하나로서, 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정한다. 때문에 명령어 포인터라고도 한다.\n\n## 버스\n\nCPU, 메모리, I/O 장치 등과 상호 필요한 정보를 교환하기 위해 연결된 공동의 전송선이다.\n"}},{"name":"2020-01-06-operating-system-9.md","oid":"68ea80dc2124e8d2e6495a2ae7232f0d565aecf7","content":{"__typename":"GitHub_Blob","text":"# 운영체제 - 프로세스 동기화 1\n\n- Title : 운영체제 - 프로세스 동기화 1\n- Date : 2020-01-06\n- Category: 운영체제\n\n> 1. 프로세스 동기화란?\n> 2. 임계구역이란?\n> 3. 세마포란?\n\n# 프로세스 동기화(Process Synchronization, Thread Synchronization)\n\n프로세스들이 서로 공유하는 데이터에 동시에 접근할 때 순서대로 실행하여 **일관성있는 데이터를 유지**하는 것\n\n- Independent : 프로세스1과 프로세스2가 관계가 없을 때\n- Cooperating : 다른 프로세스에게 영향을 미치거나 다른 프로세스로부터 영향을 받을 때\n- 프로세스 간 통신 : 전자 우편, 파일 전송\n- 프로세스 간 자원 공유 : 메모리 상의 자료, 데이터베이스 등\n- 실생활 예 : 명절 기차표 예약, 대학 온라인 수강신청, 실시간 주식 거래\n\n## 프로세스/쓰레드 동기화를 하려면?\n\n- 임계구역 문제 해결(틀린 답이 나오지 않도록)\n- 프로세스 실행 순서 제어(원하는 대로)\n- busy wait 등 비효율성은 제거\n\n## 동기화 도구\n\n- 세마포(Semaphores)\n- 모니터(Monitors)\n- Misc.\n\n## 은행 계좌 예시\n\n아래의 코드는 공통 변수(balance)에 대해 동시 업데이트를 수행하여 0이 아닌 잘못된 결과값이 출력된다. 이는 한번에 한 쓰레드만 업데이트하도록 하여 해결할 수 있다. -> **임계구역 문제**\n\n```java\nclass Test {\npublic static void main(String[] args) throws InterruptedException {\n  BankAccount b = new\n  BankAccount();\n  Parent p = new Parent(b);\n  Child c = new Child(b);\n  p.start();\n  c.start();\n  p.join();\n  c.join();\n  System.out.println( \"\\nbalance = \" + b.getBalance());\n  }\n}\n```\n\n```java\nclass BankAccount {\n  int balance;\n  void deposit(int amount) {\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp; // 임계구역\n  }\n  void withdraw(int amount) {\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp; // 임계구역\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n\n```java\nclass Parent extends Thread {\n  BankAccount b;\n  Parent(BankAccount b) {\n    this.b = b;\n  }\n  public void run() {\n    for (int i=0; i<100; i++)\n    b.deposit(1000);\n  }\n}\nclass Child extends Thread {\n  BankAccount b;\n  Child(BankAccount b) {\n    this.b = b;\n  }\n  public void run() {\n    for (int i=0; i<100; i++)\n    b.withdraw(1000);\n  }\n}\n```\n\n# 임계구역 문제(The Critical-Section Problem)\n\n## 임계구역(Critical Section)\n\n여러 개의 스레드로 구성된 시스템에서 각 스레드가 같이 사용하는 변수, 테이블, 파일을 바꾸는 코드 영역을 임계구역이라고 한다. 예) 은행 계좌 예시에서 balance 값을 바꾸는 코드가 임계구역이다.\n\n## 임계구역 문제 해결방법 - 아래 3가지 다 만족해야한다!\n\n- Mutual exclusion (상호배타): 오직 한 쓰레드만 진입<br/>예) Parent 스레드가 임계구역 실행 중에는 Child 스레드는 임계구역에 들어갈 수 없다.\n- Progress (진행): 진입 결정은 유한 시간 내<br/>예) 임계구역에 어떤 스레드가 먼저 진입할지에 대한 결정은 유한 시간 내에 결정되어야 한다.\n- Bounded waiting (유한대기): 어느 쓰레드라도<br/>예) 어느 스레드라도 기다리고 있으면 유한한 시간내에 임계구역에 들어갈 수 있다.\n\n# 세마포 (Semaphore)\n\n동기화 문제 해결을 위한 소프트웨어 도구로 <span class=\"clr-note\">정수형 변수 + 두 개의 동작 (P, V)</span>으로 이루어져있다.\n\n## 동작\n\n- P: Proberen (test) → **acquire()**\n- V: Verhogen (increment) → **release()**\n\n## 구조\n\n- acquire() : 임계구역 전에 호출하여 value가 조건에 맞으면 **프로세스(or 스레드)를 list(큐)에 넣는다.** 큐에 들어간 프로세스는 다른 프로세스에 의해 release()가 호출될 때까지 Block된다. 즉 임계구역을 실행할 수 없게 된다. (Block이 된다 == Ready Queue에 들어가지 못한다)\n- release() : value 조건에 맞으면 list에서 **프로세스를 꺼내서 깨운다.** 깨운다는 것은 Ready Queue(cpu 서비스 기다리는 줄)에 넣는 다는 것을 의미한다.\n\n```java\nclass Semaphore {\n  int value; // number of permits\n\n  Semaphore(int value) {\n  ... }\n  void acquire() {\n    value--;\n    if (value < 0) {\n      add this process/thread to list;\n      block;\n    }\n  }\n  void release() {\n    value++;\n    if (value <= 0) {\n      remove a process P from list;\n      wakeup P;\n    }\n  }\n}\n\n```\n\n## 세마포의 사용 - 상호 배타(Mutual exclusion)\n\nsem.value = 1로 두어 임계구역에는 프로세스 한 개만 들어갈 수 있도록 한다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2020-01-06-img/1.png)<br/>\n\n아래 코드는 은행 계좌 예시의 BankAccount 클래스를 수정한 것으로 임계구역 문제를 해결한다.\n\n```java\nimport java.util.concurrent.Semaphore;\n\nclass BankAccount {\n  int balance;\n  Semaphore sem;\n  public BankAccount () {\n    this.sem = new Semaphore(1)\n  }\n  void deposit(int amount) {\n    try {\n      sem.acquire()\n    } catch(InterruptedException) {}\n\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp;\n    sem.release()\n  }\n  void withdraw(int amount) {\n    try {\n      sem.acquire()\n    } catch(InterruptedException) {}\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp;\n    sem.release()\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n\n1. Parent 프로세스가 deposit()을 호출하면 acquire() 메소드가 실행된다. 이는 value를 0으로 만드나 조건이 false라 바로 빠져나와 임계구역을 실행한다.\n2. 문맥 전환에 의해 Child 프로세스의 witdhdraw()가 호출되면 acquire()이 호출된다. value를 -1로 만들어 조건이 true가 되어 Child 프로세스는 큐에 들어가고 Block 된다. 즉, 임계구역을 못 간다.\n3. Parent 프로세스가 임계구역 실행을 완료한 후 release()를 호출하면 큐의 프로세스 하나를 뺀다. 즉, Child 프로세스를 깨워 Ready Queue로 보낸다.\n\n## 세마포의 사용 - 프로세스 실행 순서 제어(Ordering)\n\nCPU 스케줄링 알고리즘에 관련없이 P1에 들어간 S1 코드가 P2의 S2 코드보다 먼저 실행되게 하고 싶을 때? 세마포를 사용하자!\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2020-01-06-img/2.png)<br/>\n\n항상 입금이 먼저 되게 BankAccount 클래스를 수정해보자.\n\n```java\nimport java.util.concurrent.Semaphore;\n\nclass BankAccount {\n  int balance;\n  Semaphore sem;\n  Semaphore sem2;\n  public BankAccount () {\n    this.sem = new Semaphore(1);\n    this.sem2 = new Semaphore(0)\n  }\n  void deposit(int amount) {\n    try {\n      sem.acquire()\n    } catch(InterruptedException) {}\n\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp;\n    sem.release()\n    sem2.release()\n  }\n  void withdraw(int amount) {\n    try {\n      sem2.acquire()\n      sem.acquire()\n    } catch(InterruptedException) {}\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp;\n    sem.release()\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n\n이제 입출금 교대로 되게 BankAccount 클래스를 수정해보자.\n\n```java\nimport java.util.concurrent.Semaphore;\n\nclass BankAccount {\n  int balance;\n  Semaphore sem;\n  Semaphore dsem;\n  Semaphore wsem;\n  public BankAccount () {\n    this.sem = new Semaphore(1);\n    this.dsem = new Semaphore(0);\n    this.wsem = new Semaphore(0);\n  }\n  void deposit(int amount) {\n    try {\n      sem.acquire();\n    } catch(InterruptedException) {}\n\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp;\n    sem.release();\n    wsem.release();\n    try {\n      dsem.acquire();\n    } catch(InterruptedException) {}\n\n  }\n  void withdraw(int amount) {\n    try {\n      wsem.acquire();\n      sem.acquire();\n    } catch(InterruptedException) {}\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp;\n    sem.release();\n    dsem.release();\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n"}},{"name":"2020-01-14-operating-system-10.md","oid":"e5e224acdcb2987fdb69287d4a7af22a7a43f244","content":{"__typename":"GitHub_Blob","text":"# 운영체제 - 프로세스 동기화 2\n\n- Title : 운영체제 - 프로세스 동기화 2\n- Date : 2020-01-14\n- Category: 운영체제\n\n> 1. 생산자-소비자 문제(Producer and Consumer Problem)\n> 2. 독자-저자 문제(Readers-Writers Problem)\n> 3. 식사하는 철학자 문제(Dining Philosopher Problem)\n\n# 전통적 동기화(Classical Synchronization Problems)\n\n## Producer and Consumer Problem\n\n- 생산자-소비자 문제\n  - 생산자가 데이터를 생산하면 소비자는 그것을 소비\n  - 예1: 컴파일러(생산자) > 어셈블러(소비자)\n  - 예2: 파일서버 > 클라이언트\n  - 예3: 웹 서버(html 생산함) -> 웹 클라이언트(브라우저로 소비)\n- 유한버퍼 문제 (Bounded Buffer Problem)\n  - 생산된 데이터는 버퍼에 일단 저장(속도 차이 등)\n  - 현실 시스템에서 버퍼 크기는 유한\n  - 생산자는 버퍼가 가득 차면 더 넣을 수 없다.\n  - 소비자는 버퍼가 비면 뺄 수 없다.\n\n> 예시<br/>\n> 일반적으로 농작물 생산 속도와 소비 속도가 다르다. 현실적으로 바로 농산물을 소비자에게 주는 게 아니라 창고에 우선 저장한다. 저장된 여러 농작물을 소비자가 조금씩 빼먹고 생산자는 계속 생산해서 저장한다. 이 창고가 바로 **버퍼**다. 버퍼는 데이터를 저장할 수 있는 메모리 또는 디스크 공간으로 주로 메모리를 이용하긴 한다. 그런데 버퍼의 크기는 얼마나 될까? 현실 시스템에서 당연히 버퍼 크기는 유한하다. 컴퓨터에서 메모리가 한정적이니 당연한 얘기다.\n\n```java\n/****** 버퍼 ******/\n\nclass Buffer {\n  int[] buf;\n  int size;\n  int count;  // 버퍼의 현재 자원 크기\n  int in; // 생산자 insert 할 버퍼의 위치\n  int out;  // 소비자가 remove 할 버퍼의 위치\n\n  Buffer(int size) {\n    buf = new int[size];\n    this.size = size;\n    count = in = out = 0;\n  }\n  // 생산자\n  void insert(int item) {\n    /* check if buf is full */\n    while (count == size)\n    ;\n\n    buf[in] = item;\n    in = (in+1)%size; //circular\n    count++;\n  }\n  // 소비자\n  int remove() {\n    /* check if buf is empty */\n    while (count == 0)\n    ;\n\n    int item = buf[out];\n    out = (out+1)%size;\n    count--;\n    return item;\n  }\n}\n```\n\n```java\n/****** 생산자 ******/\nclass Producer extends Thread {\n  Buffer b;\n  int N;\n  Producer(Buffer b, int N) {\n    this.b = b; this.N = N;\n  }\n  public void run() {\n    for (int i=0; i<N; i++)\n    b.insert(i);\n  }\n}\n```\n\n```java\n/****** 소비자 ******/\nclass Consumer extends Thread {\n  Buffer b;\n  int N;\n  Consumer(Buffer b, int N) {\n    this.b = b; this.N = N;\n  }\n  public void run() {\n    int item;\n    for (int i=0; i<N; i++)\n    item = b.remove();\n  }\n}\n```\n\n```java\n/****** 메인 ******/\nclass Test {\n  public static void main(String[] arg) {\n    Buffer b = new Buffer(100);\n    Producer p = new Producer(b, 10000);\n    Consumer c = new Consumer(b, 10000);\n    p.start();\n    c.start();\n    try {\n      p.join();\n      c.join();\n    } catch (InterruptedException e) {}\n      System.out.println(\"Number of items in the buf is \" + b.count);\n  }\n}\n```\n\n- 위 코드는 잘못된 결과가 나온다.\n  - <code>실행 불가</code> 또는 <code>count != 0</code> (생산된 항목 숫자 != 소비자 항목 숫자)\n  - 최종적으로 버퍼 내에는 0개의 항목이 있어야 한다.\n- 원인은 무엇일까?\n  - 공통변수 count, buf[]에 대한 동시 업데이트 때문이다.\n  - 공통 변수 업데이트 구간(=임계구역)에 대한 동시 진입한다.\n- 어떻게 해결하지?\n  - <span class=\"clr-note\">임계구역에 대한 동시 접근 방지(상호배타)하기</span>\n  - 세마포를 사용한 상호배타 (mutual exclusion) 하기\n  - 세마포: mutex.value = 1 (# of permit)\n\n<br/>\n\n```java\n/****** 버퍼 ******/\nimport java.util.concurrent.Semaphore;\n\nclass Buffer {\n  int[] buf;\n  int size;\n  int count;  // 버퍼의 현재 자원 크기\n  int in; // 생산자 insert 할 버퍼의 위치\n  int out;  // 소비자가 remove 할 버퍼의 위치\n  Semaphore mutex;\n\n  Buffer(int size) {\n    buf = new int[size];\n    this.size = size;\n    count = in = out = 0;\n    this.mutex = new Semaphore(1);\n  }\n  // 생산자\n  void insert(int item) {\n    /* check if buf is full */\n    while (count == size)\n    ;\n    try {\n      mutex.acquire();\n      /****** S : 임계구역 *****/\n      buf[in] = item;\n      in = (in+1)%size; //circular\n      count++;\n      /****** E : 임계구역 *****/\n    } catch(InterruptedException) {}\n    mutex.release();\n  }\n  // 소비자\n  int remove() {\n    /* check if buf is empty */\n    while (count == 0)\n    ;\n    try {\n      mutex.acquire();\n      /****** S : 임계구역 *****/\n      int item = buf[out];\n      out = (out+1)%size;\n      count--;\n      return item;\n      /****** E : 임계구역 *****/\n    } catch(InterruptedException) {}\n    mutex.release();\n    return -1;\n  }\n}\n```\n\n<br/><br/>\n\n- 하지만 또! <code>Busy-wait</code> 라는 문제가 있다.\n  - insert의 <code>while (count == size);</code>와 remove의 <code>while (count == 0);</code> 로 인해 반복문에 붙잡히는 경우가 생긴다. cpu가 딴 일 못하고 붙잡힌다.\n  - 생산자: 버퍼가 가득 차면 기다려야 = 빈(empty) 공간이 있어야 한다.\n  - 소비자: 버퍼가 비면 기다려야 = 찬(full) 공간이 있어야 한다.\n- 어떻게 해결하지?\n  - 무한루프가 아니라 아예 감옥에 가둬버리자!\n  - 세마포를 사용한 busy-wait 회피\n  - 생산자: empty.acquire() // # of permit = BUF_SIZE\n  - 소비자: full.acquire() // # of permit = 0\n\n<br/>\n\n```java\n/****** 버퍼 ******/\nimport java.util.concurrent.Semaphore;\n\nclass Buffer {\n  int[] buf;\n  int size;\n  int count;  // 버퍼의 현재 자원 크기\n  int in; // 생산자 insert 할 버퍼의 위치\n  int out;  // 소비자가 remove 할 버퍼의 위치\n  Semaphore mutex;   // 임계구역에 1개만 들어가게 하려고\n  Semaphore empty;\n  Semaphore full;\n\n  Buffer(int size) {\n    buf = new int[size];\n    this.size = size;\n    count = in = out = 0;\n    this.mutex = new Semaphore(1);\n    this.empty = new Semaphore(size);\n    this.full = new Semaphore(0);\n  }\n  // 생산자\n  void insert(int item) {\n    /* check if buf is full */\n    while (count == size)\n    ;\n    try {\n      empty.acuire();\n      mutex.acquire();\n      /****** S : 임계구역 *****/\n      buf[in] = item;\n      in = (in+1)%size; //circular\n      count++;\n      /****** E : 임계구역 *****/\n    } catch(InterruptedException) {}\n    mutex.release();\n    full.release();\n  }\n  // 소비자\n  int remove() {\n    /* check if buf is empty */\n    while (count == 0)\n    ;\n    try {\n      full.acquire();\n      mutex.acquire();\n      /****** S : 임계구역 *****/\n      int item = buf[out];\n      out = (out+1)%size;\n      count--;\n      return item;\n      /****** E : 임계구역 *****/\n    } catch(InterruptedException) {}\n    mutex.release();\n    empty.release();\n    return -1;\n  }\n}\n```\n\n## Readers-Writers Problem\n\n- 공통 데이터베이스\n  - Readers: read data, never modify it\n  - Writers: read data and modifiy it\n  - 상호배타: 한 번에 한 개의 프로세스만 접근하는 것 효율성이 안 좋다.\n- 효율성을 높이려면?\n  - 데이터베이스 읽고 쓰기는 임계 구역 안에서 발생한다.\n  - 그러므로 Writers은 당연히 상호 배타 해야한다.\n  - 그러나 Reader1이 DB 읽고 있으면 Reader2도 읽을 수 있게 해줘야 효율성에 좋다!\n- 변종\n  - The first R/W problem (readers-preference) : 항상 readers에게 우선권을 주는 것. 예) 현재 Reader1이 DB를 읽고 있다고 가정해보자. Writer1의 경우는 상호 배타되어서 접근할 수 없다. 잠시 후 Reader2가 접근하면 Reader2는 늦게 왔음에도 불구하고 DB에 접근할 수 있다.\n  - The second R/W problem (writers-preference) : writers에게 우선권 주는 것\n  - The Third R/W problem : 우선권 아예 안 주는 것\n\n## Dining Philosopher Problem\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2020-01-14-img/1.png)<br/>\n\n> 5명의 철학자가 원탁에 앉아 있고 각자의 앞에는 스파게티가 있다. 그리고 양 옆에는 젓가락이 하나씩 있다. 각각의 철학자는 스파게티를 먹으려면 젓가락을 2개를 사용해야 하며, 다른 철학자에게 말을 걸 수 없고 젓가락을 빼앗을 수도 없다.\n> <br/><br/> 이제 5명의 철학자 모두가 갑자기 배가 고파서 동시에 왼쪽 젓가락을 집어든다고 생각해보자. 철학자들은 젓가락을 공유할 수 없고 자신의 오른쪽에 앉은 철학자가 젓가락을 놓을 때까지 기다린다. 오른쪽 젓가락을 빼앗을 방법도 없어서 철학자들의 계속 대기만 한다...\n\n- 식사하는 철학자 문제\n  - 5명의 철학자, 5개의 젓가락, 생각 → 식사 → 생각 → 식사\n  - 식사하려면 2개의 젓가락 필요\n- 프로그래밍\n  - 젓가락: 세마포 (# of permit = 1) -> 젓가락을 기준으로 2명 중 1명만 사용할 수 있으니깐 1로 한다.\n  - 젓가락과 세마포에 일련번호: 0 ~ 4\n  - 왼쪽 젓가락 → 오른쪽 젓가락\n\n```java\n/*********철학자*********/\nimport java.util.concurrent.Semaphore;\nclass Philosopher extends Thread {\n  int id; // philosopher id\n  Semaphore lstick, rstick; // left, right chopsticks\n  Philosopher(int id, Semaphore lstick, Semaphore rstick) {\n    this.id = id;\n    this.lstick = lstick;\n    this.rstick = rstick;\n  }\n  public void run() {\n    try {\n      while (true) {\n        lstick.acquire();\n        rstick.acquire();\n        eating();\n        lstick.release();\n        rstick.release();\n        thinking();\n      }\n    }catch (InterruptedException e) { }\n  }\n\n  void eating() {\n    System.out.println(\"[\" + id + \"] eating\");\n  }\n  void thinking() {\n    System.out.println(\"[\" + id + \"] thinking\");\n  }\n}\n```\n\n```java\n/*********메인*********/\nclass Test {\n  static final int num = 5; // number of philosphers & chopsticks\n  public static void main(String[] args) {\n    int i;\n    /* chopsticks */\n    Semaphore[] stick = new Semaphore[num];\n    for (i=0; i<num; i++)\n      stick[i] = new Semaphore(1);\n    /* philosophers */\n    Philosopher[] phil = new Philosopher[num];\n    for (i=0; i<num; i++)\n      phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]);\n    /* let philosophers eat and think */\n    for (i=0; i<num; i++)\n      phil[i].start();\n  }\n}\n```\n\n- 위 코드는 프로그램이 돌다가 멈춘다.. 왜???!!!\n  - 잘못된 결과: starvation -> 모든 철학자가 식사를 하지 못해 굶어 죽는 상황\n  - 이유 = <span class=\"clr-note\">교착상태 (deadlock)</span>\n"}},{"name":"2020-03-29-operating-system-11.md","oid":"46f1163ddd6eee6183debd713845d84759157be4","content":{"__typename":"GitHub_Blob","text":"# 운영체제 - 교착상태\n\n- Title : 운영체제 - 교착상태\n- Date : 2020-03-29\n- Category : 운영체제\n\n# 시스템 모델(System Model)\n\n시스템은 경쟁하는 프로세스들 사이에 분배되어야 할 유한한 자원들로 구성되며 여러 프로세스들은 해당 자원을 점유하기 위해 서로 경쟁 구도에 놓여있다. 프로세스가 자원을 사용하기 위해서는 반드시 사용하기 전에 요청을 해야 하고 사용 후에는 반드시 방출해야한다. 정상적인 작동 모드에서 프로세스는 다음의 순서로만 자원을 사용할 수 있다.\n\n1. 요청(Request) : 자원을 요청한다. 다른 프로세스가 사용 중이라서 자원를 받을 수 없다면 대기한다.\n2. 사용(Use) : 프로세스는 자원에 대해 작업 수행한다.\n3. 방출(Release) : 자원을 다 사용했으면 자원을 방출한다.\n\n# 교착상태(Deadlocks)\n\n둘 이상의 프로세스들이 자원(CPU, 메모리, 파일, 프린터 등..)을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상을 말한다. 교착 상태에서 프로세스들은 결코 실행을 끝낼 수 없으며, 시스템 자원이 묶여 있어서 다른 작업을 시작하는 것도 불가능하다.\n\n# 교착상태 필요조건\n\n교착 상태는 아래 4가지 조건이 **모두 만족**되야 발생할 수 있다.\n\n## 1. 상호배제(mutual exclusion)\n\n여러 프로세스 중 하나만 임계 구역에 진입할 수 있을 때 즉, 자원을 동시에 공유하지 못할 때\n\n## 2. 점유하며 대기(hold-and-height)\n\n최소 하나의 자원을 점유한 채, 현재 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 대기 중일 때\n\n## 3. 비선점(no-preemption)\n\n자원들을 선점할 수 없어야 한다. 즉, OS가 작동 중인 프로세스를 임의로 중단시킬 수 없을 때\n\n## 4. 순환대기(circular-wait)\n\n프로세스가 순환적으로 서로를 기다릴 때\n\n# 자원 할당 그래프(Resource Allocation Graph)\n\n자원과 프로세스의 관계를 그래프로 도식화한 **자원 할당 그래프**를 통해 데드락 유무를 파악할 수 있다. 자원 할당 그래프란 시스템 내 모든 활성 프로세스의 집합인 P와 모든 자원의 집합인 R로 정점의 집합 V를 구성한다. 이 그래프에서 P로부터 R로 뻣어나가는 간선은 특정 프로세스가 해당 자원을 요청하고 기다리는 것을 표시하며 자원 R에서 P로 뻣어나가는 간선은 할당 간선으로 해당 자원이 해당 프로세스에 할당되어있음을 나타낸다. 이러한 **자원 할당 그래프에 사이클이 있다면 데드락 위험이 있다는 의미가 된다.** 사이클이 있다고 무조건 데드락이 발생하는 것은 아니지만, 사이클이 없으면 절대로 데드락이 발생하지 않는다. 가능성이라고 얘기하는 이유는 자원이 하나의 인스턴스가 아닌 여러 개의 인스턴스를 가질 수도 있기 때문이다. 만약 자원이 여러 개의 인스턴스를 가질 수 있어서 여러 프로세스에게 자원을 제공한다면 교착 상태가 일어나지 않게 된다.\n\n# 교착상태 처리 방법\n\n## 1. 교착 상태 방지(Deadlock Prevention)\n\n교착상태 4가지 필요조건 중 하나를 만족시키지 않음으로서 교착 상태가 발생하는 것을 방지할 수 있다.\n\n### 상호배타 (Mutual exclusion)\n\n읽기 전용 파일은 여러 프로세스가 공유할 수 있게 하여 상호 배타를 깰 수가 있다. 하지만 대부분의 컴퓨터 자원들은 임계 구역 문제를 해결하기위해 상호 배타를 만족해야만 한다. 상호 배타를 깨는 건 현실적으로 불가능한 일이다.\n\n### 보유 및 대기 (Hold and wait)\n\n프로세스가 실행되기 전에 필요한 모든 자원을 요청하여 할당받도록 하는 거다. 이렇게 하면 프로세스가 다른 자원을 요청하여 할당받을 때까지 대기하는 일이 없고 모든 자원을 가지고 프로세스를 시작하기 때문에 대기하는 일이 발생하지 않는다. 하지만 많은 자원들이 할당된 후 오랫동안 사용되지 않기 때문에 자원 활용률이 떨어지는 단점이 있고 **기아 문제**가 발생할 수 있다. 식사하는 철학자를 예를 들면 젓가락을 동시에 두개를 집게 하고 하나만 집을 수 있다면 아예 못 집게 하는 방법이다. 또는 프로세스가 자원을 점유하지 않을 때만 자원을 요청할 수 있도록 하는 방법도 있다.\n\n### 비선점 (No Preemption)\n\n자원을 점유하고 있는 프로세스가 다른 자원를 요청했을 때 즉시 리자원를 사용할 수 없다면 점유하고 있던 자원을 방출(release)한다.\n\n### 순환 대기 (Circular wait)\n\n모든 자원 유형들에게 전체적인 순서를 부여하여 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 강제하는 것이다. 이를 통해 모든 자원들은 먼저 할당되는 순서가 정해져 있기 때문에 교착상태가 일어날 수 없다. 즉, 자원의 타입에 따라 프로세스마다 일대일 함수로 순서를 지정해준다. 식사하는 철학자 같은 경우는 아이디를 부여하여 홀수번은 오른쪽 왼쪽, 짝수번은 왼쪽 오른쪽 순서로 집도록 하였다. 역시 자원 활용률을 떨어트린다.\n\n## 2. 교착 상태 회피(Deadlock Avoidance)\n\n여기서는 교착 상태를 자원 요청에 대해 운영체제가 잘못 할당한 것으로 정의한다. 운영체제는 리소스 매니저, 리소스 allocator라고 불리듯이 자원을 프로세스에게 골고루 나눠주는 역할을 한다. 즉, **운영체제의 프로세스 관리 부서가 자원을 잘 못 나눠줘서 교착상태가 발생했다고 보는 것**이다. 은행 파산으로 비유할 수 있다. \n\n이러한 교착 상태는 어떤 프로세스가 요청을 할 때 미래에 대한 분석을 통해 자원 요청을 늦추는 방법으로 피할 수 있다. 시스템이 unsafe 상태가 되지 않도록 해야 하며 만약 unsafe 상태면 최대한 빨리 safe 상태로 복구한다. 데드락 가능성은 자원 할당 그래프를 구현해 파악하며 리소스 타입이 여러 개면 Banker's algorithm을 사용한다.\n\n> 안전 상태란 이러한 교착 상태 알고리즘을 설계함에 있어 각 유효 자원의 최대 개수까지 어떤 순서로 요청을 하더라도 교착상태를 야기하지 않고 모두 할당을 잘 해줄 수 있음 을 뜻한다.\n\n### Banker's Alogorithm\n\n교착상태 회피 알고리즘으로 프로세스가 리소스를 요청할때마다 수행되며, 이 자원을 할당하면 미래에 교착상태가 발생할지를 시뮬레이션한다.\n\n## 3. 교착 상태 검출 및 복구\n\n교착 상태가 일어나는 것을 허용하며 자원을 마음껏 나눠준다. 어쩌다가 교착상태가 일어나면 이를 회복하는 방법이다. 검출을 위한 오버헤드가 크다. 복구를 위해 프로세스 일부를 강제 종료하거나 자원을 선점하여 일부 프로세스에게 할당한다. 복구를 위해 주기적으로 현재 상태를 기억해둬야하며 데드락이 일어나지 않은 상태로 다시 돌아가야 한다.\n\n### 복구 1. 프로세스를 종료시키는 방법\n\n- 교착 상태 프로세스를 모두 중지\n    - 다시 처음부터 계산해야한다.\n- 교착 상태가 제거될 때까지 한 프로세스씩 중지하는 방법\n    - 각 프로세스가 중지될 때마다 아직도 교착 상태에 있는 지 매번 살펴봐야 하기 때문에 상당한 오버헤드를 유발한다.\n\n**어떤 프로세스를 종료시킬까?**\n\n- 프로세스의 중요도\n- 프로세스가 얼마나 오래 실행됐는가\n- 얼마나 많을 자원을 사용했는가\n- 프로세스가 작업을 마치기 위해 얼마나 많은 리소스가 필요한가\n- 프로세스가 종료되기 위해 얼마나 많은 리소스가 필요한가\n- 프로세스가 batch인가 interactive한가?\n\n### 복구 2. 자원 선점 방법\n\n교착 상태가 깨어질 때까지 프로세스로부터 자원을 계속적으로 선점해 다른 프로세스에게 주는 방법이다.\n\n**고려사항**\n\n- 희생자 선택(selection of a victim)\n    - 어떤 자원과 어느 프로세스가 선점될 것인가 를 고민\n- 롤백(rollback)\n    - 만약 특정 프로세스의 자원을 강제로 방출하고 선점시켰다면, 그 프로세스를 어떻게 처리 할 것인가에 대한 고민이다. 보통 가장 안전한 방법은 프로세스를 중지시키고 재시작하는 것 즉, 롤백하는 것이다.\n- 기아 상태(starvation)\n    - 특정 프로세스의 자원을 강제 방출시켜 선점을 시켜주게 되면 그 프로세스는 계속해서 희생자로 선택될 확률이 높고 이경우 그 프로세스는 영원히 실행이 완료되지 못하는 기아상태에 빠질 수 있다. 프로세스가 한정된 시간에만 희생자로 선정된다는 것을 반드시 보장 해야 한다.\n\n## 4. 교착 상태 무시\n\n실제 잘 안일어나니깐 그냥 무시하고..교착상태를 처리하는 것을 응용 개발자의 몫으로 맡기는 것.\n\n참고\n\n[운영체제 | 교착상태(deadlock)란 무엇인가?](https://frontalnh.github.io/2018/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-deadlock-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/)"}},{"name":"images","oid":"94d4924d6d44d62b93e6253445a5107afe0fa632","content":{"__typename":"GitHub_Tree"}}]}},{"name":"ProblemSolving","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":"2019-11-28-algorithm-1.md","oid":"002604cb528a34c3c941c0895d530037ce7296ec","content":{"__typename":"GitHub_Blob","text":"# 프로그래머스 모의고사 Javascript\n\n- Title : 프로그래머스 모의고사 Javascript\n- Date : 2019-11-28\n- Category: 알고리즘 풀이\n\n# 문제 설명\n\n수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.\n\n1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...  \n2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...  \n3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...\n\n1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.\n\n# 제한 조건\n\n- 시험은 최대 10,000 문제로 구성되어있습니다.\n- 문제의 정답은 1, 2, 3, 4, 5중 하나입니다.\n- 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.\n\n# 풀이\n\n```javascript\nfunction solution(answers) {\n  const person_ans = [\n    [1, 2, 3, 4, 5],\n    [2, 1, 2, 3, 2, 4, 2, 5],\n    [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]\n  ];\n\n  const scores = Array(3).fill(0);\n\n  for (let i = 0; i < answers.length; i++) {\n    if (person_ans[0][i % 5] === answers[i]) scores[0]++;\n    if (person_ans[1][i % 8] === answers[i]) scores[1]++;\n    if (person_ans[2][i % 10] === answers[i]) scores[2]++;\n  }\n\n  let max = Math.max(...scores);\n\n  let answer = [];\n\n  scores.forEach((element, index) => {\n    if (max == element) answer.push(index + 1);\n  });\n\n  return answer;\n}\n```\n"}},{"name":"2019-11-28-algorithm-2.md","oid":"75b2859bd64143393ac340b0b9c506a3ac7bbcba","content":{"__typename":"GitHub_Blob","text":"# 프로그래머스 조이스틱 Javascript\n\n- Title : 프로그래머스 조이스틱 Javascript\n- Date : 2019-11-28\n- Category: 알고리즘 풀이\n\n# 문제 설명\n\n조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.  \nex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA\n\n조이스틱을 각 방향으로 움직이면 아래와 같습니다.  \n▲ - 다음 알파벳  \n▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)  \n◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)  \n▶ - 커서를 오른쪽으로 이동\n\n예를 들어 아래의 방법으로 JAZ를 만들 수 있습니다.\n\n- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.\n- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.\n- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.\n\n따라서 11번 이동시켜 \"JAZ\"를 만들 수 있고, 이때가 최소 이동입니다.\n\n만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.\n\n# 제한 사항\n\n- name은 알파벳 대문자로만 이루어져 있습니다.\n- name의 길이는 1 이상 20 이하입니다.\n\n# 풀이\n\n```javascript\nfunction solution(name) {\n  var arrName = Array(name.length).fill(\"A\"); // 초기값 'A...'로 셋팅해서 name과 같을 때까지 반복 돌림\n  var index = 0; // 조작할 인덱스\n  var answer = 0; // 조작 횟수\n  while (arrName.join(\"\") !== name) {\n    // 현재 인덱스의 알파벳 변경\n    arrName[index] = name[index];\n    // 알파벳 조작 횟수\n    answer += alpha(name[index]);\n    // 다음에 조작할 인덱스 찾기\n    let obj = findPos(index, name, arrName);\n    if (obj !== null) {\n      answer += obj.diff;\n      index = obj.index;\n    }\n  }\n  return answer;\n}\n\nfunction findPos(index, name, arrName) {\n  var nextRightIndex = (index + 1) % name.length;\n  var nextLeftIndex = (index - 1 + name.length) % name.length;\n  var moveSize = 1;\n\n  // 최소값을 찾는 거니깐 or로 해서 동시 탐색\n  // 'A'가 아니면서 이미 변경처리한 알파벳이 아닌 인덱스 찾기\n  while (nextRightIndex != index || nextLeftIndex != index) {\n    if (\n      name[nextRightIndex] !== \"A\" &&\n      arrName[nextRightIndex] !== name[nextRightIndex]\n    ) {\n      return {\n        index: nextRightIndex,\n        diff: moveSize\n      };\n    }\n    if (\n      name[nextLeftIndex] !== \"A\" &&\n      arrName[nextLeftIndex] !== name[nextLeftIndex]\n    ) {\n      return {\n        index: nextLeftIndex,\n        diff: moveSize\n      };\n    }\n    nextRightIndex = ++nextRightIndex % name.length;\n    nextLeftIndex = (--nextLeftIndex + name.length) % name.length;\n    moveSize++;\n  }\n  return null;\n}\n\nfunction alpha(n) {\n  return Math.min(\n    n.charCodeAt(0) - \"A\".charCodeAt(0),\n    \"Z\".charCodeAt(0) - n.charCodeAt(0) + 1\n  );\n}\n```\n"}},{"name":"2019-11-28-algorithm-3.md","oid":"5c0786d6f1e1d8c7b84d2158fb2a236a354f6504","content":{"__typename":"GitHub_Blob","text":"# 프로그래머스 [3차] n진수게임 Javascript\n\n- Title : 프로그래머스 [3차] n진수게임 Javascript\n- Date : 2019-11-28\n- Category: 알고리즘 풀이\n\n# 문제 설명\n\n튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다.\n\n숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다.  \n10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다.  \n이렇게 게임을 진행할 경우,  \n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, …  \n순으로 숫자를 말하면 된다.\n\n한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는  \n0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, …  \n순으로 숫자를 말하면 된다.\n\n이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다.  \n숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다. 튜브의 프로그램을 구현하라.\n\n# 풀이\n\n```javascript\nfunction solution(n, t, m, p) {\n  var answer = \"\";\n  var game = new Array();\n  var number = 0;\n  while (game.length < t * m) {\n    let tmp = number;\n    let arrTmp = new Array();\n    while (tmp >= n) {\n      arrTmp.unshift(tmp % n); // 배열 맨 앞에 삽입\n      tmp = Math.floor(tmp / n); // Math.floor() 소숫점 내림\n    }\n    arrTmp.unshift(tmp);\n    game.push(...arrTmp); // game.push.apply(game, arrTmp);와 같음 확장연산자(e6)\n    //game = game.concat(arrTmp); // 배열 합치기 느리다.\n    number++;\n  }\n\n  for (let i = p - 1; i < game.length; i = i + m) {\n    answer += game[i].toString(n).toUpperCase(); // toString() number를 n진수 형태로 반환한다. abcdef를 소문자 형태로 반환해서 toUpperCase()를 사용했다.\n    if (answer.length == t) break;\n  }\n  return answer;\n}\n```\n\n## Number.prototype.toString([radix]]) 메서드\n\n- Number.prototype.toString() 은 Number 객체를 문자열로 반환하는 메서드다.\n- radix는 진수를 나타내는 기수의 값으로 2~36 범위의 정수다. 이 범위를 벗어나는 radix가 주어지면 RangeError가 발생한다. (default는 10진수)\n\nNumber 객체는 Object 객체의 toString() 메서드(**Object.prototype.toString()**)를 오버라이딩했다.\n그래서 Number 객체에서 toString() 메서드를 사용하면 특정 진수로 객체를 표현한 문자열을 리턴받을 수 있는 것이다.\n\n```javascript\nlet number = 254;\nconsole.log(number.toString(16)); // fe 출력\n```\n\n## Array.prototype.unshift([...elementN])\n\n새로운 요소를 배열의 맨 앞쪽에 추가하고, 배열의 길이를 리턴\n\n```javascript\nlet arr = [1, 2];\narr.unshift(0); // [0,1,2]\narr.unshift(-2, -1); // [-2, -1, 0, 1, 2]\n```\n\n## Array.prototype.push vs Array.prototype.concat\n\n처음에는 **game = game.concat(arrTmp)** 식으로 배열을 합쳤다. 근데 시간이 너무 많이 소요되길래 **game.push(...arrTmp)** 이렇게 바꿨더니 효율성이 좀 좋아진 듯 하다. 왜 그럴까?...\n\n[https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki](https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki) 이 글을 보면 알 수 있다.\n\n즉 concat은 .push로 원본 배열을 수정하면서 **새 배열**을 만들기때문에 느리고 push는 원본 배열의 뒤에 배열을 추가하며 원본 배열을 변경하기 때문에 concat 보다는 빠르다.\n\n## 다른 사람 풀이\n\n다른 사람 풀이를 봤더니 이렇게 간단하게도 풀 수 있다는 걸 알았다.\n\n```javascript\nfunction solution(n, t, m, p) {\n  let answer = \"\",\n    numbers = [],\n    j = 0;\n\n  for (let i = p; answer.length < t; i += m) {\n    let order = i - 1;\n\n    while (numbers[order] === undefined) {\n      j.toString(n)\n        .toUpperCase()\n        .split(\"\")\n        .forEach(v => numbers.push(v));\n      j++;\n    }\n    answer += numbers[order];\n  }\n  return answer;\n}\n```\n"}},{"name":"2019-11-29-algorithm-4.md","oid":"d473c7d17840e5d9159d068cd069263b08e30591","content":{"__typename":"GitHub_Blob","text":"# 프로그래머스 2xn 타일링 Javascript\n\n- Title : 프로그래머스 2xn 타일링 Javascript\n- Date : 2019-11-29\n- Category: 알고리즘 풀이\n\n# 문제 설명\n\n가로 길이가 2이고 세로의 길이가 1인 직사각형모양의 타일이 있습니다. 이 직사각형 타일을 이용하여 세로의 길이가 2이고 가로의 길이가 n인 바닥을 가득 채우려고 합니다. 타일을 채울 때는 다음과 같이 2가지 방법이 있습니다.\n\n타일을 가로로 배치 하는 경우  \n타일을 세로로 배치 하는 경우\n\n직사각형의 가로의 길이 n이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요.\n\n# 제한 사항\n\n- 가로의 길이 n은 60,000이하의 자연수 입니다.\n- 경우의 수가 많아 질 수 있으므로, 경우의 수를 1,000,000,007으로 나눈 나머지를 return해주세요.\n\n# 풀이\n\n문제를 보는 순간 규칙이 있을 거 같다는 생각을 했다.  \n근데 그 규칙 찾는 데 한참 걸렸다.. ㅠ\\_\\_ㅠ\n\n결론부터 말하자면, 이 문제의 점화식은 **DP[N] = DP[N-1][n-2]** 다. 그리고 n이 최대 60000 이므로 재귀를 쓰는 것보다 메모이제이션을 이용하는 게 낫다고 판단했다.\n\n아래는 점화식 도출 과정이다.\n\n- n = 0, 1개\n- n = 1, 1개\n- n = 2, 2개 (DP[1] + DP[0])\n- n = 3, 3개 (DP[2] + DP[1])\n- n = 4, 4개 (DP[3] + DP[2])\n- ....\n\n```javascript\nfunction solution(n) {\n  const memo = Array(n + 1).fill(0);\n  memo[0] = 1;\n  memo[1] = 1;\n  for (let i = 2; i < n + 1; i++) {\n    memo[i] = (memo[i - 1] + memo[i - 2]) % 1000000007;\n  }\n  return memo[n];\n}\n```\n"}},{"name":"2019-11-29-algorithm-5.md","oid":"a232821a5f7761c1362d349bea69e0660876cc43","content":{"__typename":"GitHub_Blob","text":"# 프로그래머스 2016년 Javascript\n\n- Title : 프로그래머스 2016년 Javascript\n- Date : 2019-11-29\n- Category: 알고리즘 풀이\n\n# 문제 설명\n\n2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT 입니다.\n\n를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 TUE를 반환하세요.\n\n# 제한 조건\n\n- 2016년은 윤년입니다.\n- 2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)\n\n# 풀이\n\n```javascript\nfunction solution(a, b) {\n  const month = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const day = [\"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\"];\n\n  let answer = b - 1;\n  for (let i = 1; i < a; i++) answer += month[i];\n\n  return day[answer % 7];\n}\n```\n\n쉬운 문제여서 금방 풀었지만, 뭔가 자바스크립트스럽지않아서 탐탁지않았다.  \n그래서 자바스크립트의 **reduce** 와 **slice** 메서드를 이용해서 다시 풀어보았다.\n\n```javascript\nfunction solution(a, b) {\n  const month = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const day = [\"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\"];\n\n  let answer = b - 1;\n  if (a > 1) {\n    answer += month.slice(1, a).reduce((accumlator, currentValue) => {\n      return accumlator + currentValue;\n    });\n  }\n\n  return day[answer % 7];\n}\n```\n\n# Array.prototype.reduce()\n\nreduce() 메서드는 배열의 각 요소에 reducer 함수를 실행하여 계산의 누적 결과값을 반환한다.\n\n```javascript\narr.reduce((accumulator, currentValue[,currentIndex, array][,initialValue]) => {\n //\n return //\n});\n```\n\n리듀서 함수 인수\n\n- accumulator : 콜백(리듀서함수)의 반환값 누적\n- currentValue : 처리할 현재 요소\n- 옵션 currentIndex : 처리할 현재 요소의 인덱스로 initialValue가 있으면 0, 아니면 1부터 시작\n- 옵션 array : reduce()를 호출한 배열\n\n- initialValue : 리듀서 함수 최초 호출에서 첫번째 인수로 제공할 값, 제공안하면 배열의 첫번째 요소를 사용한다. 만약 빈 배열에서 초기값 없이 reduce() 호출하면 에러난다.\n"}},{"name":"2019-12-09-algorithm-6.md","oid":"47fd52255ef30bd58a17b3696a2a9869befb8488","content":{"__typename":"GitHub_Blob","text":"# 프로그래머스 다음 큰 숫자 Javascript\n\n- Title : 프로그래머스 다음 큰 숫자 Javascript\n- Date : 2019-11-29\n- Category: 알고리즘 풀이\n\n# 문제 설명\n\n자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다.\n\n- 조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다.\n- 조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다. \\*조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다.\n\n예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다.\n\n자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요.\n\n# 내 풀이\n\n2진수 n의 1 비트 갯수와 같은 비트수를 가지는 숫자를 n+1부터 반복을 돌려서 찾으면 된다.\n\n```javascript\nfunction solution(n) {\n  let nBit = getBitCount(n);\n  while (true) {\n    if (getBitCount(++n) === nBit) break;\n  }\n\n  function getBitCount(number) {\n    let bitCount = 0;\n    while (number > 0) {\n      if (number & (1 === 1)) bitCount++;\n      number = number >>> 1;\n    }\n    return bitCount;\n  }\n\n  return n;\n}\n```\n\n# 다른 사람 풀이\n\n풀고 다른 사람의 풀이를 보니 아이디어는 비슷했으나 비트 수를 세는 방법이 다양했다.\n\n1. String.prototype.match() 메서드와 정규 표현식 이용하기\n\n```javascript\nfunction solution(n) {\n  // console.log(n.toString(2).match(/1/g)) : [ '1', '1', '1', '1' ] 배열 형태로 반환\n  let nBit = n.toString(2).match(/1/g).length;\n  while (true) if ((++n).toString(2).match(/1/g).length === nBit) return n;\n}\n```\n"}},{"name":"2019-12-09-algorithm-7.md","oid":"0b7c34714ce4c87957b97c6cb4a503aa70efdaf6","content":{"__typename":"GitHub_Blob","text":"# 백준 설탕배달 Java\n\n- Title : 백준 설탕배달 Java\n- Date : 2019-12-09\n- Category: 알고리즘 풀이\n\n# 문제 설명\n\n상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.\n\n상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.\n\n상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.\n\n**입력**  \n첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)\n\n**출력**  \n상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.\n\n# 내 풀이\n\n최소 개수의 봉지를 구해야해서 5킬로그램 봉지부터 계산한다.\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tSystem.out.println(Solution(N));\n\t}\n\n\tpublic static int Solution(int N) {\n\t\tint c = N / 5;\n\t\tint r = N % 5;\n\t\twhile (c >= 0 && r > 0) {\n\t\t\tif (r % 3 == 0) {\n\t\t\t\tc += r/3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc--;\n\t\t\tr += 5;\n\t\t}\n\t\tif (c < 0) return -1;\n\t\treturn c;\n\t}\n}\n```\n"}},{"name":"2019-12-09-algorithm-8.md","oid":"38350bdf91fec2dfe882ccaa625590845647701f","content":{"__typename":"GitHub_Blob","text":"# 백준 벌집 Java\n\n- Title : 백준 벌집 Java\n- Date : 2019-12-09\n- Category: 알고리즘 풀이\n\n# 문제 설명\n\n(https://www.acmicpc.net/problem/2292)[https://www.acmicpc.net/problem/2292]\n\n# 내 풀이\n\n규칙을 찾아보았다.\n\n- 1 (1개) => 1칸\n- 2 ~ 7 (6개) => 2칸\n- 8 ~ 19 (12개) => 3칸\n- 20 ~ 37 (18개) => 4칸\n\n즉, 방의 수를 1부터 6\\*count(1,2,3..) 값을 누적시켰을 때 방의 수가 N보다 크거나 같아지는 순간이 답이 된다.\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tSystem.out.println(Solution(N));\n\t}\n\n\tpublic static int Solution(int N) {\n\t\tint room = 1;\n\t\tint count = 1;\n\t\twhile (N > room) {\n\t\t\troom += 6 * (count++);\n\t\t}\n\t\treturn count;\n\t}\n}\n```\n"}},{"name":"2019-12-10-algorithm-10.md","oid":"5912e74405510659e7c8587081bb3e7ed7afe56f","content":{"__typename":"GitHub_Blob","text":"# 백준 분수찾기 Java\n\n- Title : 백준 분수찾기 Java\n- Date : 2019-12-10\n- Category: 알고리즘 풀이\n\n# 문제\n\n[분수찾기](https://www.acmicpc.net/problem/1193)\n\n# 내 풀이\n\n자세히 살펴보면 다음과 같은 규칙이 있다.\n\n1/1 => 1 layer (이 라인에서 제일 큰 번호 : 1)  \n1/2 2/1 => 2 layer (이 라인에서 제일 큰 번호 : 3)  \n3/1 2/2 1/3 => 3 layer (이 라인에서 제일 큰 번호 : 6)  \n1/4 2/3 3/2 4/1 => 4 layer (이 라인에서 제일 큰 번호 : 10)  \n5/1 4/2 3/3 2/4 1/5 => 5 layer (이 라인에서 제일 큰 번호 : 15)\n\n- x layer에는 x 개의 분수가 있다.\n- x layer에서 제일 큰 번호는 1 + 2 + 3 + ... + x 이다. 즉 x \\* (x + 1) / 2\n- layer 번호가 짝수면, 제일 큰 번호의 분수를 기준으로 분자는 -1, 분모는 +1 을 한다.\n- layer 번호가 홀수면, 제일 큰 번호의 분수를 기준으로 분자는 +1, 분모는 -1 을 한다.\n\n위의 규칙을 이용하여 입력 N이 있는 layer와 그 layer의 제일 큰 번호를 찾고 layer의 홀/짝 여부를 통해 분자, 분모를 1 빼거나 더하면 된다.\n\n```java\nimport java.util.Scanner;\n\npublic class P1193 {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tSystem.out.println(Solution(N));\n\t}\n\n\tpublic static String Solution(int N) {\n\t\tint a = 1, b = 1;\n\t\tint num = 1, number = 1;\n\t\tint r = 0;\n\t\tint[] cal_a = {-1, 1};\n\t\tint[] cal_b = {1, -1};\n\n\t\twhile (number < N) {\n\t\t\tnum++;\n\t\t\tnumber += num;\n\n\t\t}\n\t\tr = num % 2;\n\t\tif (r == 0) a = num;\n\t\telse b = num;\n\n\t\twhile (number != N) {\n\t\t\ta += cal_a[r];\n\t\t\tb += cal_b[r];\n\t\t\tnumber--;\n\n\t\t}\n\t\treturn a+\"/\"+b;\n\t}\n}\n```\n"}},{"name":"2019-12-10-algorithm-11.md","oid":"89b4b04fdaaaba7ac8398bcb75f2e244f029debb","content":{"__typename":"GitHub_Blob","text":"# 백준 2869 달팽이는 올라가고 싶다 Java\n\n- Title : 백준 2869 달팽이는 올라가고 싶다 Java\n- Date : 2019-12-10\n- Category: 알고리즘 풀이\n\n# 문제\n\n[달팽이는 올라가고 싶다](https://www.acmicpc.net/step/8)\n\n# 내 풀이\n\n하루에 a 만큼 올라가고 b 만큼 내려오므로 하루에 a-b 만큼 막대기에 올라가는 거와 같다. 정상에 도착하면 내려가지않으므로 c-a를 한다. (c-a) / (a-b) 의 값을 올림한 것이 소요된 일 수 이며 c-a를 했으므로 구한 값에 1을 더하면 된다.\n\n```java\nimport java.util.Scanner;\n\npublic class P2869 {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tSystem.out.println(Solution(a, b, c));\n\t}\n\n\tpublic static int Solution(double a, double b, double c) {\n\t\treturn (int) Math.ceil((c-a)/(a-b)) + 1;\n\n\t}\n}\n```\n"}},{"name":"2019-12-10-algorithm-9.md","oid":"148bb6e841674fd68d22916f49323b344c33e005","content":{"__typename":"GitHub_Blob","text":"# 프로그래머스 기지국 설치 javascript\n\n- Title : 프로그래머스 기지국 설치 javascript\n- Date : 2019-12-10\n- Category: 알고리즘 풀이\n\n# 문제\n\n[프로그래머스 기지국 설치](https://programmers.co.kr/learn/courses/30/lessons/12979)\n\n아파트의 개수 N, 현재 기지국이 설치된 아파트의 번호가 담긴 1차원 배열 stations, 전파의 도달 거리 W가 매개변수로 주어질 때, 모든 아파트에 전파를 전달하기 위해 증설해야 할 기지국 개수의 최솟값을 리턴하는 solution 함수를 완성하는 문제다.\n\n# 내 풀이\n\n떠올린 아이디어는 현재 설치된 기지국의 영향이 끼치는 곳에서 범위를 잘라주는 방식이었다.\n\n예를 들어 다음과 같이 초기 아파트의 상태가 있다면<br/>\n![1](/assets/images/2019-12-10-img/p1-1.png) <br/>\n![1](/assets/images/2019-12-10-img/p1-1-1.png) <br/>\n과 같이 분할을 한다.\n\n이 경우도 마찬가지다. <br/>\n![1](/assets/images/2019-12-10-img/p1-2-1.png) <br/>\n![1](/assets/images/2019-12-10-img/p1-2-1.png) <br/>\n\n```javascript\nfunction solution(n, stations, w) {\n  var answer = 0;\n  let s = 1;\n  const func = (s, e) => {\n    if (s > e) return;\n    answer++;\n    func(s + w + w + 1, e);\n  };\n  for (let i = 0; i < stations.length; i++) {\n    func(s, stations[i] - w - 1);\n    s = stations[i] + w + 1;\n  }\n  func(s, n);\n  return answer;\n}\n```\n\n# 다른 사람 풀이\n\n재귀 쓸 필요 없이 해당 범위 크기를 (2\\*w) + 1로 나눈 후 올림한 값을 구하면 그 범위 내 기지국 개수를 알아 낼 수 있다.\n\n```javascript\nfunction solution(n, stations, w) {\n  var answer = 0;\n  let s = 0;\n  for (var i = 0; i < stations.length; i++) {\n    var r = stations[i] - w - 1;\n    answer += Math.ceil((r - s) / (2 * w + 1));\n    s = stations[i] + w;\n  }\n  answer += Math.ceil((n - s) / (2 * w + 1));\n  return answer;\n}\n```\n"}},{"name":"2019-12-30-algorithm-12.md","oid":"badecf2a1d8b27736ed2d861abdb95aeffc07070","content":{"__typename":"GitHub_Blob","text":"# 프로그래머스 - lv3 네트워크, lv2 짝지어 제거하기\n\n- Title : 프로그래머스 - lv3 네트워크, lv2 짝지어 제거하기\n- Date : 2019-12-30\n- Category: 알고리즘 풀이\n\n# # LV3 네트워크\n\n각 행을 순회해서 컬럼 값이 1일 때, 해당 col을 row로 하여 또 순회하는 식으로 해결했다.\n\n```javascript\nfunction solution(n, computers) {\n  var answer = 0;\n  var arr = [];\n  arr = computers.reduce((acc, cur) => {\n    acc.push(cur.includes(1));\n    return acc;\n  }, []);\n\n  for (let i = 0; i < n; i++) {\n    if (arr[i]) {\n      dfs(i);\n      answer++;\n    }\n  }\n\n  function dfs(row) {\n    if (!arr[row]) return;\n    arr[row] = false;\n    for (let i = 0; i < n; i++) {\n      if (computers[row][i] > 0) {\n        computers[row][i] = 0;\n        dfs(i);\n      }\n    }\n  }\n\n  return answer;\n}\n```\n\n# # lv2 짝지어 제거하기\n\n스택을 생각해냈으면 쉽게 해결할 수 있다.\n\n```javascript\nfunction solution(s) {\n  var stack = [];\n  stack.push(s[0]);\n  for (let i = 1; i < s.length; i++) {\n    if (stack[stack.length - 1] === s[i]) stack.pop();\n    else stack.push(s[i]);\n  }\n  return stack.length ? 0 : 1;\n}\n```\n"}},{"name":"2020-01-28-algorithm-13.md","oid":"6c5737bcef4046d74738a7a56d218a7a8c80d728","content":{"__typename":"GitHub_Blob","text":"# 백준 - 16235 나무 재테크(C++)\n\n- Title : 백준 - 16235 나무 재테크(C++)\n- Date : 2020-01-28\n- Category: 알고리즘 풀이\n\n# 나무 재테크\n\n- 각 계절을 구현하는 데는 어려움이 없었으나 처음에 벡터 하나에 나무를 다 저장하고 매번 sort를 해서 시간 초과가 발생했었다.\n- 고민하다가 각 칸마다 deque에 나무 나이를 담는 식으로 바꿨다.\n- vector가 아닌 deque를 선택한 건 가을(번식)때 생성되는 나무는 나이가 1이므로 맨 앞에 추가되어야하기 때문이다.\n- vector는 배열이라 맨 앞 추가할 때 O(N)의 시간복잡도가 발생한다.\n- deque로 바꿨기에 처음 1번만 sort를 사용하여 효율성을 높였다.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <deque>\nusing namespace std;\n\n#define MAX 10\n\nint N, M, K;\nint A[MAX][MAX]; // 로봇 양분\nint L[MAX][MAX]; // 땅\ndeque<int> T[MAX][MAX]; // 각 땅의 나무 나이\n\nvoid addTree(int r, int c){\n\tif (r < 0 || c < 0 || r >= N || c >= N) return;\n\tT[r][c].push_front(1);\n}\n\nint main() {\n\tint x, y, age;\n\tscanf(\"%d %d %d\", &N, &M, &K);\n\n\tfor (int i=0; i<N; i++) {\n\t\tfor (int j=0; j<N; j++) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t\tL[i][j] = 5;\n\t\t}\n\t}\n\tfor (int i=0; i<M; i++) {\n\t\tscanf(\"%d %d %d\", &x, &y, &age);\n\t\tT[--x][--y].push_back(age);\n\t}\n\n\tfor (int i=0; i<N; i++) {\n\t\tfor (int j=0; j<N; j++) {\n\t\t\tif (T[i][j].size() > 1) {\n\t\t\t\tsort(T[i][j].begin(), T[i][j].end());\n\t\t\t}\n\t\t}\n\t}\n\n\tbool flag;\n\twhile(K-- > 0) {\n\n\t\t// 같은 칸이면 어린 순으로 나이만큼 양분먹고 나이 증가\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tdeque<int> &tmp = T[i][j];\n\t\t\t\tflag = true;\n\t\t\t\tfor(auto iter=tmp.begin(); iter != tmp.end();) {\n\t\t\t\t\tint &t = *iter;\n\t\t\t\t\tif (L[i][j] >= t && flag) {\n\t\t\t\t\t\tL[i][j] -= t;\n\t\t\t\t\t\tt += 1;\n\t\t\t\t\t\titer++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t// 여름 처리\n\t\t\t\t\t\tL[i][j] += t / 2;\n\t\t\t\t\t\titer = tmp.erase(iter);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\t// 나이 5의 배수 나무 번식\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tdeque<int> &tmp = T[i][j];\n\t\t\t\tfor(auto iter=tmp.begin(); iter != tmp.end(); iter++) {\n\t\t\t\t\tint t = *iter;\n\t\t\t\t\tif (t % 5 == 0) {\n\t\t\t\t\t\taddTree(i - 1, j - 1);\n\t\t\t\t\t\taddTree(i - 1, j);\n\t\t\t\t\t\taddTree(i - 1, j + 1);\n\t\t\t\t\t\taddTree(i, j - 1);\n\t\t\t\t\t\taddTree(i, j + 1);\n\t\t\t\t\t\taddTree(i + 1, j - 1);\n\t\t\t\t\t\taddTree(i + 1, j);\n\t\t\t\t\t\taddTree(i + 1, j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 로봇이 양분 추가\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tL[i][j] += A[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i=0; i<N; i++) {\n\t\tfor (int j=0; j<N; j++) {\n\t\t\tans += T[i][j].size();\n\t\t}\n\t}\n\tprintf(\"%d\", ans);\n\n\treturn 0;\n}\n```\n"}},{"name":"2020-01-28-algorithm-14.md","oid":"d79c410b05d91234e7105209de7dcf5c278166bf","content":{"__typename":"GitHub_Blob","text":"# 백준 - 17143 낚시왕(C++)\n\n- Title : 백준 - 17143 낚시왕(C++)\n- Date : 2020-01-28\n- Category: 알고리즘 풀이\n\n# 낚시왕\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\nusing namespace std;\n\nstruct Shark\n{\n\tint r;\n\tint c;\n\tint s; // 속력\n\tint d; // 이동\n\tint z; // 크기\n};\n\nint main() {\n\tint R, C, M;\n\tint r, c, s, d, z;\n\tmap<int, Shark> sharkmap; // 상어정보들 [크기, 정보구조체]\n\tmap<int, Shark>::iterator it;\n\tint row[5] = {0, -1, 1, 0, 0}; // 1:위, 2:아래, 3: 오른쪽, 4:왼쪽\n\tint col[5] = {0, 0, 0, 1, -1};\n\tint ans = 0;\n\n\tscanf(\"%d %d %d\", &R, &C, &M);\n\tint arr[R+1][C+1] = {0};\n\tint arrtmp[R+1][C+1] = {0};\n\tfor (int i=0; i<M; i++) {\n\t\tscanf(\"%d %d %d %d %d\", &r, &c, &s, &d, &z);\n\t\tarr[r][c] = z;\n\t\tShark tmp = {r, c, s, d, z};\n\t\tsharkmap.insert(make_pair(z, tmp));\n\t}\n\n\n\tint nr, nc, nd, move;\n\tfor (int i=1; i<=C; i++) {\n\n\n\t\t// 상어잡기\n\t\tfor (int j=1; j<=R; j++) {\n\t\t\tif (arr[j][i] > 0) {\n\t\t\t\tsharkmap.erase(arr[j][i]);\n\t\t\t\tans += arr[j][i];\n\t\t\t\tarr[j][i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// 상어이동\n\t\tfor(it=sharkmap.begin(); it != sharkmap.end(); it++) {\n\t\t\tShark &shark = it -> second;\n\t\t\t// 오른쪽, 왼쪽\n\t\t\tif (shark.d == 3 || shark.d == 4) {\n\t\t\t\tmove = shark.s % ((C-1)*2);\t// 실제 이동해야할 MOVE\n\t\t\t\tnc = shark.c;\n\t\t\t\tnd = shark.d;\n\t\t\t\twhile (move > 0) {\n\t\t\t\t\tif (nc == 1) nd = 3;\n\t\t\t\t\telse if (nc == C) nd = 4;\n\t\t\t\t\tnc += col[nd];\n\t\t\t\t\tmove--;\n\t\t\t\t}\n\t\t\t\tshark.d = nd;\n\t\t\t\tshark.c = nc;\n\t\t\t}\n\t\t\t// 위, 아래\n\t\t\telse if (shark.d == 1 || shark.d == 2) {\n\t\t\t\tmove = shark.s % ((R-1)*2);\t// 실제 이동해야할 MOVE\n\t\t\t\tnr = shark.r;\n\t\t\t\tnd = shark.d;\n\t\t\t\twhile (move > 0) {\n\t\t\t\t\tif (nr == 1) nd = 2;\n\t\t\t\t\telse if (nr == R) nd = 1;\n\t\t\t\t\tnr += row[nd];\n\t\t\t\t\tmove--;\n\t\t\t\t}\n\t\t\t\tshark.d = nd;\n\t\t\t\tshark.r = nr;\n\t\t\t}\n\t\t\t// 상어 먹기\n\t\t\tif (arrtmp[shark.r][shark.c] < shark.z) {\n\t\t\t\tif (arrtmp[shark.r][shark.c] > 0)\n\t\t\t\t\tsharkmap.erase(arrtmp[shark.r][shark.c]);\n\n\t\t\t\tarrtmp[shark.r][shark.c] = shark.z;\n\n\t\t\t} else sharkmap.erase(shark.z);\n\n\n\t\t}\n\n\t\tfor (int j=1; j<=R; j++) {\n\t\t\tfor (int k=1; k<=C; k++) {\n\t\t\t\tarr[j][k] = arrtmp[j][k];\n\t\t\t\tarrtmp[j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\", ans);\n\n\treturn 0;\n}\n```\n"}},{"name":"2020-01-29-algorithm-15.md","oid":"74f84e9d20d88dabd2edfd88b79237bc44153e4a","content":{"__typename":"GitHub_Blob","text":"# 백준 - 17142 연구소3(C++)\n\n- Title : 백준 - 17142 연구소3(C++)\n- Date : 2020-01-29\n- Category: 알고리즘 풀이\n\n## 입력 받기\n\n- 연구소 상태는 N x N 이니깐 int A[N][n] 형태로 입력을 저장해야겠다.\n- 입력을 받을 때, 선택 가능한 바이러스들(값이 2인)의 row, col 값을 따로 저장할 필요가 있겠네. pair<int, int> V[10] 형태로 저장해야겠다. 바이러스 개수는 최대 10이니깐 배열의 크기는 10으로 하자.\n- 퍼트릴 수 있는 빈 칸의 개수도 카운트 해놓자. 그래야 모든 빈칸에 바이러스를 퍼트렸는 지 알 수 있으니깐.\n- 아! 퍼트린 후 연구소 상태를 원상 복귀해야하니깐 int TMP[N][n] 형태의 2차원 배열을 만들어놔야지.\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nint main() {\n  int A[50][50]; // 연구소\n  int TMP[50][50]; // 연구소 결과 처리용\n  int N, M; // N: 연구소 크기, M: 활성화할 바이러스 수\n  int tcnt = 0; // 연구소 빈칸(0)의 개수\n  pair<int, int> V[10]; // 연구소 선택 가능한 바이러스(2)의 위치\n  int vcnt = 0; // V 배열을 위한 인덱스\n  int prow[4] = {-1, 1, 0, 0}; // 상하좌우 확산 시 사용 row\n  int pcol[4] = {0, 0, -1, 1}; // 상하좌우 확산 시 사용 col\n\n  // 입력받기\n  scanf(\"%d %d\", &N, &M);\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n      TMP[i][j] = A[i][j];\n      if (A[i][j] == 2) V[vcnt++] = make_pair(i, j);\n      if (A[i][j] == 0) tcnt++;\n    }\n  }\n}\n```\n\n## 활성화할 바이러스 선택하기\n\n- DFS로 할 수도 있지만 비트 마스크로 풀어봐야지\n- 만약 5개의 바이러스 중 3개를 선택해야한다면 범위는 00111 ~ 11100 이다.\n- 근데 사실, DFS로 하는 게 코드가 간단해서... DFS가 나을 듯,, 비트 마스크로 풀다가 실수를 너무 많이 했다.\n\n```cpp\n  unsigned int flag = (1 << M) - 1; // 시작 플래그, unsigned int는 양수 범위를 가짐\n  int tcc = M;\n  unsigned int fin = 0; // 종료 플래그\n  // 종료 플래그 만들기.\n  while (tcc-- > 0) {\n    fin |= (1 <<  (vcnt - 1 - tcc));\n  }\n  unsigned int curflag = 0; // 조작용\n  int fcnt = 0;\n  int pos = 0;\n  queue<pair<int, int> > q;\n  // 시작플래그 ~ 종료플래그\n  for (flag; flag<=fin; flag++) {\n    curflag = flag;\n    fcnt = 0;\n    // 1비트 개수 세기, M개 일때만 코드 진행\n    while (curflag > 0) {\n      if (curflag & 1 == 1) fcnt++;\n      if (fcnt > M) break;\n      curflag = curflag >> 1;\n    }\n    if (fcnt != M) continue;\n\t\t// 이제 고른 바이러스 표시하기\n    curflag = flag;\n    pos = 0;\n    while (curflag > 0) {\n      if (curflag & 1 == 1) {\n        TMP[V[pos].first][V[pos].second] = -1; // 바이러스 복제\n        // 큐에 선택한 바이러스 넣기 -> 퍼트리기에서 BFS로 사용할 예정\n        q.push(make_pair(V[pos].first, V[pos].second));\n      }\n      pos++;\n      curflag = curflag >> 1;\n    }\n    // ...바이러스 퍼트리기가 이어진다.\n  }\n```\n\n## 바이러스 퍼트리기\n\n- 만약 백준에서 제출 시 100%에서 틀린다면 비활성화 바이러스도 시간 체크했는 지 살펴봐야한다.\n  여기서 엄청 헤매서 시간 다 잡아먹었다ㅠㅠ\n- 쉽게 설명하자면 대부분 BFS로 q가 빌 때까지 반복을 돌릴텐데 만약 이미 빈칸(0)에는 다 전파했는 데 q에 비활성화(선택 못 받은 바이러스)가 있다면? 이 상황을 이해한다면 오류를 잡을 수 있을 거다.\n  > 반례가 있어야 이해가 되겠죠?  \n  > 5 1  \n  > 1 1 1 1 1  \n  > 1 1 1 1 1  \n  > 1 1 1 1 1  \n  > 2 0 0 2 0  \n  > 1 1 1 1 1  \n  > answer : 2\n- 사실 q에 시간 체크용 값도 넣어버려서.. 복잡하게 풀어버린 것 같다..\n- 더 간단히 풀 수 있을 듯..\n\n```cpp\n  // ..위에는 바이러스 선택하기\n  // 시간 체크용, 현재 q에는 선택된 바이러스가 있고 얘는 0초이므로 0을 넣어준다. -1은 구분 용\n  q.push(make_pair(-1, 0));\n  spread = 0; // 퍼진 바이러스\n  time = 0; // 시간\n  stopflag = false; // 빈칸에 다 퍼트렸으면 true로 바꿀거다.\n  while (!q.empty()) {\n    // c++에서 q.pop()은 void 메소드라서 q.front()로 값 가져온다.\n    pair<int, int> po = q.front();\n    q.pop();\n    if (po.first >= 0) { // 퍼트린 칸이면\n      if (A[po.first][po.second] == 0) spread++; // 해당 칸이 원래 빈칸(0)이면 값 증가\n      if (spread == tcnt) stopflag = true; // 빈칸에 다 퍼트리면 시간체크용 값 나올 때 스탑하려고\n      for (int i=0; i<4; i++) { // 상하좌우 처리\n        nextrow = po.first + prow[i];\n        nextcol = po.second + pcol[i];\n        if (nextrow < 0 || nextrow >= N || nextcol < 0 || nextcol >= N) continue; // 범위 밖\n        if (TMP[nextrow][nextcol] == -1 || TMP[nextrow][nextcol] == 1) continue;\n        q.push(make_pair(nextrow, nextcol)); // 큐에 넣자넣자!\n        TMP[nextrow][nextcol] = -1; // 퍼트렸다는(방문했다는) 표시!\n      }\n    } else { // 시간체크용\n      time = po.second;\n      if (!q.empty()) q.push(make_pair(-1, po.second + 1));\n      if (stopflag) break; // 이미 모든 빈칸에 퍼트렸으면 나오자!\n    }\n  }\n  while (!q.empty()) // 위 반복에서 stopflag에 의해 중간에 빠져나왔을 경우를 대비해서\n  {\n    q.pop();\n  }\n  // 시간 넣자!!\n  if (spread == tcnt && ans > time) ans = time;\n```\n\n## 원상복귀\n\n- TMP는 또 써야하니깐!\n\n```cpp\nfor (int i=0; i<N; i++) {\n  for (int j=0; j<N; j++) {\n    TMP[i][j] = A[i][j];\n  }\n}\n```\n\n## 전체 코드\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <limits>\nusing namespace std;\n\n\nint A[50][50];\nint TMP[50][50];\nint N, M;\nint vcnt = 0;\nint tcnt = 0;\npair<int, int> V[10];\nint prow[4] = {-1, 1, 0, 0};\nint pcol[4] = {0, 0, -1, 1};\n\nint main() {\n  // 입력받기\n  scanf(\"%d %d\", &N, &M);\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n      TMP[i][j] = A[i][j];\n      if (A[i][j] == 2) V[vcnt++] = make_pair(i, j);\n      if (A[i][j] == 0) tcnt++;\n    }\n  }\n  unsigned int flag = (1 << M) - 1; // 시작 플래그, unsigned int는 양수 범위를 가짐\n  int tcc = M;\n  unsigned int fin = 0; // 종료 플래그\n  // 종료 플래그 만들기.\n  while (tcc-- > 0) {\n    fin |= (1 <<  (vcnt - 1 - tcc));\n  }\n  unsigned int curflag = 0; // 조작용\n  int fcnt = 0;\n  int pos = 0;\n  int nextrow = 0, nextcol = 0;\n  queue<pair<int, int> > q;\n  int spread = 0, time = 0;\n  int ans = numeric_limits<int>::max();\n  bool stopflag = false;\n  // 시작플래그 ~ 종료플래그\n  for (flag; flag<=fin; flag++) {\n    curflag = flag;\n    fcnt = 0;\n    // 1비트 개수 세기, M개 일때만 코드 진행\n    while (curflag > 0) {\n      if (curflag & 1 == 1) fcnt++;\n      if (fcnt > M) break;\n      curflag = curflag >> 1;\n    }\n    if (fcnt != M) continue;\n\t\t// 이제 고른 바이러스 표시하기\n    curflag = flag;\n    pos = 0;\n    while (curflag > 0) {\n      if (curflag & 1 == 1) {\n        TMP[V[pos].first][V[pos].second] = -1; // 바이러스 복제\n        // 큐에 선택한 바이러스 넣기 -> 퍼트리기에서 BFS로 사용할 예정\n        q.push(make_pair(V[pos].first, V[pos].second));\n      }\n      pos++;\n      curflag = curflag >> 1;\n    }\n    q.push(make_pair(-1, 0));\n    spread = 0; // 퍼진 바이러스\n    time = 0; // 시간\n    stopflag = false; // 빈칸에 다 퍼트렸으면 true로 바꿀거다.\n    while (!q.empty()) {\n      // c++에서 q.pop()은 void 메소드라서 q.front()로 값 가져온다.\n      pair<int, int> po = q.front();\n      q.pop();\n      if (po.first >= 0) { // 퍼트린 칸이면\n        if (A[po.first][po.second] == 0) spread++; // 해당 칸이 원래 빈칸(0)이면 값 증가\n        if (spread == tcnt) stopflag = true; // 빈칸에 다 퍼트리면 시간체크용 값 나올 때 스탑하려고\n        for (int i=0; i<4; i++) { // 상하좌우 처리\n          nextrow = po.first + prow[i];\n          nextcol = po.second + pcol[i];\n          if (nextrow < 0 || nextrow >= N || nextcol < 0 || nextcol >= N) continue; // 범위 밖\n          if (TMP[nextrow][nextcol] == -1 || TMP[nextrow][nextcol] == 1) continue;\n          q.push(make_pair(nextrow, nextcol)); // 큐에 넣자넣자!\n          TMP[nextrow][nextcol] = -1; // 퍼트렸다는(방문했다는) 표시!\n        }\n      } else { // 시간체크용\n        time = po.second;\n        if (!q.empty()) q.push(make_pair(-1, po.second + 1));\n        if (stopflag) break; // 이미 모든 빈칸에 퍼트렸으면 나오자!\n      }\n    }\n    while (!q.empty()) // 위 반복에서 stopflag에 의해 중간에 빠져나왔을 경우를 대비해서\n    {\n      q.pop();\n    }\n    // 시간 넣자!!\n    if (spread == tcnt && ans > time) ans = time;\n    for (int i=0; i<N; i++) {\n      for (int j=0; j<N; j++) {\n        TMP[i][j] = A[i][j];\n      }\n    }\n  }\n  if (ans == numeric_limits<int>::max()) ans = -1;\n  printf(\"%d\", ans);\n  return 0;\n}\n```\n"}},{"name":"2020-01-30-algorithm-16.md","oid":"16dcace2ef64f8366920a452156651609248244b","content":{"__typename":"GitHub_Blob","text":"# 백준 - 17837 새로운 게임2(C++)\n\n- Title : 백준 - 17837 새로운 게임2(C++)\n- Date : 2020-01-30\n- Category: 알고리즘 풀이\n\n## 생각의 흐름\n\n- 자료구조는 뭘 사용해야하지?\n- 체스는 구조체로 정의해서 배열로 저장해야겠고.. 보드판 각 칸마다 어떤 체스가 순서대로 있는 지를 표현해야하는 데.. 어떤 걸 사용할까?\n- 앞, 뒤로 pop, push 하고 싶으니깐 deque를 사용해보자..!\n  > 다 푼 후,.. <br/>\n  > 근데.. 다른 사람들 코드를 보니깐 vector를 사용했던 데 나중에 살펴봐야겠다..\n- 구조체 배열을 받을 때는 &를 사용한 참조변수를 사용하자! 그래야 수정도 가능하니깐!\n- A말이 위치한 체스칸의 큐에서 뒤부터 하나씩 빼야겠다. 단, A가 나올 때까지만!\n- 그 다음 뺀 거를 가지고 A말이 이동할 체스칸에 push_back을 해줘야겠지..?\n- 빨간색은 반대로 넣어줘야하니깐 pop_front, pop_back을 적절히 활용해봐야겠다..\n\n```cpp\n#include <iostream>\n#include <deque>\nusing namespace std;\n\nstruct Horse {\n int row, col, dir;\n};\n\nint N, K;\nint prow[4] = {0, 0, -1, 1}; //우,좌,상,하\nint pcol[4] = {1, -1, 0, 0};\n\nHorse horse[10];\nint color[12][12];\ndeque<int> board[12][12];\n\nvoid input() {\n scanf(\"%d %d\", &N, &K);\n\n for (int i=0; i<N; i++) {\n  for (int j=0; j<N; j++) {\n   scanf(\"%d\", &color[i][j]);\n  }\n }\n\n for (int i=0; i<K; i++) {\n  scanf(\"%d %d %d\", &horse[i].row, &horse[i].col, &horse[i].dir);\n  horse[i].row--, horse[i].col--, horse[i].dir--;\n  board[horse[i].row][horse[i].col].push_back(i);\n }\n}\n\nbool move(int k) {\n Horse &h = horse[k];\n int nextrow = h.row + prow[h.dir];\n int nextcol = h.col + pcol[h.dir];\n\n // 범위 밖 or 파란색\n if ((nextrow < 0 || nextcol < 0 || nextrow >= N || nextcol >= N) || color[nextrow][nextcol] == 2) {\n  // 방향 반대로\n  switch(h.dir) {\n   case 0:\n    h.dir = 1;\n    break;\n   case 1:\n    h.dir = 0;\n    break;\n   case 2:\n    h.dir = 3;\n    break;\n   case 3:\n    h.dir = 2;\n    break;\n   default: break;\n  }\n  nextrow = h.row + prow[h.dir];\n  nextcol = h.col + pcol[h.dir];\n\n  if ((nextrow < 0 || nextcol < 0 || nextrow >= N || nextcol >= N) || color[nextrow][nextcol] == 2)\n   return false;\n }\n\n deque<int> &q = board[h.row][h.col];\n deque<int> tmpq;\n int tmpk;\n while (!q.empty()) {\n  tmpk = q.back();\n  // k말 좌표 이동\n  horse[tmpk].row = nextrow;\n  horse[tmpk].col = nextcol;\n\n  // 원래 큐에서 이동할 말들 빼기\n  tmpq.push_front(tmpk);\n  q.pop_back();\n\n  if (tmpk == k) break;\n }\n deque<int> &nextq = board[nextrow][nextcol];\n // 다음 이동칸이 흰색\n if (color[nextrow][nextcol] == 0) {\n  while (!tmpq.empty()) {\n   nextq.push_back(tmpq.front());\n   tmpq.pop_front();\n  }\n } else if (color[nextrow][nextcol] == 1) { // 빨간(순서 반대로)\n  while (!tmpq.empty()) {\n   nextq.push_back(tmpq.back());\n   tmpq.pop_back();\n  }\n }\n if (nextq.size() >= 4) return true;\n else return false;\n}\n\nint main() {\n int ans = 0;\n int i;\n input();\n while (ans++ < 1000) {\n  for (i=0; i<K; i++) {\n   if (move(i)) break;\n  }\n  if (i < K) break;\n }\n\n if (ans > 1000) ans = -1;\n printf(\"%d\", ans);\n return 0;\n}\n```\n"}},{"name":"2020-01-31-algorithm-17.md","oid":"743834917aab9e696c3a64fdc6a0a3dd281ebb68","content":{"__typename":"GitHub_Blob","text":"# 백준 - 17779 게리멘더링2(C++)\n\n- Title : 백준 - 17779 게리멘더링2(C++)\n- Date : 2020-01-31\n- Category: 알고리즘 풀이\n\n## 생각의 흐름\n\n- x, y, d1, d2를 정해야되서 4중 포문을 써야지.. 시간 초과가 나려나.. 일단 해본 후에 최적화하자 --> 시간 초과 발생하지 않음\n\n```cpp\n#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint N;\nint total = 0;\nint A[21][21]; // 인풋용\nint C[21][21]; // 각 구역 표시 용도\nint S[6] ={0, 0, 0, 0, 0, 0}; // 1~5 구역 인구수 합 표시\nint prow[4] = {1, -1, 0, 0};\nint pcol[4]= {0, 0, -1, 1};\nint ans = 40001;\n\n// 구역 그리기\nvoid dfs(int sx, int sy, int ex, int ey, int area) {\n // 좌표가 범위 밖인 경우\n if (sx < 1 || sy < 1 || sx > ex || sy > ey) return;\n if (C[sx][sy] > 0) return; // 이미 다른 구역인 경우\n S[area] += A[sx][sy]; // 인구 수 더하기\n C[sx][sy] = area; // 구역 방문했다는 표시\n for (int i=0; i<4; i++) { // 상하좌우\n  dfs(sx + prow[i], sy + pcol[i], ex, ey, area);\n }\n}\nvoid dividearea(int x, int y, int d1, int d2) {\n int tx, ty;\n memset(C, 0, sizeof(C));\n memset(S, 0, sizeof(S));\n\n /* 경계선 그리기 */\n // 경계선 1, 4번 조건\n for (tx=x, ty=y; tx<=x+d1 && ty>=y-d1; tx++, ty--) {\n  C[tx][ty] = 5, C[tx+d2][ty+d2] = 5;\n  S[5] += A[tx][ty] + A[tx+d2][ty+d2];\n }\n // 경계선 2, 3번 조건\n for (tx=x, ty=y; tx<=x+d2 && ty<=y+d2; tx++, ty++) {\n  C[tx][ty] = 5, C[tx+d1][ty-d1] = 5;\n  S[5] += A[tx][ty] + A[tx+d1][ty-d1];\n }\n\n // 각 구역 인구수 세기\n // 문제에서 주어진 조건대로 시작 좌표와 종료 좌표 입력\n dfs(1, 1, x+d1-1, y, 1); // 1번 구역\n dfs(1, y+1, x+d2, N, 2); // 2번 구역\n dfs(N, 1, N, y-d1+d2-1, 3); // 3번 구역\n dfs(N, N, N, N, 4); // 4번 구역\n\n // 경계선 내부 인구수 계산\n // 위 dfs로 인해 S[]에 인구수 합이 있으므로 얘를 이용하면 경계선 내부 인구 수 알 수 있다.\n int inside= total;\n for (int i=1; i<=5; i++) {\n  inside -= S[i];\n }\n S[5] += inside;\n\n // 최댓값, 최솟값, 정답 구하기\n int largest = 0, smallest = 40001;\n for (int i=1; i<=5; i++) {\n  largest = max(largest, S[i]);\n   smallest = min(smallest, S[i]);\n }\n ans = min(ans, largest - smallest);\n\n}\n\n// x, y, d1, d2 구하기 == 경계썬 구하기\nvoid selectval() {\n int x, y, d1, d2;\n for (x=1; x<=N; x++) {\n  for (y=1; y<=N; y++) {\n   for (d1=1; d1<N; d1++) {\n    for (d2=1; d2<N; d2++) {\n     if (x + d1 + d2 <= N && 1 <= y - d1 && y + d2 <= N) {\n      dividearea(x, y, d1, d2);\n     } else break;\n    }\n   }\n  }\n }\n}\nint main() {\n scanf(\"%d\", &N);\n for (int i=1; i<=N; i++) {\n  for (int j=1; j<=N; j++) {\n   scanf(\"%d\", &A[i][j]);\n   total += A[i][j]; // 나중에 경계선 내부 인구 수 계산할 때 쓰려고 전체 인구수를 저장해놓음\n  }\n }\n selectval();\n printf(\"%d\", ans);\n return 0;\n}\n\n```\n"}},{"name":"2020-03-27-algorithm.md","oid":"cc4c2ba350ff2dcd7d43ee1ce312d69f9c1991b8","content":{"__typename":"GitHub_Blob","text":"# 백준 문제 - 문자열 처리\n\n- Title : [백준] 문자열 처리\n- Date : 2020-03-27\n- Category : 알고리즘 문제 풀기\n\n# Why?\n\nC++ 로 문자열 문제를 풀 때 입출력, 파싱 등 부분에서 막힌다는 생각이 들어서 연습겸 문자열 관련 문제만 풀어보았다. 난이도는 브론즈 정도?\n\n## 11654 아스키 코드\n\n알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하세요.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tchar c;\n    \tcin >> c;\n    \tcout << (int) c;\n    \treturn 0;\n    }\n\n> 'A' 는 65, 'a' 는 97\n\n## 1152 단어의 개수\n\n영어 대소문자와 띄어쓰기만으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \tint ans = 0;\n    \tgetline(cin, str);\n    \tcin.ignore();\n    \t\n    \tfor (int i=0; i<str.size(); i++) {\n    \t\tif (str[i] == ' ') ans++;\n    \t}\n    \t\n    \tif (str[str.size()-1] == ' ') ans--;\n    \tif (str[0] != ' ') ans++;\n    \t\n    \tcout << ans;\n    \treturn 0;\n    }\n\n> 문자열을 공백으로 파싱해야할 때\n\n    #include <iostream>\n    #include <vector>\n    #include <sstream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \t\n    \tgetline(cin, str);\n    \tcin.ignore();\n    \t\n    \tstring buf;\n    \tstringstream ss(str);\n    \tvector<string> tokens;\n    \t\n    \twhile (ss >> buf) {\n    \t\ttokens.push_back(buf);\n    \t}\n    \t\n    \tcout << tokens.size();\t\n    \t\n    \treturn 0;\n    }\n\n> `getline(cin, str)` 로 공백을 포함한 문자열을 입력받을 수 있다. 단, `\\n` 을 포함하지않으므로 버퍼에서 `\\n` 을 제거하기 위해 `cin.ignore()` 을 해야한다.\n\n## 10809 알파벳 찾기\n\n알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \tcin >> str;\n    \tint ans[26];\n    \tfill(&ans[0], &ans[26], -1);\n    \t\n    \tfor (int i=str.size()-1; i>=0; i--) {\n    \t\tint c = (int) str[i];\n    \t\tans[c - 97] = i;\n    \t}\n    \t\n    \tfor (int i=0; i<26; i++) {\n    \t\tcout << ans[i] << ' ';\n    \t}\n    \t\n    \treturn 0;\n    }\n\n## 1157 단어공부\n\n알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tchar str[1000000];\n    \tint cnt[26] = {0};\n    \tint idx = 0, max = 0, maxi = 0;\n    \t\n    \tscanf(\"%s\", str);\n    \t\n    \tfor (int i=0; str[i]; i++) {\n    \t\tif (str[i] < 97) idx = str[i] - 65;\n    \t\telse idx = str[i] - 97;\n    \t\t\n    \t\tcnt[idx]++;\n    \t\tif (cnt[idx] > max) {\n    \t\t\tmax = cnt[idx];\n    \t\t\tmaxi = idx;\n    \t\t} else if (cnt[idx] == max) {\n    \t\t\tmaxi = -1;\n    \t\t}\n    \t}\n    \t\n    \tprintf(\"%c\", maxi == -1 ? '?' : maxi + 65);\n    \t\n    \treturn 0;\n    }\n\n## 2908 상수\n\n상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다. 두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오.\n\n### strcmp로 문자열 비교\n\n    #include <iostream>\n    #include <string.h>\n    using namespace std;\n    \n    int main() {\n    \tchar a[4], b[4];\n    \tscanf(\"%s %s\", a, b);\n    \t\n    \tswap(a[2], a[0]);\n    \tswap(b[2], b[0]);\n    \t\n    \tif (strcmp(a, b) < 0) printf(\"%s\", b);\n    \telse printf(\"%s\", a);\n    \t\n    \treturn 0;\n    }\n\n### atoi로 char * → int로 변경 후 비교\n\n    #include <iostream>\n    #include <string>\n    using namespace std;\n    \n    int main() {\n    \tchar a[4], b[4];\n    \tscanf(\"%s %s\", a, b);\n    \t\n    \tswap(a[2], a[0]);\n    \tswap(b[2], b[0]);\n    \t\n    \tint na = atoi(a);\n    \tint nb = atoi(b);\n    \t\n    \tif (na > nb) printf(\"%d\", na);\n    \telse printf(\"%d\", nb);\n    \t\n    \treturn 0;\n    }\n\n- a, b 값을.. 3으로 했을 때 입력을 제대로 못 받는 문제 생김 ㅜ_ㅜ\n    - c의 문자열은 `\\0` 을 기준으로 구분한다. 문자열의 끝에 있는 `\\0` 이 어떤 식으로든 없어지게 된다면 그 뒤에 `\\0` 이 나타날 때까지 진행하게 된다\n    - 123 456 일 때, a, b 크기를 3으로 하면 a에는 \"123\"이 들어간다. 그럼 `\\0` 은 b[0]에 들어갔을 거다. 이 상태로 456을 입력받으면 b[0]에 4가 쓰여진다. 마찬가지로 b의  `\\0` 도 메모리 어딘가에 들어가게된다.\n    - 즉, a 출력시 123456이 나오는 이유는 123을 입력받을 때 `\\0` 을 받지 못해 456까지 입력받게 되서다."}}]}},{"name":"README.md","type":"blob","posts":{"__typename":"GitHub_Blob"}},{"name":"React","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":"2020-01-07-basic-react.md","oid":"40f40953b7ab43bf93781786a87871d92de6d63c","content":{"__typename":"GitHub_Blob","text":"# React 기반을 다져보자!\n\n- Title : React 기반을 다져보자!\n- Date : 2020-01-07\n- Category: React\n\n<span class=\"clr-grey\">새로 알게 된 내용이 있으면 계속해서 추가할 예정입니다. </span>\n\n> **참조 링크** <br/>\n>\n> - [리액트 공식 문서](https://reactjs-kr.firebaseapp.com/docs/hello-world.html)\n\n# JSX\n\n```javascript\nconst element = <h1>Hello, world</h1>;\nReactDOM.render(\n  element,\n  document.getElementById(\"root\") // ID가 root인 노드에 렌더링하겠다!\n);\n```\n\n- JSX는 화면에서 볼 수 있는 내용에 대한 설명인 <code>React elements</code> 객체를 만든다.\n- 표현식이므로 if문, for 반복, 변수 할당, 매개 변수로 사용 가능하다.\n- Babel은 JSX를 <code>React.createElement()</code> 호출로 컴파일합니다.\n- 리액트 요소는 <code>Immutable Objects</code>라서 한번 만들면 그 자식이나 속성을 변경할 수 없다. UI를 업데이트 하려면 새로운 요소를 만들어서 <code>ReactDOM.render()</code>에 전달해야한다.\n\n> **Note:** <br/>\n> 실제로 대부분의 React 어플리케이션은 ReactDOM.render() 를 한번만 호출한다. -> state를 이용한다.\n\n# 순수 함수란?\n\n순수 함수는 입력을 변경하지않으며 항상 동일한 입력에 대해 동일한 결과를 반환하는 함수다.\n\n**순수 함수**\n\n```javascript\nfunction sum(a, b) {\n  return a + b;\n}\n```\n\n**순수 함수가 아님**\n\n```javascript\nfunction withdraw(account, amount) {\n  account.total -= amount;\n}\n```\n\n# Props\n\n- 부모 컴포넌트에서 자식 컴포넌트로 전달된 데이터다.\n- Props는 읽기전용이므로 수정할 수 없다.\n- 모든 React 컴포넌트는 props와 관련한 동작을 할 때 <code>순수 함수</code>처럼 동작해야한다.\n\n# State\n\n## 1. 클래스 컴포넌트에서 state 사용하기\n\n```javascript\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { date: new Date() };\n  }\n\n  // mounting : Clock 이 DOM에 최초로 렌더링 될 때\n  componentDidMount() {}\n\n  // unmounting : DOM에서 Clock 을 삭제했을 때\n  componentWillUnmount() {}\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(<Clock />, document.getElementById(\"root\"));\n```\n\n## 2. 함수형 컴포넌트에서 state 사용하기\n\n```javascript\nimport React, { useEffect, useState } from \"react\";\n// ...\n\nconst PetSitterApplyContainer = () => {\n  const [current, setCurrent] = useState(0); // 인자는 초기값\n\n  // ...\n\n  // 라이프사이클 훅\n  useEffect(() => {\n    function handleResize() {\n      dispatch(resize(window.innerWidth, window.innerHeight));\n    }\n    window.addEventListener(\"resize\", handleResize);\n  });\n\n  const next = () => {\n    setCurrent(current + 1);\n  };\n\n  const prev = () => {\n    setCurrent(current - 1);\n  };\n\n  return <PetSitterApply current={current} />;\n};\n```\n\n- state는 React 컴포넌트가 유저 액션, 네트워크 응답, 기타 등등에 대한 응답으로 시간 경과에 따라 출력을 변경할 수 있게 한다.\n- State는 로컬이며 캡슐화되어있다 : 부모 컴포넌트나 자식 컴포넌트는 특정 컴포넌트의 state 유무를 알 수 없으며 해당 컴포넌트가 함수나 클래스로 선언되었는 지 알 수 없기 때문\n- <code>componentDidMount() 훅</code> : 컴포넌트 출력이 DOM에 렌더링 된 이후 동작한다.\n- <code>componentWillUnmount() 훅</code> : 컴포넌트가 DOM에서 삭제된 이후 동작한다.\n- <code>useEffect</code> : 리액트 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 설정 할 수 있는 Hook으로 클래스형 컴포넌트의 componentDidMount 와 componentDidUpdate 를 합친 형태다.\n\n## 3. State 바르게 사용하기\n\n- State를 직접 수정하지말기\n\n```javascript\n// Wrong\nthis.state.comment = \"Hello\";\n\n// Correct\nthis.setState({ comment: \"Hello\" });\n```\n\n- this.props 및 this.state가 비동기로 업데이트될 수 있다는 것을 고려하기\n\n```javascript\n// Wrong\nthis.setState({\n  counter: this.state.counter + this.props.increment\n});\n\n// Correct : 이전 state를 인수로 받음\nthis.setState((prevState, props) => ({\n  counter: prevState.counter + props.increment\n}));\n```\n\n# 하향식(top-down) 혹은 단방향(unidirectional) 데이터 흐름\n\n- 모든 state는 항상 특정 컴포넌트가 가지며, 해당 state에서 파생된 모든 데이터 또는 UI는 트리의 컴포넌트 <code>아래(below)</code>에만 영향을 미친다.\n- 컴포넌트는 자신의 state를 자식 컴포넌트에 props 로 내려줄 수 있다. => <code>컴포넌트 트리 == props의 폭포</code>\n\n# Refs\n\n일반적인 리액트 데이터 플로우에서 부모 컴포넌트와 자식 컴포넌트는 <code>props</code>를 통해서만 통신할 수 있어서 자식 컴포넌트를 수정하려면 새로운 <code>props</code>와 함께 다시 렌더링해야한다. 그럼 일반적인 데이터 플로우 밖에서 자식 컴포넌트(컴포넌트 인스턴스 or DOM)에 직접 접근하려면 어떻게 해야할까? <code>Refs</code>를 사용하면 되지만 공식문서에서는 Refs 보다는 state를 이용하기로 권장한다.\n\n```javascript\nclass CustomTextInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.focusTextInput = this.focusTextInput.bind(this);\n  }\n\n  focusTextInput() {\n    // Explicitly focus the text input using the raw DOM API\n    this.textInput.focus();\n  }\n\n  render() {\n    // Use the `ref` callback to store a reference to the text input DOM\n    // element in an instance field (for example, this.textInput).\n    return (\n      <div>\n        <input\n          type=\"text\"\n          ref={input => {\n            this.textInput = input;\n          }}\n        />\n        <input\n          type=\"button\"\n          value=\"Focus the text input\"\n          onClick={this.focusTextInput}\n        />\n      </div>\n    );\n  }\n}\n```\n\n- React는 컴포넌트가 마운트될 때 DOM 요소와 함께 ref 콜백을 호출하며 언마운트될 때 null 과 함께 호출한다. ref 콜백은 componentDidMount 나 componentDidUpdate 라이프사이클 훅 전에 호출된다.\n- ref 속성을 HTML 요소에서 사용하면, ref 콜백은 기본 DOM 요소를 인수로 받는다.\n\n> Refs는 언제 사용하면 좋을까?\n>\n> - input/textarea 포커스 제어, 텍스트 선택, 미디어 재생을 관리할 때\n> - 명령형 애니메이션을 발동시킬 때\n> - 써드 파티 DOM 라이브러리를 통합할 때\n"}},{"name":"2020-01-13-composition.md","oid":"f2c6e1de774cf12c864abb9275a4cfcf910767c3","content":{"__typename":"GitHub_Blob","text":"# 합성으로 컴포넌트에 다른 컴포넌트를 담아보자.\n\n- Title : 합성으로 컴포넌트에 다른 컴포넌트를 담아보자.\n- Date : 2020-01-13\n- Category: React\n\nModals을 만들면서 로그인 모달, 메모 모달 등 기능에 따라 모달 바디에 다른 UI를 보여주고 싶었다. 엘리먼트도 컴포넌트에 전달할 수 있을 까? 라는 의문으로 검색해보니 **Composition**이 나왔다.\n\n# 컴포넌트에 다른 컴포넌트를 담고 싶다면?\n\n## 예시 1\n\n<code>props.children</code>을 사용하여 자식 엘리먼트를 그대로 출력할 수 있다.\n\n```javascript\n// ...\nimport Login from \"./login\"; // 로그인 UI 컴포넌트\nimport ModalCard from \"./modalCard\"; // 모달 컴포넌트\n\nconst Bio = () => {\n  // ...\n  return (\n    <>\n      <ModalCard>\n        <Login />\n      </ModalCard>\n    </>\n  );\n};\n```\n\nModalCard JSX 태그 안에 있는 것들이 아래와 같이 ModalCard 컴포넌트의 children prop으로 전달됩니다.\n\n```javascript\n// ...\nconst ModalCard = props => {\n  return (\n    <>\n      <div className=\"modal is-active\">\n        <div className=\"modal-background\"></div>\n        <div className=\"modal-card\">\n          <header className=\"modal-card-head\">\n            <p className=\"modal-card-title\"></p>\n            <button className=\"delete\" aria-label=\"close\"></button>\n          </header>\n          <section className=\"modal-card-body\">{props.children}</section>\n        </div>\n      </div>\n    </>\n  );\n};\n// ...\n```\n\n## 예시 2\n\nReact에서 prop으로 전달할 수 있는 것에는 제한이 없기 때문에 이렇게도 된다.\n\n```javascript\n// ...\nimport ModalCard from \"./modalCard\"\nimport Login from \"./login\"\n\nconst Bio = () => {\n  // ...\n  return (\n    <>\n      {// ...}\n      <ModalCard headTitle={`Who are you?`} ContentComponent={Login} isActive={isActive}/>\n    </>\n  )\n}\n```\n\n```javascript\n// ...\nconst ModalCard = ({ headTitle, ContentComponent, isActive }) => {\n  return (\n    <>\n      <div className=\"modal\">\n        <div className=\"modal-background\"></div>\n        <div className=\"modal-card\">\n          <header className=\"modal-card-head\">\n            <p className=\"modal-card-title\">{headTitle}</p>\n            <button className=\"delete\" aria-label=\"close\"></button>\n          </header>\n          <section className=\"modal-card-body\">\n            <ContentComponent />\n          </section>\n        </div>\n      </div>\n    </>\n  );\n};\n```\n\n끝!\n"}}]}},{"name":"Typescript","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":"2020-03-08-typescript-variable.md","oid":"eb4eae48978a7e276ad569a852c70fbe692ea9ad","content":{"__typename":"GitHub_Blob","text":"# [타입스크립트] 변수 선언과 타입\n\n- Title : [타입스크립트] 변수 선언과 타입\n- Date : 2020-03-08\n- Category: Typescript\n\n## 1. 변수 선언\n\n**var**\n\n- 호이스팅\n- 함수 레벨 스코프\n\n**let**\n\n- 변수를 초기화하기 전에는 변수에 접근할 수 없게 호이스팅 방지\n- 같은 블록 내에서 같은 이름의 변수 중복 선언 불가\n- 블록 레벨 스코프\n\n**const**\n\n- 호이스팅 안함\n- 블록 레벨 스코프\n- 변수를 상수로 선언할 때 사용(재할당되지 않는 읽기 전용 변수)\n- 객체로 초기화하는 경우 값 자체를 재할당할 수는 없으나 속성값의 변경은 허용\n\n> 호이스팅 - 선언한 변수가 스코프의 최상위로 끌어올림 되는 현상\n\n## 2. 타입 검사\n\n**정적 타입 검사**\n\n- 컴파일 타임에 타입 검사\n- 타입 검사하는 데 시간은 들지만 안정성 보장\n- 자바, C++\n\n**동적 타입 검사**\n\n- 실행 시간에 타입 검사 수행\n- 동적 타이핑 수행\n  - 동적 타이핑 : 값을 변수에 할당할 때 타입이 정해지는 것\n- 자바스크립트\n\n**점진적 타입 검사**\n\n- 컴파일 시간에 타입 검사를 수행\n- 타입 선언 생략 허용\n  - 생략시 암시적 형변환 발생\n  - 암시적 형변환 : 컴파일러가 알아서 데이터 타입 변환\n- 여러 타입을 결합해 새로운 타입을 정의하는 것 허용\n- 타입스크립트, 파이썬\n\n## 3. 타입 계층도\n\n- 타입스크립트는 자바스크립트에서 지원하는 내장 타입을 제공하며 크게 기본 타입, 객체 타입, 함수 타입이 있다.\n\n![200308/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Typescript/images/2020-03-08-img/Untitled.png)\n\n## 4. Primitive(기본) 타입\n\n### 1) string, number, boolean 타입\n\n```ts\n// string\nlet name: string = \"rami\"; // 큰 따옴표 사용 권장\nlet sentence: string = `안녕하세요 ${name}입니다.`;\n\n// number\nlet decimal: number = 6;\nlet hex: number = 0xf00d;\nlet binary: number = 0b1010;\nlet octal: number = 0o744;\n\n// boolean\nlet isShow: boolean = false;\n```\n\n### 2) enum 열거 타입\n\n- numberic 값 집합에 친숙한 이름을 부여하는 방법\n- 기본적으로 멤버 번호는 0부터 시작\n- 수동으로 값을 변경할 수도 있음\n\n```ts\nenum Color {\n  Red,\n  Green,\n  Blue\n}\nlet c: Color = Color.Green;\nconsole.log(c); // 1\nconsole.log(typeof Color); // object\n\n// 0대신 1로 시작할 수 있게 --> 1, 2, 3\nenum Color {\n  Red = 1,\n  Green,\n  Blue\n}\nlet c: Color = Color.Green;\n\n// 열거 형 모든 값 수동 설정\nenum Color {\n  Red = 1,\n  Green = 2,\n  Blue = 4\n}\nlet c: Color = Color.Green;\n\n// 2가 Color enum의 어떤 값과 매핑되는 지 모를 때 이름을 찾을 수 있음\nenum Color {\n  Red = 1,\n  Green,\n  Blue\n}\nlet colorName: string = Color[2];\nconsolo.log(colorName); // Green\n```\n\n**const enum**\n\n- 일반 열거형과 달리 컴파일하는 동안 완전히 제거됨\n\n```ts\n// typescript\nenum WeekDay {\n  Mon = 1,\n  Tue,\n  Wed,\n  Thu\n}\nconsole.log(WeekDay.Mon); // 1\nconsole.log(WeekDay[\"Mon\"]); // 1\nconsole.log(WeekDay[WeekDay.Mon]); // Mon\nlet day = WeekDay;\n// enum 객체의 키는 속성의 인덱스, 속성의 이름이 된다.\n// 따라서 객체에 할당되는 속성의 수는 enum 객체의 속성 개수보다 2배 많다.\nconsole.log(day); // {1: \"Mon\", 2: \"Tue\", 3: \"Wed\", 4: \"Thu\", Mon: 1, Tue: 2, Wed: 3, Thu: 4}\n\n// 컴파일 후 ES5\n\"use strict\";\nvar WeekDay;\n(function(WeekDay) {\n  WeekDay[(WeekDay[\"Mon\"] = 1)] = \"Mon\";\n  WeekDay[(WeekDay[\"Tue\"] = 2)] = \"Tue\";\n  WeekDay[(WeekDay[\"Wed\"] = 3)] = \"Wed\";\n  WeekDay[(WeekDay[\"Thu\"] = 4)] = \"Thu\";\n})(WeekDay || (WeekDay = {}));\n```\n\n```ts\n// typescript\nconst enum WeekDay {\n  Mon = 1,\n  Tue,\n  Wed,\n  Thu\n}\nconsole.log(WeekDay.Mon); // 1\nconsole.log(WeekDay[\"Mon\"]); // 1\nconsole.log(WeekDay[WeekDay.Mon]); // 에러, 문자열 리터럴을 이용해서만 접근 가능\nlet day = WeekDay; // 에러, 속성 또는 인덱스 표현식으로만 가능\n// 컴파일 후 ES5\n\"use strict\";\n```\n\n**기타 enum**\n\n```ts\n// 초기값으로 문자열 할당 가능\nenum WeekDay {\n  Mon = \"MON\",\n  Tue = \"TUE\",\n  Wed = \"WED\",\n  Thu = \"TUE\"\n}\nconsole.log(WeekDay.Mon); // MON\nconsole.log(WeekDay[\"Mon\"]); // MON\n// 리버스 매핑 적용 안됨\n// 문자열 할당하면 속성 값으로 속성 이름 알 수 없음\nconsole.log(WeekDay[WeekDay.Mon]); // 에러,\n\n// 문자열 또는 숫자 섞어서 가능\nenum WeekDay {\n  Mon = \"MON\",\n  Tue = 1,\n  Wed = \"WED\",\n  Thu = \"TUE\"\n}\n\n// boolean, 표현식 불가능\nenum WeekDay {\n  Mon = \"MON\",\n  Tue = 1,\n  Wed = true,\n  Thu = \"TUE\"\n}\nenum WeekDay {\n  Mon = \"MON\",\n  Tue = 1,\n  Wed = 1 + 2,\n  Thu = \"TUE\"\n}\n```\n\n### 3) symbol 타입\n\n- Symbol 생성자를 호출하여 생성\n- 불변 고유\n- 심벌 객체는 호출될 때마다 새로운 심벌 객체를 만듬\n- 객체 리터럴의 속성 키로 사용할 수 있음\n\n```ts\nlet hello = Symbol(\"key\");\nlet hello2 = Symbol(\"key\");\nconsole.log(hello === hello2); // false\nconsole.log(hello, hello2); // Symbol(key) Symbol(key)\nconsole.log(typeof hello); // symbol\n\nlet uniqueKey = Symbol();\nlet obj = {\n  [uniqueKey]: 1234,\n  title: \"hi\"\n};\nconsole.log(obj.uniqueKey); // undefined\nconsole.log(obj.title); // hi\nconsole.log(obj); // {title: \"hi\", Symbol(): 1234}\n```\n\n### 4) string literal 타입\n\n```ts\n// 사용자 정의 타입에 정의한 문자열만 할당 받을 수 있음\ntype EventType = \"keyup\" | \"mouseover\";\n```\n\n## 5. Object(객체) 타입\n\n### 1) Array(배열) 타입\n\n- 타입스크립트에서 배열 타입은 배열 타입과 제네릭 배열 타입으로 나뉜다\n\n```ts\nlet arr: string[] = [\"a\", \"b\", \"c\"];\nlet arr2: Array<string> = [\"a\", \"b\", \"c\"];\n```\n\n**배열 타입**\n\n- 요소 타입으로 string, boolean, number와 같은 자바스크립트 내장 타입뿐 아니라 클래스나 인터페이스도 올 수 있음\n\n```ts\nlet items: number[] = [1, 2, 3];\nlet fruits: string[] = [];\nfruits.push(\"banana\");\nfruits.push(\"apple\");\n\n// any 타입 지정하면 어떤 타입이든 배열의 요소로 추가 가능\nlet myVar: any[] = [1, \"hi\", true];\n\n// 유니언 타입\nlet myVar: (number | string | boolean)[] = [1, \"hi\", true];\n```\n\n**제네릭 배열**\n\n- Array<T> 형태로 선언 (T: 타입)\n- 제네릭 타입 인수로 사용된 타입은 컴파일 시점에 타입을 검사함\n\n```ts\nlet num: Array<number> = [1, 2, 3];\nlet num: Array<number | string> = [1, \"hello\"];\nlet num2: typeof num = [1, \"hello\"]; // 타입 쿼리로 num 변수의 타입을 참조\n\n// 배열요소로 익명 함수 받으려면\nlet nums: Array<() => string> = [() => \"one\", () => \"two\"];\nconsole.log(nums[0]()); // one 출력\n\n// 배열 선언 부분과 요소 추가하는 부분 분리\nlet num3: Array<number> = new Array<number>();\nnum3.push(1);\nnum3.push(2);\nnum4.push(3);\n```\n\n타입스크립트에서 배열 타입이든 제네릭 타입이든 컴파일 시 타입 검사를 위해 필요하며 컴파일 후(ES5)에는 타입이 제거된 배열만 남는다.\n\n### 2) Tuple(튜플) 타입\n\n- 배열 요소가 n개로 정해질 때 각 요소별로 타입을 지정함\n\n```ts\nlet x: [string, number];\nx = [\"tuple\", 100]; // 성공\nx = [10, \"tuple\"]; // 에러\nconsole.log(typeof x, typeof x[0], typeof x[1]); // object string number\nconsole.log(x[0].substring(1)); // uple\nconsole.log(x[1].substring(1)); // 에러\nx[3] = \"world\"; // 에러 - [string, number] 타입에서 3번째 속성이 없어서\n```\n\nFunction, 생성자, Class, Interface는 추후 정리\n\n## 6. Union 타입\n\n2개 이상의 타입을 하나의 타입으로 정의\n\n```ts\nlet x: string | number;\n```\n\n## 7. Intersection 타입\n\n두 타입을 합쳐 하나로 만들 수 있는 타입\n\n```ts\ninterface Cat {\n  leg: number;\n}\ninterface Bird {\n  wing: number;\n}\nlet birdCat: Cat & Bird = { leg: 4, wing: 2 };\n```\n\n## 8. Void 타입\n\n- 빈 값을 나타내는 타입\n- 함수의 반환값이 없을 때\n- null이나 undefined만 할당 가능\n  - void 타입이 null, undefined의 상위 타입이기 때문\n\n```ts\n// 반환값이 없는 함수\nfunction say(): void {\n  alert(\"hello!\");\n}\n// 반환값은 void이지만 실제로는 undefined가 할당됨\nlet mySay: void = say();\n\n// 변수에 undefined나 null 할당 -> 비추\nlet unusable: void = undefined;\nlet unusable; // 위 코드와 같은 의미\nlet unusable = null; // 쓰지 말자\n```\n\n> 변수를 선언할 때 값을 할당하지 않았음을 나타내기 위해 선언한 변수에 null을 할당하는 것은 권장하지 않음\n\n- null이나 undefined를 할당하면 컴파일러 오류가 발생하도록 tsconfig.json에 아래와 같이 설정한다.\n\n```ts\n    {\n    \t\"compilerOptions\": {\n    \t\t\"strictNullChecks\": true\n    \t}\n    }\n```\n\n## 9. null과 undefined 타입\n\n- 둘다 모든 타입의 하위타입\n- undefined는 선언은 됐지만 값이 할당되지 않은 것\n- null은 값은 할당됐지만 값이 빈 객체로 초기화되는 것\n\n```ts\nlet person = { name: \"happy\" };\nperson = null;\nconsole.log(typeof person); // object\n\n// undefined vs null\nlet testUndefined;\nconsole.log(testUndefined, typeof testUndefined); // undefined 'undefined'\n\nlet testUndefined2: undefined = undefined;\nconsole.log(testUndefined2, typeof testUndefined2); // undefined 'undefined'\n\nlet testNull: null = null;\nconsole.log(testNull, typeof testNull); // null 'object'\n\n// 비교\nconsole.log(undefined === null); // false\nconsole.log(undefined == null); // true\nconsole.log(undefined == undefined); // true\n```\n\n## 10. Any 타입\n\n- 제약이 없는 타입으로 어떤 타입의 값도 받아들일 수 있음\n- 최소한의 정적 타입 검사만 수행\n- 외부라이브러리의 연산 결과를 받는 것과 같이 타입 결과를 예측할 수 없을 때\n- 배열 값의 타입이 다양해서 한 가지 타입으로 고정할 수 없을 때\n\n```ts\nlet basket: any = 10;\nbasket = true;\nbasket = \"banana\";\nconsole.log(basket);\n\nlet vList: any[] = [1, false, \"happy\"];\nconsole.log(vList[0]);\n```\n\n### 1) **최소한의 정적 타입 검사...?**\n\n- any 타입으로 선언된 변수는 최소한의 정적 타입 검사만 수행\n\n아래 예를 보면 any 타입으로 선언한 경우, 존재하지않는 함수를 호출할 때 컴파일 에러는 안나지만 런타임 에러가 난다. 속성의 유무를 런타임 시에 검사하나보다..\n\n```ts\nlet number = 50;\nlet number2: any = 50;\n\nconsole.log(number.toFixed(2)); // 50.00\nconsole.log(number2.toFixed(2)); // 50.00\n\nnumber.notExistMethod(); // 컴파일 타임에 에러\nnumber2.notExistMethod(); // 컴파일 에러는 안나지만 런타임 에러\n```\n\n### 2) object 타입과의 차이...?\n\nobject도 any 처럼 타입 구분 없이 값을 할당할 수 있는 특성이 있다. 하지만 속성 유무를 검사하는 시간이 다름. any는 런타임 시에 검사, object는 컴파일 시간에 속성 유무 검사\n\n```ts\nlet number2: Object = 50;\n// 변수에 할당된 타입이 number인지 string인지 몰라서 컴파일 에러 뱉음\nnumber2.toFixed(1); // property 'toFixed' does not exist on type 'Object'\n```\n\n### 3) 비교\n\n```ts\nlet number1 = 50;\nlet number2: any = 50;\nlet number3: Object = 50;\nconsole.log(typeof number1); // number\nconsole.log(typeof number2); // number\nconsole.log(typeof number3); // number\nconsole.log(number1.toFixed(2)); // 50.00\nconsole.log(number2.toFixed(2)); // 50.00\nconsole.log(number3.toFixed(2)); // 컴파일 에러, Object에 tofixed가 없음\n```\n\n### 4) noImplicitAny 옵션\n\n타입을 생략하면 명시적으로 any 타입이 된다. any 타입임을 추론할 수는 있지만, 명시적으로 any 타입임을 선언하는 것이 더 명확하므로 any 타입을 강제하는 게 좋다. 이는 tsconfig.json 파일에서 noImplicitAny 속성을 true로 하면 된다.\n"}},{"name":"images","oid":"79c2a09c33cd777a4e5907aeec9ed44385cb2abd","content":{"__typename":"GitHub_Tree"}}]}},{"name":"Vue","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":"2018-04-07-vue2.md","oid":"0dbcfc35d480024752ff60c2f66b6ecbbd381e19","content":{"__typename":"GitHub_Blob","text":"# Vue2 65분만에 배우기!\n\n- Title : Vue2 65분만에 배우기!\n- Date : 2018-04-07\n- Category: Vue\n\n유튜브 영상 The Vue Tutorial for 2018 - Learn Vue 2 in 65 Minutes 중 몰랐던 내용 정리한 글입니다.\n\n## 1. Vue-CLI 설치하기\n\nVue-CLI를 통해 Vue 프로젝트를 빠르고 쉽게 생성할 수 있다.\n\n```\n> mkdir vue-toy\n> cd vue-toy\n> npm install -g @vue/cli        -- Vue-CLI 설치\n> vue create vue-voca            -- Vue 프로젝트 생성[ vue create 프로젝트이름 ]\n```\n\n2018.04.09추가) yarn 설치 후, yarn을 통해 Vue-Cli 설치하는 방법\n\n```\n> npm install -g yarn\n> yarn global add @vue/cli\n```\n\n뷰 프로젝트를 생성하면 다음과 같은 프롬프트를 볼 수 있다.\n\n```\nVue CLI v3.0.0-beta.6\n?Please Pick a preset : (Use arrow Keys)\n> default (babel, eslint)\n   menually select features\n```\n\n2018.04.09추가)\n\n- Vue-Cli의 기본 템플릿은 babel, eslint, unit-mocha를 포함한다.\n\ndefault로 생성을 성공적으로 완료하면 다음과 같이 명령어를 실행한다.\n\n```\n> cd vue-voca\n> npm run serve\n```\n\n성공적으로 컴파일이 되면 http://localhost:8080/ 로 들어가본다.\n아래와 같은 화면을 볼 수 있다면, 성공적으로 Vue.js App을 생성한 것이다.\n\n![화면](https://raw.githubusercontent.com/devgaram/TIL/master/Vue/images/2018-04-07-img/2018-04-07-img.png)\n\n## 2. Vue Form Validation\n\nVeeValidate는 폼 유효성 체크를 위한 패키지다.\n\n설치방법\n\n```\n> yarn add vee-validate\n#또는\n> npm install vee-validate --save\n```\n\n사용방법\n\n```\nimport VeeValidate from 'vee-validate';\nVue.use(veeValidate);\n```\n\n## 3. Vue router\n\n```\n> npm add vue-router\n#또는\n> yarn add vue-router\n```\n\n```\nimport vue from 'vue'\nimport Router from 'vue-router'\n```\n\nvue 후에 vue-router를 임포트해야한다.\n\n동영상에서 진행한 프로젝트를 따라한 [깃으로 가기](https://github.com/devgaram/vueStudy). 개인적인 주석이 포함되어있습니다.\n"}},{"name":"2020-02-29-without-vue-cli-1.md","oid":"5d8f5742317fc2443a1810a411eb106b455e189d","content":{"__typename":"GitHub_Blob","text":"# Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 1탄\n\n- Title : Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 1탄\n- Date : 2020-02-29\n- Category: Vue\n\n## Why?\n\nVue CLI로 프로젝트를 생성해왔는데 문뜩 웹팩과 바벨에 대한 이해가 부족한듯 싶었다. 그래서😎 오늘은 Vue, Typescript, Babel, Webpack을 사용해서 Vue CLI 없이 프로젝트를 설정해보면서 공부한 내용을 정리해보기로 했다. 1탄은 웹팩과 바벨에 대한 설정과 개념을 잡아보고 2탄에서 Vue와 Typescript 설정을 진행할 거다.\n\n## 1. 프로젝트 생성\n\n```\n    $ mkdir vue-typescript\n    $ cd vue-typescript\n    $ mkdir src\n    $ cd src\n    $ mkdir components\n    $ cd ..\n```\n\n## 2. package.json 파일 생성\n\n> **npm(node package manager)** 은 자바스크립트 패키지 매니저다. Node.js에서 사용할 수 있는 모듈들을 패키지화하여 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI(Common line interface)를 제공한다. 비슷한 패키지 매니저인 페이스북이 만든 **yarn**은 npm보다 더 빠르고 안전하다. 둘 다 package.json 파일에 선언된 semver rule을 만족하는 최신 버전을 설치한다.\n\n```\n    $ npm init\n```\n\n**package.json란?**\n\n- 프로젝트가 의존하고 있는 패키지들의 리스트를 보여준다.\n- semantic versioning rule에 따라 프로젝트에 의존한 패키지들의 버전을 설정할 수 있다.\n- 빌드를 재현할 수 있어 좀 더 쉽게 다른 개발자와 공유할 수 있다.\n\n> **—save-dev** 란? —production 빌드 시 포함될 필요가 없는 패키지는 —save-dev 옵션을 사용하여 package.json의 devDependencies에 패키지 정보를 저장한다.\n\n## 3. Webpack 설치 및 초기 설정\n\n> 웹팩은 자바스크립트 애플리케이션을 위한 **정적 모듈 번들러**다. 자바스크립트 코드를 하나의 파일로 관리하는 것과 여러개의 파일로 관리하는 것은 각각 단점이 있다. 우선 각 파일을 브라우저에 로딩하면 그만큼 네트워크 비용이 커진다. 또한 각 파일이 서로의 스코프를 침범하여 변수 충돌의 위험이 생길 수도 있다. 물론 해결 방법이 있다. 자바스크립트는 함수 스코프를 사용하니 즉시호출함수를 사용해 모듈을 만들면 된다. 그러나 모듈을 모두 즉시호출함수로 변경하여 하나의 파일로 묶는 것을 일일이 작업하면 귀찮지않을까? 웹팩이 등장한 배경이 바로 여기에 있다.\n\n    npm install --save-dev webpack webpack-cli webpack-dev-server html-webpack-plugin\n\n- webpack : 웹팩\n- webpack-cli : 커맨드 라인에서 웹팩을 구동시키기위한 패키지\n- webpack-dev-server : 실시간 리로드를 제공하는 개발 서버로 localhost에서 테스트하고 싶을 때 사용\n- html-webpack-plugin : 웹팩 번들을 서비스하기 위한 HTML 파일을 만들어주는 패키지로 컴파일할 때마다 이름이 변하는 번들파일을 HTML 파일에 넣어줄 때 유용하다.\n\n설치가 완료되면 src 폴더에 index.js 파일을 만들고 package.json 파일의 scripts에 **\"build\": \"webpack\"** 와 **\"start:dev\": \"webpack-dev-server\"** 를 추가한다.\n\n```\n    {\n      \"name\": \"vue-typescript\",\n      \"version\": \"1.0.0\",\n      \"description\": \"\",\n      \"main\": \"index.js\",\n      \"scripts\": {\n    \t\t\"start:dev\": \"webpack-dev-server\",\n    \t\t\"build\": \"webpack\",\n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n      },\n      \"author\": \"\",\n      \"license\": \"ISC\",\n      \"devDependencies\": {\n        \"html-webpack-plugin\": \"^3.2.0\",\n        \"webpack\": \"^4.42.0\",\n        \"webpack-cli\": \"^3.3.11\",\n        \"webpack-dev-server\": \"^3.10.3\"\n      }\n    }\n```\n\n웹팩4는 webpack.config.js 파일이 없어도 파일을 번들할 수 있다. 커맨드 라인에서 **npm run build** 를 치면 dist 폴더에 번들된 파일인 main.js를 볼 수 있다. 또한 **npm run start:dev** 로 치면 8080포트로 개발서버가 동작한다. 하지만 index.html 파일이 없어서 localhost:8080에서 제대로 된 화면을 볼 수 없다. index.html 파일을 직접 dist 폴더에 만들어서 main.js 파일을 **<script src=\"main.js\"></script>** 로 로딩시켜서 동작시킬 수는 있다. 하지만 번들 파일의 이름이 매번 바뀐다면? 또 번들 파일이 많다면? 매우 귀찮을 거다. 그래서 **html-webpack-plugin** 을 이용하여 자동으로 index.html 파일을 생성시키고 번들 파일들을 주입시킬 거다. 설정을 위해 프로젝트 루트에 프로젝트 루트에 webpack.config.js 파일을 생성한 후 아래와 같이 작성한다.\n\n```js\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  entry: \"./src/index.js\",\n  plugins: [new HtmlWebpackPlugin()],\n  output: {\n    filename: \"main.js\",\n    path: path.resolve(__dirname, \"dist\")\n  }\n};\n```\n\n- **entry** : 자바스크립트가 로딩하는 모듈이 많아질수록 모듈간의 의존성은 증가한다. 웹팩에서 의존성 그래프의 시작점을 엔트리(entry)라고 한다.\n- **output** : entry에 설정한 main.ts을 시작으로 의존되어있는 모든 모듈을 하나로 묶은(번들된) 결과의 위치를 output에 정의한다. webpack을 실행하면 /dist 폴더에 main.bundle.js란 이름으로 파일이 생성될 것이다.\n\n**npm run build** 를 실행시키면 dist 폴더에 index.html 파일이 생성되고 `<script type=\"text/javascript\" src=\"main.js\">`로 번들 파일이 주입된다.\n\nwebpack-dev-server 에 대한 추가적인 설정을 하려면 devServer 옵션을 이용하면 된다.\n\n```js\nmodule.exports = {\n  devServer: {\n    hot: true,\n    contentBase: path.join(__dirname, \"dist\"),\n    compress: true,\n    port: 9000\n  }\n};\n```\n\nhot: true 는 핫로더, contentBase는 대상 위치, compress는 파일 gzip 압축, port는서버 포트 설정이다.\n\n[DevServer | webpack](https://webpack.js.org/configuration/dev-server/)\n\n    DevTools failed to parse SourceMap: webpack:///node_modules/sockjs-client/dist/sockjs.js.map\n\n[localhost:9000](http://localhost:9000) 에서 콘솔 창을 확인하면 devtools을 설정하지 않아 위와 같은 경고 문구가 뜬다. devtools 옵션으로 소스맵 생성을 정의할 수 있다. 소스맵은 번들링된 파일과 원래 파일을 맵핑하여 에러 추적할 때 용이하다. 예를 들어 세개의 js 파일을 번들링한 main.js 파일이 있다고 하자. 콘솔 창을 확인해보니 main.js 파일에서 에러가 났다. 만약 소스맵을 사용하지않는다면 세 개의 파일 중 어디서 에러가 났는 지 알 수가 없다. _여러가지 종류가 있지만 inline-source-map 을 추천한다길래 얘를 사용했다. 나중에 각 옵션의 차이점도 알아봐야겠다._\n\n```js\nmodule.exports = {\n  devtool: \"inline-source-map\"\n};\n```\n\n## 4. Babel로 ES6를 ES5로 변환하기\n\n> 구형 브라우저(IE)에서는 ES6 코드가 호환되지 않는다. 그렇다고 ES5로 코드를 짤 수도 없는 노릇. ES2015+ 문법을 ES5로 바꿔주는 녀석이 없을까? 바로 바벨이 그 역할을 한다.\n\n먼저 바벨 패키지를 설치한다.\n\n```\n    npm install --save-dev babel-loader @babel/core @babel/preset-env\n```\n\n- babel-loader : 웹팩에서 ES6로 된 파일을 ES5로 변환할 때 사용\n- @babel/core\n\n웹팩에게 빌드하기전 자바스크립트 파일을 ES5로 트랜스파일링하라고 말해야한다. 웹팩의 Loaders를 이용하여 이를 설정할 수 있다.\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: \"babel-loader\"\n      }\n    ]\n  }\n};\n```\n\n- **loader** : 웹팩은 자바스크립트, 이미지, 폰트, 스타일시트도 전부 모듈로 관리한다. 하지만 웹팩은 자바스크립트만 아는 녀석이라서 웹팩이 자바스크립트 파일이 아닌 파일들을 이해할 수 있게끔 변경해야하는데 로더(loader)가 그런 역할을 한다. 위 코드를 보면 test에 로딩할 파일, use에 적용할 로더, exclude는 제외할 파일를정의한 것을 알 수 있다.\n\n바벨 설정을 완료했지만 사실 바벨은 아무 것도 하지않는다. 프로젝트 루트에 .babelrc 파일을 만들어 설정을 해야한다. 그 전에 ES2015+를 트랜스파일링하기위해 필요한 프리셋과 플러그인을 모은 모듈을 다운받는다. @babel/preset-env는 자동으로 브라우저 polyfill 을 맞춘다.\n\n    npm install @babel/preset-env --save-dev\n\n.babelrc에 아래와 같이 입력한다.\n\n    {\n      \"presets\": [\"@babel/preset-env\"]\n    }\n\n따로 .babelrc 파일을 만들지않고 웹팩에서도 설정 가능하다.\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: \"babel-loader\",\n          options: {\n            presets: [\"@babel/preset-env\"]\n          }\n        }\n      }\n    ]\n  }\n};\n```\n\n실제로 트랜스파일링되는지 테스트하기위해 index.js에 아래와 같이 작성하고 npm run build하면 es5 문법으로 바뀐 것을 알 수 있다.\n\n```js\nconst myconst = 123;\nlet mylet = 456;\n```\n\n![Vue%20CLI%20Vue%20Typescript%20Babel%20Webpack%201/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Vue/images/2020-02-29-img/Untitled.png)\n\n추가로 @babel/preset-env에서 타켓에 옵션으로 브라우저 버전을 직접 설정할 수도 있다. options을 쓰거나 package.json에 작성하는 방법도 있지만 공식문서는 **.browserslistrc** 파일을 만들어서 설정하는 것을 추천하고 있다. 프로젝트 루트 폴더에 .browserslistrc를 만든 후 아래의 내용을 작성하자. 각 브라우저에서 최근 2개의 버전까지, 1% 이상 사용되는 브라우저를 타켓으로 한다. 디폴트는 _> 0.5%, last 2 versions, Firefox ESR, not dead_ 다.\n\n    > 1%\n    last 2 versions\n\n### ES6 메서드나 생성자 지원하려면?\n\nindex.js 에 console.log(Array.from('foo')); 을 입력한 후 IE11에서 확인해보자.\n\n```js\nconsole.log(Array.from(\"foo\"));\n```\n\n콘솔 창을 보면 개체가 'from' 속성이나 메서드를 지원하지 않습니다. 라는 에러 문구를 보게될 것이다. 바벨로 ES5로 바꿨는 데 왜 그러지??? 라는 혼란이 생길 것이다.😨😨\n\n방금까지는 바벨을 이용하여 ES6 문법을 ES5로 문법 트랜스파일링만 한 거다. 그래서 Array.from()과 같이 ES6에만 있는 메서드나 생성자들은 구형 브라우저에서 동작하지 않는다. 이 문제를 해결하기 위해polyfill을 사용한다. **polyfill**은 code 조각으로 런타임에 존재하지 않는 nativeAPI의 복사본을 말한다. @babel/polyfill이나 @babel/plugin-transform-runtime를 사용하면 되지만 **@babel/polyfill** 은 7.4.0부터 deprecated 되서 **core-js@3**를 사용하는 것을 추천한다.\n\n**Babel-Polyfill vs Babel-Transform-Runtime**\n\n- Babel-Polyfill은 전역적으로 polyfill을 사용하여 전역 스코프를 오염시킬 수 있다. 또한 번들 파일에 포함되고 코드 상단에 **import 'babel-polyfill';** 을 추가해야 사용할 수 있다. 프로젝트에서 전역적으로 polyfill을 사용하거나 라이브러리 규모가 클 경우에 사용하는 게 유리하다.\n- Babel-Transform-Runtime는 플러그인으로 추가하면 되고 기능은babel-polyfill과 거의 비슷하나 array.includes()와 array.values() 같은 특정 함수를 제공하지않는다. core-js@3과 함께 사용하면 이 문제를 해결할 수 있다. 간단하게 라이브러리에서 사용하는 API를 래핑시킬 때 좋다.\n\n여기서는 core-js@3를 사용하며 @babel/preset-env의 옵션으로 폴리필을 설정한다. 우선 core-js를 설치해주자.\n\n    npm install core-js@3 --save\n\n.babelrc에 아래와 같이 추가한다. \"useBuiltIns\": \"usage\"는 트랜스파일 시 소스에서 쓰는 폴리필을 자동으로 넣어준다.\n\n    {\n      \"presets\": [\n        [\n          \"@babel/preset-env\",\n          {\n            \"useBuiltIns\": \"usage\",\n            \"corejs\": {\n              \"version\": 3,\n              \"proposals\": true\n            }\n          }\n        ]\n      ]\n    }\n\n구글 크롬 브라우저에 들어가보면 아래와 같이 트랜스 파일링 된 것을 알 수 있다.\n\n```js\n    /***/ \"./src/index.js\":\n    /*!**********************!*\\\n      !*** ./src/index.js ***!\n      \\**********************/\n    /*! no exports provided */\n    /***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n    \"use strict\";\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony import */ var core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.from */ \"./node_modules/core-js/modules/es.array.from.js\");\n    /* harmony import */ var core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0__);\n    /* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.string.iterator */ \"./node_modules/core-js/modules/es.string.iterator.js\");\n    /* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_1__);\n\n\n    console.log(Array.from('foo'));\n\n    /***/ }),\n```\n\nIE 11에서도 폴리필하려면 브라우저 타켓에 IE 11을 추가해야한다. .browserslistrc에 아래와 같이 추가하고 IE 브라우저를 확인하면 잘 동작하는 것을 볼 수 있다.\n\n    > 1%\n    last 2 versions\n    IE 11\n\n**참고**\n\n[웹팩의 기본 개념](http://jeonghwan-kim.github.io/js/2017/05/15/webpack.html)\n\n[[Tool] (번역)Babel에 대한 모든 것](https://jbee.io/etc/Everything-about-babel/)\n"}},{"name":"2020-03-03-without-vue-cli-2.md","oid":"90b6ccb77c8749885afcac589cc7c853f9e17a48","content":{"__typename":"GitHub_Blob","text":"# Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 2탄\n\n- Title : Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 2탄\n- Date : 2020-03-03\n- Category: Vue\n\n## Why?\n\n에 이어 오늘은 Typescript와 Vue를 설정할거다.\n\n## 5. Vue 설치 및 설정\n\n    npm install --save-dev vue vue-loader vue-template-compiler\n\n> vue 가 릴리즈 될 때 vue-template-compiler도 릴리즈된다. vue-template-compiler 버전이 vue 패키지와 동기되어야 vue-loader가 vue를 웹팩이 이해할 수 있는 코드로 생산할 수 있다. 즉 프로젝트에서 vue를 업그레이드 했으면 반드시 vue-template-compiler 버전도 맞춰줘야한다.\n\n- vue-loader : vue-loader는 rule 설정 외에 추가적으로 vue loader 플러그인을 설정해야한다. 예를 들어 **new VueLoaderPlugin()** 을 해야 .vue 파일의 `<script>` 블록이 웹팩의 /\\.js\\$/ 의 바벨 로더에도 적용될 수 있다.\n\nwebpack.config.js에 아래를 추가해주자.\n\n```js\nconst VueLoaderPlugin = require(\"vue-loader/lib/plugin\");\n\nmodule.exports = {\n  mode: \"development\",\n  plugins: [new VueLoaderPlugin()],\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: \"babel-loader\"\n      },\n      {\n        test: /\\.vue$/,\n        loader: \"vue-loader\"\n      }\n    ]\n  }\n};\n```\n\n.vue 파일의 `<style>` 블록과 .css 파일을 처리하기 위해 vue-style-loader와 css-loader 를 설치하자\n\n    npm install --save-dev vue-style-loader css-loader\n\nwebpack.config.js 파일에도 추가하자.\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\"vue-style-loader\", \"css-loader\"]\n      }\n    ]\n  }\n};\n```\n\nVue 루트 인스턴스를 `<div id=\"app\"></div>`에 마운트 시키려면 dist/index.html 에 위 DOM이 있어야 한다. 이 작업을 위해 public/index.html 파일을 만들고 아래와 같이 작성한다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Webpack App</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n  </body>\n</html>\n```\n\nwebpack.config.js의 HtmlWebpackPlugin에 template 옵션을 추가하여 위 html을 기반으로 index.html이 만들어지게 설정한다. npm run build를 해보면 dist/index.html 파일에 `<div id=\"app\"></div>`이 보일 것이다.\n\n```js\nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: \"public/index.html\"\n    })\n  ]\n};\n```\n\n테스트를 위해 간단히 vue-router가 적용된 vue앱을 만들어보자. 우선 vue-router을 설치한다.\n\n    npm install --save-dev vue-router\n\nsrc에 router/index.js 파일을 만들고 아래와 같이 입력한다.\n\n```js\n    // router/index.js\n    import Vue from \"vue\"\n    import VueRouter from \"vue-router\"\n    import Hello from \"../components/Hello.vue\"\n\n    Vue.use(VueRouter)\n\n    export default new VueRouter({\n      mode: \"history\",\n      base: process.env.BASE_URL,\n      routes: [\n        {\n          path: \"/\",\n          name: \"Hello\",\n          component: Hello\n        }\n      ]\n    })\n\n    // index.js\n    import Vue from \"vue\";\n    import App from \"./App.vue\";\n    import router from \"./router\";\n\n    new Vue({\n      render: h => h(App),\n      router\n    }).$mount(\"#app\");\n\n    // App.vue\n    <template>\n      <div id=\"app\">\n        <router-view></router-view>\n      </div>\n    </template>\n\n    // Hello.vue\n    <template>\n      <p>{{ greeting }} world!</p>\n    </template>\n    <script>\n    module.exports = {\n      data: function () {\n        return {\n          greeting: 'Hello'\n        }\n      }\n    }\n    </script>\n    <style scoped>\n    p {\n      font-size: 2em;\n      text-align: center;\n    }\n    </style>\n```\n\nnpm run start:dev 를 했을 때 아래 화면이 보이면 제대로 설정된 것이다.\n\n![Vue%20CLI%20Vue%20Typescript%20Babel%20Webpack%202/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Vue/images/2020-03-03-img/Untitled.png)\n\n**추가 설정**\n\nrouter/index.js 에서 import Hello from \"../components/Hello.vue\" 를 매번 ../ 식으로 쓰는 게 귀찮을 때! webpack resolve 설정을 통해 src를 기준으로 모듈을 찾을 수 있다. webpack.config.js 에 아래와 같이 추가하면 **import Hello from \"@/components/Hello.vue\"** 를 사용할 수 있다. 또 .vue 확장자를 빼고 입력하고 싶다면 extensions를 추가하면 된다. 웹팩이 알아서 파일 확장자를 처리해준다.\n\n```js\nmodule.exports = {\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"src\")\n    },\n    extensions: [\".js\", \".vue\"]\n  }\n};\n```\n\n- **resolve** : 모듈을 어떻게 처리할지 정의 만약 ES2015에서 import 'lodash' 를 사용한다면 웹팩에서 lodash를 어떻게 볼 것인지 lodash.js로 볼지 lodash.ts 로 볼 지 등을 정의한다.\n\n> 물론 이 외에도 설정할 게 많겠지만...... 일단은 여기까지 하고 Vue에서 Typescript 사용하는 방법을 이어가려고 한다. 나중에 이 설정을 기반으로 실제로 프로젝트를 진행하게 된다면 문제가 쏟아질 듯 싶다....\n\n## 6. Vue에서 Typescript 설치 및 설정\n\ntypescript와 ts-loader 패키지를 설치한다.\n\n    npm install --save-dev typescript ts-loader\n\n- typescript : 타입스크립트\n- ts-loader : 웹팩 로더 패키지\n\nwebpack.config.js 에 아래 내용을 추가한다. 이제 .vue 파일 안의 ts도 .ts 파일도 ts-loader에 의해 처리된다.\n\n```js\n    module.exports = {\n    \tentry: './src/index.ts',\n      module: {\n          {\n            test: /\\.ts$/,\n    \t\t\t\texclude: /node_modules/,\n            loader: 'ts-loader',\n            options: { appendTsSuffixTo: [/\\.vue$/] }\n          }\n        ]\n      },\n      resolve: {\n        extensions: ['.ts', 'tsx', '.js', '.vue']\n      }\n    };\n```\n\ntypescript 설정을 위해 프로젝트 루트 폴더에 tsconfig.json 파일을 생성하고 아래 내용을 입력한다.\n\n    {\n      \"compilerOptions\": {\n        \"outDir\": \"./dist/\",\n        \"strict\": true,\n        \"module\": \"es2015\",\n        \"target\": \"es5\",\n    \t\t\"moduleResolution\": \"node\",\n        \"sourceMap\": true,\n        \"allowSyntheticDefaultImports\": true\n      },\n      \"include\": [\n        \"src/**/*\"\n      ],\n      \"exclude\": [\n        \"node_modules\",\n        \"**/*.spec.ts\"\n      ]\n    }\n\n- allowSyntheticDefaultImports : export default 를 export 한 값들을 가지는 객체로 설정\n\n테스트를 위해 프로젝트 코드 수정하자. 우선 src/index.js, src/router/index.js → src/index.ts, src/router/index.ts 로 바꾼다. Hello.vue의 내용을 아래처럼 바꾼다. Vue 컴포넌트 안에서 Typescript를 사용하려면 Vue.component 또는 Vue.extend로 컴포넌트를 정의해야한다. 타입스크립트가 Vue 컴포넌트 타입 유추를 할 수 있게 하기 위해서다.\n\n```js\n    <template>\n      <p>{{ greeting }} world!</p>\n    </template>\n    <script lang=\"ts\">\n    import Vue from 'vue'\n    export default Vue.extend({\n      data: function () {\n        return {\n          greeting: 'Hello'\n        }\n      }\n    })\n    </script>\n    <style scoped>\n    p {\n      font-size: 2em;\n      text-align: center;\n    }\n    </style>\n```\n\n실행하려고 하면 .vue 파일이 import 되지 않는 오류를 발견할 것이다. ts 파일에 .vue 파일을 임포트하려면 추가적인 설정이 필요하다. src/shims-vue.d.ts 파일을 생성하여 이렇게 적자.\n\n```js\n    declare module \"*.vue\" {\n      import Vue from \"vue\";\n      export default Vue;\n    }\n```\n\n저장 후 실행해보면 잘된다.\n\n다음 TIL에서는 vue-class-component 데코레이터를 사용하여 컴포넌트를 선언할 때 클래스 기반 API를 이용하는 방식을 적용해봐야지!\n"}},{"name":"2020-03-09-vue-slots.md","oid":"146f5eb0b2e672cd66e3c67c69e36f8cac38be23","content":{"__typename":"GitHub_Blob","text":"# [Vue] 슬롯(Slots)\n\n- Title : [Vue] 슬롯(Slots)\n- Date : 2020-03-09\n- Category: Vue\n\n## Why?\n\n요즘 vue 프로젝트를 하면서 Vuetify 공식 문서를 매일 같이 들락날락 하고 있다. 크롬 탭 한켠에 켜놓고 Vuetify 죠아..🤩하며 잘 쓰고 있던 중 낯선 예제가 눈에 밟혔다. 바로 아래의 `<v-menu>` 컴포넌트의 예시 코드다.\n\n```ts\n    <v-menu offset-y>\n    \t<template v-slot:activator=\"{ on }\">\n    \t  <v-btn\n    \t    color=\"primary\"\n          dark\n          v-on=\"on\"\n    \t   >\n    \t     Dropdown\n    \t\t </v-btn>\n       </template>\n       <v-list>\n         <v-list-item\n           v-for=\"(item, index) in items\"\n           :key=\"index\"\n           @click=\"\"\n         >\n           <v-list-item-title>{{ item.title }}</v-list-item-title>\n         </v-list-item>\n       </v-list>\n     </v-menu>\n```\n\n**`<template v-slot:activator=\"{ on }>`** 음.. slot이 컴포넌트 렌더링할 때 베이스 컴포넌트의 `<slot>` 에 부모 컴포넌트가 들어가는 거 였는 데...? 근데 예제에서 어떻게 리스트를 보였다 숨겼다 하는 거지? 라는 생각이 들었고 지식의 짧음을 깨달아 곧장 Vue 공식 문서를 방문했다.\n\n[슬롯(Slots) - Vue.js](https://kr.vuejs.org/v2/guide/components-slots.html)\n\n## 슬롯?\n\n### A 컴포넌트 안에 B(컴포넌트, 텍스트, HTML 템플릿..)를 넣고 싶을 때\n\n예시로 페이지마다 쓰이는 레이아웃(헤더, 푸터) 컴포넌트에 페이지마다 달라지는 컨텐츠 컴포넌트를 넣고 싶다고 하자.\n\n레이아웃(Layout) 컴포넌트는 아래와 같다.\n\n```ts\n<template>\n  <Header />\n  <main>\n    <slot></slot>\n  </main>\n  <Footer />\n</template>\n```\n\n이제 콘텐츠(Content) 컴포넌트를 Layout 컴포넌트의 `<slot></slot>` 부분에 넣어보자.\n\n콘텐츠(Content) 컴포넌트는 아래와 같다.\n\n```ts\n<template>\n  <Layout>\n    <div>매번 변경되는 컨텐츠들..</div>\n    <Shop />\n  </Layout>\n</template>\n```\n\n만약 레이아웃 컴포넌트에 `<slot>` 이 없으면 위 예제의 `<Layout>` 요소 안에 있는 내용은 무시된다.\n\n### 음 근데 A컴포넌트 안에 여러 `<slot>`을 만들고 싶은데?\n\n당근 가능하다. 위 예제에서 컨텐츠뿐만 아니라 헤더와 푸터도 `<slot>` 요소로 받을 수 있게 바꿔보자\n\n```ts\n<template>\n  <slot name=\"header\"></slot>\n  <main>\n    <slot></slot>\n  </main>\n  <slot name=\"footer\"></slot>\n</template>\n```\n\n자세히 살펴보면 `<slot>`이 name 속성을 가지고 있다. `<main>`안의 `<slot>`은 name이 지정되지 않았는 데 이때는 암묵적으로 \"default\" 이름을 갖는다.\n\n자 이제 레이아웃 컴포넌트에 헤더, 푸터 컴포넌트와 콘텐츠 내용을 전달해보자.\n\n```ts\n    <template>\n    \t<Layout>\n    \t\t<template v-slot:header><Header /></template>\n    \t\t<div>매번 변경되는 컨텐츠들..</div>\n    \t\t<Shop />\n    \t\t<template v-slot:footer><Footer/></template>\n    \t</Layout>\n    </template>\n```\n\nname 속성이 있는 슬롯에 내용을 전달하려면 `<template>`에 `v-slot` 디렉티브를 쓰고 속성에 앞에서 지정한 name을 넣으면 된다. 이제 `<template>` 요소들의 모든 내용들은 적절한 슬롯에 전달된다. `<template>`에 싸여있지 않은 내용들은 default 슬롯으로 간주하여 이름 없는 `<slot>`요소에 전달된다. v-slot:default로 명시적으로 표시할 수도 있는 데 아래 예제로 확인해보자. 아래 예제는 바로 위 예제와 동일하다.\n\n```ts\n    <template>\n    \t<Layout>\n    \t\t<template v-slot:header><Header /></template>\n    \t\t<template v-slot:default>\n    \t\t\t<div>매번 변경되는 컨텐츠들..</div>\n    \t\t\t<Shop />\n    \t\t</template>\n    \t\t<template v-slot:footer><Footer/></template>\n    \t</Layout>\n    </template>\n```\n\nv-slot만 `<template>` 태그에 추가할 수 있다는 점! 기억하기.\n\n### 슬롯에 전달될 내용이 없을 때 디폴트로 어떤 내용을 표시하고 싶으면?\n\n버튼 텍스트를 `<slot>` 요소로 전달 받으려면 아래와 같이 만들어야한다. 컴포넌트의 이름은 SubmitBtn으로 하자.\n\n```ts\n    <template>\n    \t<v-btn type=\"submit\" :color=\"color\">\n    \t\t<slot></slot>\n    \t</v-btn>\n    </template>\n```\n\n아래와 같이 `<slot>`을 \"저장\" 텍스트로 대체해보자\n\n```ts\n<template>\n  <SubmitBtn color=\"grey\">저장</SubmitBtn>\n</template>\n```\n\n근데 `<SubmitBtn>`안에 아무 것도 안적어도 `<slot>`요소가 \"submit\"으로 대체되게 하고 싶다면? SubmitBtn 컴포넌트를 아래와 같이 수정하자.\n\n```ts\n    <template>\n    \t<v-btn type=\"submit\" :color=\"color\">\n    \t\t<slot>submit</slot>\n    \t</v-btn>\n    </template>\n```\n\n이제 아무 내용이 없으면 submit이 렌더링 된다.\n\n```ts\n<template>\n  <SubmitBtn></SubmitBtn>\n</template>\n```\n\n위 코드의 렌더링 결과는 아래와 같다.\n\n```ts\n<v-btn type=\"submit\">submit</v-btn>\n```\n\n### 자. 여기까지 배운 상태에서 v-menu 예제를 다시 살펴보자.\n\n```ts\n    <v-menu offset-y>\n    \t<template v-slot:activator=\"{ on }\">\n    \t  <v-btn\n    \t    color=\"primary\"\n          dark\n          v-on=\"on\"\n    \t   >\n    \t     Dropdown\n    \t\t </v-btn>\n       </template>\n       <v-list>\n         <v-list-item\n           v-for=\"(item, index) in items\"\n           :key=\"index\"\n           @click=\"\"\n         >\n           <v-list-item-title>{{ item.title }}</v-list-item-title>\n         </v-list-item>\n       </v-list>\n     </v-menu>\n```\n\n이정도 해석은 가능할거다. `<v-menu>` 컴포넌트에 `<slot name=\"activator\"></slot>`이 존재하겠구나. 그래서 `<v-btn>` 요소는 \"activator\" 슬롯에 대체되고 `<template>`로 싸여있지않은 `<v-list>` 컴포넌트는 `<slot></slot>` 즉, 이름 없는 \"default\" 슬롯에 전달되겠네!\n\n그래도 여전히 의문이 남아있다. activator=\"{ on }\" 의 의미는 뭐지? `<v-btn>` 요소의 v-on 디렉티브에 on이 전달되는 데? 무슨 의미일까? 계속 슬롯에 대해 알아보자\n\n잠시 컴파일 범위를 짚고 넘어가보자.\n\n> 부모 템플릿 안에 있는 것은 부모 컴포넌트의 범위에 컴파일되고 자식 템플릿 안에 있는 것들은 자식 컴포넌트의 범위에 컴파일된다.\n\n무슨 의미인지 예제로 이해해보자. 우선 자식 컴포넌트를 살펴보자. 베이스 컴포넌트라고 이해해도 좋다. 일부러 아직 `<slot>` 요소를 넣지 않았다. 이 컴포넌트는 props로 items를 전달받고 v-for 디렉티브로 리스트 렌더링을 수행한다. 이 템플릿은 이 컴포넌트의 범위에서 컴파일된다. 즉, items는 이 컴포넌트 범위에 있으므로 `{{ item.name }}` 데이터 옵션이 정상적으로 'a', b', 'c'로 렌더링된다는 의미다.\n\n```ts\n    <template>\n    \t<ul>\n    \t\t<li v-for=\"item in items\" :key=\"item.name\">\n    \t\t\t{{ item.name }}\n    \t\t</li>\n    \t</ul>\n    </template>\n    <script>\n    export default {\n    \tprops: ['items']\n    }\n    /*\n    \titems = [\n    \t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t{ name: 'c', soldout: true, bestten: false  }\n    \t]\n    */\n    </script>\n```\n\n만약 어떤 컴포넌트에서는 soldout 이 true면 \"Sold Out a\" 이런식으로 렌더링하고 싶고 또 다른 컴포넌트에서는 bestten이 true인 아이템만 렌더링하고 싶다면? 물론 또 다른 props를 전달받아서 구분 값으로 사용하여 렌더링하는 방법도 있긴 하다. 하지만 item 속성에 따른 렌더링 방식에 더 다양해진다면 재사용성이 떨어질 것이다. 그럴 때 슬롯을 사용하면된다.\n\n하지만 부모 컴포넌트에서는 베이스 컴포넌트의 데이터를 사용할 수가 없다. items를 넘기므로 items야 물론 접근할 수 있다. 하지만 베이스 컴포넌트에서 렌더링되는 item에 접근할 수가 없는 거다. 컴파일 범위가 다르니 당연한 얘기다. 그럼 어떻게 해야할까? 바로 슬롯스코프를 사용하면 된다.\n\n```ts\n    <template>\n    \t<ul>\n    \t\t<li v-for=\"item in items\" :key=\"item.name\">\n    \t\t\t<slot name=\"item\" :item=\"item\">\n    \t\t\t\t{{ item.name }}\n    \t\t\t</slot>\n    \t\t</li>\n    \t</ul>\n    </template>\n    <script>\n    export default {\n    \tprops: ['items']\n    }\n    /*\n    \titems = [\n    \t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t{ name: 'c', soldout: true, bestten: false  }\n    \t]\n    */\n    </script>\n```\n\n위 코드의 `<slot name=\"item\" :item=\"item\">`에 주목해보자. 이렇게 item 속성으로 item 값을 내보냈다. 이렇게 `<slot>` 요소에 연결된 속성을 슬롯 속성(slot props)라고 한다. 이제 이 베이스 컴포넌트를 사용하는 부모 컴포넌트는 item에 접근할 수 있다. 아래는 베이스 컴포넌트를 사용하여 Sold Out 표시를 해주는 컴포넌트다. `<template v-slot:item=\"{ item }\">` 템플릿 v-slot에 슬롯 속성인 item을 쓰면 된다. 아래처럼 item의 slodout 속성에 접근할 수 있게 되었다.\n\n```ts\n    <template>\n    \t<ItemList v-bind:items=\"items\">\n    \t  <template v-slot:item=\"{ item }\">\n    \t    <span v-if=\"item.soldout\">Sold Out</span>\n    \t    {{ item.name }}\n    \t  </template>\n    \t</ItemList>\n    </template>\n    <script>\n    export default {\n    \tdata() {\n    \t\treturn {\n    \t\t\titems: [\n    \t\t\t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t\t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t\t\t{ name: 'c', soldout: true, bestten: false  }\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n    </script>\n```\n\n마찬가지로 bestten이 true인 경우에만 렌더링하는 컴포넌트에 사용할 수 있다.\n\n```ts\n    <template>\n    \t<ItemList v-bind:items=\"items\">\n    \t  <template v-slot:item=\"{ item }\">\n    \t    <span v-if=\"item.bestten\">{{ item.name }}</span>\n    \t  </template>\n    \t</ItemList>\n    </template>\n    <script>\n    export default {\n    \tdata() {\n    \t\treturn {\n    \t\t\titems: [\n    \t\t\t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t\t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t\t\t{ name: 'c', soldout: true, bestten: false  }\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n    </script>\n```\n\n사실 v-slot:item=\"{ item }\" 은 v-slot:item=\"slotProps\" 와 같은 데 ES6의 구조분해를 이용하여 { item } 처럼 사용한 거다.\n\n휴 거의 다했다. 이제 v-menu를 다시 살펴보자\n\n이제 v-menu 컴포넌트의 on(slotProps)를 부모 컴포넌트에서 사용할 수 있게 했구나. 라는 것이 이해될 것이다. 아마 v-menu에서 on은 이벤트 핸들러로 부모 컴포넌트에서 v-on 요소에 on을 연결하면 해당 컴포넌트가 클릭되면 default 슬롯이 보이도록 개발이 되어있을 것이다.\n\n```ts\n    <v-menu offset-y>\n    \t<template v-slot:activator=\"{ on }\">\n    \t  <v-btn\n    \t    color=\"primary\"\n          dark\n          v-on=\"on\"\n    \t   >\n    \t     Dropdown\n    \t\t </v-btn>\n       </template>\n       <v-list>\n         <v-list-item\n           v-for=\"(item, index) in items\"\n           :key=\"index\"\n           @click=\"\"\n         >\n           <v-list-item-title>{{ item.title }}</v-list-item-title>\n         </v-list-item>\n       </v-list>\n     </v-menu>\n```\n\n슬롯 정리 끝!\n"}},{"name":"images","oid":"61d3f08767839bcdf0b3e022643734635c55f0f3","content":{"__typename":"GitHub_Tree"}}]}},{"name":"Web","type":"tree","posts":{"__typename":"GitHub_Tree","entries":[{"name":"2020-03-16-rest-api.md","oid":"cf3a7b61b8bfe799d47adca29daf2b3c341d13a4","content":{"__typename":"GitHub_Blob","text":"# REST API에 대해\n\n- Title : REST API에 대해\n- Date : 2020-03-16\n- Category: Web\n\n## ✨ REST API 란?\n\nREST(Representational State Transfer)는 웹처럼 HTTP 기반의 시스템에 필요한 자원(리소스, DBMS 데이터, 이미지, 동영상, 서비스..등)에 접근하는 방식을 정해놓은 아키텍쳐다.\n\n### REST 구성\n\n- 자원(RESOURCE) - URI\n  - 리소스명은 동사보다는 명사를 사용\n- 행위(Verb) - HTTP METHOD(GET, POST, PUT, DELETE)\n- 표현(Representations)\n\n### REST 특징\n\n- **클라이언트/서버 구조** : REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로 간 의존성이 줄어든다.\n- **무상태성(Stateless)** : 클라이언트 컨텍스트(세션, 쿠키)는 서버에 저장되어서는 안 된다. API 서버는 단순히 들어오는 요청만을 처리한다.\n- **캐시 처리 가능(Cacheable)** : HTTP가 가진 캐싱 기능 적용이 가능하다. 클라이언트 응답을 캐싱할 수 있어야 한다.\n- **계층화(Layered System)** : REST 서버는 다중 계층으로 구성될 수 있다. 하지만 클라이언트는 REST 서버에 직접 연결되었는지, 또는 중간 서버를 통해 연결되었는 지를 알 수 없게 해야한다. 중간 서버는 로드 밸런싱 기능이나 공유 캐시 기능을 제공함으로써 시스템 규모 확장성을 향상시키는 데 유용하다.\n- **유니폼 인터페이스(Uniform)** : URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말한다.\n\n### URI 설계 시 주의할 점\n\n- 슬래시 구분자(/)는 계층 관계를 나타내는 데 사용한다.\n- URI 마지막 문자로 슬래시(/)를 포함하지 않는다.\n- 하이픈(-)은 URI 가독성을 높이는데 사용한다.\n- 밑줄(\\_)은 URI에 사용하지 않는다.\n- URI 경로에는 소문자가 적합하다.\n- 파일 확장자는 URI에 포함시키지 않는다.\n\n### 리소스 간의 관계 표현하는 방법\n\n사용자가 좋아하는 디바이스 목록 가져오기\n\n    GET : /users/{userid}/likes/devices\n\n### 자원을 표현하는 Collection과 Document\n\n- Collection: 문서들의 집합, 객체들의 집합\n- Document: 문서, 객체\n\n예시로 이해하기\n\n- sports, players: 컬렉션\n- soccer, 13: 다큐먼트\n\n  http:// restapi.example.com/sports/soccer/players/13\n\n**참고 99.9%**\n\n[REST API 제대로 알고 사용하기 : TOAST Meetup](https://meetup.toast.com/posts/92)\n"}}]}}]}}}},"pageContext":{}},"staticQueryHashes":["2685952063","2841359383"]}