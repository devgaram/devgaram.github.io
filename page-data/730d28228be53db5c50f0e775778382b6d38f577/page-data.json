{"componentChunkName":"component---src-templates-blog-post-js","path":"/730d28228be53db5c50f0e775778382b6d38f577","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"730d28228be53db5c50f0e775778382b6d38f577","text":"# HTTP 커넥션(part 2, TCP 성능에 대한 고려)\n\n- Title : HTTP 커넥션(part 2, TCP 성능에 대한 고려)\n- Date : 2020-12-26\n- Category : Network\n\n> HTTP는 TCP 바로 위의 계층이기 때문에 좋은 성능의 HTTP 애플리케이션을 설계하고 구현하기 위해서는 기본적인 TCP 성능의 특성을 이해해야 한다.\n\n## HTTP 트랜잭션 지연의 원인\n\n![HTTP트랜잭션 처리되는 과정](https://raw.githubusercontent.com/devgaram/TIL/master/Network/images/2020-12-26-img/1.png)\n\n위 그림은 HTTP 트랜잭션이 처리되는 과정을 타임라인 방식으로 보여준다. 그림을 보면 HTTP 트랜잭션을 처리하는 시간은 TCP 커넥션을 설정하고, 요청을 전송하고, 응답 메시지를 보내는 것에 비하면 상당히 짧다는 것을 알 수 있다. 클라이언트와 서버가 너무 많은 데이터를 내려받거나 복잡하고 동적인 자원들을 실행하지 않는 한 **대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생**한다.\n\n### 원인\n\n1. DNS Lookup: 클라이언트는 DNS 이름 분석 인프라를 사용하여 URI에서 웹 서버의 IP 주소와 포트 번호를 알아내야 한다.\n2. Connect: 클라이언트는 TCP 커넥션 요청을 서버에게 보내고 서버가 커넥션 허가 응답을 회신하기를 기다린다. 수백 개의 HTTP 트랜잭션이 만들어지면 소요 시간은 크게 증가한다.\n3. Request: 커넥션이 맺어지면 클라이언트는 HTTP 요청을 새로 생성된 TCP 파이프를 통해 전송한다.\n4. Process: 웹 서버는 데이터 도착하는 대로 TCP 커넥션에서 요청 메시지를 읽고 처리한다.\n5. Response: 웹 서버가 HTTP 응답을 보낸다.\n\n## HTTP 성능에 영향을 주는 TCP 지연의 원인\n\n### TCP 커넥션 핸드셰이크 지연\n\n![TCP 커넥션 핸드셰이크](https://raw.githubusercontent.com/devgaram/TIL/master/Network/images/2020-12-26-img/2.png)\n\n✔️  **TCP 커넥션이 핸드셰이크 하는 순서**\n\n1. 클라이언트는 **SYN** 플래그를 가진 TCP 패킷을 서버에게 보낸다. 40~60바이트로 작은 크기의 패킷이다. \n2. 서버는 커넥션 요청을 받아들였다는 의미로 **SYN + ACK** 플래그를 가진 TCP 패킷을 클라이언트에게 보낸다.\n3. 클라이언트는 커넥션이 잘 맺어졌다는 것을 알리기 위해 서버에게 **ACK 와 HTTP 요청 메시지**를 보낸다.\n\n✔️  **결론**\n\n작은 크기의 HTTP 트랜잭션은 SYN, SYN+ACK 핸드셰이크로 인해 50%의 시간을 TCP 구성에 써버린다. 또한 ACK 패킷은 HTTP 요청 메시지 전체를 전달할 수 있을 만큼 크고 HTTP 서버 응답 메시지는 하나의 IP 패킷에도 담길 수 있다.\n\n### 확인 응답(ACK) 지연\n\n✔️  **TCP는 어떻게 신뢰성 있는 통신을 할까?**\n\nTCP 세그먼트는 순번과 데이터 무결성 체크섬을 가진다. 수신자는 세그먼트가 온전하다고 판단되면 ACK 패킷을 송신자에게 반환한다. 송신자는 특정 시간 안에 ACK 패킷을 받지 못하면 패킷이 파괴되었거나 오류가 있는 것으로 판단하고 데이터를 다시 전송한다.\n\n✔️  **확인 응답 알고리즘이란?**\n\n네트워크를 효율적으로 사용하기 위해 TCP는 크기가 작은 확인 응답을 같은 방향으로 송출되는 **데이터 패킷에 편승(piggyback)** 시킨다. 피기백 경우를 늘리기 위해 확인 응답 알고리즘을 사용한다. 알고리즘은 송출할 확인 응답을 특정 시간 동안 버퍼에 저장해두고 편승시킬 데이터 패킷을 찾는다. 일정 시간안에 데이터 패킷을 찾지 못하면 확인 응답을 별도 패킷을 만들어 전송한다. 이 때 발생되는 지연이 확인 응답 지연이다.\n\n✔️  **결론**\n\n요청과 응답 두 가지 형식으로만 이루어지는 HTTP 동작 방식은 확인 응답이 송출 데이터 패킷에 편승할 기회를 감소시킨다. 막상 편승할 패킷을 찾으려고 하면 해당 방향으로 송출될 패킷이 많지 않기 때문에 확인응답 지연 알고리즘으로 인한 지연이 자주 발생한다.\n\n### TCP 느린 시작\n\nTCP 느린 시작은 TCP가 한 번에 전송할 수 있는 패킷의 수를 제한한다. 패킷이 성공적으로 전달되는 각 시점에 송신자는 추가로 2개의 패킷을 더 전송할 수 있는 권한을 얻는다. 급작스런 부하와 혼잡을 방지하는 데 쓰이는 이 혼잡 제어 기능 때문에 새로운 커넥션보다 이미 어느 정도 데이터를 주고 받은 튜닝된 커넥션이 더 빠르다. HTTP 지속 커넥션과 관련 있다.\n\n### 네이글(Nagle) 알고리즘과 TCP_NODELAY\n\n> 실리 윈도 증후군 전송자는 1바이트 크기의 패킷을 대량으로 전송하는 것으로 네트워크 성능을 크게 떨어뜨린다. 네이글 알고리즘은 이를 방지하기 위해 등장했다.\n\n네이글 알고리즘은 네트워크 효율을 위해 **패킷을 전송하기 전에 많은 양의 TCP 데이터를 한 개의 덩어리로** 합친다. 세그먼트가 최대 크기(랜상 1,500바이트, 인터넷상 수백 바이트)가 되지 않으면 전송을 하지 않는다. 다만 다른 **모든 패킷이 확인 응답을 받았을 경우에는 최대 크기보다 작은 패킷의 전송을 허락**한다. 다른 패킷들이 아직 전송 중이면 데이터는 버퍼에 저장된다. \n\n✔️  **네이글 알고리즘은 HTTP 성능을 어떻게 지연시키나?**\n\n- 크기가 작은 HTTP 메시지는 세그먼트의 최대 크기를 채우지 못해 계속해서 지연된다.\n- 확인 응답 알고리즘과 함께 쓰면 지연이 더 심해진다. 확인 응답 알고리즘은 확인 응답을 100~200 밀리초 지연시키게 되고 네이글 알고리즘은 확인 응답이 도착할 때까지 데이터 전송을 멈추기 때문이다.\n\n✔️  **해결**\n\nHTTP 스택에 TCP_NODELAY 파라미터 값을 설정하여 네이글 알고리즘을 비활성화 할 수 있다. 단, 작은 크기의 패킷이 너무 많이 생기지 않도록 큰 크기의 데이터 덩어리를 만들어야 한다.\n\n### TIME_WAIT의 누적과 포트 고갈\n\n성능 측정 시에 심각한 성능 저하를 발생시키나, 실제 상황에서는 문제를 발생시키지 않는다.\n\n참고 책 - HTTP 완벽 가이드"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e168a4db79259b30f63a6c9f23f8806832ac1c12","text":null}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"9835722865c9ef05272f6c4aecb8c287f78182ed","text":"# HTTP 커넥션(part 1)\n- Title : HTTP 커넥션(part 1)\n- Date : 2020-12-14\n- Category : Network\n\n## `http://www.github.com:80/devgaram` URL을 입력받은 브라우저가 하는 일\n> 전 세계 HTTP 통신은 컴퓨터와 네트워크 장비에서 널리 쓰이고 있는 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이루어진다.\n> 세계 어디서든 클라이언트 애플리케이션은 서버 애플리케이션으로 TCP/IP 커넥션을 맺을 수 있다.\n\n1. 브라우저가 `www.github.com`라는 호스트 명을 추출한다.\n2. 브라우저가 호스트 명에 대한 IP 주소, 192.30.252.153를 찾는다.\n3. 브라우저가 포트 번호, 80을 얻는다.\n4. 브라우저가 192.30.252.153의 80포트로 TCP 커넥션을 생성한다.\n5. 브라우저가 서버로 HTTP GET 요청 메시지를 보낸다.\n6. 브라우저가 서버에서 온 HTTP 응답 메시지를 읽는다.\n7. 브라우저가 커넥션을 끊는다.\n\n## TCP 커넥션\n> HTTP 커넥션은 몇몇 사용 규칙을 제외하고는 TCP 커넥션에 불과하며 TCP는 HTTP에게 신뢰할 만한 통신 방식을 제공한다.\n\n- TCP 커넥션은 **<발신지 IP주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>** , 이 네가지 값으로 생성되며, 네가지가 모두 동일한 커넥션은 존재할 수 없다.\n- IP 주소가 컴퓨터, 포트 번호가 애플리케이션으로 생각하면 된다.\n\n### 프로토콜 스택\nHTTP - 애플리케이션 계층 | TCP - 전송 계층 | IP - 네트워크 계층 | Network Interfaces - 데이터링크 계층\n\n**HTTP**\n\n|HTTP 프로토콜|\n|:---:|\n|HTTP|\n|TCP|\n|IP|\n|Network Interfaces|\n\n**HTTPS**    \nHTTP에 보안 기능을 더한 것으로 SSL 또는 TLS라고 불리기도 하며 HTTP와 TCP 사이에 있는 암호화 계층이다.\n\n|HTTPS 프로토콜|\n|---|\n|HTTP| \n|TLS 또는 SSL|\n|TCP|\n|IP|\n|Network Interfaces|\n\n### 전송 과정\n\n1. HTTP가 메시지를 전송하고자 현재 연결되어 있는 TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보낸다.\n2. TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나눈다. 각 세그먼트를 IP 패킷(혹은 IP 데이터그램)에 담아서 하나의 IP 주소에서 다른 IP 주소로 전달한다.\n\n### IP 패킷에 포함되는 정보\n- IP 패킷 헤더(20byte): 발신지와 목적지의 IP 주소, 크기, 기타 플래그 가짐\n- TCP 세그먼트 헤더(20byte): TCP 포트 번호, TCP 제어 플래그, 데이터 순서와 무결성을 검사하기 위해 사용하는 숫자 값 가짐\n- TCP 데이터 조각(0혹은 그 이상의 바이트)\n\n## TCP 소켓 프로그래밍\n\n소켓 API를 사용하면 TCP 종단(endpoint) 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.\nTCP API는 기본적인 네트워크 프로토콜의 핸드셰이킹, 그리고 TCP 데이터 스트림과 IP 패킷 간의 분할 및 재조립에 대한 모든 세부사항을 외부로부터 숨긴다.\n\n### 클라이언트와 서버가 TCP 소켓 인터페이스를 사용하여 상호작용 하는 방법\n\n|클라이언트|서버|\n|---|---|\n|| 1. 새로운 소켓을 만든다|\n||2. 80 포트로 소켓을 묶는다|\n||3. 소켓 커넥션을 허가한다(listen)|\n||4. 커넥션을 기다린다(accept)|\n|1. IP 주소와 포트를 얻는다.||\n|2. 새로운 소켓을 생성한다.||\n|3. 서버의 IP포트로 연결한다(connect)||\n||5. 애플리케이션에 커넥션 통지|\n|4. 성공적으로 연결 |6. 요청을 읽기 시작한다(read)|\n|5. HTTP 요청을 보낸다(write)|7. HTTP 요청 메시지를 처리한다.|\n|6. HTTP 응답을 기다린다(read)||\n||8. HTTP 응답을 보낸다(write)|\n|7. HTTP 응답을 처리한다||\n|8. 커넥션을 닫는다(close)|\n||9. 커넥션을 닫는다(close)|\n\n\n참고 책 - HTTP 완벽 가이드\n"}}}},"pageContext":{"id":"730d28228be53db5c50f0e775778382b6d38f577","previousPostId":"e168a4db79259b30f63a6c9f23f8806832ac1c12","nextPostId":"9835722865c9ef05272f6c4aecb8c287f78182ed"}},"staticQueryHashes":["2685952063","2841359383"]}