{"componentChunkName":"component---src-templates-blog-post-js","path":"/925c932c741ff2a153eedb35c2a39a5860255566","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"925c932c741ff2a153eedb35c2a39a5860255566","text":"# 자바스크립트의 iterable, iterator 프로토콜과 generator\n\n- Title : 자바스크립트의 iterable, iterator 프로토콜과 generator\n- Date : 2020-05-23\n- Category : Javascript\n\n# iterable 프로토콜\n\n- iterable 프로토콜은 반복 가능한 객체를 정의하는 방법(규약)으로 `for..of` 를 통해 value를 반복할 수 있다.\n- 반복 가능한 내장 객체로 `Array`, `Map`, `Set`, `String` 등이 있으며 객체는`[Symbol.iterator]` 속성 키를 가진다. *이 객체 들의 프로토타입 객체들이 `@@iterator` 메소드를 가지기 때문에 반복이 가능하다.*\n- `Promise.all(iterable)`, `Array.from()` 도 iterable을 허용한다.\n- 반복 가능한 객체를 만들고 싶다면 객체의 `[Symbol.iterator]` 속성에 `@@iterator` 메소드를 구현 하면 된다. 이 메소드는 iterator 프로토콜을 따르며 인수 없이 호출 되고 iterator 객체를 반환한다.\n\n반복 가능한 객체(iterable)는 `for-of` , `spread operator`, `yield*`, `구조 분해 할당`에 함께 사용된다.\n\n```java\nfor(let value of ['a', 'b', 'c']){\n    console.log(value)\n}\n// \"a\"\n// \"b\"\n// \"c\"\n\n[...'abc'] // [\"a\", \"b\", \"c\"]\n\nfunction* gen(){\n  yield* ['a', 'b', 'c']\n}\n\ngen().next() // { value:\"a\", done:false }\n\n[a, b, c] = new Set(['a', 'b', 'c'])\na // \"a\"\n```\n\nString은 반복 가능한 내장 객체로 `[Symbol.iterator]` 속성에 `@@iterator` 메소드가 있다.\n\n```java\nconst someString = \"hi\";\ntypeof someString[Symbol.iterator]; // function\nconst iterator = someString[Symbol.iterator](); // StringIterator {}\niterator + \"\" // [Object String Iterator]\n\niterator.next(); // { value: \"h\", done: false }\niterator.next(); // { value: \"i\", done: false }\niterator.next(); // { value: undefined, done: true }\n\n[...someString] // [ \"h\", \"i\" ]\n```\n\n반면에 일반 객체는 `@@iterator` 없어서 `undefined` 값을 반환한다. *물론 정의가 가능하다.*\n\n```java\nconst testObject = new Object();\ntypeof testObject[Symbol.iterator] // undefined\n```\n\n# iterator 프로토콜\n\n- 반복 가능한 객체의 value들을 시퀀스(어떠한 일련의 순서)대로 처리하는 방법(규약)이다.\n\n### iterator 객체 구현 규칙\n\n- `next()` 메소드가 있어야 한다. 이 메소드는 `done`, `value` 속성을 가진 객체를 반환한다.\n    - `done`(boolean): iterator가 마지막 반복 작업을 끝내면 true, 작업이 남아 있으면 false다. *done이 true이면 반환되는 객체의 value 프로퍼티의 값은 undefined다.*\n    - `value`: iterator에서 반환되는 값으로 done이 true면 생략될 수 있다.\n\n아래 코드는 문자를 하나씩 반환하는 String의 `@@iterator` 메소드를  \"bye\" 만 반환하고 끝내도록 재 정의한 예제다.\n\n```java\nconst someString = new String(\"hi\");\n\nsomeString[Symbol.iteraror] = function() {\n\treturn { // iterator 객체를 리턴\n\t\tnext: function() {\n\t\t\tif (this._first) {\n\t\t\t\tthis._first = false;\n\t\t\t\treturn { value: \"bye\", done: false };\n\t\t\t} else {\n\t\t\t\treturn { done: true };\n\t\t\t}\n\t\t},\n\t\t_first: true\n\t};\n};\n```\n\n# Generator\n\n## Generator 함수\n\n- 실행이 연속적이지 않는 작업을 iterator 처럼 사용할 수 있게 해준다.\n- `function*` 키워드를 통해 선언되는 Generator 함수는 호출 되어도 즉시 실행되지 않고, 대신 함수를 위한 Iterator 객체(Generator 객체)가 반환됩니다\n- `next()` 메소드를 호출하면 Generator 함수가 실행되어 `yield` 문을 만날 때까지 진행하고, 해당 yield가 반환하는 객체를 리턴 한다.  반환하는 객체는 yield문이 반환할 값(yielded value)을 나타내는 `value` 속성과, Generator 함수 안의 모든 yield 문의 실행 여부를 표시하는 boolean 타입의 `done` 속성을 갖는다.\n\n> `yield*`: 다른 generator 또는 iterable 객체에 yield를 위임할 때 쓰이며 `yield [iterable 객체를 반환하는 표현식]` 방식으로 사용한다.\n\n## Generator 객체\n\n- generator function에서 반환된 값으로 iterator, iterable 프로토콜을 준수한다.\n- `Generator.prototype.next()`: `yield` 표현을 통해 yield된 값을 반환\n- `Generator.prototype.return()`: 주어진 값을 반환하고 Generator 종료\n- `Generator.prototype.throw()`:  Generator의 실행을 재개시키고 Generator 함수의 실행 문맥 속으로 error를 주입하며 done, value 프로퍼티를 가진 객체를 반환한다.\n\n```java\nfunction* gen() {\n\twhile(true) {\n\t\ttry {\n\t\t  yield 1;\n\t\t  yield 2;\n\t\t  yield 3;\n\t\t} catch(e) {\n\t\t\tconsole.log('Error caught!');\n\t\t}\n\t}\n}\n\nvar g = gen(); // \"Generator { }\"\n\ng.next();        // { value: 1, done: false }\ng.throw(new Error(\"Something went wrong\"));\n// \"Error caught!\"\n// { value: 1, done: false }\ng.return(\"foo\"); // { value: \"foo\", done: true }\ng.next();        // { value: undefined, done: true }\n```\n\n반복 가능한 객체를 만들기 위해 `[Symbol.iterator]` 속성에 Generator 객체를 아래와 같이 정의할 수 있다.\n\n```java\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n[...myIterable]; // [1, 2, 3]\n```\n\n무한 iterable 객체 만드는 방법\n\n```java\nfunction* idMaker(){\n    var index = 0;\n    while(true)\n        yield index++;\n}\n\nvar gen = idMaker(); // \"Generator { }\"\n\nconsole.log(gen.next().value); // 0\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"0dfe7484013b534a57d77a03dafae8490bb0d27b","text":"# 자바스크립트 async, await, promise\n\n- Title : 자바스크립트 async, await, promise\n- Date : 2020-05-20\n- Category : Javascript\n\n# Rules for Promise\n\n1. 비 동기나 블로킹 코드 작업을 하고 싶을 때 `Promise`를 사용하자.\n2. `resolve`는 `then`과  `reject`는  `catch` 와 맵핑된다.\n3. `.catch` `.then` 메소드를 사용하자.\n4. 꼭 실행 해야 할 코드가 있다면 `.finally` 를 사용하자.\n5. 여러 개의 `Promise`가 모두 완료 되었을 때 작업을 진행하고 싶다면 `Promise.all(iterable)`를 사용하자. `Promise.all`은 배열 내 모든 프로미스의 이행(또는  첫 번째 거부)를 기다린다.\n\n    ```jsx\n    const p1 = Promise.resolve(3);\n    const p2 = 1337;\n    const p3 = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        resolve(\"foo\");\n      }, 100);\n    }); \n\n    // p2는 프로미스가 아니지만 이행 결과 배열에는 포함된다.\n    Promise.all([p1, p2, p3]).then(values => { \n      console.log(values); // [3, 1337, \"foo\"] \n    });\n\n    // 매개변수 배열이 빈 것과 동일하게 취급하므로 이행함\n    const p4 = Promise.all([1,2,3]); // Promise {<resolved>: Array(3)} [1, 2, 3]\n\n    // 프로미스 거부됨\n    const p5 = Promise.all([1,2,3, Promise.reject(555)]); // Uncaught (in promise) 555\n    ```\n\n# Rules for async-await\n\n1. `async function` 은 `Promise`를 리턴한다.\n2. 코드에서 직접 `Promise`를 직접 리턴하지않았어도 async 함수는 Promise를 리턴한다는 것을 기억하자.\n3. `await` 블록은 `async` 함수 안에 위치한다.\n4. `async` 함수에는 두 개 이상의 `await` 구문을 사용할 수 있다.\n5. `async await`를 사용할 때, `try~catch`로 에러 핸들링을 하자.\n6. `iterator`과 `loop`에서 `await`를 사용하며 코드가 순차적으로 실행될 것 같지만 사실은 동시에 실행된다.\n7. `await`는 하나의 `Promise`를 위해서만 사용하자.\n8. `await` 블록은 항상 `async` 함수 내에 있다. `promise`가 `resolve`되면 다음 코드가 실행된다는 것을 기억하자. \n\n# Promise vs async-await\n\n1. `async` 함수는 `promise`를 반환하고 반대도 성립된다. 즉, `promise`를 반환하는 모든 함수는 `async` 함수로 사용할 수 있다.\n2. function2의 아웃풋이 function1의 아웃풋에 따라 달라진다면 `await`를 사용하자.\n3. 두 개의 함수가 순차적으로 실행될 필요가 없다면 `await`를 쓸 필요가 없다.\n4. Promise를 동시에 실행시키고 싶다면 `Promise.all`을 사용하자\n5. `await`는 `blocking code`를 만든다는 사실을 잊지 말자.\n6. 많은 await 구문이 있는 async 함수를 사용하는 것보다는 여러 개의 async 함수로 쪼개서 사용하자.\n    - 너무 많은 `blocking code`는 좋지 않다.\n    - 비동기 코드가 수평적으로 실행된다는 것을 강조할 수 있다.\n\n[JavaScript: Promises or async-await](https://medium.com/better-programming/should-i-use-promises-or-async-await-126ab5c98789)\n\n# Symbol\n\n```jsx\n// 위 코드는 매 번 새로운 심볼을 생성한다.\nconst sym1 = Symbol();\nconst sym2 = Symbol(\"foo\");\nconst sym3 = Symbol(\"foo\");\n```\n\n1. 이름 충돌의 위험 없이 **속성의 키**로 쓰기 위해 생성하고 사용할 수 있는 값이다.\n2. Boolean, String, Number 같이 원시 데이터 형의 일종이다.\n3. `Symbol()` 로 부터 반환되는 모든 심볼 값은 고유하다.\n4. 객체 속성에 대한 `식별자`로 사용할 수 있다.\n5. `Object.getOwnPropertySymbols()` 메서드를 이용하여 객체의 심볼 속성을 찾을 수 있다. 모든 객체는 심볼 속성이 없는 상태로 초기화 되기 때문에 해당 객체에 심볼 속성을 설정하기 전까지는 빈 배열을 반환한다는 점에 유의하자.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d40dfa460c3404882d4c862ecddb0374d3a40df0","text":"# 자바스크립트 동작 방식 - 스레드 큐와 setTimeout()\n\nDate: Mar 31, 2020\n\n- Title : 자바스크립트 동작 방식 - 스레드 큐와 setTimeout()\n- Date : 2020-03-31\n- Category : Javascript\n\n# WHY?\n\n자바스크립트가 단일 스레드 환경에서 돌아간다는 것은 대부분의 사람들이 알고 있을 것이다. 하지만 어떻게 동작하는 지는 모르는 사람이 있다.. ~~바로..나처럼..?~~ 그런 이유로 자바스크립트가 어떻게 돌아가는 지 낱낱이 파헤쳐 봐야지!\n\n# 스레드 큐(태스크 큐)\n\n스레드 큐는 단일 스레드 환경에서 어떠한 순서로 함수나 기능을 수행할지 결정하는 목록으로 FIFO(First-In First-Out)의 정책을 가진다. 스레드 큐 덕분에 지연이 발생하더라도 들어온 순서대로 요청을 처리할 수 있다. \n\n> ✨ 여기서 말하는 지연이란? 자바스크립트는 사용자와 상호작용하는 이벤트 기반 언어라, 비동기로 동작하거나 현재 소스가 실행 중에 사용자의 입력이 들어오면 지연이 발생할 수 있다.\n\n# setTimeOut() 파헤치기\n\n🎉아래 코드에서 `buttonAddItem.onclick`, `divItems.appendChild()`, `inputCloneItem.focus()` 가 스레드 큐에 어떤 순서로 들어갈지 생각해보자.\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n      </head>\n      <body>\n        <button id=\"addItem\">Add New Input</button>\n        <div id=\"items\"></div>\n        <script>\n          (function() {\n            const divItems = document.getElementById(\"items\"),\n              buttonAddItem = document.getElementById(\"addItem\"),\n              inputItem = document.createElement(\"input\");\n            buttonAddItem.onclick = () => {\n              const inputCloneItem = inputItem.cloneNode(true);\n              inputCloneItem.value = \"Give me focus\";\n    \n              divItems.appendChild(inputCloneItem);\n              setTimeout(() => {\n                inputCloneItem.focus();\n              }, 0);\n            };\n          }());\n        </script>\n      </body>\n    </html>\n\n`setTimeout()` 함수의 두번째 파라미타를 0으로 했으니깐 버튼을 클릭하면 `divItems.appendChild(inputCloneItem)` 보다 `inputCloneItem.focus()` 가 먼저 들어가있을거라고 생각했다면...? 땡땡!!😂😂 정답은 아래와 같다. `setTimeout()` 함수를 0초 후에 호출되도록 설정하면 호출하자마자 실행되는 것이 아니라 UI 업데이트가 이루어지고 나서 호출된다. 즉, setTimeout() 함수는 특정 시간이 되면 콜백 함수를 호출하도록 실행 큐 뒤에 해당 함수를 넣는 거지 함수 자체를 호출한다는 의미가 아니다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled.png)\n\n🎉 다음 예제를 통해 `setTimeout()` 함수와 단일 스레드 환경을 명확하게 이해해보자. 방금 예제와 비슷하지만 `setTimeout()`은 버튼이 클릭되고 2초 뒤에 콜백함수로 호출하도록 했고 `sleep()` 함수를 추가해서 10초동안 while 문이 돌아가게 했다. 자, 그럼 `setTimeout()`의 콜백함수는 언제 실행될까?\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n      </head>\n      <body>\n        <button id=\"addItem\">Add New Input</button>\n        <div id=\"items\"></div>\n        <script>\n          (function() {\n            const divItems = document.getElementById(\"items\"),\n              buttonAddItem = document.getElementById(\"addItem\"),\n              inputItem = document.createElement(\"input\"),\n              divLog = document.getElementById(\"log\");\n            buttonAddItem.onclick = () => {\n              const inputCloneItem = inputItem.cloneNode(true),\n                    waitSeconds = 10;\n              \n              inputCloneItem.value = \"Give me focus\";\n    \n              divItems.appendChild(inputCloneItem);\n    \n              console.log(\"Execute setTimeout at: \\t\" + Date.now());\n              setTimeout(() => {\n                inputCloneItem.focus();\n                console.log(\"Execute setTimeout at: \\t\" + Date.now());\n              }, 2000);\n    \n              sleep(waitSeconds * 1000);\n            };\n    \n            function sleep(waitSeconds) {\n              const waitUntil = Date.now() + waitSeconds;\n              while (Date.now() < waitUntil);\n            }\n          }());\n        </script>\n      </body>\n    </html>\n\n아래의 실행결과를 보면 setTimeout() 안의 콜백함수는 2초 뒤에 실행되지않고 10초 뒤에 실행된다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%201.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%201.png)\n\nsetTimeout()의 콜백함수는 버튼 클릭 2초 후 스레드 큐에 등록되지만 버튼 클릭 핸들러 내 sleep() 함수가 다 실행되어야 순서대로 처리되기 때문에 10초보다 뒤에 실행된다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%202.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%202.png)\n\n🎉 위 예제에서 버튼 클릭 시 setTimeout() 함수를 두번 호출하도록 코드를 수정해보고 실행이 어떤식으로 되는 지 알아보자.\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n      </head>\n      <body>\n        <button id=\"addItem\">Add New Input</button>\n        <div id=\"items\"></div>\n        <script>\n          (function() {\n            const divItems = document.getElementById(\"items\"),\n              buttonAddItem = document.getElementById(\"addItem\"),\n              inputItem = document.createElement(\"input\"),\n              divLog = document.getElementById(\"log\");\n            buttonAddItem.onclick = () => {\n              const inputCloneItem = inputItem.cloneNode(true),\n                    waitSeconds = 10;\n              \n              inputCloneItem.value = \"Give me focus\";\n    \n              divItems.appendChild(inputCloneItem);\n    \n              console.log(\"onclick function invoked at: \\t\" + Date.now());\n              setTimeout(() => {\n                console.log(\"1st Execute setTimeout at: \\t\" + Date.now());\n                sleep(waitSeconds * 1000);\n              }, 2000);\n              setTimeout(() => {\n                inputCloneItem.focus();\n                console.log(\"2 Execute setTimeout at: \\t\" + Date.now());\n              }, 2000);\n    \n              sleep(waitSeconds * 1000);\n            };\n    \n            function sleep(waitSeconds) {\n              const waitUntil = Date.now() + waitSeconds;\n              while (Date.now() < waitUntil);\n            }\n          }());\n        </script>\n      </body>\n    </html>\n\n클릭 이벤트가 발생하면 setTimeout() 함수의 콜백 이벤트를 등록하고 2초 뒤에는 등록한 2개의 setTimeout() 함수가 호출된다(스레드 큐에 콜백함수가 들어간다) 이때 스레드 큐에서는 10초간 sleep()을 수행하기때문이 sleep()이 끝나고 UI 업데이트가 이루어진 후 첫번째 콜백이 실행된다. 콜백 안에 또 sleep()이 있어서 10초 뒤에 두번째 콜백이 수행된다. 즉, 두번째 setTimeout 콜백은 20초 뒤에나 실행된다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%203.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%203.png)\n\n스레드 큐는 아래와 같다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%204.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%204.png)\n\n# 결론\n\nsetTimeout() 뿐만 아니라 모든 XMLHttpRequest나 다른 콜백 이벤트가 발생했다고 해서 바로바로 현재의 스레드에 인터럽트를 걸고 실행하는 것이 아니라, **현재 실행하고 있는 스레드 큐가 끝나고 자신의 차리가 와야 실행된다**. 즉, 처리가 오래 걸리는 자바스크립트 함수가 있을 때는 호출이 이루어져야 하는 시간이 되어도 그 함수의 처리가 끝날 때까지 스레드 큐에서 대기한다."}}}},"pageContext":{"id":"925c932c741ff2a153eedb35c2a39a5860255566","previousPostId":"0dfe7484013b534a57d77a03dafae8490bb0d27b","nextPostId":"d40dfa460c3404882d4c862ecddb0374d3a40df0"}},"staticQueryHashes":["2685952063","2841359383"]}