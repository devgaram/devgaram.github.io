{"componentChunkName":"component---src-templates-blog-post-js","path":"/40f40953b7ab43bf93781786a87871d92de6d63c","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"40f40953b7ab43bf93781786a87871d92de6d63c","text":"# React 기반을 다져보자!\n\n- Title : React 기반을 다져보자!\n- Date : 2020-01-07\n- Category: React\n\n<span class=\"clr-grey\">새로 알게 된 내용이 있으면 계속해서 추가할 예정입니다. </span>\n\n> **참조 링크** <br/>\n>\n> - [리액트 공식 문서](https://reactjs-kr.firebaseapp.com/docs/hello-world.html)\n\n# JSX\n\n```javascript\nconst element = <h1>Hello, world</h1>;\nReactDOM.render(\n  element,\n  document.getElementById(\"root\") // ID가 root인 노드에 렌더링하겠다!\n);\n```\n\n- JSX는 화면에서 볼 수 있는 내용에 대한 설명인 <code>React elements</code> 객체를 만든다.\n- 표현식이므로 if문, for 반복, 변수 할당, 매개 변수로 사용 가능하다.\n- Babel은 JSX를 <code>React.createElement()</code> 호출로 컴파일합니다.\n- 리액트 요소는 <code>Immutable Objects</code>라서 한번 만들면 그 자식이나 속성을 변경할 수 없다. UI를 업데이트 하려면 새로운 요소를 만들어서 <code>ReactDOM.render()</code>에 전달해야한다.\n\n> **Note:** <br/>\n> 실제로 대부분의 React 어플리케이션은 ReactDOM.render() 를 한번만 호출한다. -> state를 이용한다.\n\n# 순수 함수란?\n\n순수 함수는 입력을 변경하지않으며 항상 동일한 입력에 대해 동일한 결과를 반환하는 함수다.\n\n**순수 함수**\n\n```javascript\nfunction sum(a, b) {\n  return a + b;\n}\n```\n\n**순수 함수가 아님**\n\n```javascript\nfunction withdraw(account, amount) {\n  account.total -= amount;\n}\n```\n\n# Props\n\n- 부모 컴포넌트에서 자식 컴포넌트로 전달된 데이터다.\n- Props는 읽기전용이므로 수정할 수 없다.\n- 모든 React 컴포넌트는 props와 관련한 동작을 할 때 <code>순수 함수</code>처럼 동작해야한다.\n\n# State\n\n## 1. 클래스 컴포넌트에서 state 사용하기\n\n```javascript\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { date: new Date() };\n  }\n\n  // mounting : Clock 이 DOM에 최초로 렌더링 될 때\n  componentDidMount() {}\n\n  // unmounting : DOM에서 Clock 을 삭제했을 때\n  componentWillUnmount() {}\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(<Clock />, document.getElementById(\"root\"));\n```\n\n## 2. 함수형 컴포넌트에서 state 사용하기\n\n```javascript\nimport React, { useEffect, useState } from \"react\";\n// ...\n\nconst PetSitterApplyContainer = () => {\n  const [current, setCurrent] = useState(0); // 인자는 초기값\n\n  // ...\n\n  // 라이프사이클 훅\n  useEffect(() => {\n    function handleResize() {\n      dispatch(resize(window.innerWidth, window.innerHeight));\n    }\n    window.addEventListener(\"resize\", handleResize);\n  });\n\n  const next = () => {\n    setCurrent(current + 1);\n  };\n\n  const prev = () => {\n    setCurrent(current - 1);\n  };\n\n  return <PetSitterApply current={current} />;\n};\n```\n\n- state는 React 컴포넌트가 유저 액션, 네트워크 응답, 기타 등등에 대한 응답으로 시간 경과에 따라 출력을 변경할 수 있게 한다.\n- State는 로컬이며 캡슐화되어있다 : 부모 컴포넌트나 자식 컴포넌트는 특정 컴포넌트의 state 유무를 알 수 없으며 해당 컴포넌트가 함수나 클래스로 선언되었는 지 알 수 없기 때문\n- <code>componentDidMount() 훅</code> : 컴포넌트 출력이 DOM에 렌더링 된 이후 동작한다.\n- <code>componentWillUnmount() 훅</code> : 컴포넌트가 DOM에서 삭제된 이후 동작한다.\n- <code>useEffect</code> : 리액트 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 설정 할 수 있는 Hook으로 클래스형 컴포넌트의 componentDidMount 와 componentDidUpdate 를 합친 형태다.\n\n## 3. State 바르게 사용하기\n\n- State를 직접 수정하지말기\n\n```javascript\n// Wrong\nthis.state.comment = \"Hello\";\n\n// Correct\nthis.setState({ comment: \"Hello\" });\n```\n\n- this.props 및 this.state가 비동기로 업데이트될 수 있다는 것을 고려하기\n\n```javascript\n// Wrong\nthis.setState({\n  counter: this.state.counter + this.props.increment\n});\n\n// Correct : 이전 state를 인수로 받음\nthis.setState((prevState, props) => ({\n  counter: prevState.counter + props.increment\n}));\n```\n\n# 하향식(top-down) 혹은 단방향(unidirectional) 데이터 흐름\n\n- 모든 state는 항상 특정 컴포넌트가 가지며, 해당 state에서 파생된 모든 데이터 또는 UI는 트리의 컴포넌트 <code>아래(below)</code>에만 영향을 미친다.\n- 컴포넌트는 자신의 state를 자식 컴포넌트에 props 로 내려줄 수 있다. => <code>컴포넌트 트리 == props의 폭포</code>\n\n# Refs\n\n일반적인 리액트 데이터 플로우에서 부모 컴포넌트와 자식 컴포넌트는 <code>props</code>를 통해서만 통신할 수 있어서 자식 컴포넌트를 수정하려면 새로운 <code>props</code>와 함께 다시 렌더링해야한다. 그럼 일반적인 데이터 플로우 밖에서 자식 컴포넌트(컴포넌트 인스턴스 or DOM)에 직접 접근하려면 어떻게 해야할까? <code>Refs</code>를 사용하면 되지만 공식문서에서는 Refs 보다는 state를 이용하기로 권장한다.\n\n```javascript\nclass CustomTextInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.focusTextInput = this.focusTextInput.bind(this);\n  }\n\n  focusTextInput() {\n    // Explicitly focus the text input using the raw DOM API\n    this.textInput.focus();\n  }\n\n  render() {\n    // Use the `ref` callback to store a reference to the text input DOM\n    // element in an instance field (for example, this.textInput).\n    return (\n      <div>\n        <input\n          type=\"text\"\n          ref={input => {\n            this.textInput = input;\n          }}\n        />\n        <input\n          type=\"button\"\n          value=\"Focus the text input\"\n          onClick={this.focusTextInput}\n        />\n      </div>\n    );\n  }\n}\n```\n\n- React는 컴포넌트가 마운트될 때 DOM 요소와 함께 ref 콜백을 호출하며 언마운트될 때 null 과 함께 호출한다. ref 콜백은 componentDidMount 나 componentDidUpdate 라이프사이클 훅 전에 호출된다.\n- ref 속성을 HTML 요소에서 사용하면, ref 콜백은 기본 DOM 요소를 인수로 받는다.\n\n> Refs는 언제 사용하면 좋을까?\n>\n> - input/textarea 포커스 제어, 텍스트 선택, 미디어 재생을 관리할 때\n> - 명령형 애니메이션을 발동시킬 때\n> - 써드 파티 DOM 라이브러리를 통합할 때\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f2c6e1de774cf12c864abb9275a4cfcf910767c3","text":"# 합성으로 컴포넌트에 다른 컴포넌트를 담아보자.\n\n- Title : 합성으로 컴포넌트에 다른 컴포넌트를 담아보자.\n- Date : 2020-01-13\n- Category: React\n\nModals을 만들면서 로그인 모달, 메모 모달 등 기능에 따라 모달 바디에 다른 UI를 보여주고 싶었다. 엘리먼트도 컴포넌트에 전달할 수 있을 까? 라는 의문으로 검색해보니 **Composition**이 나왔다.\n\n# 컴포넌트에 다른 컴포넌트를 담고 싶다면?\n\n## 예시 1\n\n<code>props.children</code>을 사용하여 자식 엘리먼트를 그대로 출력할 수 있다.\n\n```javascript\n// ...\nimport Login from \"./login\"; // 로그인 UI 컴포넌트\nimport ModalCard from \"./modalCard\"; // 모달 컴포넌트\n\nconst Bio = () => {\n  // ...\n  return (\n    <>\n      <ModalCard>\n        <Login />\n      </ModalCard>\n    </>\n  );\n};\n```\n\nModalCard JSX 태그 안에 있는 것들이 아래와 같이 ModalCard 컴포넌트의 children prop으로 전달됩니다.\n\n```javascript\n// ...\nconst ModalCard = props => {\n  return (\n    <>\n      <div className=\"modal is-active\">\n        <div className=\"modal-background\"></div>\n        <div className=\"modal-card\">\n          <header className=\"modal-card-head\">\n            <p className=\"modal-card-title\"></p>\n            <button className=\"delete\" aria-label=\"close\"></button>\n          </header>\n          <section className=\"modal-card-body\">{props.children}</section>\n        </div>\n      </div>\n    </>\n  );\n};\n// ...\n```\n\n## 예시 2\n\nReact에서 prop으로 전달할 수 있는 것에는 제한이 없기 때문에 이렇게도 된다.\n\n```javascript\n// ...\nimport ModalCard from \"./modalCard\"\nimport Login from \"./login\"\n\nconst Bio = () => {\n  // ...\n  return (\n    <>\n      {// ...}\n      <ModalCard headTitle={`Who are you?`} ContentComponent={Login} isActive={isActive}/>\n    </>\n  )\n}\n```\n\n```javascript\n// ...\nconst ModalCard = ({ headTitle, ContentComponent, isActive }) => {\n  return (\n    <>\n      <div className=\"modal\">\n        <div className=\"modal-background\"></div>\n        <div className=\"modal-card\">\n          <header className=\"modal-card-head\">\n            <p className=\"modal-card-title\">{headTitle}</p>\n            <button className=\"delete\" aria-label=\"close\"></button>\n          </header>\n          <section className=\"modal-card-body\">\n            <ContentComponent />\n          </section>\n        </div>\n      </div>\n    </>\n  );\n};\n```\n\n끝!\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"68ea80dc2124e8d2e6495a2ae7232f0d565aecf7","text":"# 운영체제 - 프로세스 동기화 1\n\n- Title : 운영체제 - 프로세스 동기화 1\n- Date : 2020-01-06\n- Category: 운영체제\n\n> 1. 프로세스 동기화란?\n> 2. 임계구역이란?\n> 3. 세마포란?\n\n# 프로세스 동기화(Process Synchronization, Thread Synchronization)\n\n프로세스들이 서로 공유하는 데이터에 동시에 접근할 때 순서대로 실행하여 **일관성있는 데이터를 유지**하는 것\n\n- Independent : 프로세스1과 프로세스2가 관계가 없을 때\n- Cooperating : 다른 프로세스에게 영향을 미치거나 다른 프로세스로부터 영향을 받을 때\n- 프로세스 간 통신 : 전자 우편, 파일 전송\n- 프로세스 간 자원 공유 : 메모리 상의 자료, 데이터베이스 등\n- 실생활 예 : 명절 기차표 예약, 대학 온라인 수강신청, 실시간 주식 거래\n\n## 프로세스/쓰레드 동기화를 하려면?\n\n- 임계구역 문제 해결(틀린 답이 나오지 않도록)\n- 프로세스 실행 순서 제어(원하는 대로)\n- busy wait 등 비효율성은 제거\n\n## 동기화 도구\n\n- 세마포(Semaphores)\n- 모니터(Monitors)\n- Misc.\n\n## 은행 계좌 예시\n\n아래의 코드는 공통 변수(balance)에 대해 동시 업데이트를 수행하여 0이 아닌 잘못된 결과값이 출력된다. 이는 한번에 한 쓰레드만 업데이트하도록 하여 해결할 수 있다. -> **임계구역 문제**\n\n```java\nclass Test {\npublic static void main(String[] args) throws InterruptedException {\n  BankAccount b = new\n  BankAccount();\n  Parent p = new Parent(b);\n  Child c = new Child(b);\n  p.start();\n  c.start();\n  p.join();\n  c.join();\n  System.out.println( \"\\nbalance = \" + b.getBalance());\n  }\n}\n```\n\n```java\nclass BankAccount {\n  int balance;\n  void deposit(int amount) {\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp; // 임계구역\n  }\n  void withdraw(int amount) {\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp; // 임계구역\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n\n```java\nclass Parent extends Thread {\n  BankAccount b;\n  Parent(BankAccount b) {\n    this.b = b;\n  }\n  public void run() {\n    for (int i=0; i<100; i++)\n    b.deposit(1000);\n  }\n}\nclass Child extends Thread {\n  BankAccount b;\n  Child(BankAccount b) {\n    this.b = b;\n  }\n  public void run() {\n    for (int i=0; i<100; i++)\n    b.withdraw(1000);\n  }\n}\n```\n\n# 임계구역 문제(The Critical-Section Problem)\n\n## 임계구역(Critical Section)\n\n여러 개의 스레드로 구성된 시스템에서 각 스레드가 같이 사용하는 변수, 테이블, 파일을 바꾸는 코드 영역을 임계구역이라고 한다. 예) 은행 계좌 예시에서 balance 값을 바꾸는 코드가 임계구역이다.\n\n## 임계구역 문제 해결방법 - 아래 3가지 다 만족해야한다!\n\n- Mutual exclusion (상호배타): 오직 한 쓰레드만 진입<br/>예) Parent 스레드가 임계구역 실행 중에는 Child 스레드는 임계구역에 들어갈 수 없다.\n- Progress (진행): 진입 결정은 유한 시간 내<br/>예) 임계구역에 어떤 스레드가 먼저 진입할지에 대한 결정은 유한 시간 내에 결정되어야 한다.\n- Bounded waiting (유한대기): 어느 쓰레드라도<br/>예) 어느 스레드라도 기다리고 있으면 유한한 시간내에 임계구역에 들어갈 수 있다.\n\n# 세마포 (Semaphore)\n\n동기화 문제 해결을 위한 소프트웨어 도구로 <span class=\"clr-note\">정수형 변수 + 두 개의 동작 (P, V)</span>으로 이루어져있다.\n\n## 동작\n\n- P: Proberen (test) → **acquire()**\n- V: Verhogen (increment) → **release()**\n\n## 구조\n\n- acquire() : 임계구역 전에 호출하여 value가 조건에 맞으면 **프로세스(or 스레드)를 list(큐)에 넣는다.** 큐에 들어간 프로세스는 다른 프로세스에 의해 release()가 호출될 때까지 Block된다. 즉 임계구역을 실행할 수 없게 된다. (Block이 된다 == Ready Queue에 들어가지 못한다)\n- release() : value 조건에 맞으면 list에서 **프로세스를 꺼내서 깨운다.** 깨운다는 것은 Ready Queue(cpu 서비스 기다리는 줄)에 넣는 다는 것을 의미한다.\n\n```java\nclass Semaphore {\n  int value; // number of permits\n\n  Semaphore(int value) {\n  ... }\n  void acquire() {\n    value--;\n    if (value < 0) {\n      add this process/thread to list;\n      block;\n    }\n  }\n  void release() {\n    value++;\n    if (value <= 0) {\n      remove a process P from list;\n      wakeup P;\n    }\n  }\n}\n\n```\n\n## 세마포의 사용 - 상호 배타(Mutual exclusion)\n\nsem.value = 1로 두어 임계구역에는 프로세스 한 개만 들어갈 수 있도록 한다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2020-01-06-img/1.png)<br/>\n\n아래 코드는 은행 계좌 예시의 BankAccount 클래스를 수정한 것으로 임계구역 문제를 해결한다.\n\n```java\nimport java.util.concurrent.Semaphore;\n\nclass BankAccount {\n  int balance;\n  Semaphore sem;\n  public BankAccount () {\n    this.sem = new Semaphore(1)\n  }\n  void deposit(int amount) {\n    try {\n      sem.acquire()\n    } catch(InterruptedException) {}\n\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp;\n    sem.release()\n  }\n  void withdraw(int amount) {\n    try {\n      sem.acquire()\n    } catch(InterruptedException) {}\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp;\n    sem.release()\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n\n1. Parent 프로세스가 deposit()을 호출하면 acquire() 메소드가 실행된다. 이는 value를 0으로 만드나 조건이 false라 바로 빠져나와 임계구역을 실행한다.\n2. 문맥 전환에 의해 Child 프로세스의 witdhdraw()가 호출되면 acquire()이 호출된다. value를 -1로 만들어 조건이 true가 되어 Child 프로세스는 큐에 들어가고 Block 된다. 즉, 임계구역을 못 간다.\n3. Parent 프로세스가 임계구역 실행을 완료한 후 release()를 호출하면 큐의 프로세스 하나를 뺀다. 즉, Child 프로세스를 깨워 Ready Queue로 보낸다.\n\n## 세마포의 사용 - 프로세스 실행 순서 제어(Ordering)\n\nCPU 스케줄링 알고리즘에 관련없이 P1에 들어간 S1 코드가 P2의 S2 코드보다 먼저 실행되게 하고 싶을 때? 세마포를 사용하자!\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2020-01-06-img/2.png)<br/>\n\n항상 입금이 먼저 되게 BankAccount 클래스를 수정해보자.\n\n```java\nimport java.util.concurrent.Semaphore;\n\nclass BankAccount {\n  int balance;\n  Semaphore sem;\n  Semaphore sem2;\n  public BankAccount () {\n    this.sem = new Semaphore(1);\n    this.sem2 = new Semaphore(0)\n  }\n  void deposit(int amount) {\n    try {\n      sem.acquire()\n    } catch(InterruptedException) {}\n\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp;\n    sem.release()\n    sem2.release()\n  }\n  void withdraw(int amount) {\n    try {\n      sem2.acquire()\n      sem.acquire()\n    } catch(InterruptedException) {}\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp;\n    sem.release()\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n\n이제 입출금 교대로 되게 BankAccount 클래스를 수정해보자.\n\n```java\nimport java.util.concurrent.Semaphore;\n\nclass BankAccount {\n  int balance;\n  Semaphore sem;\n  Semaphore dsem;\n  Semaphore wsem;\n  public BankAccount () {\n    this.sem = new Semaphore(1);\n    this.dsem = new Semaphore(0);\n    this.wsem = new Semaphore(0);\n  }\n  void deposit(int amount) {\n    try {\n      sem.acquire();\n    } catch(InterruptedException) {}\n\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp;\n    sem.release();\n    wsem.release();\n    try {\n      dsem.acquire();\n    } catch(InterruptedException) {}\n\n  }\n  void withdraw(int amount) {\n    try {\n      wsem.acquire();\n      sem.acquire();\n    } catch(InterruptedException) {}\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp;\n    sem.release();\n    dsem.release();\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n"}}}},"pageContext":{"id":"40f40953b7ab43bf93781786a87871d92de6d63c","previousPostId":"f2c6e1de774cf12c864abb9275a4cfcf910767c3","nextPostId":"68ea80dc2124e8d2e6495a2ae7232f0d565aecf7"}},"staticQueryHashes":["2685952063","2841359383"]}