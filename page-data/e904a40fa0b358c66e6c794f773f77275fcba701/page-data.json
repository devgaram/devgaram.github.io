{"componentChunkName":"component---src-templates-blog-post-js","path":"/e904a40fa0b358c66e6c794f773f77275fcba701","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e904a40fa0b358c66e6c794f773f77275fcba701","text":"# [안드로이드] 안드로이드 ViewModel에 대해 알아보자\n\n- Title : [안드로이드] 안드로이드 ViewModel에 대해 알아보자\n- Date : 2019-01-07\n- Category: Android\n\n안드로이드 아키텍쳐 중 ViewModel 클래스에 대한 내용입니다.\n\n안드로이드 프레임워크는 액티비티와 프래그먼트와 같은 UI 컨트롤러의 라이프 사이클을 관리한다.\n\n![액티비티가 회전을 거쳐 끝날 때까지의 라이프 사이클](https://raw.githubusercontent.com/devgaram/TIL/master/Android/images/2019-01-07-img/viewmodel-lifecycle.png)  \n[ UI 컨트롤러 라이프 사이클과 ViewModel 스코프]\n\n아래와 같은 구성 변경 발생 시, 안드로이드는 UI 컨트롤러를 종료하거나 재생성한다.\n\n- 런타임에 화면 방향이 전환되는 경우\n- 언어, 글꼴 배율과 같은 기기 구성이 변경되는 경우\n\n이 때 두가지 문제가 발생한다.\n\n## 1) UI에 종속된 데이터 손실\n\n해결1 - 적은 데이터의 경우 <code class=\"codetainer\">OnCreate()</code>에서 <code class=\"codetainer\">onSaveInstanceState()</code> 메서드를 사용하여 번들에서 해당 데이터를 복원할 수 있다.\n<span class=\"clr-grey\">많은 데이터와 비트맵에는 부적절하다.</span>  \n해결2 - UI가 없는 워커 프래그먼트에 UI에 필요한 데이터를 관리하고 프래그먼트를 <code class=\"codetainer\">SetRetainInstance(true)</code>로 설정함으로써 프래그먼트를 메모리에 유지(유보)시킨다.\n\n## 2) 메모리 누수, 리소스 낭비\n\nUI 컨트롤러 재생성 시 다시 데이터를 로드하므로 리소스가 낭비되며, UI 컨트롤러가 비동기 호출을 하고 콜백을 받을 때 해당 컨트롤러가 파괴되었다면 에러가 발생하거나 메모리 누수가 날 수도 있다.\n\n## 문제해결방법\n\nUI 컨트롤러는 아래와 같은 작업을 다루는 경향이 있다.\n\n- UI 데이터 표시\n- 사용자 행동에 반응\n- 권한 요청\n\n그러므로 데이터베이스 또는 네트워크에서 데이터를 요청하고 로드하는 작업은 다른 클래스에 위임하여 UI 컨트롤러 로직에서 뷰 데이터에 대한 소유권을 분리하는 것이 효율적이다.\n\n# ViewModel 클래스 구현\n\n[예제로 바로가기](/android/android-mvvm/#viewModel).\n\nArchitecture Components는 ViewModel 클래스를 제공한다.  \n**ViewModel 클래스의 인스턴스(객체)는 구성 변경에도 데이터를 유지하며, ViewModel 인스턴스는 재생성된 액티비티에서 즉시 사용될 수 있다.**\n소유자가 액티비티를 끝낼 때, 안드로이드는 ViewModel 객체의 <code class=\"codetainer\">onCleared()</code> 메서드를 호출하여 리소스를 정리한다.\n\n<span class=\"clr-note\">\nViewModel 사용 시 ViewModel에 액티비티, 프래그먼트, 뷰에 대한 컨텍스트를 저장해서는 안된다.     \n</span>\n\n<span class=\"clr-grey\">액티비티가 재생성 될 때, ViewModel은 액티비티 생명주기 외부에 존재하기 때문에 UI 컨텍스트를 ViewModel에 저장하면 메모리 락을 발생시키는 직접적인 원인이 된다. 단, Application 컨텍스트(전체 앱의 수명주기)를 저장하는 것은 괜찮다. Application 컨텐스트는 AndroidViewModel 클래스를 통해 받을 수 있다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"9aacac8dd60a2171340862343e0ee39877fa3df9","text":"# [안드로이드] 안드로이드 MVVM에 대해 알아보자1\n\n- Title : [안드로이드] 안드로이드 MVVM에 대해 알아보자1\n- Date : 2019-01-07\n- Category: Android\n\nCoding in Flow의 Room + ViewModel + LiveData + RecyclerView (MVVM) 튜토리얼을 정리했습니다.\n\n# 파일 구성\n\n- MainActivity.java\n- Note.java\n- NoteAdapter.java\n- NoteDao.interface\n- NoteDatabase.java\n- NoteRepository.java\n- NoteViewModel.java\n\n# MVVM - VIEW와 VIEWMODEL\n\n<span class=\"li-icon\">MainActivity.class : 앱의 시작점으로 RecyclerView 설정 및 ViewModel 생성하는 부분 </span>\n<span class=\"li-icon\">NoteViewModel.class : UI 컴포넌트와 UI 데이터의 분리</span>\n<span class=\"li-icon\">NoteAdapter.class : 리사이클러뷰 어댑터</span>\n<span class=\"li-icon\">NoteRepository.class : 저장소, 도메인과 모델 사이의 중간체 역할?</span>\n\n## 1. 리사이클러뷰 구현\n\n```java\nRecyclerView recyclerView = findViewById(R.id.recycler_view);\nrecyclerView.setLayoutManager(new LinearLayoutManager(this));   // 1)\nrecyclerView.setHasFixedSize(true); // 2)\n\nfinal NoteAdapter adapter = new NoteAdapter();  // 3)\nrecyclerView.setAdapter(adapter);   // 3-1)\n```\n\n1. LayoutManager 클래스, 아이템을 어떻게 배치할 것인가를 결정한다.  \n   <span class=\"clr-grey\">LinearLayoutManager 클래스 : 가로/세로 형태로 아이템을 배열한다.</span>\n\n2. 각 아이템의 변화가 리사이클러 뷰의 전체 크기에 영향을 끼치지 않는다면 true를 사용한다.\n\n3. 데이터를 리사이클러뷰에 연결해 줄 어댑터 객체 생성\n\n3-1) 3)에서 생성한 어댑터 객체를 리사이클러뷰에 붙인다.\n\n<span id=\"viewModel\"></span>\n\n## 2. ViewModel과 LiveData\n\n[뷰모델 개념 익히러가기](/android/android-viewModel/).\n\n```java\nnoteViewModel = ViewModelProviders.of(this).get(NoteViewModel.class);\n```\n\n**ViewModel 객체 요청**  \n보통 ViewModel 생성 요청은 <code class=\"codetainer\">onCreate()</code> 메서드에서 이루어지며, **ViewModelProvider 클래스**를 통해서 ViewModel 객체를 생성한다.\nViewModelProviders 클래스의 <code class=\"codetainer\">of(this)</code> 를 통해 this(UI 컨트롤러) 스코프를 가진 ViewModelProvider 인스턴스가 반환된다.\n리턴된 ViewModelProvider 객체의 메서드 <code class=\"codetainer\">get(NoteViewModel.class)</code> 를 통해 NoteViewModel 인스턴스가 생성된다.\n\n<span class=\"clr-grey\">**NOTE:** get()은 이미 ViewModel 객체가 생성되었을 경우, 그 객체를 리턴한다. </span>\n\n<span id=\"LiveData\"></span>\n**LiveData 사용**  \n[LiveData 개념 익히러가기](/android/android-LiveData/).\n\nnoteViewModel.java\n\n```java\npublic class NoteViewModel extends AndroidViewModel {\n    // ...생략\n    private LiveData<List<Note>> allNotes;\n\n    public NoteViewModel(@NonNull Application application) {\n        super(application);\n        repository = new NoteRepository(application);\n        allNotes = repository.getAllNotes();\n    }\n\n    // ...생략\n    public LiveData<List<Note>> getAllNotes() {\n        return allNotes;\n    }\n}\n```\n\nLiveData는 보통 ViewModel 내에서 함께 쓰인다.\n\nMainActivity.java\n\n```java\nnoteViewModel.getAllNotes().observe(this, new Observer<List<Note>>() {  // 1) LifeCycleOwner, Observer\n    @Override\n    public void onChanged(@Nullable List<Note> notes) { // 2)\n        // update RecyclerView\n        // Toast.makeText(MainActivity.this, \"onchanged\", Toast.LENGTH_SHORT).show();\n        adapter.setNotes(notes);\n    }\n});\n```\n\n1. <code class=\"codetainer\">noteViewModel.getAllNotes()</code>를 통해 LiveData를 리턴받고 <code class=\"codetainer\">observe()</code> 메서드를 통해 Observer를 붙여 감지를 시작한다.\n   <span class=\"clr-grey\">보통 Observer는 프래그먼트나 액티비티 같은 UI 컨트롤러에서 만든다.</span>  \n   <span class=\"clr-note\">LiveData의 data가 변경될 때 LifeCycleOwner가 활성화 되어있는 한 등록된 모든 Observer들 에게 이벤트를 보낸다.</span>\n\n2. Observer는 <code class=\"codetainer\">onChanged()</code> 메서드를 반드시 오버라이드해야하며, <code class=\"codetainer\">onChanged()</code> 메서드에서 UI 업데이트를 한다.\n\n# MVVM - MODEL\n\n<span class=\"li-icon\">NoteDatabase.class</span>\n<span class=\"li-icon\">NoteDao.interface</span>\n<span class=\"li-icon\">Note.class</span>\n\nRoom은 SQLite 추상계층을 감싸고 있으며, 쉽게 데이터베이스에 접근하여 SQLite를 자유롭게 사용할 수 있다. Room에는 세가지 주요한 컴포넌트가 있다.\n\n## 1. Database (NoteDatabase.class)\n\n데이터베이스 홀더를 포함하고, 관계형 데이터베이스에 접근할 수 있는 액세스 포인트를 제공한다.\n\n```java\n@Database(entities = {Note.class}, version = 1, exportSchema = false)   // 1)\npublic abstract class NoteDatabase extends RoomDatabase {\n\n    private static NoteDatabase instance;\n\n    public abstract NoteDao noteDao();  // 3)\n\n    public static synchronized NoteDatabase getInstance(Context context) {\n        if (instance == null) {\n            instance = Room.databaseBuilder(context.getApplicationContext(),    // 4)\n                    NoteDatabase.class, \"note_database\")\n                    .fallbackToDestructiveMigration()\n                    .addCallback(roomCallback)\n                    .build();\n        }\n        return instance;\n    }\n    // ..생략\n}\n```\n\n1. @Database 애노테이션을 클래스에 달아야하며, 데이터베이스와 관련된 Entity들은 애노테이션 인자값으로 포함해야한다.\n2. RoomDatabase를 상속한 abstract class여야 한다.\n3. abstract method 포함해야하는데, 이 메소드에는 인자가 0개이고 reture되는 클래스가 @Dao 애노테이션을 달고 있어야한다.\n4. 런타임때에는 Room.databaseBuilder() 또는 Room.inMemoryDatabaseBuilder()를 통해 Database의 객체를 얻어 낼 수 있다.\n\n<span class=\"clr-grey\">**Note:** RoomDatabase 객체를 인스턴스화 하는 비용은 매우 크므로 인스턴스를 얻는 작업을 싱글톤패턴으로 만드는 게 좋다.</span>\n\n```java\n@Database(entities = {Note.class}, version = 1, exportSchema = false)   // 1)\npublic abstract class NoteDatabase extends RoomDatabase {\n    private static NoteDatabase instance;\n    public abstract NoteDao noteDao();\n    // ..생략\n\n    private static RoomDatabase.Callback roomCallback = new RoomDatabase.Callback() {\n\n        // 데이터베이스가 처음 생성될 때 호출됨, 모든 테이블이 생성된 후 호출됨.\n        @Override\n        public void onCreate(@NonNull SupportSQLiteDatabase db) {\n            super.onCreate(db);\n            new PopulateDbAsyncTask(instance).execute(); // AsyncTask 실행\n        }\n    };\n\n    private static class PopulateDbAsyncTask extends AsyncTask<Void, Void, Void> {\n        private NoteDao noteDao;\n\n        private PopulateDbAsyncTask(NoteDatabase db) {\n            noteDao = db.noteDao();\n        }\n\n        @Override\n        protected Void doInBackground(Void... voids) {\n            noteDao.insert(new Note(\"Title 1\", \"Description 1\", 1));\n            noteDao.insert(new Note(\"Title 2\", \"Description 2\", 2));\n            noteDao.insert(new Note(\"Title 3\", \"Description 3\", 3));\n\n            return null;\n        }\n    }\n}\n```\n\n**AsyncTask클래스**  \n비즈니스 로직과 UI 컴포넌트 조작이 동시에 일어나야 할 때 유용하며, 비교적 오래 걸리지 않는 작업에 적합하다. 또한, task 캔슬이 용이하다.\n\nAsyncTask <Params, Progress, Result> 제너릭 타입\n<span class=\"li-icon\">Params: doInBackground 파라미타 타입이며, execute 메소드의 인자 값이 된다.</span>\n<span class=\"li-icon\">Progress: doInBakcgroud 작업 시 진행 단위의 타입으로 onProgressUpdate 파라미터의 타입이다.</span>\n<span class=\"li-icon\">doInBackground 리턴값으로 onPostExecute 파라미터 타입이다.</span>\n\n<span class=\"clr-grey\">**제네릭스(Generics):** 객체 생성시 타입을 선언하므로 캐스팅할 필요가 없으며, 다른 타입을 할당할 경우 컴파일 단계에서 예외처리가 된다. <T>는 객체(Object) 타입이다.</span>\n\n## 2. Entity (Note.class)\n\nEntity를 사용하여 데이터 구조를 정의하고, 데이터베이스 테이블을 표현한다.\n\n```java\n@Entity(tableName = \"note_table\")   // tableName 속성 : 테이블명을 Note로 사용하고 싶지 않을 때\npublic class Note {\n\n    @PrimaryKey(autoGenerate = true)    // 기본키 정의 필수\n    private int id;\n    @ColumnInfo(name = \"Notetitle\") // name 속성 : 필드명을 다르게 지정하고 싶을 때\n    private String title;\n    private String description;\n    private int priority;\n    @Ignore // 데이터베이스에서 칼럼으로 생성되기를 원치 않을 때\n    Bitmap picture;\n\n    public Note(String title, String description, int priority) {\n        this.title = title;\n        this.description = description;\n        this.priority = priority;\n    }\n\n    // ..생략 (반드시, getter setter 필요)\n}\n```\n\n## 3. DAO (NoteDao.interface)\n\n데이터베이스의 데이터에 접근하기 위해서는 DAO가 필요하다. 직접적인 쿼리를 작성하는 대신 DAO 클래스를 사용하여 데이터베이스에 추상적으로 접근한다. <span class=\"clr-note\">DAO는 interface나 abstract class가 되야한다.</span>\n\n```java\n@Dao\npublic interface NoteDao {\n\n    @Insert\n    void insert(Note note);\n\n    @Update\n    void update(Note note);\n\n    @Delete\n    void delete(Note note);\n\n    @Query(\"DELETE FROM note_table\")\n    void deleteAllNotes();\n\n    @Query(\"SELECT * FROM note_table ORDER BY priority DESC\")\n    LiveData<List<Note>> getAllNotes();\n}\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f3c739a9f9af2d42a8f59bed45bd78959efdcd6e","text":"# jekyll의 minimal-mistakes에서 자바스크립트 커스텀하는 방법\n\n- Title : jekyll의 minimal-mistakes에서 자바스크립트 커스텀하는 방법\n- Date : 2019-01-05\n- Category: Jekyll\n\nminimal-mistakes 테마를 적용한 jekyll 블로그를 커스텀하는 과정에서 자바스크립트 코드를 추가하는 방법입니다.  \nminimal-mistakes 문서에 자바스크립트 커스텀 방법이 잘 정리되어있습니다.\n[공식문서 바로가기](https://mmistakes.github.io/minimal-mistakes/docs/javascript/).\n\n---\n\n우리가 수정해야 할 파일은 /assets/js/ 에 위치한 \\_main.js 파일입니다.  \n하지만, jekyll은 \\_main.js 파일이 아닌 main.min.js 파일을 컴파일하여 화면에 반영합니다.  \nmain.min.js 는 \\_main.js 자바스크립트 코드를 압축화하고 난독화한 파일로 npm 패키지 중 하나인 uglify를 이용하여 만들 수 있습니다.\n\n## 1. npm 셋팅\n\n```\n> npm init\n```\n\n블로그 프로젝트 디렉토리 위치에서 위 코드를 실행시키면 package.json 파일이 생성됩니다.\n\n## 2. package.json 파일 수정\n\nhttps://github.com/mmistakes/minimal-mistakes/blob/master/package.json\npackage.json 파일을 아래와 같이 수정합니다.\n\n```json\n{\n  \"name\": \"minimal-mistakes\",\n  \"version\": \"4.14.2\",\n  \"description\": \"Minimal Mistakes 2 column Jekyll theme.\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/mmistakes/minimal-mistakes.git\"\n  },\n  \"keywords\": [\"jekyll\", \"theme\", \"minimal\"],\n  \"author\": \"Michael Rose\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mmistakes/minimal-mistakes/issues\"\n  },\n  \"homepage\": \"https://mmistakes.github.io/minimal-mistakes/\",\n  \"engines\": {\n    \"node\": \">= 0.10.0\"\n  },\n  \"devDependencies\": {\n    \"npm-run-all\": \"^4.1.5\",\n    \"onchange\": \"^5.1.3\",\n    \"uglify-js\": \"^3.4.9\"\n  },\n  \"scripts\": {\n    \"uglify\": \"uglifyjs assets/js/vendor/jquery/jquery-3.3.1.min.js assets/js/plugins/jquery.fitvids.js assets/js/plugins/jquery.greedy-navigation.js assets/js/plugins/jquery.magnific-popup.js assets/js/plugins/jquery.smooth-scroll.min.js assets/js/_main.js -c -m -o assets/js/main.min.js\",\n    \"add-banner\": \"node banner.js\",\n    \"watch:js\": \"onchange \\\"assets/js/**/*.js\\\" -e \\\"assets/js/main.min.js\\\" -- npm run build:js\",\n    \"build:js\": \"npm run uglify && npm run add-banner\"\n  }\n}\n```\n\n## 3. uglify 설치 및 실행\n\nuglify-js 패키지 설치\n\n```\n> npm install uglify-js\n```\n\npackage.json의 scripts 부분을 보면 build:js 스크립트 실행시 **npm run uglify && npm run add-banner** 를 실행하도로 되어있습니다.\n이를 참고하여 cmd에서 <code class=\"codetainer\">npm run build:js</code>를 실행해봅시다. 정상적으로 \\_main.js 파일이 main.min.js로 압축된 것을 확인할 수 있을 것입니다.\n\n## 4. jekyll serve 실행\n\n이미 서버가 실행되어있다면 자동으로 반영됩니다.  \n그렇지 않다면 다시 **jekyll serve** 를 통해 서버를 실행해주면 커스텀한 자바스크립트 코드가 반영된 것을 확인할 수 있습니다.\n"}}}},"pageContext":{"id":"e904a40fa0b358c66e6c794f773f77275fcba701","previousPostId":"9aacac8dd60a2171340862343e0ee39877fa3df9","nextPostId":"f3c739a9f9af2d42a8f59bed45bd78959efdcd6e"}},"staticQueryHashes":["2685952063","2841359383"]}