{"componentChunkName":"component---src-templates-blog-post-js","path":"/966ea5b2cd8e89dbab1723a18bec85539cbfa10a","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"966ea5b2cd8e89dbab1723a18bec85539cbfa10a","text":"# SPA, SSR vs CSR\n- Title : SSR vs CSR vs SPA\n- Date : 2020-08-22\n- Category : 프론트\n# SPA(Single Page Application)\n\n- 앱에 필요한 모든 정적 리소스를 **최초 한번만** 받아 오고 이후에는 동적으로 DOM을 구성하여 렌더링 되는 화면만 바꾼다.\n- 페이지가 한번 로딩된 이후 데이터를 수정하거나 조회할 때, 페이지가 새로 고침되거나 다른 페이지로 넘어가지 않는다.\n- 클라이언트 렌더링 방식을 채택\n\n**장점**\n- 전체적인 트래픽을 감소시킨다.\n- 새로고침이 발생하지 않아 네이티브 앱과 유사한 사용자 경험을 제공한다. -> **모바일 퍼스트** 전략에 적합\n\n**단점**\n- 모든 정적 리소스를 최초에 한번 다운로드하기 때문에 초기 구동 속도가 상대적으로 느리다. -> 최초 첫 페이지(어느 정도 그려진)를 서버로부터 받는 SSR을 진행하여 속도를 개선할 수 있다.\n- SEO(검색엔진 최적화) 문제 -> SPA 프레임워크(앵귤러, 리액트..)에서 SSR을 지원하여 SEO에 대응할 수 있다.\n\n**전통적 Link Tag와 차이**\n- Link tag는 새로운 페이지를 요청할 때마다 정적 리소스를 다운 받고 전체 페이지를 다시 렌더링한다.   \n- 새로고침이 매번 발생되어 사용성이 좋지 않고 변경이 필요 없는 부분을 포함하여 전체 페이지를 갱식하므로 비효율적이다.\n\n# SSR(Server Side Rendering)\n**서버**가 사용자에게 보여줄 페이지를 모두 구성하여 사용자에게 페이지를 보여주는 방식이다.\n\n1. 브라우저가 서버에 페이지 요청한다.\n2. 서버는 DB에서 데이터를 가져오든 뭐든, 필요한 데이터를 모두 매핑시킨 HTML을 만들어 브라우저에 응답한다.\n3. 브라우저는 응답 받은 페이지를 렌더링한다. 이 때부터 **사용자는 페이지를 볼 수 있다.** 동시에 브라우저는 필요한 JS 파일들을 다운 받는다. [Viewable]\n4. 브라우저가 React를 실행한다.\n5. 드디어 페이지가 사용자와 상호 작용 할 수 있게 된다. [Interactable]\n\n# CSR(Client Side Rendering)\n데이터 없는 빈 HTML 파일을 받아오고 데이터는 문서와 여러 static 파일들이 로드된 후에 요청해서 받아오는 방식\n\n1. 서버가 아래와 같은 빈 HTML을 보내준다.\n\n```html\n<html>\n  <head>\n    <script src=\"client-side-framework.js\"></script>\n    <script src=\"app.js\"></script>\n  </head>\n  <body>\n    <div class=\"container\"></div>\n  </body>\n</html>\n```\n\n2. 브라우저는 JS 파일을 다운로드 받는다.\n3. 브라우저가 리액트를 실행한다.\n4. 드디어 사용자가 페이지를 볼 수 있고 상호 작용할 수 있다. [Viewable & Interactable]\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e1d231567cddc9de8b345729cc86853dff9718ce","text":"# DOM API\n\n- Title : DOM API\n- Date : 2020-09-05\n- Category : 프론트\n\n# DOM(Document Object Model)\n\n- 문서 객체 모델은 HTML 또는 XML과 상호작용을 위한 일종의 API\n- 브라우저에 로드 되며 DOM tree 형태로 문서를 만듬 (노드로 트리를 구성, element, text string, coment)\n- 스크립트 또는 프로그래밍 언어를 웹 페이지에서 사용할 수 있게 연결 시킴\n- 자바 스크립트를 이용해 DOM을 수정할 수 있음\n- 웹 페이지를 객체 지향적으로 표현한 것\n- Dom Tree: 트리 구조 형태의 노드들이 문서를 만듬\n\n    ![DOM%20API%2045dcb9dfa98b4ca7969268d9de5e8451/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Front/images/2020-09-05-img/Untitled.png)\n\n    ![DOM%20API%2045dcb9dfa98b4ca7969268d9de5e8451/Untitled%201.png](https://raw.githubusercontent.com/devgaram/TIL/master/Front/images/2020-09-05-img/Untitled1.png)\n\n    예시)\n\n    HTMLElement ← HTMLMediaElement ← HMLTAudioElement ← <audio>\n\n    HTMLElement ← HTMLMediaElement ← HMLTVideoElement ← <video>\n\n# DOM API\n\n[Web API](https://developer.mozilla.org/ko/docs/Web/API)\n\n- DOM의 각 노드와 상호작용을 위한 인터페이스\n- 노드 생성, 이동, 수정\n- 노드에 이벤트 리스너 추가\n- 폼 데이터 조작\n- `<canvas>`, `2D 이미지`와 상호작용\n- media 관리 `<audio>` `<video>`\n- 웹페이지 컨텐츠 `드래그 앤 드랍`\n- 브라우저의 세션 기록에 접근 `History API`\n- `Web Components`, `Web Storage`, `Web Workers`, `WebSocket`, and `Server-sent events`."}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"0ccca43f88286fec26b69ffb24385bb7af57d737","text":"# CORS\n\n- Title : CORS\n- Date : 2020-08-15\n- Category : 프론트\n\n# SOP(Same-Origin Policy)\n**동일 출처 정책**으로 한 출처(Origin)에서 로드된 문서나 스크립트가 다른 출처의 자원과 상호 작용을 못하도록 제한하는 것을 말한다. <br/>\n이 정책으로 의해 XMLHttpRequest 객체로 특정 웹 페이지 접근할 때, 해당 페이지와 동일한 출처의 페이지에만 접근이 가능한 것이다.\n\n# 동일 출처(Origin)란?\n`Protocol`, `Host`, `Port` 가 모두 같을 때 동일 출처다.\n\n# CORS(Cross-Origin Resource Sharing)\n다른 출처의 자원과의 상호 작용을 위해 SOP 예외 조건으로 CORS 정책이 생겼다.    \nCORS 정책을 위반하지 않는 다면 다른 출처의 리소스를 공유할 수 있다.\n\n## 어떻게 CORS 정책을 위반했는 지 판단할까?\n출처를 비교하는 로직은 서버가 아닌 **브라우저**에 구현되어 있다.    \nCORS 정책에 위반하는 리소스 요청을 하면 서버가 같은 출처만 받겠다는 로직이 있는 경우가 아니면 서버는 정상적인 응답을 하고,\n이후 브라우저가 응답 헤더를 분석하여 CORS 정책 위반이라고 판단되면 그 응답을 사용하지 않는다.\n\n1. HTTP 프로토콜을 사용하여 리소스 요청을 한다.\n2. 이 때 브라우저는 요청 헤더의 Origin 필드에 출처를 담아 보낸다.\n3. 서버는 응답 헤더의 Access-Control-Allow-Origin 필드에 해당 리소스에 대한 접근이 허용된 출처를 담아 응답한다.\n4. 브라우저는 응답의 Access-Control-Allow-Origin 과 요청 헤더의 Origin을 비교하여 응답이 유효한 지 판단한다.\n\n# CORS, SOP 정책 존재 이유는?\n다른 출처의 애플리케이션이 서로 통신하는 것에 대해 아무런 제약도 존재하지 않으면 \n해커가 `CSRF(Cross-Site Request Forgery)`나 `XSS(Cross-Site Scripting)`와 같은 방법으로 앱 코드가 실행된 것처럼 꾸며 \n사용자의 정보를 탈취하기 쉬워진다. 또 개발자가 신경써야 할 일이 늘어난다.\n\n# Preflight, Simple, Credential Request 에서 CORS\n## 1. Preflight Request\npreflight는 브라우저가 본 요청을 보내기 전에 보내는 예비 요청을 말하며 HTTP METHOD 중 OPTIONS를 사용한다.    \n예비 요청은 본 요청을 보내기 전에 브라우저 스스로 안전한 요청인지 확인하는 과정이다.\n\n## 2. Simple Request\n예비 요청 없이 바로 본 요청을 보내는 경우로 발생 조건이 까다로워 해당 요청이 발생하는 경우는 드물다.\n- 요청 메소드: GET, HEAD, POST 중 하나만 사용 가능\n- Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width를 제외한 헤더를 사용 불가\n- 만약 Content-Type를 사용하는 경우에는 application/x-www-form-urlencoded, multipart/form-data, text/plain만 허용\n\n## 3. Credentialed Request\n다른 출처 간 통신에서 좀 더 보안을 강화하고 싶을 때 사용한다.\n\n```javascript\nfetch(url, {\n  credentials: 'include', // 요청에 인증과 관련된 정보를 포함하겠다.\n});\n```\n위와 같이 설정하면 요청 시 브라우저의 쿠키 정보가 함께 보내진다.\n\n단, `credentials: include`를 사용하면 브라우저는 `Access-Control-Allow-Origin: *` 처럼 와일드 문자를 허용하지 않게 된다.\n인증 정보가 담겨있는 상태에서 다른 출처에 요청을 하고 싶다면 아래 두가지를 추가해야 CORS 정책 위반을 피할 수 있다.\n\n- `Access-Control-Allow-Origin`에는 *를 사용할 수 없으며, 명시적인 URL이어야한다.\n- 응답 헤더에는 반드시 `Allow-Control-Allow-Credentials: true`가 존재해야한다.\n\n# CORS 해결 방법\n1. 서버에서 Access-Control-Allow-Origin 헤더에 알맞은 값 세팅하기\n2. Webpack Dev Server로 리버스 프록싱\n\n```javascript\nmodule.exports = {\n  devServer: {\n    proxy: {\n      '/api': {\n        target: 'https://api.evan.com',\n        changeOrigin: true,\n        pathRewrite: { '^/api': '' },\n      },\n    }\n  }\n}\n```\n"}}}},"pageContext":{"id":"966ea5b2cd8e89dbab1723a18bec85539cbfa10a","previousPostId":"e1d231567cddc9de8b345729cc86853dff9718ce","nextPostId":"0ccca43f88286fec26b69ffb24385bb7af57d737"}},"staticQueryHashes":["2841359383"]}