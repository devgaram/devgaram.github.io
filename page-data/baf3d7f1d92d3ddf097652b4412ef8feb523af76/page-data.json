{"componentChunkName":"component---src-templates-blog-post-js","path":"/baf3d7f1d92d3ddf097652b4412ef8feb523af76","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"baf3d7f1d92d3ddf097652b4412ef8feb523af76","text":"# 완전 초보를 위한 가상화 개념\n\n- Title : 완전 초보를 위한 가상화 개념\n- Date : 2020-02-19\n- Category: Infra\n\n이 포스팅은 완전 초보를 위한 글로 \"무슨 이거까지 설명해?\" 라는 생각이 들 수 있어요. 초보가 정리한 거라 오류가 있을 수도 있으니 발견하시면 코멘트 주세요! 😊\n\n> Windows 운영체제 위에서 Linux를 사용하기 위해 가상머신을 설치해본 적이 있나요? 주로 VM웨어사가 만든 하이퍼바이저 기반 가상머신 소프트웨어인 VM웨어 워크스테이션을 사용했을 거예요. 이처럼 하이퍼바이저(hypervisor)는 호스트 컴퓨터(여기선 윈도우 환경)에서 리눅스와 같은 다수의 운영체제를 동시에 실행할 수 있는 플랫폼을 제공해줘요.\n\n위 글에서 언급된 **가상화**, **가상머신**, **하이퍼바이저**를 설명할 수 있나요? 있다면, 고수네요. 부럽..🤣 초보인 저와 또 다른 초보를 위해 차근차근 정리해볼게요.\n\n<br/>\n\n---\n\n<br/>\n\n## 1. 가상화(virtualization)\n\n가상화는 컴퓨팅 리소스(서버, 데이터베이스, 스토리지, 애플리케이션 등)를 **추상화**하여 다수의 운영 체제 또는 애플리케이션 이미지를 하나의 물리적 서버에서 공유할 수 있도록 하는 프로세스예요. 물리적 컴퓨터 수를 줄일 수 있어 **비용 절감**에 효과적인데요. 대부분의 서버는 단지 용량의 10~15%만 사용하는 데 가상화를 통해 서버 효용률을 70% 이상으로 올릴 수 있기 때문이죠.\n\n## 2. 가상 머신(virtual machine, VM)\n\n**가상머신**은 컴퓨팅 환경을 소프트웨어로 구현한 것으로 컴퓨터를 **에뮬레이션**하는 소프트웨어예요.\n에뮬레이터 역할을 하는 거죠. 가상 머신은 CPU를 포함한 모든 하드웨어를 가상화하여 가상머신상에서 운영체제나 응용 프로그램을 설치하고 실행할 수 있게 해요.\n\n<span class=\"clr-grey\">에뮬레이션은 한 시스템을 복제하여 그 시스템을 흉내 내는 것으로 가상화 구현에서는 CPU를 포함한 모든 하드웨어를 가상화하는 것을 말해요. 즉, 옵코드가 달라도 실행 가능하죠. PC에서 실행되는 수많은 게임 에뮬레이터도 이런 가상화 기술 중 하나예요. 느리다는 단점이 있긴 하죠.</span>\n\n## 3. 하이퍼바이저(hypervisor)\n\n호스트 컴퓨터에서 다수의 게스트 OS를 동시에 실행할 수 있게 하는 소프트웨어로 가상화 머신 모니터 또는 가상화 머신 매니저라고 불러요. 하이퍼바이저는 아래와 같이 2가지 타입으로 나눠져요.\n<br/><br/>\n\n<div style=\"text-align:center\">\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-19-img/Hyperviseur.png)\n<br/>\n<span class=\"clr-grey\">위키피디아 하이퍼바이저</span>\n\n</div>\n<br/>\n\n### 타입 2 (호스트형)\n\n일반 프로그램과 같이 하이퍼바이저는 호스트 OS 위에서 실행돼요. VM 내부에서 동작되는 게스트 OS는 하드웨어에서 3번째 수준으로 실행되는 거죠. 타입1에 비해 오버헤드가 크지만, 게스트 OS 종류에 대한 제약이 없고 데스크탑, 노트북에서도 운영할 수 있어요.\n\n<BR/>\n\n### 타입 1 (native 또는 bare-metal)\n\n타입2와 달리 **호스트 OS 없이** 하드웨어 위에 하이퍼바이저가 바로 위치해요. 별도의 호스트 OS가 없기에 오버헤드가 적고 하드웨어를 직접 제어하기 때문에 효율적으로 리소스를 사용할 수 있어요. 하지만 여러 하드웨어 드라이버를 세팅해야 하므로 설치가 어려워요. VM 내부의 게스트 OS는 하드웨어 위에서 2번째 수준으로 실행되는 거죠.\n\n<span class=\"clr-grey\">네이티브형 하이퍼바이저는 전가상화, 반가상화 방식으로 세분화할 수 있어요. 하이퍼바이저를 통해 가상 머신 내의 게스트 OS가 호스트 시스템을 활용한다는 점을 같지만, 하드웨어와 인터랙션하는 방식에 차이가 있어요.</span>\n\n**1) 전가상화(Full-virtualization, Native-virtualization)**\n\n동일한 아키텍처에서 실행되는 게스트 OS를 **수정없이** 그대로 띄워주는데 필요한 하드웨어를 모두 에뮬레이션 하는 형식으로 가상화해요.\n\n- 게스트 OS는 하드웨어에 직접 액세스 하는 것으로 인식해요. 사실 이 하드웨어는 하이퍼 바이저가 하드웨어를 에뮬레이션한 복제품이죠. 그래서 게스트 OS는 하드웨어를 자신이 소유하고 있는 걸로 인식해요.\n- 하이퍼바이저는 게스트 OS가 하드웨어에 주는 명령을 감시해 \"하드웨어를 독점\"하는 명령이 발생하면 별도로 핸들링 해줘야 해요. 즉, 하이퍼바이저가 게스트 OS와 하드웨어 사이의 **중재자** 역할을 하죠. 그 전에 모든 게스트 OS는 \"DOM 0\"이라는 관리 머신을 거쳐 하이퍼바이저와 통신해요\n- 매번 하이퍼바이저와 통신하므로 CPU와 RAM처럼 I/O가 잦은 자원을 컨트롤 하기에는 번거롭기에 아래의 반가상화 방식이 출현했어요.\n\n**2) 반가상화(Para-virtualization)**\n\n하드웨어 에뮬레이션 없이 하이퍼바이저를 통해 하이퍼바이저가 제공하는 API를 이용한 OS를 실행할 수 있는 가상화해요. **게스트 OS를 하이퍼바이저의 API를 이용할 수 있도록 수정**해야해요. 게스트 OS를 수정해야 하므로 좀 번거롭죠.\n\n- 게스트 OS는 하드웨어에 하이퍼바이저가 제공한 API를 통해서 엑세스할 수 있어요.\n- 게스트 OS 입장에선 하드웨어를 소유하고 있지 않다는 것을 알고 있으므로 하드웨어를 독점하는 명령을 하지 않아요.\n- 각각의 게스트 OS는 필요한 자원을 직접 API를 통해 요청할 수 있으므로 모든 요청을 \"DOM 0\"가 한꺼번에 처리하여 하드웨어를 제어하는 전가상화 방식에 비해 성능이 좋아요.\n\n## 4. 컨테이너 기반의 가상화(도커) - 추후 추가예정\n\nOS레벨 가상화(OperatingSystem-level virtualization)는 OS상에서 같은 OS를 하나 더 사용하는것 처럼 꾸며주는 가상화로 가상화로 인한 속도저하가 없다고 생각해도 무방해요. 특히 OS레벨 가상화는 요즘 가장 핫한 방식인데, Container 를 사용해 SaaS, PaaS를 제공하는 Docker 와, 수많은 Container 관리를 용이하게 해주는 Kubernetes가 그 중심에 있다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"a235f572d3b9bbda67147d2603cbeadcb82d0eda","text":"# AWS 연습하자 1탄 - AWS EC2 인스턴스에 Jenkins 서버 구축하기\n\n- Title : AWS 연습하자 1탄 - AWS EC2 인스턴스에 Jenkins 서버 구축하기\n- Date : 2020-02-24\n- Category: Infra\n\nAWS 연습하기 1탄에서는 AWS EC2에 인스턴스를 생성하고 Jenkins를 구축하는 과정을 다뤄보겠습니다. AWS에서 제공하는 [가이드](https://d1.awsstatic.com/Projects/P5505030/aws-project_Jenkins-build-server.pdf)를 참고하여 실습을 진행했습니다.\n\n# AWS EC2 인스턴스를 생성하기\n\n먼저 [Amazon EC2 console](https://console.aws.amazon.com/ec2/)로 이동해서 우측 상단의 Region을 서울로 설정합니다.\n\n인스턴스 생성에 앞서 키 페어부터 생성하도록 하겠습니다.\n왼쪽 네비게이션 바에서 **네트워크 및 보안 -> 키 페어 -> 키 페어 생성** 을 클릭합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/1.PNG)\n\n이름을 입력 후 파일 형식은 pem을 선택하고 키 페어 생성 버튼을 누르면 .pem 파일 형식의 개인키가 다운로드됩니다. 인스턴스 생성, 연결 시 필요하므로 **꼭 잘 보관해두세요**.\n\n> 윈도우 10은 openssh가 내장되어있어 ssh 명령어를 사용할 수 있습니다. ssh를 지원하지않는 경우라면 ppk를 사용하시면 됩니다.\n\n이제 인스턴스를 생성하겠습니다. **EC2 대시보드 -> 인스턴스 시작 섹션 -> 인스턴스 시작** 을 선택합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/2.PNG)\n\n**단계 1: AMI 선택** 에서 Amazon Linux AMI 프리 티어 사용 가능한 AMI를 선택하세요.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/3.PNG)\n\n**단계 2: 인스턴스 유형 선택** 에서 디폴트로 선택된 t2.micro를 선택한 후 다음: 인스턴스 세부 정보 구성을 선택합니다.\n\n**단계 3: 인스턴스 세부 정보 구성** 에서 디폴트 값을 그대로 사용하겠습니다. 다음:스토리지 추가를 선택합니다.\n\n**단계 4: 스토리지 추가** 에서 프리티어는 최대 30GB의 EBS 범용(SSD) 또는 마그네틱 스토리지를 사용할 수 있습니다. 크기 항목에 8로 되어있는 것을 30으로 수정한 후 다음:태그 추가를 클릭합니다.\n\n**단계 5: 태그 추가** 에서 여러 인스턴스를 태그로 검색이나 그룹짓기 위해 아래와 같이 태그를 추가합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/4.PNG)\n\n**단계 6: 보안 그룹 구성** 에서 인스턴스 방화벽 역할을 하는 보안 그룹을 설정하겠습니다. 보안그룹에서 인바운드와 아웃바운드 트래픽을 인스턴스 레벨에서 컨트롤할 수 있습니다.\n\n우선 디폴트로 있는 SSH 유형의 소스를 내 IP로 변경합니다. SSH의 소스를 모든 IPv4(0.0.0.0/0)으로 설정하는 것은 보안상 추천하지않습니다.\n\nHTTP, HTTPS 유형을 추가하고 소스를 0.0.0.0/0으로 설정합니다. 외부에서 이 서버로 접속하려면 꼭 설정해야합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/5.PNG)\n\n**검토 및 시작 -> 시작 -> 기존 키 페어 선택 또는 새 키 페어 생성 모달** 을 띄웁니다. 앞에서 키 my-key-pair 이름으로 키 페어를 생성해놨던 것을 여기서 사용할 것입니다. 아래와 같이 선택한 후 인스턴스 시작을 클릭합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/6.PNG)\n\n인스턴스 상태가 running이 되면 정상적으로 인스턴스 생성 및 실행이 완료된 것입니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/7.PNG)\n\n# Jenkins 설치하기\n\n방금 생성한 ec2 인스턴스에 젠킨스를 구축하려면 보안 그룹을 편집해야합니다.\n\n보안그룹에서 HTTPS 프로토콜을 제거하고 사용자 지정 TCP 규칙을 추가하겠습니다.\n\n스크롤을 오른쪽으로 해보면 보안그룹이 보입니다. 바로 밑의 링크를 클릭하여 인스턴스 보안그룹으로 이동합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/8.PNG)\n\n아래 사진과 같이 EC2 인스턴스를 생성할 때 설정한 보안 그룹의 내용을 확인할 수 있습니다. 이제 편집 버튼을 눌러서 수정하겠습니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/9.PNG)\n\nHTTPS 프로토콜을 삭제하고 사용자 지정 TCP 규칙을 추가 후 포트 범위로는 8080을 입력합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/10.PNG)\n\n본격적으로 젠킨스를 설치하고 환경을 설정하겠습니다.\n\n윈도우10에서 cmd 창을 킨 다음 my-key-pair.pem이 있는 폴더로 이동합니다.\n\n```\nC:\\Users\\USER>cd C:\\Users\\USER\\github\\project\\devrami-blog\\aws\n```\n\n개인키 my-key-pair.pem을 가지고 인스턴스에 접속하겠습니다.\n\n```\nssh -i my-key-pair.pem ec2-user@퍼블릭DNS\n```\n\n**Are you sure you want to continue connecting\n(yes/no)?** 가 뜨면 yes를 입력한 후 엔터를 누릅니다.\n\n아래와 같은 문구를 보게되면 인스턴스에 성공적으로 접속된 것입니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/images/2020-02-24-img/11.PNG)\n\n다음과 같이 커맨드를 입력합니다.\n\n```\nsudo yum update –y\n```\n\n> - Yum은 RPM 기반의 시스템을 위한 자동 업데이트 겸 패키지 설치/제거 도구\n> - RPM은 원래 레드햇에서 사용되었던 패키지 파일이었지만 현재는 많은 RPM 기반 배포판(RPM 패키지, RPM 패키지 관리 도구)이 사용되고 있습니다. 즉, RPM을 사용하면 각종 소프트웨어의 설치 및 업데이트를 굉장히 편하게 할 수 있습니다.\n\nAWS는 기본적으로 OS 설치시 타임존이 UTC로 맞춰져있어서 한국 시간에 맞추기위해 다음 작업을 추가로 하겠습니다.\n\n```\n# 날짜확인\ndate\n\nsudo rm /etc/localtime\nsudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime\n\n```\n\nyum이 젠킨스 설치 위치를 알 수 있도록 젠킨스 레파지토리를 추가합니다.\n\n```\nsudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo\n```\n\n패키지를 설치할 수 있게 젠킨스 키 파일을 rpm에 추가한다.\n\n```\n sudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key\n```\n\n> rpm 포맷은 전자서명을 첨부하여 위변조 여부를 확인할 수 있습니다. rpm 패키지가 위변조 되면 에러가 발생합니다. 다른 제조사가 서명했는데 서명자의 검증용 키가 없을 경우도 검증이 실패하게 되는 데 이럴 경우 --import 옵션을 이용하여 검증용 키를 rpm에 추가하면 됩니다.\n\n젠킨스를 설치하겠습니다.\n\n```\nsudo yum install jenkins -y\n```\n\n젠킨스 서버를 시작합니다.\n\n```\n sudo service jenkins start\n```\n\n> 다음과 같은 에러가 발생하면 자바 버전 문제로 자바8로 재 설치한 후 다시 서버를 시작하시면 됩니다.  \n> **Starting jenkins (via systemctl): Job for jenkins.service failed because the control process exited with error code. See \"systemctl status jenkins.service\" and \"journalctl -xe\" for details.**\n>\n> ```\n> sudo yum remove java-1.7.0-openjdk\n> sudo yum install java-1.8.0\n> ```\n\n# Jenkins 설정하기\n\n브라우저에서 http://퍼블릭DNS:8080 로 접속하면 아래와 같은 화면이 보일 것입니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/12.PNG)\n\n근데 매번 8080 포트 입력하기 귀찮죠? Nginx를 프록시로 사용해서 80포트로 들어오면 8080으로 연결되게 추가 설정을 진행하도록 하겠습니다.\n\n우선 Nginx를 설치해줍니다. nginx는 yum으로 설치할 수 없어서 아래처럼 설치해줍니다.\n\n```\nsudo amazon-linux-extras install nginx1\n```\n\nnginx 서비스를 시작합니다.\n\n```\nsudo service nginx start\n```\n\n이제 포트없이 퍼블릭 도메인으로 들어가보면 아래 화면처럼 보일 것입니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/17.PNG)\n\n자! 그럼 젠킨스 서버로 프록시하기위해 추가 설정을 하도록하겠습니다.\n\nnginx 설정 파일에서 location에 proxy_pass 정보를 추가하겠습니다.\n\n```\nsudo vi /etc/nginx/nginx.conf\n```\n\n다음과 같이 입력하면됩니다.\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/18.PNG)\n\n저장 후 nginx 서비스를 재시작하면 처음에 8080포트로 들어갔을 때 봤던 화면이 포트없이 접속해도 잘 보이는 것을 확인할 수 있을 것입니다.\n\n```\nsudo service nginx restart\n```\n\n이제 젠킨스 내부에서 설정을 해보겠습니다.\n\n접속을 위해 **/var/lib/jenkins/secrets/initialAdminPassword** 에 있는 패스워드를 찾습니다.\n\n```\n sudo cat /var/lib/jenkins/secrets/initialAdminPassword\n```\n\n위 커맨드로 나오는 내용을 복사하여 Administrator password에 입력한 후 continue 버튼을 클릭합니다.\n\nCustomize Jenkins 페이지에서 **Install suggested plugins** 를 선택합니다. 플러그인 설치가 완료되면 Create First Admin User 페이지에서 관리자 계정을 생성합니다. 여기까지 완료했으면 이 페이지를 볼 수 있을 것입니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/13.PNG)\n\n[AWS 연습하자 2탄 - Jenkins와 Github 연동하기](/post/2020-02-25-how-to-use-aws) 로 이어집니다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"77ee51be00a66cb386e84663fe372b319859e4f3","text":"# 알고리즘 개념 잡자 - 그래프\n\n- Title : 알고리즘 개념 잡자 - 그래프\n- Date : 2020-02-01\n- Category: Algorithm\n\n> 참고서적\n>\n> - [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539)\n\n<br/>\n\n# 1. 그래프(graph)란\n\n- 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조다.\n- 정점(vertex)과 간선(edge)들의 집합으로 구성된다 => G = (V, E)\n- 정점 == 객체 == 노드, 간선 == 관계 == 노드\n- 그래프로 표현할 수 있는 것들) 도로, 영역 간 인접 관계, 선수 과목\n- 간선의 종류에 따라 무방향 그래프와 방향 그래프로 구분된다.\n\n> **오일러 경로**\n>\n> - 모든 간선을 한번만 통과하면서 처음 정점으로 되돌아오는 경로다.\n> - 그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 오일러 경로가 존재한다.\n\n# 2. 그래프 용어정리\n\n- 가중치 그래프(네트워크) : 간선에 비용이나 가중치가 할당된 그래프\n- 차수(degree) : 정점이 가지고 있는 인접 링크의 수\n- 인접 정점(adjacent vertex) : 간선에 의해 직접 연결된 정점\n  - 무방향 그래프에서 정점의 차수(degree)는 인접 정점의 수다.\n  - 무방향 그래프에 존재하는 정점의 모든 차수를 합하면 그래프의 간선 수의 2배가 된다.\n- 방향 그래프 : 간선에 방향성이 존재하는 그래프\n  - 집입 차수(in-degree) : 외부에서 오는 간선 수\n  - 진출 차수(out-degree) : 외부로 향하는 간선 수\n  - 정점의 진입 차수와 진출 차수의 합은 방향 그래프의 간선의 수가 된다.\n- 경로 길이(path length) : 경로를 구성하는 데 사용된 간선의 수\n  - 단순 경로(simple path) : 경로 중에서 반복되는 간선이 없는 경우\n  - 사이클(cycle) : 단순 경로의 시작 정점과 종료 정점이 동일한 경우\n- 연결 그래프(connected graph) : 무방향 그래프에 있는 모든 정점에 대해 항상 경로가 존재하면 그래프는 연결되어 있다고 한다.\n  - 그래프의 어느 두 정점을 선택해도 그 사이에 경로가 존재하면 연결 그래프다.\n  - 트리는 그래프의 특수한 형태로 사이클을 가지지 않는 연결 그래프이다.\n- 완전 그래프(complete graph) : 그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프\n  - 무방향 완전 그래프의 정점 수가 n이면 하나의 정점은 n-1개의 다른 정점으로 연결되므로 간선의 수는 n x (n-1)/2가 된다.\n\n# 3. 그래프의 구현\n\n## 1) 인접 행렬(adjacency matrix)\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-23-img/1.png)<br/>\n\n- 2차원 배열로 표현\n- n개의 정점을 가지는 그래프를 표현하기 위해서는 n<sup>2</sup>의 메모리 공간이 필요해서 간선이 많이 존재하는 밀집 그래프를 표현하는 경우에 적합하다.\n- 간선 수가 적은 최소 그래프의 경우에는 메모리의 낭비가 크므로 부적합하다.\n- 두 정점을 연결하는 간선의 존재 여부를 O(1) 시간 안에 알 수 있다.\n- 정점의 차수는 인접 행렬의 행이나 열을 조사하면 알 수 있으므로 O(n)의 연산에 알 수 있다.\n- 정점 i에 대한 차수는 인접 행렬의 i번째 행에 있는 값을 모두 더하면 된다.\n- 그래프에 존재하는 모든 간선의 수를 알아내려면 인접 행렬 전체를 조사해야하므로 O(n<sup>2</sup>)의 시간이 요구된다.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n  int n, m; // n: 정점개수, m: 간선 개수\n  int v1, v2, d, c; // v1: 정점1, v2: 정점2, d: 0(무방향) 1(v1->v2), c: 간선 가중치 (1이상)\n  scanf(\"%d %d\", &n, &m);\n\n  int graph[n+1][n+1] = {0}; // 0으로 초기화\n\n  for (int i=0; i<m+1; i++) {\n    scanf(\"%d %d %d %d\", &v1, &v2, &d, &c);\n    if (d == 0) {\n      graph[v1][v2] = graph[v2][v1] = c;\n    } else {\n      graph[v1][v2] = c;\n    }\n  }\n\n  return 0;\n}\n```\n\n## 2) 인접 리스트(adjacency list)\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-23-img/2.png)<br/>\n\n- 각 정점에 인접한 정점들을 연결리스트로 표현\n- 각 연결 리스트들은 헤드 포인터를 가지고 있고 이 헤드 포인터들은 하나의 배열로 구성되어 있어 정점의 번호만 알면 이 번호를 배열의 인덱스로 하여 각 정점의 연결리스트에 쉽게 접근할 수 있다.\n- 정점의 수가 n개고 간선의 수가 e개인 무방향 그래프를 표시하기 위해서는 n개의 연결 리스트가 필요하고 n개의 헤드 포인터와 2e개의 노드가 필요하다.\n- 간선의 개수가 적은 희소 그래프의 표현에 적합하다.\n- 간선의 존재 여부나 정점 i의 차수를 알기 위해서는 정점 i의 연결리스트를 탐색해야 하므로 연결리스트에 있는 노드의 수만큼(정점 차수만큼)의 시간이 필요하다.\n- n개의 정점, e개의 간선을 가진 그래프의 전체 간선 수를 알아내려면 O(n+e)의 연산이 요구된다.\n\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main() {\n  int n, m;\n  int v1, v2, d, c;\n  scanf(\"%d %d\", &n, &m);\n\n  vector<pair<int, int> > graph[n+1];\n\n  for (int i=0; i<m+1; i++) {\n    scanf(\"%d %d %d %d\", &v1, &v2, &d, &c);\n    if (d == 0) { // 무방향\n      graph[v1].push_back(make_pair(v2, c));\n      graph[v2].push_back(make_pair(v1, c));\n    } else {\n      graph[v1].push_back(make_pair(v2, c));\n    }\n  }\n}\n```\n\n# 4. 그래프 탐색\n\n- 그래프에서 모든 노드를 방문하고 싶다면?\n  - DFS, BFS 중 아무거나 사용해도 상관없으나 DFS가 좀 더 간단하긴 하다.\n- 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶다면?\n  - BFS가 일반적으로 더 낫다.\n  - DFS는 경로를 찾을 수는 있겠지만 모든 노드를 탐색해야할지도 모르고 최단 경로가 아닐 수도 있다.\n\n## 1) 깊이 우선 탐색(DFS)\n\n> 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 가다가 더 이상 갈 수 없게 되면 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색을 진행하는 방법과 유사하다.\n\n- 순환 호출이나 명시적 스택을 사용한다.\n- 전위 순회를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류다.\n- 그래프 탐색의 경우는 어떤 노드를 방문했었는지 여부를 반드시 검사해야한다. 이를 검사하지 않으면 무한 루프에 빠질 위험이 있다.\n- 정점의 수가 n, 간선의 수가 e인 그래프를 깊이 우선 탐색하는 시간은? (힌트 : 모든 간선을 조사한다.)\n  - 인접리스트 : O(n+e)\n  - 인접행렬 : O(n<sup>2</sup>)\n\n**인접 행렬로 표현된 무방향 그래프 DFS**\n\n```cpp\n#include <iostream>\n#define MAX_V 20; // 정점 최대 값\nusing namespace std;\n\nint n; // 입력받은 정점의 수\n\nvoid dfs(int graph[][MAX_V], int visited[], int v) {\n  visited[v] = true;\n  printf(\"%d\", v);\n  for (int i=0; i<n+1; i++) {\n    if (graph[v][i] == 1 && !visited[i]) dfs(graph, visited, i);\n  }\n}\n```\n\n## 2) 너비 우선 탐색(BFS)\n\n- 큐를 사용한다.\n- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.\n\n**인접 행렬로 표현된 무방향 그래프 BFS**\n\n```cpp\n#include <iostream>\n#include <queue>\n#define MAX_V 20; // 정점 최대 값\nusing namespace std;\n\nint n; // 입력받은 정점의 수\n\nvoid bfs(int graph[][MAX_V], int visited[], int v) {\n  visited[v] = true;\n  queue<int> q;\n  q.push(v);\n\n  while(!q.empty()) {\n    int top = q.front();\n    q.pop();\n    printf(\"%d\", top);\n\n    for (int i=0; i<n+1; i++) {\n      if (graph[v][i] == 1 && !visited[i]) {\n        q.push(i);\n        visited[i] = true;\n      }\n    }\n  }\n\n}\n\n```\n\n## 3) 양방향 탐색\n\n- 출발지와 도착지 사이에 최단 경로를 찾을 때 사용한다.\n- 출발지, 도착지 두 노드에서 동시에 너비 우선 탐색을 수행한 뒤, 두 탐색 지점이 충돌하는 경우에 경로를 찾는 방법이다.\n- 두 탐색 알고리즘이 대략 d/2 단계(s와 t 사이의 중간 지점)에서 충돌하여 각 출발지와 도착지 노드의 방문 노드의 개수는 대략 k<sup>d/2</sup>가 된다. (k : 각 노드의 인접 노드의 개수)\n"}}}},"pageContext":{"id":"baf3d7f1d92d3ddf097652b4412ef8feb523af76","previousPostId":"a235f572d3b9bbda67147d2603cbeadcb82d0eda","nextPostId":"77ee51be00a66cb386e84663fe372b319859e4f3"}},"staticQueryHashes":["2841359383"]}