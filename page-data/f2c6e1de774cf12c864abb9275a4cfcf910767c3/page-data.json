{"componentChunkName":"component---src-templates-blog-post-js","path":"/f2c6e1de774cf12c864abb9275a4cfcf910767c3","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f2c6e1de774cf12c864abb9275a4cfcf910767c3","text":"# 합성으로 컴포넌트에 다른 컴포넌트를 담아보자.\n\n- Title : 합성으로 컴포넌트에 다른 컴포넌트를 담아보자.\n- Date : 2020-01-13\n- Category: React\n\nModals을 만들면서 로그인 모달, 메모 모달 등 기능에 따라 모달 바디에 다른 UI를 보여주고 싶었다. 엘리먼트도 컴포넌트에 전달할 수 있을 까? 라는 의문으로 검색해보니 **Composition**이 나왔다.\n\n# 컴포넌트에 다른 컴포넌트를 담고 싶다면?\n\n## 예시 1\n\n<code>props.children</code>을 사용하여 자식 엘리먼트를 그대로 출력할 수 있다.\n\n```javascript\n// ...\nimport Login from \"./login\"; // 로그인 UI 컴포넌트\nimport ModalCard from \"./modalCard\"; // 모달 컴포넌트\n\nconst Bio = () => {\n  // ...\n  return (\n    <>\n      <ModalCard>\n        <Login />\n      </ModalCard>\n    </>\n  );\n};\n```\n\nModalCard JSX 태그 안에 있는 것들이 아래와 같이 ModalCard 컴포넌트의 children prop으로 전달됩니다.\n\n```javascript\n// ...\nconst ModalCard = props => {\n  return (\n    <>\n      <div className=\"modal is-active\">\n        <div className=\"modal-background\"></div>\n        <div className=\"modal-card\">\n          <header className=\"modal-card-head\">\n            <p className=\"modal-card-title\"></p>\n            <button className=\"delete\" aria-label=\"close\"></button>\n          </header>\n          <section className=\"modal-card-body\">{props.children}</section>\n        </div>\n      </div>\n    </>\n  );\n};\n// ...\n```\n\n## 예시 2\n\nReact에서 prop으로 전달할 수 있는 것에는 제한이 없기 때문에 이렇게도 된다.\n\n```javascript\n// ...\nimport ModalCard from \"./modalCard\"\nimport Login from \"./login\"\n\nconst Bio = () => {\n  // ...\n  return (\n    <>\n      {// ...}\n      <ModalCard headTitle={`Who are you?`} ContentComponent={Login} isActive={isActive}/>\n    </>\n  )\n}\n```\n\n```javascript\n// ...\nconst ModalCard = ({ headTitle, ContentComponent, isActive }) => {\n  return (\n    <>\n      <div className=\"modal\">\n        <div className=\"modal-background\"></div>\n        <div className=\"modal-card\">\n          <header className=\"modal-card-head\">\n            <p className=\"modal-card-title\">{headTitle}</p>\n            <button className=\"delete\" aria-label=\"close\"></button>\n          </header>\n          <section className=\"modal-card-body\">\n            <ContentComponent />\n          </section>\n        </div>\n      </div>\n    </>\n  );\n};\n```\n\n끝!\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e5e224acdcb2987fdb69287d4a7af22a7a43f244","text":"# 운영체제 - 프로세스 동기화 2\n\n- Title : 운영체제 - 프로세스 동기화 2\n- Date : 2020-01-14\n- Category: 운영체제\n\n> 1. 생산자-소비자 문제(Producer and Consumer Problem)\n> 2. 독자-저자 문제(Readers-Writers Problem)\n> 3. 식사하는 철학자 문제(Dining Philosopher Problem)\n\n# 전통적 동기화(Classical Synchronization Problems)\n\n## Producer and Consumer Problem\n\n- 생산자-소비자 문제\n  - 생산자가 데이터를 생산하면 소비자는 그것을 소비\n  - 예1: 컴파일러(생산자) > 어셈블러(소비자)\n  - 예2: 파일서버 > 클라이언트\n  - 예3: 웹 서버(html 생산함) -> 웹 클라이언트(브라우저로 소비)\n- 유한버퍼 문제 (Bounded Buffer Problem)\n  - 생산된 데이터는 버퍼에 일단 저장(속도 차이 등)\n  - 현실 시스템에서 버퍼 크기는 유한\n  - 생산자는 버퍼가 가득 차면 더 넣을 수 없다.\n  - 소비자는 버퍼가 비면 뺄 수 없다.\n\n> 예시<br/>\n> 일반적으로 농작물 생산 속도와 소비 속도가 다르다. 현실적으로 바로 농산물을 소비자에게 주는 게 아니라 창고에 우선 저장한다. 저장된 여러 농작물을 소비자가 조금씩 빼먹고 생산자는 계속 생산해서 저장한다. 이 창고가 바로 **버퍼**다. 버퍼는 데이터를 저장할 수 있는 메모리 또는 디스크 공간으로 주로 메모리를 이용하긴 한다. 그런데 버퍼의 크기는 얼마나 될까? 현실 시스템에서 당연히 버퍼 크기는 유한하다. 컴퓨터에서 메모리가 한정적이니 당연한 얘기다.\n\n```java\n/****** 버퍼 ******/\n\nclass Buffer {\n  int[] buf;\n  int size;\n  int count;  // 버퍼의 현재 자원 크기\n  int in; // 생산자 insert 할 버퍼의 위치\n  int out;  // 소비자가 remove 할 버퍼의 위치\n\n  Buffer(int size) {\n    buf = new int[size];\n    this.size = size;\n    count = in = out = 0;\n  }\n  // 생산자\n  void insert(int item) {\n    /* check if buf is full */\n    while (count == size)\n    ;\n\n    buf[in] = item;\n    in = (in+1)%size; //circular\n    count++;\n  }\n  // 소비자\n  int remove() {\n    /* check if buf is empty */\n    while (count == 0)\n    ;\n\n    int item = buf[out];\n    out = (out+1)%size;\n    count--;\n    return item;\n  }\n}\n```\n\n```java\n/****** 생산자 ******/\nclass Producer extends Thread {\n  Buffer b;\n  int N;\n  Producer(Buffer b, int N) {\n    this.b = b; this.N = N;\n  }\n  public void run() {\n    for (int i=0; i<N; i++)\n    b.insert(i);\n  }\n}\n```\n\n```java\n/****** 소비자 ******/\nclass Consumer extends Thread {\n  Buffer b;\n  int N;\n  Consumer(Buffer b, int N) {\n    this.b = b; this.N = N;\n  }\n  public void run() {\n    int item;\n    for (int i=0; i<N; i++)\n    item = b.remove();\n  }\n}\n```\n\n```java\n/****** 메인 ******/\nclass Test {\n  public static void main(String[] arg) {\n    Buffer b = new Buffer(100);\n    Producer p = new Producer(b, 10000);\n    Consumer c = new Consumer(b, 10000);\n    p.start();\n    c.start();\n    try {\n      p.join();\n      c.join();\n    } catch (InterruptedException e) {}\n      System.out.println(\"Number of items in the buf is \" + b.count);\n  }\n}\n```\n\n- 위 코드는 잘못된 결과가 나온다.\n  - <code>실행 불가</code> 또는 <code>count != 0</code> (생산된 항목 숫자 != 소비자 항목 숫자)\n  - 최종적으로 버퍼 내에는 0개의 항목이 있어야 한다.\n- 원인은 무엇일까?\n  - 공통변수 count, buf[]에 대한 동시 업데이트 때문이다.\n  - 공통 변수 업데이트 구간(=임계구역)에 대한 동시 진입한다.\n- 어떻게 해결하지?\n  - <span class=\"clr-note\">임계구역에 대한 동시 접근 방지(상호배타)하기</span>\n  - 세마포를 사용한 상호배타 (mutual exclusion) 하기\n  - 세마포: mutex.value = 1 (# of permit)\n\n<br/>\n\n```java\n/****** 버퍼 ******/\nimport java.util.concurrent.Semaphore;\n\nclass Buffer {\n  int[] buf;\n  int size;\n  int count;  // 버퍼의 현재 자원 크기\n  int in; // 생산자 insert 할 버퍼의 위치\n  int out;  // 소비자가 remove 할 버퍼의 위치\n  Semaphore mutex;\n\n  Buffer(int size) {\n    buf = new int[size];\n    this.size = size;\n    count = in = out = 0;\n    this.mutex = new Semaphore(1);\n  }\n  // 생산자\n  void insert(int item) {\n    /* check if buf is full */\n    while (count == size)\n    ;\n    try {\n      mutex.acquire();\n      /****** S : 임계구역 *****/\n      buf[in] = item;\n      in = (in+1)%size; //circular\n      count++;\n      /****** E : 임계구역 *****/\n    } catch(InterruptedException) {}\n    mutex.release();\n  }\n  // 소비자\n  int remove() {\n    /* check if buf is empty */\n    while (count == 0)\n    ;\n    try {\n      mutex.acquire();\n      /****** S : 임계구역 *****/\n      int item = buf[out];\n      out = (out+1)%size;\n      count--;\n      return item;\n      /****** E : 임계구역 *****/\n    } catch(InterruptedException) {}\n    mutex.release();\n    return -1;\n  }\n}\n```\n\n<br/><br/>\n\n- 하지만 또! <code>Busy-wait</code> 라는 문제가 있다.\n  - insert의 <code>while (count == size);</code>와 remove의 <code>while (count == 0);</code> 로 인해 반복문에 붙잡히는 경우가 생긴다. cpu가 딴 일 못하고 붙잡힌다.\n  - 생산자: 버퍼가 가득 차면 기다려야 = 빈(empty) 공간이 있어야 한다.\n  - 소비자: 버퍼가 비면 기다려야 = 찬(full) 공간이 있어야 한다.\n- 어떻게 해결하지?\n  - 무한루프가 아니라 아예 감옥에 가둬버리자!\n  - 세마포를 사용한 busy-wait 회피\n  - 생산자: empty.acquire() // # of permit = BUF_SIZE\n  - 소비자: full.acquire() // # of permit = 0\n\n<br/>\n\n```java\n/****** 버퍼 ******/\nimport java.util.concurrent.Semaphore;\n\nclass Buffer {\n  int[] buf;\n  int size;\n  int count;  // 버퍼의 현재 자원 크기\n  int in; // 생산자 insert 할 버퍼의 위치\n  int out;  // 소비자가 remove 할 버퍼의 위치\n  Semaphore mutex;   // 임계구역에 1개만 들어가게 하려고\n  Semaphore empty;\n  Semaphore full;\n\n  Buffer(int size) {\n    buf = new int[size];\n    this.size = size;\n    count = in = out = 0;\n    this.mutex = new Semaphore(1);\n    this.empty = new Semaphore(size);\n    this.full = new Semaphore(0);\n  }\n  // 생산자\n  void insert(int item) {\n    /* check if buf is full */\n    while (count == size)\n    ;\n    try {\n      empty.acuire();\n      mutex.acquire();\n      /****** S : 임계구역 *****/\n      buf[in] = item;\n      in = (in+1)%size; //circular\n      count++;\n      /****** E : 임계구역 *****/\n    } catch(InterruptedException) {}\n    mutex.release();\n    full.release();\n  }\n  // 소비자\n  int remove() {\n    /* check if buf is empty */\n    while (count == 0)\n    ;\n    try {\n      full.acquire();\n      mutex.acquire();\n      /****** S : 임계구역 *****/\n      int item = buf[out];\n      out = (out+1)%size;\n      count--;\n      return item;\n      /****** E : 임계구역 *****/\n    } catch(InterruptedException) {}\n    mutex.release();\n    empty.release();\n    return -1;\n  }\n}\n```\n\n## Readers-Writers Problem\n\n- 공통 데이터베이스\n  - Readers: read data, never modify it\n  - Writers: read data and modifiy it\n  - 상호배타: 한 번에 한 개의 프로세스만 접근하는 것 효율성이 안 좋다.\n- 효율성을 높이려면?\n  - 데이터베이스 읽고 쓰기는 임계 구역 안에서 발생한다.\n  - 그러므로 Writers은 당연히 상호 배타 해야한다.\n  - 그러나 Reader1이 DB 읽고 있으면 Reader2도 읽을 수 있게 해줘야 효율성에 좋다!\n- 변종\n  - The first R/W problem (readers-preference) : 항상 readers에게 우선권을 주는 것. 예) 현재 Reader1이 DB를 읽고 있다고 가정해보자. Writer1의 경우는 상호 배타되어서 접근할 수 없다. 잠시 후 Reader2가 접근하면 Reader2는 늦게 왔음에도 불구하고 DB에 접근할 수 있다.\n  - The second R/W problem (writers-preference) : writers에게 우선권 주는 것\n  - The Third R/W problem : 우선권 아예 안 주는 것\n\n## Dining Philosopher Problem\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2020-01-14-img/1.png)<br/>\n\n> 5명의 철학자가 원탁에 앉아 있고 각자의 앞에는 스파게티가 있다. 그리고 양 옆에는 젓가락이 하나씩 있다. 각각의 철학자는 스파게티를 먹으려면 젓가락을 2개를 사용해야 하며, 다른 철학자에게 말을 걸 수 없고 젓가락을 빼앗을 수도 없다.\n> <br/><br/> 이제 5명의 철학자 모두가 갑자기 배가 고파서 동시에 왼쪽 젓가락을 집어든다고 생각해보자. 철학자들은 젓가락을 공유할 수 없고 자신의 오른쪽에 앉은 철학자가 젓가락을 놓을 때까지 기다린다. 오른쪽 젓가락을 빼앗을 방법도 없어서 철학자들의 계속 대기만 한다...\n\n- 식사하는 철학자 문제\n  - 5명의 철학자, 5개의 젓가락, 생각 → 식사 → 생각 → 식사\n  - 식사하려면 2개의 젓가락 필요\n- 프로그래밍\n  - 젓가락: 세마포 (# of permit = 1) -> 젓가락을 기준으로 2명 중 1명만 사용할 수 있으니깐 1로 한다.\n  - 젓가락과 세마포에 일련번호: 0 ~ 4\n  - 왼쪽 젓가락 → 오른쪽 젓가락\n\n```java\n/*********철학자*********/\nimport java.util.concurrent.Semaphore;\nclass Philosopher extends Thread {\n  int id; // philosopher id\n  Semaphore lstick, rstick; // left, right chopsticks\n  Philosopher(int id, Semaphore lstick, Semaphore rstick) {\n    this.id = id;\n    this.lstick = lstick;\n    this.rstick = rstick;\n  }\n  public void run() {\n    try {\n      while (true) {\n        lstick.acquire();\n        rstick.acquire();\n        eating();\n        lstick.release();\n        rstick.release();\n        thinking();\n      }\n    }catch (InterruptedException e) { }\n  }\n\n  void eating() {\n    System.out.println(\"[\" + id + \"] eating\");\n  }\n  void thinking() {\n    System.out.println(\"[\" + id + \"] thinking\");\n  }\n}\n```\n\n```java\n/*********메인*********/\nclass Test {\n  static final int num = 5; // number of philosphers & chopsticks\n  public static void main(String[] args) {\n    int i;\n    /* chopsticks */\n    Semaphore[] stick = new Semaphore[num];\n    for (i=0; i<num; i++)\n      stick[i] = new Semaphore(1);\n    /* philosophers */\n    Philosopher[] phil = new Philosopher[num];\n    for (i=0; i<num; i++)\n      phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]);\n    /* let philosophers eat and think */\n    for (i=0; i<num; i++)\n      phil[i].start();\n  }\n}\n```\n\n- 위 코드는 프로그램이 돌다가 멈춘다.. 왜???!!!\n  - 잘못된 결과: starvation -> 모든 철학자가 식사를 하지 못해 굶어 죽는 상황\n  - 이유 = <span class=\"clr-note\">교착상태 (deadlock)</span>\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"3c55417e429710884ade0d6c7bca7c149081a2a3","text":"# 알고리즘 개념 잡자 - 재귀와 동적 프로그래밍\n\n- Title : 알고리즘 개념 잡자 - 재귀와 동적 프로그래밍\n- Date : 2020-01-09\n- Category: Algorithm\n\n> 참고 <br/>\n>\n> - [코딩 인터뷰 완전분석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545) 재귀와 동적 프로그래밍\n> - [Geeksforgeeks 바로가기](https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/)\n\n# 동적 프로그래밍\n\n- 주어진 문제를 부분 문제로 나눠 값을 계산하는 것\n- 중복되는 계산을 막기 위해 부분 문제의 결과 값을 저장함 - 메모이제이션(Memoization)과 타뷸레이션(Tabulation)\n\n## 메모이제이션(Memoization)과 타뷸레이션(Tabulation)\n\n- 메모이제이션 : 하향식 접근법 (Top Down) - 재귀적\n  - 테이블을 만들고 NIL(예, -1) 값을 넣음\n  - 서브 문제의 결과값을 구할 때, 먼저 테이블 검색\n  - 계산된 값이 있으면 얘를 리턴\n  - NIL이면 계산 실행하여 계산 결과를 테이블에 저장\n  - 요구가 있을 때 채워지므로 테이블에 데이터가 다 채워지지 않을 수도 있음\n- 타뷸레이션 : 상향식 접근법 (Bottom Up) - 순환적\n  - 테이블의 마지막 요소를 반환하는 구조\n  - 첫번째부터 전체가 채워지는\n\n## DP의 2가지 속성\n\n모든 DP 문제는 Overlapping subproblems 속성을 만족하고 대부분의 클래식 DP 문제는 Optimal Substructure 속성을 만족한다.\n\n**1. overlapping subproblems** <br/><br/>\n\n- 부분 문제들이 공통으로 겹치는 부분이 있는 지?<br/>\n\n  > <span class=\"clr-grey\">우리가 메모이제이션이나 타뷸레이션을 사용하는 이유는 부분 문제의 결과값을 저장해놔서 나중에 이를 활용하려고 사용하죠. 근데 겹치는 부분 문제가 없으면?? 이게 필요가 없음.</span>\n\n- 동적 프로그래밍과 분할 정복\n  - 문제를 나누는 방식에 차이가 있음 <br/><br/>\n  - 피보나치<br/>\n    ![피보나치](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-10-img/2.png)\n  - 이진탐색 <br/>\n    ![이진탐색](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-10-img/1.png)\n\n<br/>\n\n**2. Optimal Substructure** <br/>\n\n- 문제의 답을 부분 문제의 답에서 구할 수 있는 가?\n- 최단 경로 vs 최장 경로<br/>\n  - 경로안에 무수히 많은 경로가 있을 때, 중간 정점들이 각각 최단이 된다면 이를 모든 이은 경로 또한 최단이 된다. <br/><br/>\n    ![경로](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-10-img/3.gif)\n    - q -> t 최단 : q -> r + r -> t\n    - q -> t 최장 : q -> s -> t -> r + r -> q -> s -> t\n\n## 문제 푸는 방법\n\n**1. DP 문제인가?**\n\n- DP의 2가지 속성으로 판단하기\n\n**2. 상태 찾기**\n\n- 서브 문제마다 값이 달라지는 변수 찾기\n- 각 서브 문제를 구별하는 값\n- 파라미타들\n- 적을 수록 좋다.\n- DP(상태) = 결과값(예, 최고 이익, 경우의 수..)\n\n**3. 재귀 방법 알아내기 == 상태들의 관계 알아내기** <br/>\n\n- state(n) = state(n-1) + state(n-3) + state(n-5)\n\n**4. 메모이제이션과 타뷸레이션 쓰기**\n\n# 8.1 트리플 스텝\n\n어떤 아이가 n개의 계단을 오른다. 한 번에 1계단 오르기도 하고 2계단이나 3계단을 오르기도 한다. 계단을 오르는 방법이 몇 가지가 있는지 계산하는 메서드를 구현하라.\n\n- Step 1 : DP 문제인지 판별하기\n  - 느낌..\n- Step 2 : 부분 문제마다 값이 달라지는 변수 찾기\n  - N : 계단의 개수 => 매개변수\n  - DP[N] = N을 만족하는 경우의 수\n- Step 3 : 재귀 방법을 알아내기\n  - 조정할 수 있는 거, 오를 수 있는 계단 개수져\n  - upStair(n) = (n - 1) || (n - 2) || (n - 3)\n  - upStair(n) = (n - 1) + (n - 2) + (n - 3)\n- Step 4 : 메모이제이션, 타뷸레이션\n\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint solution(int n, vector<int>& memo) {\n  if (n < 0) return 0;\n  if (n == 0) return 1;\n  if (memo[n] > -1) return memo[n];\n  memo[n] = solution(n - 1, memo) + solution (n - 2, memo) + solution (n - 3, memo);\n  return memo[n];\n}\n\nint solution_BU(int n) {\n  vector<int> dp(n+1, -1);\n  dp[0] = 1;\n  dp[1] = 1;\n  dp[2] = 2;\n  for (int i=3; i<=n; i++) {\n    dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\n  }\n  return dp[n];\n}\n\nint main(){\n  int n = 10;\n  vector<int> memo(n+1, -1);\n  std::cout << solution(n, memo) << \",\";\n  std::cout << solution_BU(n) << std::endl;\n  return 0;\n}\n```\n\n# 8.11 코인\n\n쿼터(25센트), 다임(10센트), 니켈(5센트), 페니(1센트)의 네 가지 동전이 무한히 주어졌을 때, n센트를 표현하는 모든 방법의 수를 계산하는 코드를 작성하라\n\n- Step 1 : DP 문제인지 판별하기\n  - 10원 방법의 수는 5원 방법에 + 5를 더하는 것....\n  - 느낌..\n- Step 2 : 부분 문제마다 값이 달라지는 변수 찾기\n  - 부분 문제는 1원일 때 방법의 수... 2원일 때 방법의 수..3원일 때....N원일 때 방법의 수\n  - N : 구할 센트, => 매개변수, 상태값\n  - D[N] = 방법의 수\n- Step 3 : 재귀 방법을 알아내기\\*\\*\n  - 재귀의 방법을 조정할 수 있는 값은? 동전의 가치 (25, 10, 5, 1)\n  - D(n) = D(n - 25) + D(n - 10) + D(n - 5) + D(n - 1)\n- Step 4 : 메모이제이션, 타뷸레이션\n\n- 10센트 만들기 (D[0] = 1)\n  - 25센트로 : 0 0 0 0 0 0 0 0 0 0\n  - 10센트로 : 0 0 0 0 0 0 0 0 0 1\n  - 5센트로 : 0 0 0 0 1 0 0 0 0 2\n  - 1센트로 : 1 1 1 1 2 2 2 2 2 4\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint coin[4] = {25, 10, 5, 1};\nint solution(int n, int index, vector<vector<int> >& memo) {\n  if (index >= 3) return 1;\n  if (memo[n][index] > 0) return memo[n][index];\n  int answer = 0;\n  for (int i=0; i * coin[index] <= n; i++) {\n    answer += solution(n - i * coin[index], index + 1, memo);\n  }\n\n  memo[n][index] = answer;\n  return memo[n][index];\n}\n\nint solution_BU(int n) {\n  vector<int> dp(n+1, 0);\n  dp[0] = 1;\n  for (int i=0; i<4; i++) {\n    for (int j=1; j<=n; j++) {\n      if (j - coin[i] >= 0) dp[j] += dp[j-coin[i]];\n    }\n  }\n  return dp[n];\n}\n\nint main() {\n  int n = 10;\n  vector<vector<int> > memo(n + 1, vector<int>(4, 0));\n  int answer = solution(n, 0, memo);\n  std::cout << answer << std::endl;\n  int answer_2 = solution_BU(n);\n  std::cout << answer << std::endl;\n  return 0;\n}\n```\n\n# 8.7 중복 없는 순열\n\n문자열이 주어졌을 때 모든 경우의 순열을 계산하는 메서드를 작성하라. 단, 문자는 중복되어 나타날 수 없다.\n\n# 8.9 괄호\n\nn-쌍의 괄호로 만들 수 있는 모든 합당한(괄호가 적절히 열리고 닫힌) 조합을 출력하는 알고리즘을 구현하라\n\n```cpp\n#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\nvoid fnc(string result, int cur, int dep, int n, vector<string>& answer) {\n  if (cur < 0) return;\n  if (cur > 0 && n - dep < cur) return;\n  if (cur == 0 && dep == n) {\n    answer.push_back(result);\n    return;\n  }\n  fnc(result + \"(\", cur + 1, dep + 1, n, answer);\n  fnc(result + \")\", cur - 1, dep + 1, n, answer);\n}\n\nvector<string> solution(int n) {\n    vector<string> answer;\n    fnc(\"\", 0, 0, n*2, answer);\n    return answer;\n}\n\nvoid solution_2(int leftRem, int rightRem, int index, char *str, vector<string>& answer) {\n  if (leftRem < 0 || leftRem > rightRem) return;\n  if (leftRem == 0 && rightRem == 0) {\n    answer.push_back(str);\n    return;\n  }\n  str[index] = '(';\n  solution_2(leftRem - 1, rightRem, index+1, str, answer);\n\n  str[index] = ')';\n  solution_2(leftRem, rightRem - 1, index + 1, str, answer);\n}\n\nint main() {\n  int n;\n  cout << \"input:\";\n  cin >> n;\n  vector<string> answer = solution(n);\n  for (int i=0; i<answer.size(); i++) {\n    cout << answer[i] << \" \";\n  }\n  cout << endl;\n  vector<string> answer2;\n  char str[n*2];\n  solution_2(n, n, 0, str, answer2);\n  for (int i=0; i<answer2.size(); i++) {\n    cout << answer2[i] << \" \";\n  }\n\n  return 0;\n}\n\n```\n\n# 8.10 영역 칠하기\n\n화면(색이 칠해진 이차원 배열), 화면상의 한 지점, 새로운 색상이 주어졌을 때, 주어진 지점과 색이 같은 주변 영역을 새로운 색상으로 다시 칠하라\n\n- BFS\n\n```cpp\n#include <string>\n#include <vector>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint row[4] = {0, 0, -1, 1};\nint col[4] = {-1, 1, 0, 0};\n\nint solution(vector<vector<int> >& screen, pair<int, int>& point, int newColor) {\n\n  queue<pair<int, int> > q;\n  int next_row, next_col;\n  int pre_color = screen[point.first][point.second];\n  q.push(point);\n  while (!q.empty()) {\n    pair<int, int> pop = q.front();\n    screen[pop.first][pop.second] = newColor;\n    q.pop();\n    for (int i=0; i<4; i++) {\n      next_row = pop.first + row[i];\n      next_col = pop.second + col[i];\n      if (next_row < 0 || next_col < 0) continue;\n      if (next_row >= screen.size() || next_col >= screen[0].size()) continue;\n      if (screen[next_row][next_col] == pre_color) {\n        q.push(make_pair(next_row, next_col));\n      }\n    }\n  }\n  return 0;\n}\n\nint main() {\n  // vector<vector<int> > screen({\n  //   vector<int>({1, 1, 2, 3}),\n  //   vector<int>({2, 1, 2, 3}),\n  //   vector<int>({1, 1, 2, 2}),\n  //   vector<int>({2, 2, 2, 1})\n  // });\n  /*\n  1 2 2 3\n  2 1 2 3\n  1 1 2 2\n  2 2 2 1\n  */\n vector<vector<int> > screen(4, vector<int>(4));\n  screen[0][0] = 1;\n  screen[0][1] = 2;\n  screen[0][2] = 2;\n  screen[0][3] = 3;\n\n  screen[1][0] = 2;\n  screen[1][1] = 1;\n  screen[1][2] = 2;\n  screen[1][3] = 3;\n\n  screen[2][0] = 1;\n  screen[2][1] = 1;\n  screen[2][2] = 2;\n  screen[2][3] = 2;\n\n  screen[3][0] = 2;\n  screen[3][1] = 2;\n  screen[3][2] = 2;\n  screen[3][3] = 1;\n\n  pair<int, int> point = make_pair(1, 2);\n  for (int i=0; i<screen.size(); i++) {\n    for (int j=0; j<screen[0].size(); j++)\n      std::cout << screen[i][j] << \" \";\n    std::cout << std::endl;\n  }\n  solution(screen, point, 0);\n  std::cout << std::endl;\n  for (int i=0; i<screen.size(); i++) {\n    for (int j=0; j<screen[0].size(); j++)\n      std::cout << screen[i][j] << \" \";\n    std::cout << std::endl;\n  }\n  return 0;\n}\n```\n\n# 8.14 불린값 계산\n\n0(false), 1(true), &(AND), |(OR), ^(XOR)으로 구성된 불린 표현식과 원하는 계산 결과(불린값)이 주어졌을 때, 표현식에 괄호를 적절하게 추가하여 그 값이 원하는 결과값과 같게 만들 수 있는 모든 경우의 수 출력하기\n\n출력 예시\n\n- countEval(\"1^0|0|1\", false) -> 2개\n- countEval(\"0&0&0&1^1|0\", true) -> 10개\n\n- Step 1 : DP 문제인지 판별하기\n  - 뭔가.. 적절하게 조합해서 모든 경우 구하는 거라서.. dp같네..?\n- Step 2 : 부분 문제마다 값이 달라지는 변수 찾기\n  - 음.. 전체 수식을 쪼개니깐 수식이 부분문제마다 달라지넵, 매개변수로 쪼개진 수식을 보내야겠댜~\n- Step 3 : 재귀 방법을 알아내기\\*\\*\n  - 괄호를 추가한다라..\n  - 1^0|0|1 예시로 보면..\n  - 1 ^ (0|0|1) 처럼 괄호를 추가하고 싶다는 건데..\n  - 그럼 ^ 같은 표현식을 기준으로 왼쪽 오른쪽 나눠어..\n  - D[수식] = D[왼쪽 수식] \\* D[오른쪽 수식]\n  - 서로 연관있으니깐 \\*곱하기\n  - 표현식은 index 1, 3, 5, 7 ..에 위치\n- Step 4 : 메모이제이션, 타뷸레이션\n\n1 ^ 0|0|1  \n1^0 | 0|1  \n1^0|0 | 1\n\n```cpp\n#include <string>\n#include <vector>\n#include <iostream>\n#include <map>\n\nusing namespace std;\n\nint fnc(std::string exp, bool r, map<string, int>& memo) {\n  if (exp.length() == 1) return exp[0] == (r ? '1' : '0') ? 1 : 0;\n  if (memo.count(exp + (r ? \"-1\" : \"-0\")) == 1) return memo[exp + (r ? \"-1\" : \"-0\")];\n  int sum = 0;\n  for (int i=1; i<exp.length(); i+=2) {\n    char e = exp[i];\n    string left = exp.substr(0, i);\n    string right = exp.substr(i+1);\n    if (e == '^') {\n      if (r) {  // true\n        sum += fnc(left, r, memo) * fnc(right, r^1, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r, memo);\n      } else {\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r^1, memo);\n      }\n\n    } else if (e == '|') {\n      if (r) { // true\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n        sum += fnc(left, r, memo) * fnc(right, r^1, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r, memo);\n      } else { // false\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n      }\n    } else {\n      if (r) { // true\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n      } else { // false\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r, memo);\n        sum += fnc(left, r, memo) * fnc(right, r^1, memo);\n      }\n\n    }\n  }\n  memo.insert(pair<string, int>(exp + (r ? \"-1\" : \"-0\") , sum));\n  return sum;\n}\n\nint countEval(std::string exp, bool result) {\n  map<string, int> map;\n  return fnc(exp, result, map);\n}\n\nint main() {\n  std::cout << countEval(\"1^0|0|1\", false) << std::endl;\n  std::cout << countEval(\"0&0&0&1^1|0\", true) << std::endl;\n  return 0;\n}\n```\n"}}}},"pageContext":{"id":"f2c6e1de774cf12c864abb9275a4cfcf910767c3","previousPostId":"e5e224acdcb2987fdb69287d4a7af22a7a43f244","nextPostId":"3c55417e429710884ade0d6c7bca7c149081a2a3"}},"staticQueryHashes":["2685952063","2841359383"]}