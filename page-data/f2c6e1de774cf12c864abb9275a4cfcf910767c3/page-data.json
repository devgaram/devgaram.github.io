{"componentChunkName":"component---src-templates-blog-post-js","path":"/f2c6e1de774cf12c864abb9275a4cfcf910767c3","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f2c6e1de774cf12c864abb9275a4cfcf910767c3","text":"# 합성으로 컴포넌트에 다른 컴포넌트를 담아보자.\n\n- Title : 합성으로 컴포넌트에 다른 컴포넌트를 담아보자.\n- Date : 2020-01-13\n- Category: React\n\nModals을 만들면서 로그인 모달, 메모 모달 등 기능에 따라 모달 바디에 다른 UI를 보여주고 싶었다. 엘리먼트도 컴포넌트에 전달할 수 있을 까? 라는 의문으로 검색해보니 **Composition**이 나왔다.\n\n# 컴포넌트에 다른 컴포넌트를 담고 싶다면?\n\n## 예시 1\n\n<code>props.children</code>을 사용하여 자식 엘리먼트를 그대로 출력할 수 있다.\n\n```javascript\n// ...\nimport Login from \"./login\"; // 로그인 UI 컴포넌트\nimport ModalCard from \"./modalCard\"; // 모달 컴포넌트\n\nconst Bio = () => {\n  // ...\n  return (\n    <>\n      <ModalCard>\n        <Login />\n      </ModalCard>\n    </>\n  );\n};\n```\n\nModalCard JSX 태그 안에 있는 것들이 아래와 같이 ModalCard 컴포넌트의 children prop으로 전달됩니다.\n\n```javascript\n// ...\nconst ModalCard = props => {\n  return (\n    <>\n      <div className=\"modal is-active\">\n        <div className=\"modal-background\"></div>\n        <div className=\"modal-card\">\n          <header className=\"modal-card-head\">\n            <p className=\"modal-card-title\"></p>\n            <button className=\"delete\" aria-label=\"close\"></button>\n          </header>\n          <section className=\"modal-card-body\">{props.children}</section>\n        </div>\n      </div>\n    </>\n  );\n};\n// ...\n```\n\n## 예시 2\n\nReact에서 prop으로 전달할 수 있는 것에는 제한이 없기 때문에 이렇게도 된다.\n\n```javascript\n// ...\nimport ModalCard from \"./modalCard\"\nimport Login from \"./login\"\n\nconst Bio = () => {\n  // ...\n  return (\n    <>\n      {// ...}\n      <ModalCard headTitle={`Who are you?`} ContentComponent={Login} isActive={isActive}/>\n    </>\n  )\n}\n```\n\n```javascript\n// ...\nconst ModalCard = ({ headTitle, ContentComponent, isActive }) => {\n  return (\n    <>\n      <div className=\"modal\">\n        <div className=\"modal-background\"></div>\n        <div className=\"modal-card\">\n          <header className=\"modal-card-head\">\n            <p className=\"modal-card-title\">{headTitle}</p>\n            <button className=\"delete\" aria-label=\"close\"></button>\n          </header>\n          <section className=\"modal-card-body\">\n            <ContentComponent />\n          </section>\n        </div>\n      </div>\n    </>\n  );\n};\n```\n\n끝!\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e5e224acdcb2987fdb69287d4a7af22a7a43f244","text":"# 운영체제 - 프로세스 동기화 2\n\n- Title : 운영체제 - 프로세스 동기화 2\n- Date : 2020-01-14\n- Category: 운영체제\n\n> 1. 생산자-소비자 문제(Producer and Consumer Problem)\n> 2. 독자-저자 문제(Readers-Writers Problem)\n> 3. 식사하는 철학자 문제(Dining Philosopher Problem)\n\n# 전통적 동기화(Classical Synchronization Problems)\n\n## Producer and Consumer Problem\n\n- 생산자-소비자 문제\n  - 생산자가 데이터를 생산하면 소비자는 그것을 소비\n  - 예1: 컴파일러(생산자) > 어셈블러(소비자)\n  - 예2: 파일서버 > 클라이언트\n  - 예3: 웹 서버(html 생산함) -> 웹 클라이언트(브라우저로 소비)\n- 유한버퍼 문제 (Bounded Buffer Problem)\n  - 생산된 데이터는 버퍼에 일단 저장(속도 차이 등)\n  - 현실 시스템에서 버퍼 크기는 유한\n  - 생산자는 버퍼가 가득 차면 더 넣을 수 없다.\n  - 소비자는 버퍼가 비면 뺄 수 없다.\n\n> 예시<br/>\n> 일반적으로 농작물 생산 속도와 소비 속도가 다르다. 현실적으로 바로 농산물을 소비자에게 주는 게 아니라 창고에 우선 저장한다. 저장된 여러 농작물을 소비자가 조금씩 빼먹고 생산자는 계속 생산해서 저장한다. 이 창고가 바로 **버퍼**다. 버퍼는 데이터를 저장할 수 있는 메모리 또는 디스크 공간으로 주로 메모리를 이용하긴 한다. 그런데 버퍼의 크기는 얼마나 될까? 현실 시스템에서 당연히 버퍼 크기는 유한하다. 컴퓨터에서 메모리가 한정적이니 당연한 얘기다.\n\n```java\n/****** 버퍼 ******/\n\nclass Buffer {\n  int[] buf;\n  int size;\n  int count;  // 버퍼의 현재 자원 크기\n  int in; // 생산자 insert 할 버퍼의 위치\n  int out;  // 소비자가 remove 할 버퍼의 위치\n\n  Buffer(int size) {\n    buf = new int[size];\n    this.size = size;\n    count = in = out = 0;\n  }\n  // 생산자\n  void insert(int item) {\n    /* check if buf is full */\n    while (count == size)\n    ;\n\n    buf[in] = item;\n    in = (in+1)%size; //circular\n    count++;\n  }\n  // 소비자\n  int remove() {\n    /* check if buf is empty */\n    while (count == 0)\n    ;\n\n    int item = buf[out];\n    out = (out+1)%size;\n    count--;\n    return item;\n  }\n}\n```\n\n```java\n/****** 생산자 ******/\nclass Producer extends Thread {\n  Buffer b;\n  int N;\n  Producer(Buffer b, int N) {\n    this.b = b; this.N = N;\n  }\n  public void run() {\n    for (int i=0; i<N; i++)\n    b.insert(i);\n  }\n}\n```\n\n```java\n/****** 소비자 ******/\nclass Consumer extends Thread {\n  Buffer b;\n  int N;\n  Consumer(Buffer b, int N) {\n    this.b = b; this.N = N;\n  }\n  public void run() {\n    int item;\n    for (int i=0; i<N; i++)\n    item = b.remove();\n  }\n}\n```\n\n```java\n/****** 메인 ******/\nclass Test {\n  public static void main(String[] arg) {\n    Buffer b = new Buffer(100);\n    Producer p = new Producer(b, 10000);\n    Consumer c = new Consumer(b, 10000);\n    p.start();\n    c.start();\n    try {\n      p.join();\n      c.join();\n    } catch (InterruptedException e) {}\n      System.out.println(\"Number of items in the buf is \" + b.count);\n  }\n}\n```\n\n- 위 코드는 잘못된 결과가 나온다.\n  - <code>실행 불가</code> 또는 <code>count != 0</code> (생산된 항목 숫자 != 소비자 항목 숫자)\n  - 최종적으로 버퍼 내에는 0개의 항목이 있어야 한다.\n- 원인은 무엇일까?\n  - 공통변수 count, buf[]에 대한 동시 업데이트 때문이다.\n  - 공통 변수 업데이트 구간(=임계구역)에 대한 동시 진입한다.\n- 어떻게 해결하지?\n  - <span class=\"clr-note\">임계구역에 대한 동시 접근 방지(상호배타)하기</span>\n  - 세마포를 사용한 상호배타 (mutual exclusion) 하기\n  - 세마포: mutex.value = 1 (# of permit)\n\n<br/>\n\n```java\n/****** 버퍼 ******/\nimport java.util.concurrent.Semaphore;\n\nclass Buffer {\n  int[] buf;\n  int size;\n  int count;  // 버퍼의 현재 자원 크기\n  int in; // 생산자 insert 할 버퍼의 위치\n  int out;  // 소비자가 remove 할 버퍼의 위치\n  Semaphore mutex;\n\n  Buffer(int size) {\n    buf = new int[size];\n    this.size = size;\n    count = in = out = 0;\n    this.mutex = new Semaphore(1);\n  }\n  // 생산자\n  void insert(int item) {\n    /* check if buf is full */\n    while (count == size)\n    ;\n    try {\n      mutex.acquire();\n      /****** S : 임계구역 *****/\n      buf[in] = item;\n      in = (in+1)%size; //circular\n      count++;\n      /****** E : 임계구역 *****/\n    } catch(InterruptedException) {}\n    mutex.release();\n  }\n  // 소비자\n  int remove() {\n    /* check if buf is empty */\n    while (count == 0)\n    ;\n    try {\n      mutex.acquire();\n      /****** S : 임계구역 *****/\n      int item = buf[out];\n      out = (out+1)%size;\n      count--;\n      return item;\n      /****** E : 임계구역 *****/\n    } catch(InterruptedException) {}\n    mutex.release();\n    return -1;\n  }\n}\n```\n\n<br/><br/>\n\n- 하지만 또! <code>Busy-wait</code> 라는 문제가 있다.\n  - insert의 <code>while (count == size);</code>와 remove의 <code>while (count == 0);</code> 로 인해 반복문에 붙잡히는 경우가 생긴다. cpu가 딴 일 못하고 붙잡힌다.\n  - 생산자: 버퍼가 가득 차면 기다려야 = 빈(empty) 공간이 있어야 한다.\n  - 소비자: 버퍼가 비면 기다려야 = 찬(full) 공간이 있어야 한다.\n- 어떻게 해결하지?\n  - 무한루프가 아니라 아예 감옥에 가둬버리자!\n  - 세마포를 사용한 busy-wait 회피\n  - 생산자: empty.acquire() // # of permit = BUF_SIZE\n  - 소비자: full.acquire() // # of permit = 0\n\n<br/>\n\n```java\n/****** 버퍼 ******/\nimport java.util.concurrent.Semaphore;\n\nclass Buffer {\n  int[] buf;\n  int size;\n  int count;  // 버퍼의 현재 자원 크기\n  int in; // 생산자 insert 할 버퍼의 위치\n  int out;  // 소비자가 remove 할 버퍼의 위치\n  Semaphore mutex;   // 임계구역에 1개만 들어가게 하려고\n  Semaphore empty;\n  Semaphore full;\n\n  Buffer(int size) {\n    buf = new int[size];\n    this.size = size;\n    count = in = out = 0;\n    this.mutex = new Semaphore(1);\n    this.empty = new Semaphore(size);\n    this.full = new Semaphore(0);\n  }\n  // 생산자\n  void insert(int item) {\n    /* check if buf is full */\n    while (count == size)\n    ;\n    try {\n      empty.acuire();\n      mutex.acquire();\n      /****** S : 임계구역 *****/\n      buf[in] = item;\n      in = (in+1)%size; //circular\n      count++;\n      /****** E : 임계구역 *****/\n    } catch(InterruptedException) {}\n    mutex.release();\n    full.release();\n  }\n  // 소비자\n  int remove() {\n    /* check if buf is empty */\n    while (count == 0)\n    ;\n    try {\n      full.acquire();\n      mutex.acquire();\n      /****** S : 임계구역 *****/\n      int item = buf[out];\n      out = (out+1)%size;\n      count--;\n      return item;\n      /****** E : 임계구역 *****/\n    } catch(InterruptedException) {}\n    mutex.release();\n    empty.release();\n    return -1;\n  }\n}\n```\n\n## Readers-Writers Problem\n\n- 공통 데이터베이스\n  - Readers: read data, never modify it\n  - Writers: read data and modifiy it\n  - 상호배타: 한 번에 한 개의 프로세스만 접근하는 것 효율성이 안 좋다.\n- 효율성을 높이려면?\n  - 데이터베이스 읽고 쓰기는 임계 구역 안에서 발생한다.\n  - 그러므로 Writers은 당연히 상호 배타 해야한다.\n  - 그러나 Reader1이 DB 읽고 있으면 Reader2도 읽을 수 있게 해줘야 효율성에 좋다!\n- 변종\n  - The first R/W problem (readers-preference) : 항상 readers에게 우선권을 주는 것. 예) 현재 Reader1이 DB를 읽고 있다고 가정해보자. Writer1의 경우는 상호 배타되어서 접근할 수 없다. 잠시 후 Reader2가 접근하면 Reader2는 늦게 왔음에도 불구하고 DB에 접근할 수 있다.\n  - The second R/W problem (writers-preference) : writers에게 우선권 주는 것\n  - The Third R/W problem : 우선권 아예 안 주는 것\n\n## Dining Philosopher Problem\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2020-01-14-img/1.png)<br/>\n\n> 5명의 철학자가 원탁에 앉아 있고 각자의 앞에는 스파게티가 있다. 그리고 양 옆에는 젓가락이 하나씩 있다. 각각의 철학자는 스파게티를 먹으려면 젓가락을 2개를 사용해야 하며, 다른 철학자에게 말을 걸 수 없고 젓가락을 빼앗을 수도 없다.\n> <br/><br/> 이제 5명의 철학자 모두가 갑자기 배가 고파서 동시에 왼쪽 젓가락을 집어든다고 생각해보자. 철학자들은 젓가락을 공유할 수 없고 자신의 오른쪽에 앉은 철학자가 젓가락을 놓을 때까지 기다린다. 오른쪽 젓가락을 빼앗을 방법도 없어서 철학자들의 계속 대기만 한다...\n\n- 식사하는 철학자 문제\n  - 5명의 철학자, 5개의 젓가락, 생각 → 식사 → 생각 → 식사\n  - 식사하려면 2개의 젓가락 필요\n- 프로그래밍\n  - 젓가락: 세마포 (# of permit = 1) -> 젓가락을 기준으로 2명 중 1명만 사용할 수 있으니깐 1로 한다.\n  - 젓가락과 세마포에 일련번호: 0 ~ 4\n  - 왼쪽 젓가락 → 오른쪽 젓가락\n\n```java\n/*********철학자*********/\nimport java.util.concurrent.Semaphore;\nclass Philosopher extends Thread {\n  int id; // philosopher id\n  Semaphore lstick, rstick; // left, right chopsticks\n  Philosopher(int id, Semaphore lstick, Semaphore rstick) {\n    this.id = id;\n    this.lstick = lstick;\n    this.rstick = rstick;\n  }\n  public void run() {\n    try {\n      while (true) {\n        lstick.acquire();\n        rstick.acquire();\n        eating();\n        lstick.release();\n        rstick.release();\n        thinking();\n      }\n    }catch (InterruptedException e) { }\n  }\n\n  void eating() {\n    System.out.println(\"[\" + id + \"] eating\");\n  }\n  void thinking() {\n    System.out.println(\"[\" + id + \"] thinking\");\n  }\n}\n```\n\n```java\n/*********메인*********/\nclass Test {\n  static final int num = 5; // number of philosphers & chopsticks\n  public static void main(String[] args) {\n    int i;\n    /* chopsticks */\n    Semaphore[] stick = new Semaphore[num];\n    for (i=0; i<num; i++)\n      stick[i] = new Semaphore(1);\n    /* philosophers */\n    Philosopher[] phil = new Philosopher[num];\n    for (i=0; i<num; i++)\n      phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]);\n    /* let philosophers eat and think */\n    for (i=0; i<num; i++)\n      phil[i].start();\n  }\n}\n```\n\n- 위 코드는 프로그램이 돌다가 멈춘다.. 왜???!!!\n  - 잘못된 결과: starvation -> 모든 철학자가 식사를 하지 못해 굶어 죽는 상황\n  - 이유 = <span class=\"clr-note\">교착상태 (deadlock)</span>\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"40f40953b7ab43bf93781786a87871d92de6d63c","text":"# React 기반을 다져보자!\n\n- Title : React 기반을 다져보자!\n- Date : 2020-01-07\n- Category: React\n\n<span class=\"clr-grey\">새로 알게 된 내용이 있으면 계속해서 추가할 예정입니다. </span>\n\n> **참조 링크** <br/>\n>\n> - [리액트 공식 문서](https://reactjs-kr.firebaseapp.com/docs/hello-world.html)\n\n# JSX\n\n```javascript\nconst element = <h1>Hello, world</h1>;\nReactDOM.render(\n  element,\n  document.getElementById(\"root\") // ID가 root인 노드에 렌더링하겠다!\n);\n```\n\n- JSX는 화면에서 볼 수 있는 내용에 대한 설명인 <code>React elements</code> 객체를 만든다.\n- 표현식이므로 if문, for 반복, 변수 할당, 매개 변수로 사용 가능하다.\n- Babel은 JSX를 <code>React.createElement()</code> 호출로 컴파일합니다.\n- 리액트 요소는 <code>Immutable Objects</code>라서 한번 만들면 그 자식이나 속성을 변경할 수 없다. UI를 업데이트 하려면 새로운 요소를 만들어서 <code>ReactDOM.render()</code>에 전달해야한다.\n\n> **Note:** <br/>\n> 실제로 대부분의 React 어플리케이션은 ReactDOM.render() 를 한번만 호출한다. -> state를 이용한다.\n\n# 순수 함수란?\n\n순수 함수는 입력을 변경하지않으며 항상 동일한 입력에 대해 동일한 결과를 반환하는 함수다.\n\n**순수 함수**\n\n```javascript\nfunction sum(a, b) {\n  return a + b;\n}\n```\n\n**순수 함수가 아님**\n\n```javascript\nfunction withdraw(account, amount) {\n  account.total -= amount;\n}\n```\n\n# Props\n\n- 부모 컴포넌트에서 자식 컴포넌트로 전달된 데이터다.\n- Props는 읽기전용이므로 수정할 수 없다.\n- 모든 React 컴포넌트는 props와 관련한 동작을 할 때 <code>순수 함수</code>처럼 동작해야한다.\n\n# State\n\n## 1. 클래스 컴포넌트에서 state 사용하기\n\n```javascript\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { date: new Date() };\n  }\n\n  // mounting : Clock 이 DOM에 최초로 렌더링 될 때\n  componentDidMount() {}\n\n  // unmounting : DOM에서 Clock 을 삭제했을 때\n  componentWillUnmount() {}\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(<Clock />, document.getElementById(\"root\"));\n```\n\n## 2. 함수형 컴포넌트에서 state 사용하기\n\n```javascript\nimport React, { useEffect, useState } from \"react\";\n// ...\n\nconst PetSitterApplyContainer = () => {\n  const [current, setCurrent] = useState(0); // 인자는 초기값\n\n  // ...\n\n  // 라이프사이클 훅\n  useEffect(() => {\n    function handleResize() {\n      dispatch(resize(window.innerWidth, window.innerHeight));\n    }\n    window.addEventListener(\"resize\", handleResize);\n  });\n\n  const next = () => {\n    setCurrent(current + 1);\n  };\n\n  const prev = () => {\n    setCurrent(current - 1);\n  };\n\n  return <PetSitterApply current={current} />;\n};\n```\n\n- state는 React 컴포넌트가 유저 액션, 네트워크 응답, 기타 등등에 대한 응답으로 시간 경과에 따라 출력을 변경할 수 있게 한다.\n- State는 로컬이며 캡슐화되어있다 : 부모 컴포넌트나 자식 컴포넌트는 특정 컴포넌트의 state 유무를 알 수 없으며 해당 컴포넌트가 함수나 클래스로 선언되었는 지 알 수 없기 때문\n- <code>componentDidMount() 훅</code> : 컴포넌트 출력이 DOM에 렌더링 된 이후 동작한다.\n- <code>componentWillUnmount() 훅</code> : 컴포넌트가 DOM에서 삭제된 이후 동작한다.\n- <code>useEffect</code> : 리액트 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 설정 할 수 있는 Hook으로 클래스형 컴포넌트의 componentDidMount 와 componentDidUpdate 를 합친 형태다.\n\n## 3. State 바르게 사용하기\n\n- State를 직접 수정하지말기\n\n```javascript\n// Wrong\nthis.state.comment = \"Hello\";\n\n// Correct\nthis.setState({ comment: \"Hello\" });\n```\n\n- this.props 및 this.state가 비동기로 업데이트될 수 있다는 것을 고려하기\n\n```javascript\n// Wrong\nthis.setState({\n  counter: this.state.counter + this.props.increment\n});\n\n// Correct : 이전 state를 인수로 받음\nthis.setState((prevState, props) => ({\n  counter: prevState.counter + props.increment\n}));\n```\n\n# 하향식(top-down) 혹은 단방향(unidirectional) 데이터 흐름\n\n- 모든 state는 항상 특정 컴포넌트가 가지며, 해당 state에서 파생된 모든 데이터 또는 UI는 트리의 컴포넌트 <code>아래(below)</code>에만 영향을 미친다.\n- 컴포넌트는 자신의 state를 자식 컴포넌트에 props 로 내려줄 수 있다. => <code>컴포넌트 트리 == props의 폭포</code>\n\n# Refs\n\n일반적인 리액트 데이터 플로우에서 부모 컴포넌트와 자식 컴포넌트는 <code>props</code>를 통해서만 통신할 수 있어서 자식 컴포넌트를 수정하려면 새로운 <code>props</code>와 함께 다시 렌더링해야한다. 그럼 일반적인 데이터 플로우 밖에서 자식 컴포넌트(컴포넌트 인스턴스 or DOM)에 직접 접근하려면 어떻게 해야할까? <code>Refs</code>를 사용하면 되지만 공식문서에서는 Refs 보다는 state를 이용하기로 권장한다.\n\n```javascript\nclass CustomTextInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.focusTextInput = this.focusTextInput.bind(this);\n  }\n\n  focusTextInput() {\n    // Explicitly focus the text input using the raw DOM API\n    this.textInput.focus();\n  }\n\n  render() {\n    // Use the `ref` callback to store a reference to the text input DOM\n    // element in an instance field (for example, this.textInput).\n    return (\n      <div>\n        <input\n          type=\"text\"\n          ref={input => {\n            this.textInput = input;\n          }}\n        />\n        <input\n          type=\"button\"\n          value=\"Focus the text input\"\n          onClick={this.focusTextInput}\n        />\n      </div>\n    );\n  }\n}\n```\n\n- React는 컴포넌트가 마운트될 때 DOM 요소와 함께 ref 콜백을 호출하며 언마운트될 때 null 과 함께 호출한다. ref 콜백은 componentDidMount 나 componentDidUpdate 라이프사이클 훅 전에 호출된다.\n- ref 속성을 HTML 요소에서 사용하면, ref 콜백은 기본 DOM 요소를 인수로 받는다.\n\n> Refs는 언제 사용하면 좋을까?\n>\n> - input/textarea 포커스 제어, 텍스트 선택, 미디어 재생을 관리할 때\n> - 명령형 애니메이션을 발동시킬 때\n> - 써드 파티 DOM 라이브러리를 통합할 때\n"}}}},"pageContext":{"id":"f2c6e1de774cf12c864abb9275a4cfcf910767c3","previousPostId":"e5e224acdcb2987fdb69287d4a7af22a7a43f244","nextPostId":"40f40953b7ab43bf93781786a87871d92de6d63c"}},"staticQueryHashes":["2685952063","2841359383"]}