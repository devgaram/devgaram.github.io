{"componentChunkName":"component---src-templates-blog-post-js","path":"/a21d94a6b96cfbfbce523c164d6e7bd377c5c4b7","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"a21d94a6b96cfbfbce523c164d6e7bd377c5c4b7","text":"# 자바스크립트의 실행 컨텍스트\n\nDate: Jul 11, 2020\n\n- Title : 실행 컨텍스트\n- Date : 2020-07-11\n- Category : Javascript\n\n이 글은 코어 자바스크립트 책의 실행 컨텍스트 부분을 정리한 내용입니다.\n\n# 실행 컨텍스트\n\n- 실행할 코드에 제공할 환경 정보들을 모아 놓은 객체다.\n- 자바 스크립트는 동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하여 콜 스택에 올린다. 가장 위에 쌓인 컨텍스트와 관련 코드를 실행하는 방법을 통해 전체 코드의 환경과 순서를 보장한다.\n- 실행 컨텍스트를 구성하는 방법은 `전역 공간`, `eval() 함수`, `함수` 등이 있다. `전역 공간`은 자동으로 생성되고 `eval()` 함수는 악마로 취급 되므로 **컨텍스트를 구성하기 위해 함수를 실행하는 방법을 흔히 사용**한다.\n\n## 실행 컨텍스트를 코드로 이해하기\n\n```jsx\n// (1)\nvar a = 1;\nfunction outer() {\n  function inner() {\n\t  console.log(a); // undefined\n\t  var a = 3;\n  }\n  inner(); // (2)\n  console.log(a); // 1\n}\nouter(); // (3)\nconsole.log(a); // 1\n```\n\n1. 처음 자바 스크립트 코드가 실행하는 순간(1) 전역 컨텍스트가 콜 스택에 담긴다.\n\n    참고로 전역 컨텍스트는 일반 실행 컨텍스트와 달리 함수가 아닌 전역 공간이기 때문에 arguments가 없고 전역 공간을 둘러싼 외부 스코프가 존재할 수 없기 때문에 스코프 체인 상에는 전역 스코프 하나만 존재한다.\n\n2. 콜 스택에 전역 컨텍스트 외에 다른 프레임이 없으므로 전역 컨텐스트와 관련된 코드들을 순차로 진행하다가 (3)에서 outer 함수를 호출하면 엔진은 outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성한 후 콜 스택에 담는다.\n3. 콜 스택의 맨 위에 outer 실행 컨텍스트가 놓인 상태이므로 전역 컨텍스트와 관련된 코드 실행을 일시 중단하고 outer 실행 컨텍스트와 관련된 코드(outer 함수 내부 코드)를 순차로 실행한다.\n4. (2)에서 inner 함수의 실행 컨텍스트가 콜 스택 가장 위에 담기면 outer 컨텍스트와 관련된 코드 실행을 중단하고 inner 함수 내부의 코드를 순서대로 실행한다.\n5. inner 함수의 실행이 종료되면 inner 실행 컨텍스트가 콜 스택에서 제거된다.\n6. outer 실행 컨텍스트가 콜 스택에 맨 위에 존재하게 되므로 중단했던 (2)의 다음 줄부터 이어서 실행한다.\n7. outer 함수의 실행이 종료되어 콜 스택에서 제거되면 전역 컨텍스트의 코드들을 실행하게 된다. 더 이상 실행할 코드가 남아 있지 않으면 전역 컨텍스트도 제거되어 콜 스택에는 아무 것도 남지 않은 상태로 종료된다.\n\n# 실행 컨텍스트에 담기는 정보들\n\n- VariableEnvironment: 현재 컨텍스트 내의 식별자에 대한 정보 + 외부 환경 정보, 선언 시점의 LexicalEnvironment의 스냅샷으로 변경 사항은 반영되지 않음\n- LexicalEnvironment: 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨\n- ThisBinding: this 식별자가 바라봐야 할 대상 객체\n\n## VariableEnvironment\n\nLexicalEnvironment에 담기는 내용과 같지만 VariableEnvironment는 **최초 실행 시의 스냅샷을 유지**한다는 점이 다르다. 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음 이를 그대로 복사해서 LexicalEnvironment를 만들고 이후에는 LexicalEnvironment를 주로 활용하게 된다.\n\n## LexicalEnvironment\n\n내부 구성\n\n- environmentRecode: 매개 변수의 이름, 함수 선언, 변수명 등이 담김\n- outerEnvironmentReference: 바로 직전 컨텍스트의 LexicalEnvironment 정보를 참조\n\n### environmentRecode\n\n컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어 나가며 순서대로 현재 컨텍스트와 관련된 코드의 식별자 정보들을 저장한다. 매개변수 식별자, 선언한 함수가 있을 경우 그 함수 자체(함수 선언문), var로 선언된 변수의 식별자가 식별자 정보에 해당된다.\n\n코드가 실행되기 전임에도 자바스크립트 엔진은 해당 컨텍스트에 속한 변수 명들을 모두 알고 있다. 즉, 자바스크립트 엔진은 **식별자들을 최 상단으로 끌어 올려 놓은 다음 실제 코드를 실행한다**라고 생각해도 된다. 여기서 호이스팅의 개념이 등장한다.\n\n자바 스크립트 엔진은 변수 선언과 값 할당이 동시에 이뤄진 문장은 **선언부**만을 호이스팅하고 할당 과정은 원래 자리에 둔다. 따라서 함수 선언문은 함수 전체가 호이스팅 되지만 함수 표현식은 변수 선언부만 호이스팅 된다.\n\n### outerEnvironmentReference\n\nouterEnvironmentReference는 **현재 호출된 함수가 선언될 당시**의 LexicalEnvironment를 참조하기 때문에 우리는 스코프 체인을 할 수 있다. \n\n코드 상에서 어떤 변수에 접근하려고 하면 현재 컨텍스트의 LexicalEnvironment를 탐색한다. 변수 값을 발견하면 그 값을 반환 하지만 발견하지 못하면 outerEnvironmentReference에 담긴 LexicalEnvironment를 탐색하는 과정을 거친다. 전역 컨텍스트의 LexicalEnvironment까지 탐색 해도 해당 변수를 찾지 못하면 undefined를 반환한다.\n\n> 스코프는 식별자에 대한 유효 범위로, 어떤 경계 A의 외부에서 선언한 변수는 A의 외부 뿐 아니라 A의 내부에서도 접근이 가능하지만, A의 내부에서 선언한 변수는 오직 A 내부에서만 접근할 수 있다는 개념으로 이해하면 된다. 이러한 식별자 유효 범위를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라고 한다.\n\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"0ccca43f88286fec26b69ffb24385bb7af57d737","text":"# CORS\n\n- Title : CORS\n- Date : 2020-08-15\n- Category : 프론트\n\n# SOP(Same-Origin Policy)\n**동일 출처 정책**으로 한 출처(Origin)에서 로드된 문서나 스크립트가 다른 출처의 자원과 상호 작용을 못하도록 제한하는 것을 말한다. <br/>\n이 정책으로 의해 XMLHttpRequest 객체로 특정 웹 페이지 접근할 때, 해당 페이지와 동일한 출처의 페이지에만 접근이 가능한 것이다.\n\n# 동일 출처(Origin)란?\n`Protocol`, `Host`, `Port` 가 모두 같을 때 동일 출처다.\n\n# CORS(Cross-Origin Resource Sharing)\n다른 출처의 자원과의 상호 작용을 위해 SOP 예외 조건으로 CORS 정책이 생겼다.    \nCORS 정책을 위반하지 않는 다면 다른 출처의 리소스를 공유할 수 있다.\n\n## 어떻게 CORS 정책을 위반했는 지 판단할까?\n출처를 비교하는 로직은 서버가 아닌 **브라우저**에 구현되어 있다.    \nCORS 정책에 위반하는 리소스 요청을 하면 서버가 같은 출처만 받겠다는 로직이 있는 경우가 아니면 서버는 정상적인 응답을 하고,\n이후 브라우저가 응답 헤더를 분석하여 CORS 정책 위반이라고 판단되면 그 응답을 사용하지 않는다.\n\n1. HTTP 프로토콜을 사용하여 리소스 요청을 한다.\n2. 이 때 브라우저는 요청 헤더의 Origin 필드에 출처를 담아 보낸다.\n3. 서버는 응답 헤더의 Access-Control-Allow-Origin 필드에 해당 리소스에 대한 접근이 허용된 출처를 담아 응답한다.\n4. 브라우저는 응답의 Access-Control-Allow-Origin 과 요청 헤더의 Origin을 비교하여 응답이 유효한 지 판단한다.\n\n# CORS, SOP 정책 존재 이유는?\n다른 출처의 애플리케이션이 서로 통신하는 것에 대해 아무런 제약도 존재하지 않으면 \n해커가 `CSRF(Cross-Site Request Forgery)`나 `XSS(Cross-Site Scripting)`와 같은 방법으로 앱 코드가 실행된 것처럼 꾸며 \n사용자의 정보를 탈취하기 쉬워진다. 또 개발자가 신경써야 할 일이 늘어난다.\n\n# Preflight, Simple, Credential Request 에서 CORS\n## 1. Preflight Request\npreflight는 브라우저가 본 요청을 보내기 전에 보내는 예비 요청을 말하며 HTTP METHOD 중 OPTIONS를 사용한다.    \n예비 요청은 본 요청을 보내기 전에 브라우저 스스로 안전한 요청인지 확인하는 과정이다.\n\n## 2. Simple Request\n예비 요청 없이 바로 본 요청을 보내는 경우로 발생 조건이 까다로워 해당 요청이 발생하는 경우는 드물다.\n- 요청 메소드: GET, HEAD, POST 중 하나만 사용 가능\n- Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width를 제외한 헤더를 사용 불가\n- 만약 Content-Type를 사용하는 경우에는 application/x-www-form-urlencoded, multipart/form-data, text/plain만 허용\n\n## 3. Credentialed Request\n다른 출처 간 통신에서 좀 더 보안을 강화하고 싶을 때 사용한다.\n\n```javascript\nfetch(url, {\n  credentials: 'include', // 요청에 인증과 관련된 정보를 포함하겠다.\n});\n```\n위와 같이 설정하면 요청 시 브라우저의 쿠키 정보가 함께 보내진다.\n\n단, `credentials: include`를 사용하면 브라우저는 `Access-Control-Allow-Origin: *` 처럼 와일드 문자를 허용하지 않게 된다.\n인증 정보가 담겨있는 상태에서 다른 출처에 요청을 하고 싶다면 아래 두가지를 추가해야 CORS 정책 위반을 피할 수 있다.\n\n- `Access-Control-Allow-Origin`에는 *를 사용할 수 없으며, 명시적인 URL이어야한다.\n- 응답 헤더에는 반드시 `Allow-Control-Allow-Credentials: true`가 존재해야한다.\n\n# CORS 해결 방법\n1. 서버에서 Access-Control-Allow-Origin 헤더에 알맞은 값 세팅하기\n2. Webpack Dev Server로 리버스 프록싱\n\n```javascript\nmodule.exports = {\n  devServer: {\n    proxy: {\n      '/api': {\n        target: 'https://api.evan.com',\n        changeOrigin: true,\n        pathRewrite: { '^/api': '' },\n      },\n    }\n  }\n}\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"3a69a280df0251492517e4cdc764f4c0e0040854","text":"# 자바스크립트 엔진과 이벤트 루프\n\nDate: Jul 1, 2020\n\n- Title : 자바스크립트 엔진과 이벤트 루프\n- Date : 2020-07-01\n- Category : Javascript\n\n![Untitled](https://user-images.githubusercontent.com/34448538/87217780-f49aac00-c387-11ea-9c33-5a77863c7f28.png)\n\n## V8 엔진\n\n자바 스크립트 엔진 중 하나로 구글이 개발한 오픈 소스다. C++로 개발되어 있으며 크롬과 NodeJS에서 사용된다.\n\n**V8 엔진은 크게 두 부분으로 구성된다.**\n\n- 메모리 힙 (Memory Heap) : 메모리 할당이 이루어지는 곳\n- 콜 스택 (Call Stack) : 코드가 실행 되면서 스택 프레임이 쌓이는 곳\n\n### 메모리 힙\n\n객체나 동적 데이터(배열, 객체...)가 저장되는 공간으로 메모리 영역에서 가장 큰 블록이면서 가비지 컬렉션(GC)가 발생하는 곳이다. 힙 메모리 전체에서 가비지 컬렉션이 실행되는 것은 아니고 Young과 Old 영역에서만 실행된다.\n\n### 콜 스택\n\n메서드, 함수 프레임, 원시 값, 객체 포인터를 포함한 정적 데이터가 저장되는 곳이다.\n자바 스크립트는 콜 스택을 하나만 가지고 있는 싱글 스레드 언어이다.\n\n> **스택 트레이스?**\n예외가 발생했을 때의 콜 스택의 상태\n**스택 날림(Blowing the stack)?**\n스택 프레임이 콜 스택의 최대 크기까지 쌓였을 때\n\n### V8 메모리 사용 (스택 vs 힙)\n\n```jsx\nclass Employee {\n    constructor(name, salary, sales) {\n        this.name = name;\n        this.salary = salary;\n        this.sales = sales;\n    }\n}\n\nconst BONUS_PERCENTAGE = 10;\n\nfunction getBonusPercentage(salary) {\n    const percentage = (salary * BONUS_PERCENTAGE) / 100;\n    return percentage;\n}\n\nfunction findEmployeeBonus(salary, noOfSales) {\n    const bonusPercentage = getBonusPercentage(salary);\n    const bonus = bonusPercentage * noOfSales;\n    return bonus;\n}\n\nlet john = new Employee(\"John\", 5000, 5);\njohn.bonus = findEmployeeBonus(john.salary, john.sales);\nconsole.log(john.bonus);\n```\n\n![stackheap](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-07-01-img/stack-heap.gif)\n\n# 이벤트 루프와 비동기 프로그래밍\n\n자바 스크립트는 스레드(콜 스택이 하나)가 하나라 수행 시간이 긴 코드를 실행하게 되면 브라우저는 아무 것도 할 수 없게 된다. 하지만 실제 자바 스크립트가 사용 되는 환경을 생각해보면 많은 작업이 동시에 처리되고 있다. 예를 들면, 웹 브라우저는 애니메이션 효과를 보여주면서 마우스 입력을 받아서 처리하고, NodeJs 기반의 웹 서버에서는 동시에 여러 개의 HTTP 요청을 처리 하기도 한다. \n\n싱글 스레드인데 어떻게 이런 일이 가능할까? 자바 스크립트는 어떻게 동시성(Concurrency)을 지원할까? 이에 대한 답은 `자바 스크립트는 이벤트 루프 기반의 비동기 방식으로 동시성을 지원 한다`로 정리할 수 있다.\n\n## Web APIs\n\n브라우저가 제공하는 웹 API로 DOM Events, XMLHttpRequest, setTimeout, addEventListener 등이 포함된다.\n\n## 이벤트 루프와 태스크 큐\n\nWeb API 중 하나인 `setTimeout` 함수는 태스크 큐에서 대기하고 있다가 이벤트 루프를 통해 실행된다.\n태스크 큐는 말 그대로 콜백 함수들이 대기하는 큐(FIFO) 형태의 배열이라 할 수 있고 이벤트 루프는 콜 스택이 비어질 때마다 큐에서 콜백 함수를 꺼내 와서 실행하는 역할을 한다.\n\n```jsx\nsetTimeout(baz, 10); // (1)\nfoo();\n```\n\n위의 예시의 코드가 처음 실행되면 `setTimeout` 함수는 브라우저에게 타이머 이벤트를 요청한 후 바로 콜 스택에서 제거된다. 그 후에 `foo` 함수가 콜 스택에 추가된다. 10ms가 지나면 브라우저의 타이머는 `baz` 함수를 태스크 큐에 추가한다. 이벤트 루프는 `foo` 함수가 실행을 마치고 콜 스택에서 사라지면 태스크 큐에서 대기 중인 `baz`를 실행하여 콜 스택에 추가한다.\n\n![image](https://user-images.githubusercontent.com/34448538/87217762-c74dfe00-c387-11ea-920e-87d0761c4fff.png)\n\n정리하자면 이벤트 루프는 **현재 실행 중인 태스크가 없는 지**와 **태스크 큐에 태스크가 있는지**를 반복적으로 확인하여 **현재 실행 중인 태스크가 없을 때**(주로 호출 스택이 비워졌을 때) 태스크 큐의 첫번째 태스크를 가져와 실행한다. 참고로 모든 브라우저의 비동기 API들은 작업이 완료되면 콜백 함수를 태스크 큐에 추가한다.\n\n### 마이크로 태스크\n\n일반 태스크보다 더 높은 우선 순위를 갖는 태스크로 태스크 큐에 대기 중인 태스크가 있더라도 마이크로 태스크가 먼저 실행된다. \n\n```jsx\nsetTimeout(function() { // (A)\n    console.log('A');\n}, 0);\nPromise.resolve().then(function() { // (B)\n    console.log('B');\n}).then(function() { // (C)\n    console.log('C');\n});\n```\n\nPromise 콜백 함수는 마이크로 태스크 큐에 추가되고 setTimeout 콜백 함수는 일반 태스크 큐에 추가되기에 이벤트 루프는 마이크로 태스크 큐에 있는 작업을 먼저 실행한 후 태스크 큐의 태스크를 실행한다. 즉 B → C → A 순으로 실행된다.\n\n \n참고\n[https://vimeo.com/96425312](https://vimeo.com/96425312)\n\n[https://meetup.toast.com/posts/89](https://meetup.toast.com/posts/89)\n\n[https://engineering.huiseoul.com/자바스크립트는-어떻게-작동하는가-v8-엔진의-내부-최적화된-코드를-작성을-위한-다섯-가지-팁-6c6f9832c1d9](https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-v8-%EC%97%94%EC%A7%84%EC%9D%98-%EB%82%B4%EB%B6%80-%EC%B5%9C%EC%A0%81%ED%99%94%EB%90%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%8B%A4%EC%84%AF-%EA%B0%80%EC%A7%80-%ED%8C%81-6c6f9832c1d9)\n"}}}},"pageContext":{"id":"a21d94a6b96cfbfbce523c164d6e7bd377c5c4b7","previousPostId":"0ccca43f88286fec26b69ffb24385bb7af57d737","nextPostId":"3a69a280df0251492517e4cdc764f4c0e0040854"}},"staticQueryHashes":["2685952063","2841359383"]}