{"componentChunkName":"component---src-templates-blog-post-js","path":"/5d8f5742317fc2443a1810a411eb106b455e189d","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"5d8f5742317fc2443a1810a411eb106b455e189d","text":"# Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 1탄\n\n- Title : Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 1탄\n- Date : 2020-02-29\n- Category: Vue\n\n## Why?\n\nVue CLI로 프로젝트를 생성해왔는데 문뜩 웹팩과 바벨에 대한 이해가 부족한듯 싶었다. 그래서😎 오늘은 Vue, Typescript, Babel, Webpack을 사용해서 Vue CLI 없이 프로젝트를 설정해보면서 공부한 내용을 정리해보기로 했다. 1탄은 웹팩과 바벨에 대한 설정과 개념을 잡아보고 2탄에서 Vue와 Typescript 설정을 진행할 거다.\n\n## 1. 프로젝트 생성\n\n```\n    $ mkdir vue-typescript\n    $ cd vue-typescript\n    $ mkdir src\n    $ cd src\n    $ mkdir components\n    $ cd ..\n```\n\n## 2. package.json 파일 생성\n\n> **npm(node package manager)** 은 자바스크립트 패키지 매니저다. Node.js에서 사용할 수 있는 모듈들을 패키지화하여 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI(Common line interface)를 제공한다. 비슷한 패키지 매니저인 페이스북이 만든 **yarn**은 npm보다 더 빠르고 안전하다. 둘 다 package.json 파일에 선언된 semver rule을 만족하는 최신 버전을 설치한다.\n\n```\n    $ npm init\n```\n\n**package.json란?**\n\n- 프로젝트가 의존하고 있는 패키지들의 리스트를 보여준다.\n- semantic versioning rule에 따라 프로젝트에 의존한 패키지들의 버전을 설정할 수 있다.\n- 빌드를 재현할 수 있어 좀 더 쉽게 다른 개발자와 공유할 수 있다.\n\n> **—save-dev** 란? —production 빌드 시 포함될 필요가 없는 패키지는 —save-dev 옵션을 사용하여 package.json의 devDependencies에 패키지 정보를 저장한다.\n\n## 3. Webpack 설치 및 초기 설정\n\n> 웹팩은 자바스크립트 애플리케이션을 위한 **정적 모듈 번들러**다. 자바스크립트 코드를 하나의 파일로 관리하는 것과 여러개의 파일로 관리하는 것은 각각 단점이 있다. 우선 각 파일을 브라우저에 로딩하면 그만큼 네트워크 비용이 커진다. 또한 각 파일이 서로의 스코프를 침범하여 변수 충돌의 위험이 생길 수도 있다. 물론 해결 방법이 있다. 자바스크립트는 함수 스코프를 사용하니 즉시호출함수를 사용해 모듈을 만들면 된다. 그러나 모듈을 모두 즉시호출함수로 변경하여 하나의 파일로 묶는 것을 일일이 작업하면 귀찮지않을까? 웹팩이 등장한 배경이 바로 여기에 있다.\n\n    npm install --save-dev webpack webpack-cli webpack-dev-server html-webpack-plugin\n\n- webpack : 웹팩\n- webpack-cli : 커맨드 라인에서 웹팩을 구동시키기위한 패키지\n- webpack-dev-server : 실시간 리로드를 제공하는 개발 서버로 localhost에서 테스트하고 싶을 때 사용\n- html-webpack-plugin : 웹팩 번들을 서비스하기 위한 HTML 파일을 만들어주는 패키지로 컴파일할 때마다 이름이 변하는 번들파일을 HTML 파일에 넣어줄 때 유용하다.\n\n설치가 완료되면 src 폴더에 index.js 파일을 만들고 package.json 파일의 scripts에 **\"build\": \"webpack\"** 와 **\"start:dev\": \"webpack-dev-server\"** 를 추가한다.\n\n```\n    {\n      \"name\": \"vue-typescript\",\n      \"version\": \"1.0.0\",\n      \"description\": \"\",\n      \"main\": \"index.js\",\n      \"scripts\": {\n    \t\t\"start:dev\": \"webpack-dev-server\",\n    \t\t\"build\": \"webpack\",\n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n      },\n      \"author\": \"\",\n      \"license\": \"ISC\",\n      \"devDependencies\": {\n        \"html-webpack-plugin\": \"^3.2.0\",\n        \"webpack\": \"^4.42.0\",\n        \"webpack-cli\": \"^3.3.11\",\n        \"webpack-dev-server\": \"^3.10.3\"\n      }\n    }\n```\n\n웹팩4는 webpack.config.js 파일이 없어도 파일을 번들할 수 있다. 커맨드 라인에서 **npm run build** 를 치면 dist 폴더에 번들된 파일인 main.js를 볼 수 있다. 또한 **npm run start:dev** 로 치면 8080포트로 개발서버가 동작한다. 하지만 index.html 파일이 없어서 localhost:8080에서 제대로 된 화면을 볼 수 없다. index.html 파일을 직접 dist 폴더에 만들어서 main.js 파일을 **<script src=\"main.js\"></script>** 로 로딩시켜서 동작시킬 수는 있다. 하지만 번들 파일의 이름이 매번 바뀐다면? 또 번들 파일이 많다면? 매우 귀찮을 거다. 그래서 **html-webpack-plugin** 을 이용하여 자동으로 index.html 파일을 생성시키고 번들 파일들을 주입시킬 거다. 설정을 위해 프로젝트 루트에 프로젝트 루트에 webpack.config.js 파일을 생성한 후 아래와 같이 작성한다.\n\n```js\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  entry: \"./src/index.js\",\n  plugins: [new HtmlWebpackPlugin()],\n  output: {\n    filename: \"main.js\",\n    path: path.resolve(__dirname, \"dist\")\n  }\n};\n```\n\n- **entry** : 자바스크립트가 로딩하는 모듈이 많아질수록 모듈간의 의존성은 증가한다. 웹팩에서 의존성 그래프의 시작점을 엔트리(entry)라고 한다.\n- **output** : entry에 설정한 main.ts을 시작으로 의존되어있는 모든 모듈을 하나로 묶은(번들된) 결과의 위치를 output에 정의한다. webpack을 실행하면 /dist 폴더에 main.bundle.js란 이름으로 파일이 생성될 것이다.\n\n**npm run build** 를 실행시키면 dist 폴더에 index.html 파일이 생성되고 `<script type=\"text/javascript\" src=\"main.js\">`로 번들 파일이 주입된다.\n\nwebpack-dev-server 에 대한 추가적인 설정을 하려면 devServer 옵션을 이용하면 된다.\n\n```js\nmodule.exports = {\n  devServer: {\n    hot: true,\n    contentBase: path.join(__dirname, \"dist\"),\n    compress: true,\n    port: 9000\n  }\n};\n```\n\nhot: true 는 핫로더, contentBase는 대상 위치, compress는 파일 gzip 압축, port는서버 포트 설정이다.\n\n[DevServer | webpack](https://webpack.js.org/configuration/dev-server/)\n\n    DevTools failed to parse SourceMap: webpack:///node_modules/sockjs-client/dist/sockjs.js.map\n\n[localhost:9000](http://localhost:9000) 에서 콘솔 창을 확인하면 devtools을 설정하지 않아 위와 같은 경고 문구가 뜬다. devtools 옵션으로 소스맵 생성을 정의할 수 있다. 소스맵은 번들링된 파일과 원래 파일을 맵핑하여 에러 추적할 때 용이하다. 예를 들어 세개의 js 파일을 번들링한 main.js 파일이 있다고 하자. 콘솔 창을 확인해보니 main.js 파일에서 에러가 났다. 만약 소스맵을 사용하지않는다면 세 개의 파일 중 어디서 에러가 났는 지 알 수가 없다. _여러가지 종류가 있지만 inline-source-map 을 추천한다길래 얘를 사용했다. 나중에 각 옵션의 차이점도 알아봐야겠다._\n\n```js\nmodule.exports = {\n  devtool: \"inline-source-map\"\n};\n```\n\n## 4. Babel로 ES6를 ES5로 변환하기\n\n> 구형 브라우저(IE)에서는 ES6 코드가 호환되지 않는다. 그렇다고 ES5로 코드를 짤 수도 없는 노릇. ES2015+ 문법을 ES5로 바꿔주는 녀석이 없을까? 바로 바벨이 그 역할을 한다.\n\n먼저 바벨 패키지를 설치한다.\n\n```\n    npm install --save-dev babel-loader @babel/core @babel/preset-env\n```\n\n- babel-loader : 웹팩에서 ES6로 된 파일을 ES5로 변환할 때 사용\n- @babel/core\n\n웹팩에게 빌드하기전 자바스크립트 파일을 ES5로 트랜스파일링하라고 말해야한다. 웹팩의 Loaders를 이용하여 이를 설정할 수 있다.\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: \"babel-loader\"\n      }\n    ]\n  }\n};\n```\n\n- **loader** : 웹팩은 자바스크립트, 이미지, 폰트, 스타일시트도 전부 모듈로 관리한다. 하지만 웹팩은 자바스크립트만 아는 녀석이라서 웹팩이 자바스크립트 파일이 아닌 파일들을 이해할 수 있게끔 변경해야하는데 로더(loader)가 그런 역할을 한다. 위 코드를 보면 test에 로딩할 파일, use에 적용할 로더, exclude는 제외할 파일를정의한 것을 알 수 있다.\n\n바벨 설정을 완료했지만 사실 바벨은 아무 것도 하지않는다. 프로젝트 루트에 .babelrc 파일을 만들어 설정을 해야한다. 그 전에 ES2015+를 트랜스파일링하기위해 필요한 프리셋과 플러그인을 모은 모듈을 다운받는다. @babel/preset-env는 자동으로 브라우저 polyfill 을 맞춘다.\n\n    npm install @babel/preset-env --save-dev\n\n.babelrc에 아래와 같이 입력한다.\n\n    {\n      \"presets\": [\"@babel/preset-env\"]\n    }\n\n따로 .babelrc 파일을 만들지않고 웹팩에서도 설정 가능하다.\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: \"babel-loader\",\n          options: {\n            presets: [\"@babel/preset-env\"]\n          }\n        }\n      }\n    ]\n  }\n};\n```\n\n실제로 트랜스파일링되는지 테스트하기위해 index.js에 아래와 같이 작성하고 npm run build하면 es5 문법으로 바뀐 것을 알 수 있다.\n\n```js\nconst myconst = 123;\nlet mylet = 456;\n```\n\n![Vue%20CLI%20Vue%20Typescript%20Babel%20Webpack%201/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Vue/images/2020-02-29-img/Untitled.png)\n\n추가로 @babel/preset-env에서 타켓에 옵션으로 브라우저 버전을 직접 설정할 수도 있다. options을 쓰거나 package.json에 작성하는 방법도 있지만 공식문서는 **.browserslistrc** 파일을 만들어서 설정하는 것을 추천하고 있다. 프로젝트 루트 폴더에 .browserslistrc를 만든 후 아래의 내용을 작성하자. 각 브라우저에서 최근 2개의 버전까지, 1% 이상 사용되는 브라우저를 타켓으로 한다. 디폴트는 _> 0.5%, last 2 versions, Firefox ESR, not dead_ 다.\n\n    > 1%\n    last 2 versions\n\n### ES6 메서드나 생성자 지원하려면?\n\nindex.js 에 console.log(Array.from('foo')); 을 입력한 후 IE11에서 확인해보자.\n\n```js\nconsole.log(Array.from(\"foo\"));\n```\n\n콘솔 창을 보면 개체가 'from' 속성이나 메서드를 지원하지 않습니다. 라는 에러 문구를 보게될 것이다. 바벨로 ES5로 바꿨는 데 왜 그러지??? 라는 혼란이 생길 것이다.😨😨\n\n방금까지는 바벨을 이용하여 ES6 문법을 ES5로 문법 트랜스파일링만 한 거다. 그래서 Array.from()과 같이 ES6에만 있는 메서드나 생성자들은 구형 브라우저에서 동작하지 않는다. 이 문제를 해결하기 위해polyfill을 사용한다. **polyfill**은 code 조각으로 런타임에 존재하지 않는 nativeAPI의 복사본을 말한다. @babel/polyfill이나 @babel/plugin-transform-runtime를 사용하면 되지만 **@babel/polyfill** 은 7.4.0부터 deprecated 되서 **core-js@3**를 사용하는 것을 추천한다.\n\n**Babel-Polyfill vs Babel-Transform-Runtime**\n\n- Babel-Polyfill은 전역적으로 polyfill을 사용하여 전역 스코프를 오염시킬 수 있다. 또한 번들 파일에 포함되고 코드 상단에 **import 'babel-polyfill';** 을 추가해야 사용할 수 있다. 프로젝트에서 전역적으로 polyfill을 사용하거나 라이브러리 규모가 클 경우에 사용하는 게 유리하다.\n- Babel-Transform-Runtime는 플러그인으로 추가하면 되고 기능은babel-polyfill과 거의 비슷하나 array.includes()와 array.values() 같은 특정 함수를 제공하지않는다. core-js@3과 함께 사용하면 이 문제를 해결할 수 있다. 간단하게 라이브러리에서 사용하는 API를 래핑시킬 때 좋다.\n\n여기서는 core-js@3를 사용하며 @babel/preset-env의 옵션으로 폴리필을 설정한다. 우선 core-js를 설치해주자.\n\n    npm install core-js@3 --save\n\n.babelrc에 아래와 같이 추가한다. \"useBuiltIns\": \"usage\"는 트랜스파일 시 소스에서 쓰는 폴리필을 자동으로 넣어준다.\n\n    {\n      \"presets\": [\n        [\n          \"@babel/preset-env\",\n          {\n            \"useBuiltIns\": \"usage\",\n            \"corejs\": {\n              \"version\": 3,\n              \"proposals\": true\n            }\n          }\n        ]\n      ]\n    }\n\n구글 크롬 브라우저에 들어가보면 아래와 같이 트랜스 파일링 된 것을 알 수 있다.\n\n```js\n    /***/ \"./src/index.js\":\n    /*!**********************!*\\\n      !*** ./src/index.js ***!\n      \\**********************/\n    /*! no exports provided */\n    /***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n    \"use strict\";\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony import */ var core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.from */ \"./node_modules/core-js/modules/es.array.from.js\");\n    /* harmony import */ var core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0__);\n    /* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.string.iterator */ \"./node_modules/core-js/modules/es.string.iterator.js\");\n    /* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_1__);\n\n\n    console.log(Array.from('foo'));\n\n    /***/ }),\n```\n\nIE 11에서도 폴리필하려면 브라우저 타켓에 IE 11을 추가해야한다. .browserslistrc에 아래와 같이 추가하고 IE 브라우저를 확인하면 잘 동작하는 것을 볼 수 있다.\n\n    > 1%\n    last 2 versions\n    IE 11\n\n**참고**\n\n[웹팩의 기본 개념](http://jeonghwan-kim.github.io/js/2017/05/15/webpack.html)\n\n[[Tool] (번역)Babel에 대한 모든 것](https://jbee.io/etc/Everything-about-babel/)\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"5219daaeb39e005c6bc68059ba819110107f2daf","text":"# 최단 경로 알고리즘 - Dijkstra\n\n- Title : 최단 경로 알고리즘 - Dijkstra\n- Date : 2020-03-01\n- Category: Algorithm\n\n## Why?\n\n[1753번: 최단경로](https://www.acmicpc.net/problem/1753)\n\n> 최단 경로 문제는 네트워크에서 정점 u와 정점 v를 연결하는 경로 중에서 간선들의 가중치 합이 최소가 되는 경로를 찾는 문제다.\n\n## Dijkstra의 최단 경로 알고리즘\n\n네트워크에서 **하나의** 시작 정점으로부터 **모든** 다른 정점까지의 최단 경로를 찾는 알고리즘이다. 최단 경로는 경로의 길이순으로 구해진다.\n\n- 집합 S는 정점 v로부터의 최단 경로가 이미 발견된 정점들의 집합이다.\n- distance[]는 시작 정점에서 집합 S에 있는 정점을 거쳐서 다른 정점으로 가는 최단 거리를 기록한 배열이다.\n- distance 배열의 초깃값은 시작 정점이 v라면 distance[v] = 0 이고 다른 정점에 대한 distance 값은 v와 해당 정점 간의 가중치가 된다. 정점 v와 w와 직접 간선이 없다면 무한대 값을 저장한다.\n- 알고리즘 매 단계에서 집합 S에 없는 정점 중 가장 distance 값이 작은 정점을 S에 추가한다. 왜냐하면 현재 정점 u에서 x, y, z 중 y의 가중치가 최소라면 u → y가 u → x → y 또는 u → y → x 등 어떤 정점을 거쳐서 y로 가든 u → y 가 최단 경로이기 때문이다.\n- 새로운 정점 x가 S에 추가되면 S에 있지 않은 다른 정점들의 distance 값을 수정한다. 새로 추가된 정점 x를 거쳐 다른 정점까지 가는 거리와 기존의 거리를 비교하여 더 작은 거리로 distance 값을 수정한다. **distance[w] = min(distance[w], distance[x] + weight[x][w])** 식과 같다.\n\n![Dijkstra/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-01-img/Untitled.png)\n\n네트워크에 n개의 정점이 있다면, 다익스트라 최단 경로 알고리즘은 주 반복문을 n번 반복하고 내부 반복문을 2n번 반복하므로 **O(n²)** 의 복잡도를 가진다. distance를 배열이 아닌 **우선순위 큐**를 사용하면 더 빠르게 수행할 수 있다.\n\n### 백준 문제 풀이\n\n**1753번 최단경로**\n\n[1753번: 최단경로](https://www.acmicpc.net/problem/1753)\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #include <queue>\n    #define MAX_W 98765432\n    using namespace std;\n\n    vector<pair<int, int> > graph[20001];\n\n    vector<int> dijkstra (int s, int cv) {\n    \tvector<int> dis(cv, MAX_W);\n    \tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n    \tpq.push(make_pair(0, s));\n    \tdis[s] = 0;\n\n    \twhile (!pq.empty()) {\n    \t\tint cost = pq.top().first;\n    \t\tint v = pq.top().second;\n    \t\tpq.pop();\n    \t\tif (dis[v] < cost) continue;\n\n    \t\tfor (int i=0; i<graph[v].size(); i++) {\n    \t\t\tif (dis[graph[v][i].second] >= cost + graph[v][i].first) {\n    \t\t\t\tpq.push(make_pair(cost + graph[v][i].first, graph[v][i].second));\n    \t\t\t\tdis[graph[v][i].second] = cost + graph[v][i].first;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn dis;\n    }\n    int main() {\n    \tint v, e, s;\n    \tint a, b, c;\n\n    \tscanf(\"%d %d\", &v, &e);\n    \tscanf(\"%d\", &s);\n\n    \twhile (e--) {\n    \t\tscanf(\"%d %d %d\", &a, &b, &c);\n    \t\tgraph[a].push_back(make_pair(c, b));\n    \t}\n\n    \tvector<int> dis = dijkstra(s, v + 1);\n\n    \tfor (int i=1; i<v+1; i++) {\n    \t\tif (dis[i] == MAX_W)\n    \t\t\tprintf(\"INF\\n\");\n    \t\telse\n    \t\t\tprintf(\"%d\\n\", dis[i]);\n    \t}\n\n    \treturn 0;\n    }\n```\n\n**참고**\n\n[C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539)\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e027d4b137d5f1bb918e6d826d69a9f8803d0228","text":"# MST(최소신장트리)\n\n- Title : MST(최소신장트리)\n- Date : 2020-02-28\n- Category: Algorithm\n\n## Why?\n\n[1922번: 네트워크 연결](https://www.acmicpc.net/problem/1922)\n\n이 문제를 풀면서 MST 이론을 정리해놔야 겠다는 생각이 들었다.\n\n## MST(Minimun spanning tree)란?\n\n신장 트리는 그래프 내의 모든 정점을 포함하는 트리다. 트리의 특수한 형태로 **모든 정점들이 연결**되어 있어야 하고 사이클을 포함해서는 안된다. 따라서 신장 트리는 그래프에 있는 n개의 정점을 정확히 n-1개의 간선으로 연결하게 된다.\n\n하나의 그래프에는 많은 신장 트리가 존재할 수 있는 데 이 중 사용된 간선들의 **가중치 합이 가장 최소인 신장 트리**가 최소 신장 트리가 된다.\n\n## 신장 트리 찾기\n\nDFS나 BFS를 사용하여 탐색 도중에 사용된 간선을 모으면 신장 트리를 만들 수 있다.\n\n**DFS와 큐로 신장트리 찾기**\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #include <queue>\n    #define MAX_NODE 20\n    using namespace std;\n\n    vector<int> graph[MAX_NODE]; // 인접 리스트로 구현한 그래프\n    bool visited[MAX_NODE] = {false}; // 방문 표시\n    queue<int> st; // 신장 트리\n\n    void dfs(int v) { // 시작 노드\n    \tvisited[v] = true;\n    \tst.push(v);\n    \tfor (int i=0; i<graph[v].size(); i++) {\n    \t\tif (!visited[graph[v][i]]) {\n    \t\t\tdfs(graph[v][i]);\n    \t\t}\n    \t}\n    }\n```\n\n## 최소 신장 트리 찾기\n\n> 구하는 방법으로는 Kruskal과 Prime이 제안한 알고리즘이 대표적이다. 이 알고리즘들은 최소 신장 트리가 간선의 가중치의 합이 최소이어야 하고, 반드시 n-1개의 간선만 사용해야 하며, 사이클이 포함되어서는 안 된다는 조건들을 적절히 이용한다.\n\n### Kruskal의 MST 알고리즘\n\n이 알고리즘은 **탐욕적인 방법**을 이용한다. 탐욕적인 방법은 결정을 해야 할때마다 그 순간에 가장 최적이라고 생각되는 것을 선택함으로써 최종적인 해답을 구한다. 최적을 선택했다고 항상 최적의 해답을 주는 건 아니지만 다행히 Kruskal 알고리즘은 최적의 해답을 주는 것으로 증명되어 있다.\n\n- 그래프 e개의 간선들을 가중치의 오름차순으로 정렬한다.\n- 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택하여 현재의 최소 비용 신장 트리의 집합에 추가한다. 만약 사이클을 형성하면 그 간선은 제외된다.\n- 선택된 간선의 개수가 정점의 개수보다 하나 적으면 알고리즘을 종료한다.\n\n**사이클 체크**\n\n간선을 집합에 추가할 때 사이클을 생성하는지를 체크해야 한다. 양 끝 정점이 서로 다른 집합에 속하는 경우 두 정점을 연결하여도 사이클이 형성되지 않는다. Union-Find 알고리즘을 이용하여 간선의 양끝 정점이 같은 집합에 속해 있는지를 검사할 수 있다.\n\n**시간복잡도**\n\nUnion-Find 알고리즘을 이용하면 Kruskal 알고리즘의 시간 복잡도는 간선들을 정렬하는 시간에 좌우된다. 따라서 간선 e개를 퀵 정렬과 같은 효율적인 알고리즘으로 정렬한다면 시간복잡도는 **O(elog₂e)** 다.\n\n✔**백준 문제 풀이**\n\n1922번 문제를 Kruskal 알고리즘을 사용한 풀이\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #include <algorithm>\n\n    using namespace std;\n\n    struct Info {\n    \tint a;\n    \tint b;\n    \tint c;\n    };\n\n    int n;\n    int parent[1001]; // 부모 노드\n    int num[1001]; // 집합의 크기\n\n    void set_init(int n) {\n    \tfor (int i=1; i<n+1; i++) {\n    \t\tparent[i] = i;\n    \t\tnum[i] = 1;\n    \t}\n    }\n    int set_find(int v) {\n    \tif (parent[v] == v) return v;\n    \treturn parent[v] = set_find(parent[v]);\n    }\n\n    bool set_union(int a, int b) {\n    \ta = set_find(a);\n    \tb = set_find(b);\n\n    \tif (a == b) return false;\n\n    \tif (num[a] > num[b]) swap(a, b);\n    \tparent[a] = b;\n    \tif (num[a] == num[b]) num[b]++;\n    \treturn true;\n    }\n\n    bool compare(Info t1, Info t2) {\n    \treturn t1.c < t2.c;\n    }\n    int main() {\n    \tint m, a, b, c;\n    \tscanf(\"%d\", &n);\n    \tscanf(\"%d\", &m);\n    \tvector<Info> edge;\n\n    \twhile (m--) {\n    \t\tscanf(\"%d %d %d\", &a, &b, &c);\n    \t\tedge.push_back({a, b, c});\n    \t}\n\n    \tsort(edge.begin(), edge.end(), compare);\n\n    \tset_init(n);\n\n    \tint count = 0, cost = 0;\n    \tint ra, rb;\n    \tfor (int i=0; i<edge.size(); i++) {\n    \t\tif (set_union(edge[i].a, edge[i].b)) {\n    \t\t\tcost += edge[i].c;\n    \t\t\tif(++count == n-1) break;\n    \t\t}\n    \t}\n\n    \tprintf(\"%d\", cost);\n\n    \treturn 0;\n    }\n```\n\n✔**응용 문제**\n\n백준 4195번\n\n[4195번: 친구 네트워크](https://www.acmicpc.net/problem/4195)\n\n```cpp\n    #include <iostream>\n    #include <string>\n    #include <map>\n    using namespace std;\n\n    map<string, string> parent;\n    map<string, int> num;\n\n    void check_init(string v) {\n    \tif (parent.find(v) == parent.end()) {\n    \t\tparent.insert(make_pair(v, v));\n    \t\tnum.insert(make_pair(v, 1));\n    \t}\n    }\n    string set_find(string v) {\n    \tif(parent[v] == v) return v;\n    \treturn parent[v] = set_find(parent[v]);\n    }\n\n    int set_union(string a, string b) {\n    \ta = set_find(a);\n    \tb = set_find(b);\n    \tif (a == b) return num[a];\n    \tif (num[a] > num[b]) swap(a, b);\n    \tparent[a] = b;\n    \tnum[b] += num[a];\n    \treturn num[b];\n    }\n    int main() {\n    \tios::sync_with_stdio(false);\n    \tcin.tie(0);\n    \tint t, f;\n    \tcin >> t;\n\n    \twhile(t--) {\n    \t\tcin >> f;\n    \t\twhile (f--) {\n    \t\t\tstring a, b;\n    \t\t\tcin >> a;\n    \t\t\tcin >> b;\n\n    \t\t\tcheck_init(a);\n    \t\t\tcheck_init(b);\n\n    \t\t\tcout << set_union(a, b) << \"\\n\";\n    \t\t}\n    \t\tparent.clear();\n    \t\tnum.clear();\n    \t}\n\n    \treturn 0;\n    }\n```\n\n> 다른 사람 풀이보다 시간이 더 걸려서 비교해보니 map<string, int>로 기존 Union-Find 알고리즘을 그대로 사용할 수 있게 이름에 index를 강제 할당시키는 방식이었다. 왜 이런 생각을 못했지.....😢😢 아! 그리고 **ios::sync_with_stdio(false); cin.tie(0);** 를 안했더니 시간 초과가 났었다.\n\n### Prim의 MST 알고리즘\n\nKruskal은 간선 선택을 기반으로 하는 알고리즘인 반면에, Prim의 알고리즘은 **정점 선택**을 기반으로 하는 알고리즘이다. 또한 Kruskal의 알고리즘은 이전 단계에서 만들어진 신장 트리와는 상관없이 무조건 최소 간선만을 선택하는 방법인 데 반하여 Prime의 알고리즘은 이전 단계에서 만들어진 신장 트리를 확장하는 방식이다.\n\n- 시작 단계에는 시작 정점만이 신장 트리 집합에 포함된다.\n- 앞 단계에서 만들어진 신장 트리 집합에 속한 정점들의 인접 정점들 중에서 최소 비용 간선으로 연결된 정점을 선택하여 신장 트리 집합에 포함한다.\n- 트리 집합의 정점 개수가 n개가 될 때까지 이 과정을 반복한다.\n\n아래 그림으로 예를 들어보자.\n\n- 우선 A 정점을 신장 트리 집합에 포함시킨다.\n- A 정점의 인접 정점인 D, B와 연결된 간선 중 가중치가 최소인 D를 선택하여 집합에 포함시킨다.\n- 신장 트리 집합의 정점 개수가 2개{A, D}로 아직 7개가 아니므로 다시 A, D의 인접 정점을 확인한다.\n- A-B, D-B, D-E, D-F 간선 중 가중치가 최소인 정점인 F를 선택하여 집합에 포함시킨다.\n- 반복..\n\n![MST/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-28-img/Untitled.png)\n\n**구현 방법**\n\n- dist[정점개수] 배열이 필요하다. dist는 현재 신장 트리의 정점 집합에서 각 정점까지의 거리를 가지고 있다. A(0)가 시작 정점이면 dist[0]만 값이 0이고 나머지 배열의 값은 무한대를 가진다. 명백하게 처음에는 트리 집합에 아무것도 없으므로 당연하다. 정점들이 트리 집합에 추가되면서 dist 값은 변경된다.\n- 우선순위 큐가 필요하다. 큐에 모든 정점을 삽입하는 데 이 때 우선순위는 dist 배열 값이 된다.\n- while 루프로 큐에서 가장 작은 dist 값을 가지는 정점을 추출한다. 추출된 정점이 트리 집합에 추가된다.\n- 트리 집합에 새로운 정점 u가 추가되었으므로 u에 인접한 정점 v들의 dist 값을 변경시켜준다. 즉, 기존의 dist[v] 값보다 간선(u, v)의 가중치가 적으면 간선 (u, v)의 가중치로 dist[v]를 변경시킨다.\n- 큐가 빌 때까지 반복한다.\n\n**시간복잡도**\n\nPrim의 알고리즘은 배열을 사용하면 주 반복문이 정점의 수 n만큼 반복하고, 내부 반복문이 n번 반복하므로 Prim의 알고리즘의 시간 복잡도는 O(n²)다. 하지만 우선 순위 큐를 사용하면 **O(elongv)** 의 시간복잡도를 가진다.\n\n✔**백준 문제 풀이**\n\n1197번 문제를 Prim의 알고리즘을 사용한 풀이\n\n[1197번: 최소 스패닝 트리](https://www.acmicpc.net/problem/1197)\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #include <queue>\n    using namespace std;\n\n    bool selected[10001] = {false}; // selected[i]: true면 mst 집합의 원소, false면 선택 가능\n    vector<pair<int, int> > edge[100001]; // 인접 리스트로 그래프 자료구조 구현\n\n    int prim() {\n    \tint cost = 0;\n    \t// 우선 순위 큐: 가중치가 적은 정점이 우선 순위로 나오게\n    \tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n    \tpq.push(make_pair(0, 1)); // 가중치:0, 정점: 1\n\n    \twhile (!pq.empty()) {\n    \t\tpair<int, int> p = pq.top();\n    \t\tpq.pop();\n    \t\tif (selected[p.second]) continue; // 이미 선택된 정점이면 작업할 필요가 없다.\n    \t\tselected[p.second] = true;\n    \t\tcost += p.first;\n    \t\tfor (int i=0; i<edge[p.second].size(); i++) {\n    \t\t\tif (!selected[edge[p.second][i].second]) {\n    \t\t\t\tpq.push(edge[p.second][i]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn cost;\n\n    }\n    int main() {\n    \tios::sync_with_stdio(false);\n    \tcin.tie(0);\n\n    \tint v, e;\n    \tcin >> v >> e;\n    \tint t = e;\n    \twhile (t--) {\n    \t\tint a, b, c;\n    \t\tcin >> a >> b >> c;\n    \t\tedge[a].push_back(make_pair(c, b));\n    \t\tedge[b].push_back(make_pair(c, a));\n    \t}\n\n    \tprintf(\"%d\", prim());\n\n    \treturn 0;\n    }\n```\n\n> 우선 순위 큐에 전달할 데이터가 2개 이상일 때, pair로 묶으면 first 값을 1순위, second 값을 2순위로 우선 순위를 정할 수 있다.\n\n**정리**\n\nKruskal 알고리즘은 희박한 그래프를 대상으로 할 경우에 유리하고 밀집한 그래프의 경우에는 Prim의 알고리즘이 적합하다라고 할 수 있다. 밀집 그래프는 간선이 많이 존재하는 그래프, 희소 그래프는 적은 숫자의 간선을 가지는 그래프다.\n\n**참고**\n\n[C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539)\n"}}}},"pageContext":{"id":"5d8f5742317fc2443a1810a411eb106b455e189d","previousPostId":"5219daaeb39e005c6bc68059ba819110107f2daf","nextPostId":"e027d4b137d5f1bb918e6d826d69a9f8803d0228"}},"staticQueryHashes":["2685952063","2841359383"]}