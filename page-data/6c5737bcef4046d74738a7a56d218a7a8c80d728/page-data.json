{"componentChunkName":"component---src-templates-blog-post-js","path":"/6c5737bcef4046d74738a7a56d218a7a8c80d728","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"6c5737bcef4046d74738a7a56d218a7a8c80d728","text":"# 백준 - 16235 나무 재테크(C++)\n\n- Title : 백준 - 16235 나무 재테크(C++)\n- Date : 2020-01-28\n- Category: 알고리즘 풀이\n\n# 나무 재테크\n\n- 각 계절을 구현하는 데는 어려움이 없었으나 처음에 벡터 하나에 나무를 다 저장하고 매번 sort를 해서 시간 초과가 발생했었다.\n- 고민하다가 각 칸마다 deque에 나무 나이를 담는 식으로 바꿨다.\n- vector가 아닌 deque를 선택한 건 가을(번식)때 생성되는 나무는 나이가 1이므로 맨 앞에 추가되어야하기 때문이다.\n- vector는 배열이라 맨 앞 추가할 때 O(N)의 시간복잡도가 발생한다.\n- deque로 바꿨기에 처음 1번만 sort를 사용하여 효율성을 높였다.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <deque>\nusing namespace std;\n\n#define MAX 10\n\nint N, M, K;\nint A[MAX][MAX]; // 로봇 양분\nint L[MAX][MAX]; // 땅\ndeque<int> T[MAX][MAX]; // 각 땅의 나무 나이\n\nvoid addTree(int r, int c){\n\tif (r < 0 || c < 0 || r >= N || c >= N) return;\n\tT[r][c].push_front(1);\n}\n\nint main() {\n\tint x, y, age;\n\tscanf(\"%d %d %d\", &N, &M, &K);\n\n\tfor (int i=0; i<N; i++) {\n\t\tfor (int j=0; j<N; j++) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t\tL[i][j] = 5;\n\t\t}\n\t}\n\tfor (int i=0; i<M; i++) {\n\t\tscanf(\"%d %d %d\", &x, &y, &age);\n\t\tT[--x][--y].push_back(age);\n\t}\n\n\tfor (int i=0; i<N; i++) {\n\t\tfor (int j=0; j<N; j++) {\n\t\t\tif (T[i][j].size() > 1) {\n\t\t\t\tsort(T[i][j].begin(), T[i][j].end());\n\t\t\t}\n\t\t}\n\t}\n\n\tbool flag;\n\twhile(K-- > 0) {\n\n\t\t// 같은 칸이면 어린 순으로 나이만큼 양분먹고 나이 증가\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tdeque<int> &tmp = T[i][j];\n\t\t\t\tflag = true;\n\t\t\t\tfor(auto iter=tmp.begin(); iter != tmp.end();) {\n\t\t\t\t\tint &t = *iter;\n\t\t\t\t\tif (L[i][j] >= t && flag) {\n\t\t\t\t\t\tL[i][j] -= t;\n\t\t\t\t\t\tt += 1;\n\t\t\t\t\t\titer++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t// 여름 처리\n\t\t\t\t\t\tL[i][j] += t / 2;\n\t\t\t\t\t\titer = tmp.erase(iter);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\t// 나이 5의 배수 나무 번식\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tdeque<int> &tmp = T[i][j];\n\t\t\t\tfor(auto iter=tmp.begin(); iter != tmp.end(); iter++) {\n\t\t\t\t\tint t = *iter;\n\t\t\t\t\tif (t % 5 == 0) {\n\t\t\t\t\t\taddTree(i - 1, j - 1);\n\t\t\t\t\t\taddTree(i - 1, j);\n\t\t\t\t\t\taddTree(i - 1, j + 1);\n\t\t\t\t\t\taddTree(i, j - 1);\n\t\t\t\t\t\taddTree(i, j + 1);\n\t\t\t\t\t\taddTree(i + 1, j - 1);\n\t\t\t\t\t\taddTree(i + 1, j);\n\t\t\t\t\t\taddTree(i + 1, j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 로봇이 양분 추가\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tL[i][j] += A[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i=0; i<N; i++) {\n\t\tfor (int j=0; j<N; j++) {\n\t\t\tans += T[i][j].size();\n\t\t}\n\t}\n\tprintf(\"%d\", ans);\n\n\treturn 0;\n}\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"74f84e9d20d88dabd2edfd88b79237bc44153e4a","text":"# 백준 - 17142 연구소3(C++)\n\n- Title : 백준 - 17142 연구소3(C++)\n- Date : 2020-01-29\n- Category: 알고리즘 풀이\n\n## 입력 받기\n\n- 연구소 상태는 N x N 이니깐 int A[N][n] 형태로 입력을 저장해야겠다.\n- 입력을 받을 때, 선택 가능한 바이러스들(값이 2인)의 row, col 값을 따로 저장할 필요가 있겠네. pair<int, int> V[10] 형태로 저장해야겠다. 바이러스 개수는 최대 10이니깐 배열의 크기는 10으로 하자.\n- 퍼트릴 수 있는 빈 칸의 개수도 카운트 해놓자. 그래야 모든 빈칸에 바이러스를 퍼트렸는 지 알 수 있으니깐.\n- 아! 퍼트린 후 연구소 상태를 원상 복귀해야하니깐 int TMP[N][n] 형태의 2차원 배열을 만들어놔야지.\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nint main() {\n  int A[50][50]; // 연구소\n  int TMP[50][50]; // 연구소 결과 처리용\n  int N, M; // N: 연구소 크기, M: 활성화할 바이러스 수\n  int tcnt = 0; // 연구소 빈칸(0)의 개수\n  pair<int, int> V[10]; // 연구소 선택 가능한 바이러스(2)의 위치\n  int vcnt = 0; // V 배열을 위한 인덱스\n  int prow[4] = {-1, 1, 0, 0}; // 상하좌우 확산 시 사용 row\n  int pcol[4] = {0, 0, -1, 1}; // 상하좌우 확산 시 사용 col\n\n  // 입력받기\n  scanf(\"%d %d\", &N, &M);\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n      TMP[i][j] = A[i][j];\n      if (A[i][j] == 2) V[vcnt++] = make_pair(i, j);\n      if (A[i][j] == 0) tcnt++;\n    }\n  }\n}\n```\n\n## 활성화할 바이러스 선택하기\n\n- DFS로 할 수도 있지만 비트 마스크로 풀어봐야지\n- 만약 5개의 바이러스 중 3개를 선택해야한다면 범위는 00111 ~ 11100 이다.\n- 근데 사실, DFS로 하는 게 코드가 간단해서... DFS가 나을 듯,, 비트 마스크로 풀다가 실수를 너무 많이 했다.\n\n```cpp\n  unsigned int flag = (1 << M) - 1; // 시작 플래그, unsigned int는 양수 범위를 가짐\n  int tcc = M;\n  unsigned int fin = 0; // 종료 플래그\n  // 종료 플래그 만들기.\n  while (tcc-- > 0) {\n    fin |= (1 <<  (vcnt - 1 - tcc));\n  }\n  unsigned int curflag = 0; // 조작용\n  int fcnt = 0;\n  int pos = 0;\n  queue<pair<int, int> > q;\n  // 시작플래그 ~ 종료플래그\n  for (flag; flag<=fin; flag++) {\n    curflag = flag;\n    fcnt = 0;\n    // 1비트 개수 세기, M개 일때만 코드 진행\n    while (curflag > 0) {\n      if (curflag & 1 == 1) fcnt++;\n      if (fcnt > M) break;\n      curflag = curflag >> 1;\n    }\n    if (fcnt != M) continue;\n\t\t// 이제 고른 바이러스 표시하기\n    curflag = flag;\n    pos = 0;\n    while (curflag > 0) {\n      if (curflag & 1 == 1) {\n        TMP[V[pos].first][V[pos].second] = -1; // 바이러스 복제\n        // 큐에 선택한 바이러스 넣기 -> 퍼트리기에서 BFS로 사용할 예정\n        q.push(make_pair(V[pos].first, V[pos].second));\n      }\n      pos++;\n      curflag = curflag >> 1;\n    }\n    // ...바이러스 퍼트리기가 이어진다.\n  }\n```\n\n## 바이러스 퍼트리기\n\n- 만약 백준에서 제출 시 100%에서 틀린다면 비활성화 바이러스도 시간 체크했는 지 살펴봐야한다.\n  여기서 엄청 헤매서 시간 다 잡아먹었다ㅠㅠ\n- 쉽게 설명하자면 대부분 BFS로 q가 빌 때까지 반복을 돌릴텐데 만약 이미 빈칸(0)에는 다 전파했는 데 q에 비활성화(선택 못 받은 바이러스)가 있다면? 이 상황을 이해한다면 오류를 잡을 수 있을 거다.\n  > 반례가 있어야 이해가 되겠죠?  \n  > 5 1  \n  > 1 1 1 1 1  \n  > 1 1 1 1 1  \n  > 1 1 1 1 1  \n  > 2 0 0 2 0  \n  > 1 1 1 1 1  \n  > answer : 2\n- 사실 q에 시간 체크용 값도 넣어버려서.. 복잡하게 풀어버린 것 같다..\n- 더 간단히 풀 수 있을 듯..\n\n```cpp\n  // ..위에는 바이러스 선택하기\n  // 시간 체크용, 현재 q에는 선택된 바이러스가 있고 얘는 0초이므로 0을 넣어준다. -1은 구분 용\n  q.push(make_pair(-1, 0));\n  spread = 0; // 퍼진 바이러스\n  time = 0; // 시간\n  stopflag = false; // 빈칸에 다 퍼트렸으면 true로 바꿀거다.\n  while (!q.empty()) {\n    // c++에서 q.pop()은 void 메소드라서 q.front()로 값 가져온다.\n    pair<int, int> po = q.front();\n    q.pop();\n    if (po.first >= 0) { // 퍼트린 칸이면\n      if (A[po.first][po.second] == 0) spread++; // 해당 칸이 원래 빈칸(0)이면 값 증가\n      if (spread == tcnt) stopflag = true; // 빈칸에 다 퍼트리면 시간체크용 값 나올 때 스탑하려고\n      for (int i=0; i<4; i++) { // 상하좌우 처리\n        nextrow = po.first + prow[i];\n        nextcol = po.second + pcol[i];\n        if (nextrow < 0 || nextrow >= N || nextcol < 0 || nextcol >= N) continue; // 범위 밖\n        if (TMP[nextrow][nextcol] == -1 || TMP[nextrow][nextcol] == 1) continue;\n        q.push(make_pair(nextrow, nextcol)); // 큐에 넣자넣자!\n        TMP[nextrow][nextcol] = -1; // 퍼트렸다는(방문했다는) 표시!\n      }\n    } else { // 시간체크용\n      time = po.second;\n      if (!q.empty()) q.push(make_pair(-1, po.second + 1));\n      if (stopflag) break; // 이미 모든 빈칸에 퍼트렸으면 나오자!\n    }\n  }\n  while (!q.empty()) // 위 반복에서 stopflag에 의해 중간에 빠져나왔을 경우를 대비해서\n  {\n    q.pop();\n  }\n  // 시간 넣자!!\n  if (spread == tcnt && ans > time) ans = time;\n```\n\n## 원상복귀\n\n- TMP는 또 써야하니깐!\n\n```cpp\nfor (int i=0; i<N; i++) {\n  for (int j=0; j<N; j++) {\n    TMP[i][j] = A[i][j];\n  }\n}\n```\n\n## 전체 코드\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <limits>\nusing namespace std;\n\n\nint A[50][50];\nint TMP[50][50];\nint N, M;\nint vcnt = 0;\nint tcnt = 0;\npair<int, int> V[10];\nint prow[4] = {-1, 1, 0, 0};\nint pcol[4] = {0, 0, -1, 1};\n\nint main() {\n  // 입력받기\n  scanf(\"%d %d\", &N, &M);\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n      TMP[i][j] = A[i][j];\n      if (A[i][j] == 2) V[vcnt++] = make_pair(i, j);\n      if (A[i][j] == 0) tcnt++;\n    }\n  }\n  unsigned int flag = (1 << M) - 1; // 시작 플래그, unsigned int는 양수 범위를 가짐\n  int tcc = M;\n  unsigned int fin = 0; // 종료 플래그\n  // 종료 플래그 만들기.\n  while (tcc-- > 0) {\n    fin |= (1 <<  (vcnt - 1 - tcc));\n  }\n  unsigned int curflag = 0; // 조작용\n  int fcnt = 0;\n  int pos = 0;\n  int nextrow = 0, nextcol = 0;\n  queue<pair<int, int> > q;\n  int spread = 0, time = 0;\n  int ans = numeric_limits<int>::max();\n  bool stopflag = false;\n  // 시작플래그 ~ 종료플래그\n  for (flag; flag<=fin; flag++) {\n    curflag = flag;\n    fcnt = 0;\n    // 1비트 개수 세기, M개 일때만 코드 진행\n    while (curflag > 0) {\n      if (curflag & 1 == 1) fcnt++;\n      if (fcnt > M) break;\n      curflag = curflag >> 1;\n    }\n    if (fcnt != M) continue;\n\t\t// 이제 고른 바이러스 표시하기\n    curflag = flag;\n    pos = 0;\n    while (curflag > 0) {\n      if (curflag & 1 == 1) {\n        TMP[V[pos].first][V[pos].second] = -1; // 바이러스 복제\n        // 큐에 선택한 바이러스 넣기 -> 퍼트리기에서 BFS로 사용할 예정\n        q.push(make_pair(V[pos].first, V[pos].second));\n      }\n      pos++;\n      curflag = curflag >> 1;\n    }\n    q.push(make_pair(-1, 0));\n    spread = 0; // 퍼진 바이러스\n    time = 0; // 시간\n    stopflag = false; // 빈칸에 다 퍼트렸으면 true로 바꿀거다.\n    while (!q.empty()) {\n      // c++에서 q.pop()은 void 메소드라서 q.front()로 값 가져온다.\n      pair<int, int> po = q.front();\n      q.pop();\n      if (po.first >= 0) { // 퍼트린 칸이면\n        if (A[po.first][po.second] == 0) spread++; // 해당 칸이 원래 빈칸(0)이면 값 증가\n        if (spread == tcnt) stopflag = true; // 빈칸에 다 퍼트리면 시간체크용 값 나올 때 스탑하려고\n        for (int i=0; i<4; i++) { // 상하좌우 처리\n          nextrow = po.first + prow[i];\n          nextcol = po.second + pcol[i];\n          if (nextrow < 0 || nextrow >= N || nextcol < 0 || nextcol >= N) continue; // 범위 밖\n          if (TMP[nextrow][nextcol] == -1 || TMP[nextrow][nextcol] == 1) continue;\n          q.push(make_pair(nextrow, nextcol)); // 큐에 넣자넣자!\n          TMP[nextrow][nextcol] = -1; // 퍼트렸다는(방문했다는) 표시!\n        }\n      } else { // 시간체크용\n        time = po.second;\n        if (!q.empty()) q.push(make_pair(-1, po.second + 1));\n        if (stopflag) break; // 이미 모든 빈칸에 퍼트렸으면 나오자!\n      }\n    }\n    while (!q.empty()) // 위 반복에서 stopflag에 의해 중간에 빠져나왔을 경우를 대비해서\n    {\n      q.pop();\n    }\n    // 시간 넣자!!\n    if (spread == tcnt && ans > time) ans = time;\n    for (int i=0; i<N; i++) {\n      for (int j=0; j<N; j++) {\n        TMP[i][j] = A[i][j];\n      }\n    }\n  }\n  if (ans == numeric_limits<int>::max()) ans = -1;\n  printf(\"%d\", ans);\n  return 0;\n}\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d79c410b05d91234e7105209de7dcf5c278166bf","text":"# 백준 - 17143 낚시왕(C++)\n\n- Title : 백준 - 17143 낚시왕(C++)\n- Date : 2020-01-28\n- Category: 알고리즘 풀이\n\n# 낚시왕\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\nusing namespace std;\n\nstruct Shark\n{\n\tint r;\n\tint c;\n\tint s; // 속력\n\tint d; // 이동\n\tint z; // 크기\n};\n\nint main() {\n\tint R, C, M;\n\tint r, c, s, d, z;\n\tmap<int, Shark> sharkmap; // 상어정보들 [크기, 정보구조체]\n\tmap<int, Shark>::iterator it;\n\tint row[5] = {0, -1, 1, 0, 0}; // 1:위, 2:아래, 3: 오른쪽, 4:왼쪽\n\tint col[5] = {0, 0, 0, 1, -1};\n\tint ans = 0;\n\n\tscanf(\"%d %d %d\", &R, &C, &M);\n\tint arr[R+1][C+1] = {0};\n\tint arrtmp[R+1][C+1] = {0};\n\tfor (int i=0; i<M; i++) {\n\t\tscanf(\"%d %d %d %d %d\", &r, &c, &s, &d, &z);\n\t\tarr[r][c] = z;\n\t\tShark tmp = {r, c, s, d, z};\n\t\tsharkmap.insert(make_pair(z, tmp));\n\t}\n\n\n\tint nr, nc, nd, move;\n\tfor (int i=1; i<=C; i++) {\n\n\n\t\t// 상어잡기\n\t\tfor (int j=1; j<=R; j++) {\n\t\t\tif (arr[j][i] > 0) {\n\t\t\t\tsharkmap.erase(arr[j][i]);\n\t\t\t\tans += arr[j][i];\n\t\t\t\tarr[j][i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// 상어이동\n\t\tfor(it=sharkmap.begin(); it != sharkmap.end(); it++) {\n\t\t\tShark &shark = it -> second;\n\t\t\t// 오른쪽, 왼쪽\n\t\t\tif (shark.d == 3 || shark.d == 4) {\n\t\t\t\tmove = shark.s % ((C-1)*2);\t// 실제 이동해야할 MOVE\n\t\t\t\tnc = shark.c;\n\t\t\t\tnd = shark.d;\n\t\t\t\twhile (move > 0) {\n\t\t\t\t\tif (nc == 1) nd = 3;\n\t\t\t\t\telse if (nc == C) nd = 4;\n\t\t\t\t\tnc += col[nd];\n\t\t\t\t\tmove--;\n\t\t\t\t}\n\t\t\t\tshark.d = nd;\n\t\t\t\tshark.c = nc;\n\t\t\t}\n\t\t\t// 위, 아래\n\t\t\telse if (shark.d == 1 || shark.d == 2) {\n\t\t\t\tmove = shark.s % ((R-1)*2);\t// 실제 이동해야할 MOVE\n\t\t\t\tnr = shark.r;\n\t\t\t\tnd = shark.d;\n\t\t\t\twhile (move > 0) {\n\t\t\t\t\tif (nr == 1) nd = 2;\n\t\t\t\t\telse if (nr == R) nd = 1;\n\t\t\t\t\tnr += row[nd];\n\t\t\t\t\tmove--;\n\t\t\t\t}\n\t\t\t\tshark.d = nd;\n\t\t\t\tshark.r = nr;\n\t\t\t}\n\t\t\t// 상어 먹기\n\t\t\tif (arrtmp[shark.r][shark.c] < shark.z) {\n\t\t\t\tif (arrtmp[shark.r][shark.c] > 0)\n\t\t\t\t\tsharkmap.erase(arrtmp[shark.r][shark.c]);\n\n\t\t\t\tarrtmp[shark.r][shark.c] = shark.z;\n\n\t\t\t} else sharkmap.erase(shark.z);\n\n\n\t\t}\n\n\t\tfor (int j=1; j<=R; j++) {\n\t\t\tfor (int k=1; k<=C; k++) {\n\t\t\t\tarr[j][k] = arrtmp[j][k];\n\t\t\t\tarrtmp[j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\", ans);\n\n\treturn 0;\n}\n```\n"}}}},"pageContext":{"id":"6c5737bcef4046d74738a7a56d218a7a8c80d728","previousPostId":"74f84e9d20d88dabd2edfd88b79237bc44153e4a","nextPostId":"d79c410b05d91234e7105209de7dcf5c278166bf"}},"staticQueryHashes":["2685952063","2841359383"]}