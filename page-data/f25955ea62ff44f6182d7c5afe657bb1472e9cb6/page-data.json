{"componentChunkName":"component---src-templates-blog-post-js","path":"/f25955ea62ff44f6182d7c5afe657bb1472e9cb6","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f25955ea62ff44f6182d7c5afe657bb1472e9cb6","text":"# Travis에서 MongoDB 사용하기 & Heroku 배포하기\n\n- Title : Travis에서 MongoDB 사용하기\n- Date : 2020-03-30\n- Category : Infra\n\n# WHY?\n\nTravis에서 MongoDB Altas 연결이 실패하여 테스트 실패하는 현상이 계속 발생하였다. 로컬에서는 잘되는 데 왜 travis에서는 안될까? 해결 방법은 간단했다. travis 내에서 로컬 MongoDB를 돌려주는 거였고 이는 Travis가 아주 편리하게 제공하고 있었다.\n\n# SOLVE\n\n1. .travis.yml 에 아래 코드를 추가해준다.\n\n    services:\n      – mongodb\n\n2. travis → setting → 변수 설정에서 이름은 각자 코드 내에서 쓰는 환경 변수 이름을 적고 값은 `mongodb://localhost:27017/mydb_test` 로 하면 된다.\n\ntravis에서 mongodb를 사용할 때는 따로 데이터베이스 만들 필요가 없고 로컬 호스트(127.0.0.1)로 바인딩되므로 위와 같이 쓰면 된다.\n\n# WHY?\n\n헤로쿠로 자동 배포되게 하는 거 까먹어서 기록 + Node.js 앱 배포\n\n[Travis CI Documentation](https://docs.travis-ci.com/user/deployment/heroku/)\n\n# SOLVE\n\n1. .travis.yml에 아래와 같이 작성한다.\n\n    deploy:\n      provider: heroku\n      api_key:\n        secure: <암호화한 heroku api token>\n      app: express-project-blog\n\n- app은 헤로쿠 앱 이름을 적으면 된다. 안 적어도 되긴 함\n\n2. secure 키 구하기\n\n- Heroku CI를 깔고 token 얻기. 아래 명령어를 치면 나오는 토큰을 복사해놓는다.\n\n    heroku auth:token\n\n- 윈도우인 경우 ruby cmd창에 travis CI를 깔고 아래 명령어 입력. 이 때 명령어 실행 위치에 .travis.yml 파일이 있어야한다. 따로 repo 설정을 안해줘서 —repo 옵션으로 github 위치 적어주면 travis.yml 파일에 알아서 암호화된 api_key가 생김\n\n    travis encrypt <복사한 TOKEN> --add deploy.api_key --pro --repo=devgaram/express-mongo-rest-api\n\n> [travis-ci.com](http://travis-ci.com/) 에서 빌드할 경우 —pro 옵션과 함께 암호화해야 정상적으로 인증할 수 있음..\n\n3. 헤로쿠 설정\n\n- 빌드팩에 nodejs 추가하기\n\n![Travis%20MongoDB%20Heroku/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-03-30-img/Untitled.png)\n\n- 프로젝트에서 es6를 사용하기 위해 babel을 이용해 빌드하는 경우가 있는 데, 이 때는 환경변수를 따로 설정해줘야 devdependencies도 설치되서 babel을 실행할 수 가 있다.\n\n![Travis%20MongoDB%20Heroku/Untitled%201.png](Travis%20MongoDB%20Heroku/Untitled%201.png)"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d828d76a01fdf156e30e5cff57c159e3cbf5c5f0","text":"# git rebase\n\nDate: Apr 27, 2020\n\n- Title : git rebase\n- Date : 2020-04-27\n- Category : Git\n\n## git rebase 하기\n\n```bash\ngit checkout develop\n\ngit fetch origin develop\n\ngit checkout feature\n\ngit rebase origin/develop\n\n// conflict 발생 시 충돌 해결 후\ngit add <수정된 파일 이름>\n\ngit rebase --continue\n```\n\n- git fetch origin develop을 하면 로컬의 origin/develop 에 원격저장소 develop의 최신 커밋들이 싱크된다. 그래서 rebase 대상이 develop이 아니라 origin/develop 이다.\n- 충돌 해결 후 파일을 commit 이 아니라 **꼭 add만 해야 한다.**\n\n## git rebase 취소\n\n이미 remote 까지 push 했을 때 rebase 취소하는 방법\n\n```bash\ngit reflog <브랜치명>\n\n// 돌아가고 싶은 커밋 확인\ngit reset --hard <128e6d4>\n\ngit push -f origin <브랜치명>\n```\n\n## 생각하기\n\n### `git rebase origin/develop` 과 `git rebase develop` 의 차이점\n\n### `git fetch origin develop` 과 `git pull origin develop` 의 차이점\n\npull 은 내부적으로 `fetch + merge` 를 실행한 것과 같다. 즉 pull 을 실행하면 원격 저장소의 내용을 가져오고(fetch) 병합작업(merge)를 수행하게 된다. 만약 단순히 원격 저장소의 내용을 확인만 하고 로컬 데이터와 병합은 하고 싶지 않다면 fetch를 수행하면 된다. fetch를 하게되면 최신 커밋들은 로컬에 `FETCH_HEAD` 라는 이름으로 가져오게 된다. 이 상태에서 원격 저장소의 내용을 로컬 저장소에 통합하고 싶다면 `FETCH_HEAD` 브랜치를 merge 하거나 pull 하면 된다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"4f925fc92243abb58588445af492b3fed43f4848","text":"# 가깝고도 먼 HTML 1탄\n\n- Title : 가깝고도 먼 HTML 1탄\n- Date : 2020-03-28\n- Category : 프론트\n\n# WHY?\n\nHTML, 잘 알고 있다고 생각했으나 지식이 구멍이 뻥뻥 뚫려있었다. 그래서 시작한 **가깝고도 먼 HTML!** 오늘부터 GO GO!\n\n# `< !DOCTYPE>` 을 왜 선언할까?\n\n> HTML 문서를 작성할 때 항상 DOCTYPE을 문서의 맨 위에 선언한다. ... 왜 선언할까?\n\n`<html>` 태그 전에 선언되야하며 `<!DOCTYPE>` 을 통해 브라우저가 해당 웹 문서가 어떤 타입(HTML5, HTML, XHTML)의 문서인지 파악할 수 있다. 웹 브라우저에게 HTML 버전을 알려주는 역할을 한다. HTML2 ~ HTML4는 SGML(Standard Generalized Markup Language, HTML 할아버지)에 기반을 두어 만들어져서 `<!DOCTYPE>` 을 통한 DTD 참조가 필요하다. 반면에 HTML5는 SGML에 기반을 두지 않아서 DTD 참조가 필요 없고 표준 모드로 작동되게 하는 역할만 하면 되서`<!DOCTYPE html>` 으로 간단하게 선언할 수 있다. \n\nDTD(Document Type Definition: 문서형 정의)는 마크업 언어를 위한 규칙으로 HTML5, XHTML, HTML 등의 문서 형식을 정의할 수 있다. `<!DOCTYPE>` 과 같은 문법을 사용한다. 기술한 유형에 따라 **마크업 문서의 요소와 속성등을 처리하며 유효성 검사 에 이용**된다. DTD를 생략하는 경우 웹 브라우저가 표준 모드가 아니라 비 표준 모드로 렌더링되어 크로스 브라우징에 어려움을 겪는다.\n\n# head 태그에는 무엇이 있을까? 메타가 있죠.\n\n> 보통 에디터의 자동 완성으로 HTML5 기본 형태를 작성한 후 `<body>` 부터 태그를 작성했다. `<body>` 앞은 신경쓰지도 않았다. 물론 예전에 일할 때 페이지 공유 기능을 위해 메타 태그를 설정한 적이 있었지만, 가물가물하니 다시 정리해보았다.\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <meta charset='utf-8'>\n      <meta http-equiv='X-UA-Compatible' content='IE=edge'>\n      <title>Page Title</title>\n      <meta name='viewport' content='width=device-width, initial-scale=1'>\n      <link rel='stylesheet' type='text/css' media='screen' href='main.css'>\n      <script src='main.js'></script>\n    </head>\n    <body>\n      \n    </body>\n    </html>\n\n## HTML head란?\n\nhead는 페이지를 열 때 브라우저에 표시되지는 않는다. head는 `<title>`, `CSS 링크`, `favicon`(사이트 아이콘), `메타 데이터`(작성자, 중요한 키워드 같은 HTML에 대한 내용)를 포함한다.\n\n## 메타데이터 `<meta>` 요소들\n\n### `<meta charset='utf-8'>`\n\n문서에서 허용하는 encoding에 대해 표시\n\n### Viewport\n\n모바일 브라우저들은 뷰포트로 알려진 가상 window 상에 페이지를 렌더링한다. 데스크탑의 뷰포트는 브라우저 창(visible area)의 뷰포트와 같고 사용자가 창의 크기를 조절하면 뷰포트의 크기도 조절된다. 웹 페이지가 뷰포트보다 크면 스크롤 하여 나머지 영역을 볼 수 있다. 반면에 모바일 뷰포트는 웹 브라우저 창보다 크거나 작을 수 있고 상하좌우로 움직이거나, 더블 탭, 줌인, 줌아웃을 통해 뷰포트의 배율을 변경할 수 있다. \n\n뷰포트를 설정안하면 기본 뷰포트가 980px라 페이지가 작게 보인다. ~~아.. 그래서 예전에 작게 보였었구나..~~\n\n기본 사용법\n\n`<meta name='viewport' content='width=device-width, initial-scale=1'>`\n\n- width : viewport의 가로 크기를 조정한다. 숫자가 들어갈 수도 있다. device-width는 100% 스케일에서 css 픽셀들로 계산된 화면의 폭을 의미한다. 즉 기기의 가로 크기에 맞게 설정된다.\n- initial-scale : 페이지가 처음 로딩될 때 줌 레벨을 조정한다. 값이 1이면 CSS 픽셀과 기기 종속적인 픽셀 간의 1:1 관계를 형성한다.\n\n> 미디어 쿼리(@media) 에서 선언된 width 범위에 따라 css를 적용하는 반응형 웹을 만드려면 `width=device-width`를 설정해야한다.\n\n### IE 문서 모드\n\n같은 웹문서를 IE 버전에 따라 마크업과 CSS를 다르게 렌더링하는 경우가 있다. 이 문제를 해결하기 위해 MS는 호환성 보기(쿼크 모드 == 비표준모드) 기능을 제공한다. 하지만 모든 사용자가 직접 호환성 보기를 설정하는 것은 불가능한 일이라 아래 메타태그가 등장했다.\n\n`<meta http-equiv='X-UA-Compatible' content='IE=edge'>` \n\n`content='IE=edge'` 이 메타 태그를 넣으면 자동으로 호환성 보기 기능이 활성화 된다. IE=edge로 선언하면 IE 버전 중 가장 최신 모드를 기준으로 보여지도록 하겠다는 의미다. 이 때, DOCTYPE 선언과 함께 사용해야 유효하다.\n\n# HTML에 CSS와 Javascript 적용하기\n\n## `<link>` 의 위치\n\n`<link>` 는 현재 문서와 외부 리소스의 관계를 명시할 때 사용한다. 스타일 시트를 연결할 때 제일 많이 사용하지만, 사이트 아이콘 연결 등 여러 가지로 쓰일 수 있다. 항상 문서의 **head** 부분에 위치하며 ret=\"stylesheet\" 와 href=\"경로\" 속성을 가진다. head에 놓아야 화면이 여러번 렌더링되는 것을 줄일 수 있다.\n\n## `<script>` 의 위치\n\n`<script>` 요소는 실행 가능한 코드를 문서에 포함하거나 참조할 때 사용한다. head에 들어갈 필요는 없고 `</body>` 태그 바로 앞, 문서 본문의 맨 끝에 넣는 것이 좋다. 자바스크립트를 적용하기 전에 브라우저가 모든 HTML 내용을 읽었는지 확인하여 자바스크립트가 아직 존재하지 않은 요소에 접근하는 경우를 방지해야 한다.\n\n# `<script>` 요소의 defer, async 속성의 차이점\n\n브라우저는 구문 분석을 진행하다 인라인 스크립트(`<script>` 내부에 코드 작성하는 방식) 또는 `async`, `defer`, `type=\"module\"` 속성이 없는 스크립트에 도달하면 스크립트를 가져온 후 실행하기 전까지 분석을 중단한다. HTML이 화면에 출력되는 시간이 길어져 사용자의 불편을 유발한다.\n\n## async\n\nasync 속성이 있으면 HTML 구문 분석 중에도 스크립트를 비동기적으로 가져올 수 있고 사용이 가능해지는 즉시 수행한다. 실행 순서가 다운로드 완료 시점이므로 실행 순서가 중요한 스크립트들에 async를 사용할 때는 유의해야 한다.\n\n## defer\n\nasync과 마찬가지로 브라우저가 HTML 구문 분석을 수행 중에도 스크립트를 다운로드 할 수 있다. 하지만 구문 분석이 완료된 후, **DOMContentLoaded** 발생 이전에 스크립트가 실행된다. defer 속성을 가진 스크립트는 문서 상의 순서를 따라 실행된다.\n\n> `DOMContentLoaded` 이벤트는 초기 HTML 문서를 완전히 불러오고 분석했을 때 발생한다. 스타일 시트, 이미지, 하위 프레임의 로딩은 기다리지 않는다.\n\n# HTML5의 섹셔닝 요소들\n\n> div로 뼈대를 만들던 시대는 지나갔다. HTML5부터 등장한 구조를 위한 태그들.. 잘 알고 잘 사용하고 있을까?\n\nHTML5 에서는 `<header>` `<nav>` `<aside>` `<article>` `<section>` `<footer>` 등의 섹셔닝 요소가 생겨 좀 더 시멘틱한(의미 있는) 마크업 작업을 할 수 있고 여기에 h1 ~ h6 로 섹션의 제목을 작성하면 좋다. 휴. 이제 `<div>` 로 레이아웃을 만들지 않아도 된다. \n\n![HTML%201/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Front/images/2020-03-28-img/Untitled.png)\n\n[https://www.w3schools.com/html/html5_semantic_elements.asp](https://www.w3schools.com/html/html5_semantic_elements.asp)\n\n### SECTION\n\n`<section>` 은 테마별로 연관된 컨텐츠를 묶어 더 큰 **논리적**인 단위를 형성할 수 있게 돕는다. 하나의 페이지 안에서 **주제가 다른 영역을 구분 짓거나 하나의 글을 부분으로 나누기도 한다.** 주로 heading 요소들과 함께 사용한다. 스타일링이나 스크립트를 위해서 엘리먼트들을 감싸는 요소가 필요하다면 `<section>` 을 사용하지 말고 문서 구조상 특별한 의미가 없는 `<div>` 를 사용해야 한다.\n\n- 예) 홈페이지의 뉴스, 긴 글의 세부 사항과 같은 관련 컨텐츠의 묶음\n\n### ARTICLE\n\n`<article>` 은 문서, 페이지, 애플리케이션, 사이트 안에 들어가는 **독립적**으로 구성할 수 있는 컴포넌트로 별도로 배포하거나 재사용하기 위한 구조다. `<article>` 은 완전히 떼어내 다른 사이트에 붙여도 그 의미를 사용자가 알 수 있는 컨텐츠를 담으면 된다. article 요소 안에 article이 들어간 경우, 밖의 article 요소의 내용과 안쪽의 article 요소의 내용이 관련있다는 것을 의미한다. article 중첩 사용은 피하는 게 좋고 대신 논리적인 부분들을 section 요소로 사용하면 된다.\n\n- 예) 블로그에서 글, 포럼에서 포스팅, 코멘트 등\n\n### NAV\n\n`<nav>`는 사이트 네비게이션(다른 페이지로의 이동) 또는 같은 페이지에서 섹션 이동을 위한 네비게이션 링크 목록을 담는 섹션이다.  페이지 안의 모든 링크 그룹이 nav로 기술될 필요는 없다.\n\n    <nav>\n    \t<h1>메인 내비게이션</h1>\n    \t<ul>\n    \t\t<li>메뉴1</li>\n    \t\t<li>메뉴2</li>\n    \t</ul>\n    </nav>\n\n### ASIDE\n\n`<aside>`  본문 컨텐츠 흐름과 분리되지만 약간의 관련성이 있는 컨텐츠에 사용한다.\n\n- 예) 관련 사이트 링크나 광고, nav 요소의 그룹, 메인 콘텐츠와 별도의 내용이라고 생각되는 것, 사이드바, 글의 발췌, 각주 부분, 글에 대한 정보, 여백을 메우는 추가 정보, 코멘트 세션\n\n### HEADER\n\n`<header>` 는 소개나 내비게이션 기능들의 묶음을 나타낸다. 보통 문서나 section의 최상단에 나타나지만, 꼭 그래야 할 필요는 없으며 여러번 사용 가능하다. 한 섹션의 목차나 검색폼, 관련 로고 등을 감싸는 용도로 사용할 수 있다.\n\n### FOOTER\n\n`<footer>` 는 페이지를 만든 사람, 저작권 정보, 연관된 컨텐츠에 대한 링크, 블로그 포스트 작성자, 발행일시 등에 쓰인다. 이 요소는 가장 가까운 섹션의 푸터를 의미한다. 작성자의 연락처는 footer 안의 `<address>` 로 표현, 저작권은 `<small>`로 표현한다.\n\n### FIGURE\n\n`<figure>` 요소는 이미지와 캡션을 그룹화하여 독립적인 컨텐츠를 표현할 때 사용한다. `<figurecaption>` 요소를 사용해 설명을 붙일 수 있다. \n\n    <figure>\n        <img src=\"/media/examples/elephant-660-480.jpg\"\n             alt=\"Elephant at sunset\">\n        <figcaption>An elephant at sunset</figcaption>\n    </figure>\n\n### MAIN\n\n`<main>` 말 그대로 문서의 메인 컨텐츠를 표현할 때 사용하며 `<main>` 안의 내용은 문서에서 유일해야한다. 여러 문서에서 반복적으로 사용되는 사이드바, 네비게이션, 로고, 검색 폼 등을 포함해서는 안되며 문서에 `<main>`은 한 개 여야 한다.\n\n# `<ul>` `<ol>` `<dl>` 의 차이점\n\n> HTML에서 목록을 표현하는 요소는? 각 요소의 차이점은?\n\n### ul(Unordered List)\n\n순서가 없는 목록을 표현할 때 사용하며 목록 앞에 점이나 사각형 등의 도형이 붙는다. 목록의 내용은 `<li>` 로 만든다.\n\n### ol(Ordered List)\n\n순서가 있는 목록을 표현할 때 사용하며 1, 2, 3... 처럼 차례대로 증가하는 번호가 붙는다. 목록의 내용은 `<li>` 로 만든다.\n\n### dl(Definition List)\n\n용어와 그 뜻을 나열할 때 사용한다. 용어는 `<dt>` , 뜻은 `<dd>` 로 만든다.\n\n참조\n\n[[HTML5] 4-1장 구조를 위한 태그](https://webdir.tistory.com/86?category=607030)"}}}},"pageContext":{"id":"f25955ea62ff44f6182d7c5afe657bb1472e9cb6","previousPostId":"d828d76a01fdf156e30e5cff57c159e3cbf5c5f0","nextPostId":"4f925fc92243abb58588445af492b3fed43f4848"}},"staticQueryHashes":["2841359383"]}