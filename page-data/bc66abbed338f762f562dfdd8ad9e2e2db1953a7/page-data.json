{"componentChunkName":"component---src-templates-blog-post-js","path":"/bc66abbed338f762f562dfdd8ad9e2e2db1953a7","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"bc66abbed338f762f562dfdd8ad9e2e2db1953a7","text":"# 알고리즘 개념 잡자 - 이진힙\n\n- Title : 알고리즘 개념 잡자 - 이진힙\n- Date : 2020-01-03\n- Category: Algorithm\n\n> 참고 서적<br/> > [코딩 인터뷰 완전분석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545) 트리와 그래프<br/> > [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539) 제 7장 트리, 제 8장 우선순위 큐\n\n# 1. 이진 힙(최소힙과 최대힙)\n\n**우선 순위 큐(priority queue)**에서 각 노드들은 우선 순위를 가지고 있고 우선 순위가 높은 노드가 먼저 나가게 된다. 이는 배열, 연결 리스트 등 여러 가지 방법으로 구현이 가능한데, 가장 효율적인 구조는 **히프(heap)**다.\n\n## 우선 순위 큐 구현 방법\n\n**배열을 이용한 방법**\n\n- 정렬이 안 된 배열\n  - 삽입 : 맨 끝에 삽입 O(1)\n  - 삭제 : 가장 우선 순위 높은 요소 찾기 O(n) + 삭제 후 뒤에 요소들 앞으로 이동 부담\n- 정렬이 된 배열(우선 순위 낮은 순으로)\n  - 삽입 : 탐색을 통해 삽입 위치를 결정해야 하며, 위치를 찾은 후에는 요소를 이동시켜서 빈 공간을 만들어야 한다. O(n)\n  - 삭제 : 맨 끝 요소 삭제 O(1)\n\n<br/>\n\n**연결리스트를 이용한 방법**\n\n- 정렬이 안 된 리스트\n  - 삽입 : 첫 번째 노드로 삽입 O(1)\n  - 삭제 : 포인터 따라서 모든 노드를 뒤져보아야 한다. O(n)\n- 정렬이 된 리스트(우선 순위 높은 순으로) - 삽입 : 맨 끝에 삽입해야하므로 O(n) - 삭제 : 맨 앞 노드 삭제 O(1)\n  <br/>\n\n**히프를 이용한 방법**\n\n- 히프는 완전 이진 트리의 일종으로 우선 순위 큐를 위하여 만들어진 자료 구조이다.\n- 반 정렬 상태를 유지한다.\n- 삽입, 삭제 시간복잡도는 **O(log<sub>2</sub>n)**로 상당히 유리\n\n## 히프란?\n\n- 여러 개의 값들 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만들어진 자료구조다.\n- **부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은)** 이진 트리다.\n- 반 정렬 상태로, 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도다.\n- 히프 트리는 중복된 값을 허용한다.\n- 히프는 <span class=\"clr-note\">완전 이진 트리</span>다.\n- 최대 힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리\n- 최소 힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리\n\n## 히프 구현 방법(최대 힙)\n\n히프는 완전 이진 트리이기 때문에 표준적인 자료 구조는 배열이다. 완전 이진 트리 구현 방법은 위 트리의 표현 방법에서 이미 언급했다.\n\n**최대 힙 표현 방법**\n<br/>\n\n![히프](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-03-img/3.png)\n\n<br/>\n\n- 삽입 연산\n\n  - 1단계 - 히프의 끝(마지막 노드 다음)에 새로운 노드를 삽입한다. <span class=\"clr-grey\">위 그림에서 키 값이 3인 말단 노드의 형제로 삽입한다.</span>\n  - 2단계 - 삽입된 노드와 그 부모 노드의 키 값을 비교한다. 삽입된 노드의 키 값이 부모 노드의 키 값보다 크면 두 노드의 위치를 바꾼다.\n  - 3단계 - 삽입된 노드의 키 값이 자신의 부모 노드 키 값보다 작아질 때까지 단계 2를 반복한다.\n\n- 삭제 연산\n  - 1단계 - 루트 노드가 삭제 된다. 빈자리에는 히프의 마지막 노드를 가져온다.\n  - 2단계 - 새로운 루트 노드를 자식 노드들과 비교해보면서 자식 노드가 더 크면 두 노드의 위치를 바꾼다. 자식 노드 두 개 모두 값이 더 크다면 더 큰 값을 가진 노드와 교환한다.\n  - 3단계 - 노드의 값이 자식보다 클 때까지 2단계를 반복한다.\n\n**자바스크립트 구현 코드**\n\n<br/>\n\n```javascript\nclass MaxHeap {\n  constructor(elements) {\n    this.heap = [, ...elements];\n  }\n\n  insert(key) {\n    this.heap.push(key);\n    let current = this.heap.length - 1;\n    let parent = parseInt(current / 2);\n    while (parent >= 1) {\n      if (key > this.heap[parent])\n        [this.heap[current], this.heap[parent]] = [\n          this.heap[parent],\n          this.heap[current]\n        ];\n      else break;\n      current = parent;\n      parent = parseInt(current / 2);\n    }\n  }\n\n  delete() {\n    if (this.heap.length === 1) {\n      return \"heap is empty\";\n    }\n    [this.heap[1], this.heap[this.heap.length - 1]] = [\n      this.heap[this.heap.length - 1],\n      this.heap[1]\n    ];\n    let maxValue = this.heap.pop();\n    let current = 1;\n    let leftChild = current * 2;\n    while (leftChild < this.heap.length) {\n      let largest = leftChild;\n      if (leftChild + 1 < this.heap.length)\n        largest =\n          this.heap[leftChild] < this.heap[leftChild + 1]\n            ? leftChild + 1\n            : leftChild;\n      if (this.heap[largest] > this.heap[current])\n        [this.heap[largest], this.heap[current]] = [\n          this.heap[current],\n          this.heap[largest]\n        ];\n      else break;\n      current = largest;\n      leftChild = current * 2;\n    }\n\n    return maxValue;\n  }\n}\n\nconst maxHeap = new MaxHeap([9, 7, 6, 5, 4, 3, 2, 2, 1, 3]);\nconsole.log(maxHeap.heap);\nmaxHeap.insert(8);\nconsole.log(maxHeap.heap);\nlet maxValue = maxHeap.delete();\nconsole.log(maxValue);\nconsole.log(maxHeap.heap);\n```\n\n## 히프의 시간 복잡도\n\n- 삽입 연산\n  - 최악의 경우는 루트 노드까지 올라간 경우이므로 트리의 높이에 해당하는 비교 연산과 이동 연산이 필요하다. 히프는 완전 이진 탐색이므로 히프의 높이는 log<sub>2</sub>n이 되고 시간 복잡도도 O(log<sub>2</sub>n)\n- 삭제 연산\n  - 삽입 연산과 같다.\n\n## 히프의 응용\n\n- 히프 정렬\n  - 최대 히프를 이용하여 정렬할 수 있다.\n  - 요소가 n개일 때, 시간 복잡도는 **O(nlog<sub>2</sub>n)**이다.\n  - 전체 자료 정렬이 아닌 가장 큰 값 몇 개만 정렬하고 싶을 때 사용하면 좋다.\n\n```javascript\nconst heapSort = (elements, num) => {\n  const sortedElements = [];\n  const maxHeap = new MaxHeap([]);\n  elements.forEach(element => {\n    maxHeap.insert(element);\n  });\n  for (let i = 0; i < num; i++) {\n    sortedElements.push(maxHeap.delete());\n  }\n  return sortedElements;\n};\n\nconsole.log(heapSort([2, 4, 1, 9, 5, 7, 6, 5, 2, 8], 5));\n```\n\n- 허프만 코드 (Huffman Coding) <span class=\"clr-grey\">나중에 추가할 예정..</span>\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"3c55417e429710884ade0d6c7bca7c149081a2a3","text":"# 알고리즘 개념 잡자 - 재귀와 동적 프로그래밍\n\n- Title : 알고리즘 개념 잡자 - 재귀와 동적 프로그래밍\n- Date : 2020-01-09\n- Category: Algorithm\n\n> 참고 <br/>\n>\n> - [코딩 인터뷰 완전분석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545) 재귀와 동적 프로그래밍\n> - [Geeksforgeeks 바로가기](https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/)\n\n# 동적 프로그래밍\n\n- 주어진 문제를 부분 문제로 나눠 값을 계산하는 것\n- 중복되는 계산을 막기 위해 부분 문제의 결과 값을 저장함 - 메모이제이션(Memoization)과 타뷸레이션(Tabulation)\n\n## 메모이제이션(Memoization)과 타뷸레이션(Tabulation)\n\n- 메모이제이션 : 하향식 접근법 (Top Down) - 재귀적\n  - 테이블을 만들고 NIL(예, -1) 값을 넣음\n  - 서브 문제의 결과값을 구할 때, 먼저 테이블 검색\n  - 계산된 값이 있으면 얘를 리턴\n  - NIL이면 계산 실행하여 계산 결과를 테이블에 저장\n  - 요구가 있을 때 채워지므로 테이블에 데이터가 다 채워지지 않을 수도 있음\n- 타뷸레이션 : 상향식 접근법 (Bottom Up) - 순환적\n  - 테이블의 마지막 요소를 반환하는 구조\n  - 첫번째부터 전체가 채워지는\n\n## DP의 2가지 속성\n\n모든 DP 문제는 Overlapping subproblems 속성을 만족하고 대부분의 클래식 DP 문제는 Optimal Substructure 속성을 만족한다.\n\n**1. overlapping subproblems** <br/><br/>\n\n- 부분 문제들이 공통으로 겹치는 부분이 있는 지?<br/>\n\n  > <span class=\"clr-grey\">우리가 메모이제이션이나 타뷸레이션을 사용하는 이유는 부분 문제의 결과값을 저장해놔서 나중에 이를 활용하려고 사용하죠. 근데 겹치는 부분 문제가 없으면?? 이게 필요가 없음.</span>\n\n- 동적 프로그래밍과 분할 정복\n  - 문제를 나누는 방식에 차이가 있음 <br/><br/>\n  - 피보나치<br/>\n    ![피보나치](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-10-img/2.png)\n  - 이진탐색 <br/>\n    ![이진탐색](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-10-img/1.png)\n\n<br/>\n\n**2. Optimal Substructure** <br/>\n\n- 문제의 답을 부분 문제의 답에서 구할 수 있는 가?\n- 최단 경로 vs 최장 경로<br/>\n  - 경로안에 무수히 많은 경로가 있을 때, 중간 정점들이 각각 최단이 된다면 이를 모든 이은 경로 또한 최단이 된다. <br/><br/>\n    ![경로](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-10-img/3.gif)\n    - q -> t 최단 : q -> r + r -> t\n    - q -> t 최장 : q -> s -> t -> r + r -> q -> s -> t\n\n## 문제 푸는 방법\n\n**1. DP 문제인가?**\n\n- DP의 2가지 속성으로 판단하기\n\n**2. 상태 찾기**\n\n- 서브 문제마다 값이 달라지는 변수 찾기\n- 각 서브 문제를 구별하는 값\n- 파라미타들\n- 적을 수록 좋다.\n- DP(상태) = 결과값(예, 최고 이익, 경우의 수..)\n\n**3. 재귀 방법 알아내기 == 상태들의 관계 알아내기** <br/>\n\n- state(n) = state(n-1) + state(n-3) + state(n-5)\n\n**4. 메모이제이션과 타뷸레이션 쓰기**\n\n# 8.1 트리플 스텝\n\n어떤 아이가 n개의 계단을 오른다. 한 번에 1계단 오르기도 하고 2계단이나 3계단을 오르기도 한다. 계단을 오르는 방법이 몇 가지가 있는지 계산하는 메서드를 구현하라.\n\n- Step 1 : DP 문제인지 판별하기\n  - 느낌..\n- Step 2 : 부분 문제마다 값이 달라지는 변수 찾기\n  - N : 계단의 개수 => 매개변수\n  - DP[N] = N을 만족하는 경우의 수\n- Step 3 : 재귀 방법을 알아내기\n  - 조정할 수 있는 거, 오를 수 있는 계단 개수져\n  - upStair(n) = (n - 1) || (n - 2) || (n - 3)\n  - upStair(n) = (n - 1) + (n - 2) + (n - 3)\n- Step 4 : 메모이제이션, 타뷸레이션\n\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint solution(int n, vector<int>& memo) {\n  if (n < 0) return 0;\n  if (n == 0) return 1;\n  if (memo[n] > -1) return memo[n];\n  memo[n] = solution(n - 1, memo) + solution (n - 2, memo) + solution (n - 3, memo);\n  return memo[n];\n}\n\nint solution_BU(int n) {\n  vector<int> dp(n+1, -1);\n  dp[0] = 1;\n  dp[1] = 1;\n  dp[2] = 2;\n  for (int i=3; i<=n; i++) {\n    dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\n  }\n  return dp[n];\n}\n\nint main(){\n  int n = 10;\n  vector<int> memo(n+1, -1);\n  std::cout << solution(n, memo) << \",\";\n  std::cout << solution_BU(n) << std::endl;\n  return 0;\n}\n```\n\n# 8.11 코인\n\n쿼터(25센트), 다임(10센트), 니켈(5센트), 페니(1센트)의 네 가지 동전이 무한히 주어졌을 때, n센트를 표현하는 모든 방법의 수를 계산하는 코드를 작성하라\n\n- Step 1 : DP 문제인지 판별하기\n  - 10원 방법의 수는 5원 방법에 + 5를 더하는 것....\n  - 느낌..\n- Step 2 : 부분 문제마다 값이 달라지는 변수 찾기\n  - 부분 문제는 1원일 때 방법의 수... 2원일 때 방법의 수..3원일 때....N원일 때 방법의 수\n  - N : 구할 센트, => 매개변수, 상태값\n  - D[N] = 방법의 수\n- Step 3 : 재귀 방법을 알아내기\\*\\*\n  - 재귀의 방법을 조정할 수 있는 값은? 동전의 가치 (25, 10, 5, 1)\n  - D(n) = D(n - 25) + D(n - 10) + D(n - 5) + D(n - 1)\n- Step 4 : 메모이제이션, 타뷸레이션\n\n- 10센트 만들기 (D[0] = 1)\n  - 25센트로 : 0 0 0 0 0 0 0 0 0 0\n  - 10센트로 : 0 0 0 0 0 0 0 0 0 1\n  - 5센트로 : 0 0 0 0 1 0 0 0 0 2\n  - 1센트로 : 1 1 1 1 2 2 2 2 2 4\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint coin[4] = {25, 10, 5, 1};\nint solution(int n, int index, vector<vector<int> >& memo) {\n  if (index >= 3) return 1;\n  if (memo[n][index] > 0) return memo[n][index];\n  int answer = 0;\n  for (int i=0; i * coin[index] <= n; i++) {\n    answer += solution(n - i * coin[index], index + 1, memo);\n  }\n\n  memo[n][index] = answer;\n  return memo[n][index];\n}\n\nint solution_BU(int n) {\n  vector<int> dp(n+1, 0);\n  dp[0] = 1;\n  for (int i=0; i<4; i++) {\n    for (int j=1; j<=n; j++) {\n      if (j - coin[i] >= 0) dp[j] += dp[j-coin[i]];\n    }\n  }\n  return dp[n];\n}\n\nint main() {\n  int n = 10;\n  vector<vector<int> > memo(n + 1, vector<int>(4, 0));\n  int answer = solution(n, 0, memo);\n  std::cout << answer << std::endl;\n  int answer_2 = solution_BU(n);\n  std::cout << answer << std::endl;\n  return 0;\n}\n```\n\n# 8.7 중복 없는 순열\n\n문자열이 주어졌을 때 모든 경우의 순열을 계산하는 메서드를 작성하라. 단, 문자는 중복되어 나타날 수 없다.\n\n# 8.9 괄호\n\nn-쌍의 괄호로 만들 수 있는 모든 합당한(괄호가 적절히 열리고 닫힌) 조합을 출력하는 알고리즘을 구현하라\n\n```cpp\n#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\nvoid fnc(string result, int cur, int dep, int n, vector<string>& answer) {\n  if (cur < 0) return;\n  if (cur > 0 && n - dep < cur) return;\n  if (cur == 0 && dep == n) {\n    answer.push_back(result);\n    return;\n  }\n  fnc(result + \"(\", cur + 1, dep + 1, n, answer);\n  fnc(result + \")\", cur - 1, dep + 1, n, answer);\n}\n\nvector<string> solution(int n) {\n    vector<string> answer;\n    fnc(\"\", 0, 0, n*2, answer);\n    return answer;\n}\n\nvoid solution_2(int leftRem, int rightRem, int index, char *str, vector<string>& answer) {\n  if (leftRem < 0 || leftRem > rightRem) return;\n  if (leftRem == 0 && rightRem == 0) {\n    answer.push_back(str);\n    return;\n  }\n  str[index] = '(';\n  solution_2(leftRem - 1, rightRem, index+1, str, answer);\n\n  str[index] = ')';\n  solution_2(leftRem, rightRem - 1, index + 1, str, answer);\n}\n\nint main() {\n  int n;\n  cout << \"input:\";\n  cin >> n;\n  vector<string> answer = solution(n);\n  for (int i=0; i<answer.size(); i++) {\n    cout << answer[i] << \" \";\n  }\n  cout << endl;\n  vector<string> answer2;\n  char str[n*2];\n  solution_2(n, n, 0, str, answer2);\n  for (int i=0; i<answer2.size(); i++) {\n    cout << answer2[i] << \" \";\n  }\n\n  return 0;\n}\n\n```\n\n# 8.10 영역 칠하기\n\n화면(색이 칠해진 이차원 배열), 화면상의 한 지점, 새로운 색상이 주어졌을 때, 주어진 지점과 색이 같은 주변 영역을 새로운 색상으로 다시 칠하라\n\n- BFS\n\n```cpp\n#include <string>\n#include <vector>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint row[4] = {0, 0, -1, 1};\nint col[4] = {-1, 1, 0, 0};\n\nint solution(vector<vector<int> >& screen, pair<int, int>& point, int newColor) {\n\n  queue<pair<int, int> > q;\n  int next_row, next_col;\n  int pre_color = screen[point.first][point.second];\n  q.push(point);\n  while (!q.empty()) {\n    pair<int, int> pop = q.front();\n    screen[pop.first][pop.second] = newColor;\n    q.pop();\n    for (int i=0; i<4; i++) {\n      next_row = pop.first + row[i];\n      next_col = pop.second + col[i];\n      if (next_row < 0 || next_col < 0) continue;\n      if (next_row >= screen.size() || next_col >= screen[0].size()) continue;\n      if (screen[next_row][next_col] == pre_color) {\n        q.push(make_pair(next_row, next_col));\n      }\n    }\n  }\n  return 0;\n}\n\nint main() {\n  // vector<vector<int> > screen({\n  //   vector<int>({1, 1, 2, 3}),\n  //   vector<int>({2, 1, 2, 3}),\n  //   vector<int>({1, 1, 2, 2}),\n  //   vector<int>({2, 2, 2, 1})\n  // });\n  /*\n  1 2 2 3\n  2 1 2 3\n  1 1 2 2\n  2 2 2 1\n  */\n vector<vector<int> > screen(4, vector<int>(4));\n  screen[0][0] = 1;\n  screen[0][1] = 2;\n  screen[0][2] = 2;\n  screen[0][3] = 3;\n\n  screen[1][0] = 2;\n  screen[1][1] = 1;\n  screen[1][2] = 2;\n  screen[1][3] = 3;\n\n  screen[2][0] = 1;\n  screen[2][1] = 1;\n  screen[2][2] = 2;\n  screen[2][3] = 2;\n\n  screen[3][0] = 2;\n  screen[3][1] = 2;\n  screen[3][2] = 2;\n  screen[3][3] = 1;\n\n  pair<int, int> point = make_pair(1, 2);\n  for (int i=0; i<screen.size(); i++) {\n    for (int j=0; j<screen[0].size(); j++)\n      std::cout << screen[i][j] << \" \";\n    std::cout << std::endl;\n  }\n  solution(screen, point, 0);\n  std::cout << std::endl;\n  for (int i=0; i<screen.size(); i++) {\n    for (int j=0; j<screen[0].size(); j++)\n      std::cout << screen[i][j] << \" \";\n    std::cout << std::endl;\n  }\n  return 0;\n}\n```\n\n# 8.14 불린값 계산\n\n0(false), 1(true), &(AND), |(OR), ^(XOR)으로 구성된 불린 표현식과 원하는 계산 결과(불린값)이 주어졌을 때, 표현식에 괄호를 적절하게 추가하여 그 값이 원하는 결과값과 같게 만들 수 있는 모든 경우의 수 출력하기\n\n출력 예시\n\n- countEval(\"1^0|0|1\", false) -> 2개\n- countEval(\"0&0&0&1^1|0\", true) -> 10개\n\n- Step 1 : DP 문제인지 판별하기\n  - 뭔가.. 적절하게 조합해서 모든 경우 구하는 거라서.. dp같네..?\n- Step 2 : 부분 문제마다 값이 달라지는 변수 찾기\n  - 음.. 전체 수식을 쪼개니깐 수식이 부분문제마다 달라지넵, 매개변수로 쪼개진 수식을 보내야겠댜~\n- Step 3 : 재귀 방법을 알아내기\\*\\*\n  - 괄호를 추가한다라..\n  - 1^0|0|1 예시로 보면..\n  - 1 ^ (0|0|1) 처럼 괄호를 추가하고 싶다는 건데..\n  - 그럼 ^ 같은 표현식을 기준으로 왼쪽 오른쪽 나눠어..\n  - D[수식] = D[왼쪽 수식] \\* D[오른쪽 수식]\n  - 서로 연관있으니깐 \\*곱하기\n  - 표현식은 index 1, 3, 5, 7 ..에 위치\n- Step 4 : 메모이제이션, 타뷸레이션\n\n1 ^ 0|0|1  \n1^0 | 0|1  \n1^0|0 | 1\n\n```cpp\n#include <string>\n#include <vector>\n#include <iostream>\n#include <map>\n\nusing namespace std;\n\nint fnc(std::string exp, bool r, map<string, int>& memo) {\n  if (exp.length() == 1) return exp[0] == (r ? '1' : '0') ? 1 : 0;\n  if (memo.count(exp + (r ? \"-1\" : \"-0\")) == 1) return memo[exp + (r ? \"-1\" : \"-0\")];\n  int sum = 0;\n  for (int i=1; i<exp.length(); i+=2) {\n    char e = exp[i];\n    string left = exp.substr(0, i);\n    string right = exp.substr(i+1);\n    if (e == '^') {\n      if (r) {  // true\n        sum += fnc(left, r, memo) * fnc(right, r^1, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r, memo);\n      } else {\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r^1, memo);\n      }\n\n    } else if (e == '|') {\n      if (r) { // true\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n        sum += fnc(left, r, memo) * fnc(right, r^1, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r, memo);\n      } else { // false\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n      }\n    } else {\n      if (r) { // true\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n      } else { // false\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r, memo);\n        sum += fnc(left, r, memo) * fnc(right, r^1, memo);\n      }\n\n    }\n  }\n  memo.insert(pair<string, int>(exp + (r ? \"-1\" : \"-0\") , sum));\n  return sum;\n}\n\nint countEval(std::string exp, bool result) {\n  map<string, int> map;\n  return fnc(exp, result, map);\n}\n\nint main() {\n  std::cout << countEval(\"1^0|0|1\", false) << std::endl;\n  std::cout << countEval(\"0&0&0&1^1|0\", true) << std::endl;\n  return 0;\n}\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"146c143b5de337f212dc8e01ca9473a2a201a1a5","text":"# 알고리즘 개념 잡자 - 트라이\n\n- Title : 알고리즘 개념 잡자 - 트라이\n- Date : 2020-01-03\n- Category: Algorithm\n\n> 참고 서적<br/> > [코딩 인터뷰 완전분석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545) 트리와 그래프<br/>\n> [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539) 제 7장 트리, 제 8장 우선순위 큐\n\n# 3. 트라이(접두사 트리, prefix tree)\n\n> 참조 링크 [wikipedia](https://en.wikipedia.org/wiki/Trie)\n\n![트라이](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-03-img/4.png)\n\n- n-차 트리의 변종으로 각 노드에 문자를 저장하는 자료구조이다.\n- 문자열 탐색에 효율적인 자료구조이다.\n- 트리를 아래쪽으로 순회하면 단어 하나가 나온다.\n- TerminatingTrieNode로 널 노드를 표현한 경우, 트라이에서 각 노드는 1개 ~ 문자열 길이 + 1개 까지 자식을 가질 수 있다.\n- 널 노드 대신 불린 플래그로 표현한 경우, 각 노드는 0개 ~ 문자열 길이개까지 자식을 가질 수 있다.\n\n> **널 노드(\\* 노드)**\n>\n> - 단어의 끝을 나타낸다.\n> - 예) MANY 이후에 널 노드가 나오면 MANY라는 단어가 완성되었다는 의미다.\n>\n> **널 노드 구현 방법**\n>\n> - TrieNode를 상속한 TerminatingTrieNode로 표현하기\n> - 널 노드의 부모 노드 안에 불린 플래그를 새로 정의함으로써 표현하기\n\n**어디에 사용할까?**\n\n- 자동 완성\n- 문자열이 어떤 문자열의 접두사인지 확인하고 싶을 때 <span class=\"clr-grey\">cf) 단순 삽입/조회만 한다면 해시테이블 사용을 권장</span>\n- 예: 'a', 'axe'로 시작하는 단어를 찾고 싶을 때\n\n> 예시, M, MA, MAN, MANY를 차례대로 살펴보는 경우 트리의 현재 노드를 참조값으로 넘김으로써 루트 노드에서 시작할 필요가 없고 단순히 Y가 MAN의 자식인지만 확인해보면 된다.\n\n## 트라이 VS 해시테이블\n\n- 최악의 경우, 시간복잡도는?\n  - 트라이 : O(K) (K: 가장 긴 문자열)\n  - 해시테이블 : 충돌이 자주 발생되었다면 O(N)의 시간복잡도를 가진다. (N: 키의 개수) 또한 입력 문자열을 기반으로 해시 계산을 하므로 O(K)의 시간이 걸린다.\n  - cf) 탐색할 문자열이 트라이에 없는 경우에는 문자열 길이 K보다 시간이 덜 걸린다.\n\n> **트라이와 해시의 시간복잡도가 비슷하다..?** <br/>\n> 길이가 K인 무자열이 주어졌을 때 트라이는 O(K) 시간에 해당 문자열이 유효한 접두사인지 확인할 수 있다. 이 시간은 해시테이블 사용했을 때와 정확히 같은 수행 시간이다. 우리가 종종 해시테이블을 검색하는 시간이 O(1)이라고 하지만 완전히 맞는 말은 아니다. 해시테이블도 입력 문자열은 전부 읽어야 하므로 길이가 K인 단어를 검색하는 데 걸리는 시간은 O(K)가 된다.\n\n- 알파벳 정렬?\n\n  - 일반적으로 자료구조에 문자열을 저장한다면 각 문자열의 순서가 중요하기도 하다. 트라이는 노드를 저장할 때 왼쪽에서 오른쪽으로 사전 순으로 저장한다면 쉽게 정렬이 가능하다.\n\n- 기타\n  - 트라이는 삭제가 직관적이며 해시 함수가 필요 없으나 해시 테이블 보다는 많은 공간을 차지한다.\n\n## 트라이 구현\n\n```javascript\nclass Trie {\n  constructor(key) {\n    this.is_terminal = false;\n    this.key = key;\n    this.trie_child = Array(26).fill(null);\n  }\n\n  char_to_index(key) {\n    return key.charCodeAt(0) - \"a\".charCodeAt(0);\n  }\n\n  // 새로운 문자열을 트라이에 추가\n  insert(key) {\n    let current_trie = this;\n    for (let i = 0; i < key.length; i++) {\n      let index = this.char_to_index(key[i]);\n      if (current_trie.trie_child[index] === null)\n        current_trie.trie_child[index] = new Trie(key.slice(0, i + 1));\n      current_trie = current_trie.trie_child[index];\n    }\n    current_trie.is_terminal = true;\n  }\n\n  // 트라이 출력\n  print(trie, dep) {\n    console.log(dep, trie.key);\n    if (trie.is_terminal) return;\n    for (let i = 0; i < 26; i++) {\n      if (trie.trie_child[i] !== null) this.print(trie.trie_child[i], dep + 1);\n    }\n  }\n\n  // key를 접두어로 가지고 있는지, 가지고 있으면 해당 접두어가 끝나는 부분의 위치를 반환\n  find(key) {\n    let current_trie = this;\n    for (let i = 0; i < key.length; i++) {\n      let index = this.char_to_index(key[i]);\n      if (current_trie.trie_child[index] === null) return false;\n      else current_trie = current_trie.trie_child[index];\n    }\n    return current_trie;\n  }\n\n  // key를 포함하는 지, 포함하면 true\n  exist(key) {\n    let current_trie = this;\n    for (let i = 0; i < key.length; i++) {\n      let index = this.char_to_index(key[i]);\n      if (current_trie.trie_child[index] === null) return false;\n      else current_trie = current_trie.trie_child[index];\n    }\n    return current_trie.is_terminal;\n  }\n}\n\nvar trie = new Trie(null);\nvar arr = [\"to\", \"tea\", \"ted\", \"ten\", \"a\", \"inn\"];\narr.forEach(str => trie.insert(str));\n// trie.print(trie, 0)\nconsole.log(trie.exist(\"tea\")); // true\nconsole.log(trie.exist(\"aaa\")); // false\nconsole.log(trie.exist(\"a\")); // true\nconsole.log(trie.find(\"te\")); // Trie {is_terminal: false, key: \"te\", trie_child: Array(26)}\n```\n"}}}},"pageContext":{"id":"bc66abbed338f762f562dfdd8ad9e2e2db1953a7","previousPostId":"3c55417e429710884ade0d6c7bca7c149081a2a3","nextPostId":"146c143b5de337f212dc8e01ca9473a2a201a1a5"}},"staticQueryHashes":["2841359383"]}