{"componentChunkName":"component---src-templates-blog-post-js","path":"/bc66abbed338f762f562dfdd8ad9e2e2db1953a7","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"bc66abbed338f762f562dfdd8ad9e2e2db1953a7","text":"# 알고리즘 개념 잡자 - 이진힙\n\n- Title : 알고리즘 개념 잡자 - 이진힙\n- Date : 2020-01-03\n- Category: Algorithm\n\n> 참고 서적<br/> > [코딩 인터뷰 완전분석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545) 트리와 그래프<br/> > [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539) 제 7장 트리, 제 8장 우선순위 큐\n\n# 1. 이진 힙(최소힙과 최대힙)\n\n**우선 순위 큐(priority queue)**에서 각 노드들은 우선 순위를 가지고 있고 우선 순위가 높은 노드가 먼저 나가게 된다. 이는 배열, 연결 리스트 등 여러 가지 방법으로 구현이 가능한데, 가장 효율적인 구조는 **히프(heap)**다.\n\n## 우선 순위 큐 구현 방법\n\n**배열을 이용한 방법**\n\n- 정렬이 안 된 배열\n  - 삽입 : 맨 끝에 삽입 O(1)\n  - 삭제 : 가장 우선 순위 높은 요소 찾기 O(n) + 삭제 후 뒤에 요소들 앞으로 이동 부담\n- 정렬이 된 배열(우선 순위 낮은 순으로)\n  - 삽입 : 탐색을 통해 삽입 위치를 결정해야 하며, 위치를 찾은 후에는 요소를 이동시켜서 빈 공간을 만들어야 한다. O(n)\n  - 삭제 : 맨 끝 요소 삭제 O(1)\n\n<br/>\n\n**연결리스트를 이용한 방법**\n\n- 정렬이 안 된 리스트\n  - 삽입 : 첫 번째 노드로 삽입 O(1)\n  - 삭제 : 포인터 따라서 모든 노드를 뒤져보아야 한다. O(n)\n- 정렬이 된 리스트(우선 순위 높은 순으로) - 삽입 : 맨 끝에 삽입해야하므로 O(n) - 삭제 : 맨 앞 노드 삭제 O(1)\n  <br/>\n\n**히프를 이용한 방법**\n\n- 히프는 완전 이진 트리의 일종으로 우선 순위 큐를 위하여 만들어진 자료 구조이다.\n- 반 정렬 상태를 유지한다.\n- 삽입, 삭제 시간복잡도는 **O(log<sub>2</sub>n)**로 상당히 유리\n\n## 히프란?\n\n- 여러 개의 값들 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만들어진 자료구조다.\n- **부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은)** 이진 트리다.\n- 반 정렬 상태로, 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도다.\n- 히프 트리는 중복된 값을 허용한다.\n- 히프는 <span class=\"clr-note\">완전 이진 트리</span>다.\n- 최대 힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리\n- 최소 힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리\n\n## 히프 구현 방법(최대 힙)\n\n히프는 완전 이진 트리이기 때문에 표준적인 자료 구조는 배열이다. 완전 이진 트리 구현 방법은 위 트리의 표현 방법에서 이미 언급했다.\n\n**최대 힙 표현 방법**\n<br/>\n\n![히프](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-03-img/3.png)\n\n<br/>\n\n- 삽입 연산\n\n  - 1단계 - 히프의 끝(마지막 노드 다음)에 새로운 노드를 삽입한다. <span class=\"clr-grey\">위 그림에서 키 값이 3인 말단 노드의 형제로 삽입한다.</span>\n  - 2단계 - 삽입된 노드와 그 부모 노드의 키 값을 비교한다. 삽입된 노드의 키 값이 부모 노드의 키 값보다 크면 두 노드의 위치를 바꾼다.\n  - 3단계 - 삽입된 노드의 키 값이 자신의 부모 노드 키 값보다 작아질 때까지 단계 2를 반복한다.\n\n- 삭제 연산\n  - 1단계 - 루트 노드가 삭제 된다. 빈자리에는 히프의 마지막 노드를 가져온다.\n  - 2단계 - 새로운 루트 노드를 자식 노드들과 비교해보면서 자식 노드가 더 크면 두 노드의 위치를 바꾼다. 자식 노드 두 개 모두 값이 더 크다면 더 큰 값을 가진 노드와 교환한다.\n  - 3단계 - 노드의 값이 자식보다 클 때까지 2단계를 반복한다.\n\n**자바스크립트 구현 코드**\n\n<br/>\n\n```javascript\nclass MaxHeap {\n  constructor(elements) {\n    this.heap = [, ...elements];\n  }\n\n  insert(key) {\n    this.heap.push(key);\n    let current = this.heap.length - 1;\n    let parent = parseInt(current / 2);\n    while (parent >= 1) {\n      if (key > this.heap[parent])\n        [this.heap[current], this.heap[parent]] = [\n          this.heap[parent],\n          this.heap[current]\n        ];\n      else break;\n      current = parent;\n      parent = parseInt(current / 2);\n    }\n  }\n\n  delete() {\n    if (this.heap.length === 1) {\n      return \"heap is empty\";\n    }\n    [this.heap[1], this.heap[this.heap.length - 1]] = [\n      this.heap[this.heap.length - 1],\n      this.heap[1]\n    ];\n    let maxValue = this.heap.pop();\n    let current = 1;\n    let leftChild = current * 2;\n    while (leftChild < this.heap.length) {\n      let largest = leftChild;\n      if (leftChild + 1 < this.heap.length)\n        largest =\n          this.heap[leftChild] < this.heap[leftChild + 1]\n            ? leftChild + 1\n            : leftChild;\n      if (this.heap[largest] > this.heap[current])\n        [this.heap[largest], this.heap[current]] = [\n          this.heap[current],\n          this.heap[largest]\n        ];\n      else break;\n      current = largest;\n      leftChild = current * 2;\n    }\n\n    return maxValue;\n  }\n}\n\nconst maxHeap = new MaxHeap([9, 7, 6, 5, 4, 3, 2, 2, 1, 3]);\nconsole.log(maxHeap.heap);\nmaxHeap.insert(8);\nconsole.log(maxHeap.heap);\nlet maxValue = maxHeap.delete();\nconsole.log(maxValue);\nconsole.log(maxHeap.heap);\n```\n\n## 히프의 시간 복잡도\n\n- 삽입 연산\n  - 최악의 경우는 루트 노드까지 올라간 경우이므로 트리의 높이에 해당하는 비교 연산과 이동 연산이 필요하다. 히프는 완전 이진 탐색이므로 히프의 높이는 log<sub>2</sub>n이 되고 시간 복잡도도 O(log<sub>2</sub>n)\n- 삭제 연산\n  - 삽입 연산과 같다.\n\n## 히프의 응용\n\n- 히프 정렬\n  - 최대 히프를 이용하여 정렬할 수 있다.\n  - 요소가 n개일 때, 시간 복잡도는 **O(nlog<sub>2</sub>n)**이다.\n  - 전체 자료 정렬이 아닌 가장 큰 값 몇 개만 정렬하고 싶을 때 사용하면 좋다.\n\n```javascript\nconst heapSort = (elements, num) => {\n  const sortedElements = [];\n  const maxHeap = new MaxHeap([]);\n  elements.forEach(element => {\n    maxHeap.insert(element);\n  });\n  for (let i = 0; i < num; i++) {\n    sortedElements.push(maxHeap.delete());\n  }\n  return sortedElements;\n};\n\nconsole.log(heapSort([2, 4, 1, 9, 5, 7, 6, 5, 2, 8], 5));\n```\n\n- 허프만 코드 (Huffman Coding) <span class=\"clr-grey\">나중에 추가할 예정..</span>\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"68ea80dc2124e8d2e6495a2ae7232f0d565aecf7","text":"# 운영체제 - 프로세스 동기화 1\n\n- Title : 운영체제 - 프로세스 동기화 1\n- Date : 2020-01-06\n- Category: 운영체제\n\n> 1. 프로세스 동기화란?\n> 2. 임계구역이란?\n> 3. 세마포란?\n\n# 프로세스 동기화(Process Synchronization, Thread Synchronization)\n\n프로세스들이 서로 공유하는 데이터에 동시에 접근할 때 순서대로 실행하여 **일관성있는 데이터를 유지**하는 것\n\n- Independent : 프로세스1과 프로세스2가 관계가 없을 때\n- Cooperating : 다른 프로세스에게 영향을 미치거나 다른 프로세스로부터 영향을 받을 때\n- 프로세스 간 통신 : 전자 우편, 파일 전송\n- 프로세스 간 자원 공유 : 메모리 상의 자료, 데이터베이스 등\n- 실생활 예 : 명절 기차표 예약, 대학 온라인 수강신청, 실시간 주식 거래\n\n## 프로세스/쓰레드 동기화를 하려면?\n\n- 임계구역 문제 해결(틀린 답이 나오지 않도록)\n- 프로세스 실행 순서 제어(원하는 대로)\n- busy wait 등 비효율성은 제거\n\n## 동기화 도구\n\n- 세마포(Semaphores)\n- 모니터(Monitors)\n- Misc.\n\n## 은행 계좌 예시\n\n아래의 코드는 공통 변수(balance)에 대해 동시 업데이트를 수행하여 0이 아닌 잘못된 결과값이 출력된다. 이는 한번에 한 쓰레드만 업데이트하도록 하여 해결할 수 있다. -> **임계구역 문제**\n\n```java\nclass Test {\npublic static void main(String[] args) throws InterruptedException {\n  BankAccount b = new\n  BankAccount();\n  Parent p = new Parent(b);\n  Child c = new Child(b);\n  p.start();\n  c.start();\n  p.join();\n  c.join();\n  System.out.println( \"\\nbalance = \" + b.getBalance());\n  }\n}\n```\n\n```java\nclass BankAccount {\n  int balance;\n  void deposit(int amount) {\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp; // 임계구역\n  }\n  void withdraw(int amount) {\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp; // 임계구역\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n\n```java\nclass Parent extends Thread {\n  BankAccount b;\n  Parent(BankAccount b) {\n    this.b = b;\n  }\n  public void run() {\n    for (int i=0; i<100; i++)\n    b.deposit(1000);\n  }\n}\nclass Child extends Thread {\n  BankAccount b;\n  Child(BankAccount b) {\n    this.b = b;\n  }\n  public void run() {\n    for (int i=0; i<100; i++)\n    b.withdraw(1000);\n  }\n}\n```\n\n# 임계구역 문제(The Critical-Section Problem)\n\n## 임계구역(Critical Section)\n\n여러 개의 스레드로 구성된 시스템에서 각 스레드가 같이 사용하는 변수, 테이블, 파일을 바꾸는 코드 영역을 임계구역이라고 한다. 예) 은행 계좌 예시에서 balance 값을 바꾸는 코드가 임계구역이다.\n\n## 임계구역 문제 해결방법 - 아래 3가지 다 만족해야한다!\n\n- Mutual exclusion (상호배타): 오직 한 쓰레드만 진입<br/>예) Parent 스레드가 임계구역 실행 중에는 Child 스레드는 임계구역에 들어갈 수 없다.\n- Progress (진행): 진입 결정은 유한 시간 내<br/>예) 임계구역에 어떤 스레드가 먼저 진입할지에 대한 결정은 유한 시간 내에 결정되어야 한다.\n- Bounded waiting (유한대기): 어느 쓰레드라도<br/>예) 어느 스레드라도 기다리고 있으면 유한한 시간내에 임계구역에 들어갈 수 있다.\n\n# 세마포 (Semaphore)\n\n동기화 문제 해결을 위한 소프트웨어 도구로 <span class=\"clr-note\">정수형 변수 + 두 개의 동작 (P, V)</span>으로 이루어져있다.\n\n## 동작\n\n- P: Proberen (test) → **acquire()**\n- V: Verhogen (increment) → **release()**\n\n## 구조\n\n- acquire() : 임계구역 전에 호출하여 value가 조건에 맞으면 **프로세스(or 스레드)를 list(큐)에 넣는다.** 큐에 들어간 프로세스는 다른 프로세스에 의해 release()가 호출될 때까지 Block된다. 즉 임계구역을 실행할 수 없게 된다. (Block이 된다 == Ready Queue에 들어가지 못한다)\n- release() : value 조건에 맞으면 list에서 **프로세스를 꺼내서 깨운다.** 깨운다는 것은 Ready Queue(cpu 서비스 기다리는 줄)에 넣는 다는 것을 의미한다.\n\n```java\nclass Semaphore {\n  int value; // number of permits\n\n  Semaphore(int value) {\n  ... }\n  void acquire() {\n    value--;\n    if (value < 0) {\n      add this process/thread to list;\n      block;\n    }\n  }\n  void release() {\n    value++;\n    if (value <= 0) {\n      remove a process P from list;\n      wakeup P;\n    }\n  }\n}\n\n```\n\n## 세마포의 사용 - 상호 배타(Mutual exclusion)\n\nsem.value = 1로 두어 임계구역에는 프로세스 한 개만 들어갈 수 있도록 한다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2020-01-06-img/1.png)<br/>\n\n아래 코드는 은행 계좌 예시의 BankAccount 클래스를 수정한 것으로 임계구역 문제를 해결한다.\n\n```java\nimport java.util.concurrent.Semaphore;\n\nclass BankAccount {\n  int balance;\n  Semaphore sem;\n  public BankAccount () {\n    this.sem = new Semaphore(1)\n  }\n  void deposit(int amount) {\n    try {\n      sem.acquire()\n    } catch(InterruptedException) {}\n\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp;\n    sem.release()\n  }\n  void withdraw(int amount) {\n    try {\n      sem.acquire()\n    } catch(InterruptedException) {}\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp;\n    sem.release()\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n\n1. Parent 프로세스가 deposit()을 호출하면 acquire() 메소드가 실행된다. 이는 value를 0으로 만드나 조건이 false라 바로 빠져나와 임계구역을 실행한다.\n2. 문맥 전환에 의해 Child 프로세스의 witdhdraw()가 호출되면 acquire()이 호출된다. value를 -1로 만들어 조건이 true가 되어 Child 프로세스는 큐에 들어가고 Block 된다. 즉, 임계구역을 못 간다.\n3. Parent 프로세스가 임계구역 실행을 완료한 후 release()를 호출하면 큐의 프로세스 하나를 뺀다. 즉, Child 프로세스를 깨워 Ready Queue로 보낸다.\n\n## 세마포의 사용 - 프로세스 실행 순서 제어(Ordering)\n\nCPU 스케줄링 알고리즘에 관련없이 P1에 들어간 S1 코드가 P2의 S2 코드보다 먼저 실행되게 하고 싶을 때? 세마포를 사용하자!\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2020-01-06-img/2.png)<br/>\n\n항상 입금이 먼저 되게 BankAccount 클래스를 수정해보자.\n\n```java\nimport java.util.concurrent.Semaphore;\n\nclass BankAccount {\n  int balance;\n  Semaphore sem;\n  Semaphore sem2;\n  public BankAccount () {\n    this.sem = new Semaphore(1);\n    this.sem2 = new Semaphore(0)\n  }\n  void deposit(int amount) {\n    try {\n      sem.acquire()\n    } catch(InterruptedException) {}\n\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp;\n    sem.release()\n    sem2.release()\n  }\n  void withdraw(int amount) {\n    try {\n      sem2.acquire()\n      sem.acquire()\n    } catch(InterruptedException) {}\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp;\n    sem.release()\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n\n이제 입출금 교대로 되게 BankAccount 클래스를 수정해보자.\n\n```java\nimport java.util.concurrent.Semaphore;\n\nclass BankAccount {\n  int balance;\n  Semaphore sem;\n  Semaphore dsem;\n  Semaphore wsem;\n  public BankAccount () {\n    this.sem = new Semaphore(1);\n    this.dsem = new Semaphore(0);\n    this.wsem = new Semaphore(0);\n  }\n  void deposit(int amount) {\n    try {\n      sem.acquire();\n    } catch(InterruptedException) {}\n\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp;\n    sem.release();\n    wsem.release();\n    try {\n      dsem.acquire();\n    } catch(InterruptedException) {}\n\n  }\n  void withdraw(int amount) {\n    try {\n      wsem.acquire();\n      sem.acquire();\n    } catch(InterruptedException) {}\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp;\n    sem.release();\n    dsem.release();\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"146c143b5de337f212dc8e01ca9473a2a201a1a5","text":"# 알고리즘 개념 잡자 - 트라이\n\n- Title : 알고리즘 개념 잡자 - 트라이\n- Date : 2020-01-03\n- Category: Algorithm\n\n> 참고 서적<br/> > [코딩 인터뷰 완전분석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545) 트리와 그래프<br/>\n> [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539) 제 7장 트리, 제 8장 우선순위 큐\n\n# 3. 트라이(접두사 트리, prefix tree)\n\n> 참조 링크 [wikipedia](https://en.wikipedia.org/wiki/Trie)\n\n![트라이](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-03-img/4.png)\n\n- n-차 트리의 변종으로 각 노드에 문자를 저장하는 자료구조이다.\n- 문자열 탐색에 효율적인 자료구조이다.\n- 트리를 아래쪽으로 순회하면 단어 하나가 나온다.\n- TerminatingTrieNode로 널 노드를 표현한 경우, 트라이에서 각 노드는 1개 ~ 문자열 길이 + 1개 까지 자식을 가질 수 있다.\n- 널 노드 대신 불린 플래그로 표현한 경우, 각 노드는 0개 ~ 문자열 길이개까지 자식을 가질 수 있다.\n\n> **널 노드(\\* 노드)**\n>\n> - 단어의 끝을 나타낸다.\n> - 예) MANY 이후에 널 노드가 나오면 MANY라는 단어가 완성되었다는 의미다.\n>\n> **널 노드 구현 방법**\n>\n> - TrieNode를 상속한 TerminatingTrieNode로 표현하기\n> - 널 노드의 부모 노드 안에 불린 플래그를 새로 정의함으로써 표현하기\n\n**어디에 사용할까?**\n\n- 자동 완성\n- 문자열이 어떤 문자열의 접두사인지 확인하고 싶을 때 <span class=\"clr-grey\">cf) 단순 삽입/조회만 한다면 해시테이블 사용을 권장</span>\n- 예: 'a', 'axe'로 시작하는 단어를 찾고 싶을 때\n\n> 예시, M, MA, MAN, MANY를 차례대로 살펴보는 경우 트리의 현재 노드를 참조값으로 넘김으로써 루트 노드에서 시작할 필요가 없고 단순히 Y가 MAN의 자식인지만 확인해보면 된다.\n\n## 트라이 VS 해시테이블\n\n- 최악의 경우, 시간복잡도는?\n  - 트라이 : O(K) (K: 가장 긴 문자열)\n  - 해시테이블 : 충돌이 자주 발생되었다면 O(N)의 시간복잡도를 가진다. (N: 키의 개수) 또한 입력 문자열을 기반으로 해시 계산을 하므로 O(K)의 시간이 걸린다.\n  - cf) 탐색할 문자열이 트라이에 없는 경우에는 문자열 길이 K보다 시간이 덜 걸린다.\n\n> **트라이와 해시의 시간복잡도가 비슷하다..?** <br/>\n> 길이가 K인 무자열이 주어졌을 때 트라이는 O(K) 시간에 해당 문자열이 유효한 접두사인지 확인할 수 있다. 이 시간은 해시테이블 사용했을 때와 정확히 같은 수행 시간이다. 우리가 종종 해시테이블을 검색하는 시간이 O(1)이라고 하지만 완전히 맞는 말은 아니다. 해시테이블도 입력 문자열은 전부 읽어야 하므로 길이가 K인 단어를 검색하는 데 걸리는 시간은 O(K)가 된다.\n\n- 알파벳 정렬?\n\n  - 일반적으로 자료구조에 문자열을 저장한다면 각 문자열의 순서가 중요하기도 하다. 트라이는 노드를 저장할 때 왼쪽에서 오른쪽으로 사전 순으로 저장한다면 쉽게 정렬이 가능하다.\n\n- 기타\n  - 트라이는 삭제가 직관적이며 해시 함수가 필요 없으나 해시 테이블 보다는 많은 공간을 차지한다.\n\n## 트라이 구현\n\n```javascript\nclass Trie {\n  constructor(key) {\n    this.is_terminal = false;\n    this.key = key;\n    this.trie_child = Array(26).fill(null);\n  }\n\n  char_to_index(key) {\n    return key.charCodeAt(0) - \"a\".charCodeAt(0);\n  }\n\n  // 새로운 문자열을 트라이에 추가\n  insert(key) {\n    let current_trie = this;\n    for (let i = 0; i < key.length; i++) {\n      let index = this.char_to_index(key[i]);\n      if (current_trie.trie_child[index] === null)\n        current_trie.trie_child[index] = new Trie(key.slice(0, i + 1));\n      current_trie = current_trie.trie_child[index];\n    }\n    current_trie.is_terminal = true;\n  }\n\n  // 트라이 출력\n  print(trie, dep) {\n    console.log(dep, trie.key);\n    if (trie.is_terminal) return;\n    for (let i = 0; i < 26; i++) {\n      if (trie.trie_child[i] !== null) this.print(trie.trie_child[i], dep + 1);\n    }\n  }\n\n  // key를 접두어로 가지고 있는지, 가지고 있으면 해당 접두어가 끝나는 부분의 위치를 반환\n  find(key) {\n    let current_trie = this;\n    for (let i = 0; i < key.length; i++) {\n      let index = this.char_to_index(key[i]);\n      if (current_trie.trie_child[index] === null) return false;\n      else current_trie = current_trie.trie_child[index];\n    }\n    return current_trie;\n  }\n\n  // key를 포함하는 지, 포함하면 true\n  exist(key) {\n    let current_trie = this;\n    for (let i = 0; i < key.length; i++) {\n      let index = this.char_to_index(key[i]);\n      if (current_trie.trie_child[index] === null) return false;\n      else current_trie = current_trie.trie_child[index];\n    }\n    return current_trie.is_terminal;\n  }\n}\n\nvar trie = new Trie(null);\nvar arr = [\"to\", \"tea\", \"ted\", \"ten\", \"a\", \"inn\"];\narr.forEach(str => trie.insert(str));\n// trie.print(trie, 0)\nconsole.log(trie.exist(\"tea\")); // true\nconsole.log(trie.exist(\"aaa\")); // false\nconsole.log(trie.exist(\"a\")); // true\nconsole.log(trie.find(\"te\")); // Trie {is_terminal: false, key: \"te\", trie_child: Array(26)}\n```\n"}}}},"pageContext":{"id":"bc66abbed338f762f562dfdd8ad9e2e2db1953a7","previousPostId":"68ea80dc2124e8d2e6495a2ae7232f0d565aecf7","nextPostId":"146c143b5de337f212dc8e01ca9473a2a201a1a5"}},"staticQueryHashes":["2685952063","2841359383"]}