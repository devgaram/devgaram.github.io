{"componentChunkName":"component---src-templates-blog-post-js","path":"/a235f572d3b9bbda67147d2603cbeadcb82d0eda","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"a235f572d3b9bbda67147d2603cbeadcb82d0eda","text":"# AWS 연습하자 1탄 - AWS EC2 인스턴스에 Jenkins 서버 구축하기\n\n- Title : AWS 연습하자 1탄 - AWS EC2 인스턴스에 Jenkins 서버 구축하기\n- Date : 2020-02-24\n- Category: Infra\n\nAWS 연습하기 1탄에서는 AWS EC2에 인스턴스를 생성하고 Jenkins를 구축하는 과정을 다뤄보겠습니다. AWS에서 제공하는 [가이드](https://d1.awsstatic.com/Projects/P5505030/aws-project_Jenkins-build-server.pdf)를 참고하여 실습을 진행했습니다.\n\n# AWS EC2 인스턴스를 생성하기\n\n먼저 [Amazon EC2 console](https://console.aws.amazon.com/ec2/)로 이동해서 우측 상단의 Region을 서울로 설정합니다.\n\n인스턴스 생성에 앞서 키 페어부터 생성하도록 하겠습니다.\n왼쪽 네비게이션 바에서 **네트워크 및 보안 -> 키 페어 -> 키 페어 생성** 을 클릭합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/1.PNG)\n\n이름을 입력 후 파일 형식은 pem을 선택하고 키 페어 생성 버튼을 누르면 .pem 파일 형식의 개인키가 다운로드됩니다. 인스턴스 생성, 연결 시 필요하므로 **꼭 잘 보관해두세요**.\n\n> 윈도우 10은 openssh가 내장되어있어 ssh 명령어를 사용할 수 있습니다. ssh를 지원하지않는 경우라면 ppk를 사용하시면 됩니다.\n\n이제 인스턴스를 생성하겠습니다. **EC2 대시보드 -> 인스턴스 시작 섹션 -> 인스턴스 시작** 을 선택합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/2.PNG)\n\n**단계 1: AMI 선택** 에서 Amazon Linux AMI 프리 티어 사용 가능한 AMI를 선택하세요.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/3.PNG)\n\n**단계 2: 인스턴스 유형 선택** 에서 디폴트로 선택된 t2.micro를 선택한 후 다음: 인스턴스 세부 정보 구성을 선택합니다.\n\n**단계 3: 인스턴스 세부 정보 구성** 에서 디폴트 값을 그대로 사용하겠습니다. 다음:스토리지 추가를 선택합니다.\n\n**단계 4: 스토리지 추가** 에서 프리티어는 최대 30GB의 EBS 범용(SSD) 또는 마그네틱 스토리지를 사용할 수 있습니다. 크기 항목에 8로 되어있는 것을 30으로 수정한 후 다음:태그 추가를 클릭합니다.\n\n**단계 5: 태그 추가** 에서 여러 인스턴스를 태그로 검색이나 그룹짓기 위해 아래와 같이 태그를 추가합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/4.PNG)\n\n**단계 6: 보안 그룹 구성** 에서 인스턴스 방화벽 역할을 하는 보안 그룹을 설정하겠습니다. 보안그룹에서 인바운드와 아웃바운드 트래픽을 인스턴스 레벨에서 컨트롤할 수 있습니다.\n\n우선 디폴트로 있는 SSH 유형의 소스를 내 IP로 변경합니다. SSH의 소스를 모든 IPv4(0.0.0.0/0)으로 설정하는 것은 보안상 추천하지않습니다.\n\nHTTP, HTTPS 유형을 추가하고 소스를 0.0.0.0/0으로 설정합니다. 외부에서 이 서버로 접속하려면 꼭 설정해야합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/5.PNG)\n\n**검토 및 시작 -> 시작 -> 기존 키 페어 선택 또는 새 키 페어 생성 모달** 을 띄웁니다. 앞에서 키 my-key-pair 이름으로 키 페어를 생성해놨던 것을 여기서 사용할 것입니다. 아래와 같이 선택한 후 인스턴스 시작을 클릭합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/6.PNG)\n\n인스턴스 상태가 running이 되면 정상적으로 인스턴스 생성 및 실행이 완료된 것입니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/7.PNG)\n\n# Jenkins 설치하기\n\n방금 생성한 ec2 인스턴스에 젠킨스를 구축하려면 보안 그룹을 편집해야합니다.\n\n보안그룹에서 HTTPS 프로토콜을 제거하고 사용자 지정 TCP 규칙을 추가하겠습니다.\n\n스크롤을 오른쪽으로 해보면 보안그룹이 보입니다. 바로 밑의 링크를 클릭하여 인스턴스 보안그룹으로 이동합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/8.PNG)\n\n아래 사진과 같이 EC2 인스턴스를 생성할 때 설정한 보안 그룹의 내용을 확인할 수 있습니다. 이제 편집 버튼을 눌러서 수정하겠습니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/9.PNG)\n\nHTTPS 프로토콜을 삭제하고 사용자 지정 TCP 규칙을 추가 후 포트 범위로는 8080을 입력합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/10.PNG)\n\n본격적으로 젠킨스를 설치하고 환경을 설정하겠습니다.\n\n윈도우10에서 cmd 창을 킨 다음 my-key-pair.pem이 있는 폴더로 이동합니다.\n\n```\nC:\\Users\\USER>cd C:\\Users\\USER\\github\\project\\devrami-blog\\aws\n```\n\n개인키 my-key-pair.pem을 가지고 인스턴스에 접속하겠습니다.\n\n```\nssh -i my-key-pair.pem ec2-user@퍼블릭DNS\n```\n\n**Are you sure you want to continue connecting\n(yes/no)?** 가 뜨면 yes를 입력한 후 엔터를 누릅니다.\n\n아래와 같은 문구를 보게되면 인스턴스에 성공적으로 접속된 것입니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/images/2020-02-24-img/11.PNG)\n\n다음과 같이 커맨드를 입력합니다.\n\n```\nsudo yum update –y\n```\n\n> - Yum은 RPM 기반의 시스템을 위한 자동 업데이트 겸 패키지 설치/제거 도구\n> - RPM은 원래 레드햇에서 사용되었던 패키지 파일이었지만 현재는 많은 RPM 기반 배포판(RPM 패키지, RPM 패키지 관리 도구)이 사용되고 있습니다. 즉, RPM을 사용하면 각종 소프트웨어의 설치 및 업데이트를 굉장히 편하게 할 수 있습니다.\n\nAWS는 기본적으로 OS 설치시 타임존이 UTC로 맞춰져있어서 한국 시간에 맞추기위해 다음 작업을 추가로 하겠습니다.\n\n```\n# 날짜확인\ndate\n\nsudo rm /etc/localtime\nsudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime\n\n```\n\nyum이 젠킨스 설치 위치를 알 수 있도록 젠킨스 레파지토리를 추가합니다.\n\n```\nsudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo\n```\n\n패키지를 설치할 수 있게 젠킨스 키 파일을 rpm에 추가한다.\n\n```\n sudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key\n```\n\n> rpm 포맷은 전자서명을 첨부하여 위변조 여부를 확인할 수 있습니다. rpm 패키지가 위변조 되면 에러가 발생합니다. 다른 제조사가 서명했는데 서명자의 검증용 키가 없을 경우도 검증이 실패하게 되는 데 이럴 경우 --import 옵션을 이용하여 검증용 키를 rpm에 추가하면 됩니다.\n\n젠킨스를 설치하겠습니다.\n\n```\nsudo yum install jenkins -y\n```\n\n젠킨스 서버를 시작합니다.\n\n```\n sudo service jenkins start\n```\n\n> 다음과 같은 에러가 발생하면 자바 버전 문제로 자바8로 재 설치한 후 다시 서버를 시작하시면 됩니다.  \n> **Starting jenkins (via systemctl): Job for jenkins.service failed because the control process exited with error code. See \"systemctl status jenkins.service\" and \"journalctl -xe\" for details.**\n>\n> ```\n> sudo yum remove java-1.7.0-openjdk\n> sudo yum install java-1.8.0\n> ```\n\n# Jenkins 설정하기\n\n브라우저에서 http://퍼블릭DNS:8080 로 접속하면 아래와 같은 화면이 보일 것입니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/12.PNG)\n\n근데 매번 8080 포트 입력하기 귀찮죠? Nginx를 프록시로 사용해서 80포트로 들어오면 8080으로 연결되게 추가 설정을 진행하도록 하겠습니다.\n\n우선 Nginx를 설치해줍니다. nginx는 yum으로 설치할 수 없어서 아래처럼 설치해줍니다.\n\n```\nsudo amazon-linux-extras install nginx1\n```\n\nnginx 서비스를 시작합니다.\n\n```\nsudo service nginx start\n```\n\n이제 포트없이 퍼블릭 도메인으로 들어가보면 아래 화면처럼 보일 것입니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/17.PNG)\n\n자! 그럼 젠킨스 서버로 프록시하기위해 추가 설정을 하도록하겠습니다.\n\nnginx 설정 파일에서 location에 proxy_pass 정보를 추가하겠습니다.\n\n```\nsudo vi /etc/nginx/nginx.conf\n```\n\n다음과 같이 입력하면됩니다.\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/18.PNG)\n\n저장 후 nginx 서비스를 재시작하면 처음에 8080포트로 들어갔을 때 봤던 화면이 포트없이 접속해도 잘 보이는 것을 확인할 수 있을 것입니다.\n\n```\nsudo service nginx restart\n```\n\n이제 젠킨스 내부에서 설정을 해보겠습니다.\n\n접속을 위해 **/var/lib/jenkins/secrets/initialAdminPassword** 에 있는 패스워드를 찾습니다.\n\n```\n sudo cat /var/lib/jenkins/secrets/initialAdminPassword\n```\n\n위 커맨드로 나오는 내용을 복사하여 Administrator password에 입력한 후 continue 버튼을 클릭합니다.\n\nCustomize Jenkins 페이지에서 **Install suggested plugins** 를 선택합니다. 플러그인 설치가 완료되면 Create First Admin User 페이지에서 관리자 계정을 생성합니다. 여기까지 완료했으면 이 페이지를 볼 수 있을 것입니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/13.PNG)\n\n[AWS 연습하자 2탄 - Jenkins와 Github 연동하기](/post/2020-02-25-how-to-use-aws) 로 이어집니다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"5a30bac6bb7fcaecb510c9cd70735f33591e0b4c","text":"# AWS 연습하자 2탄 - Jenkins와 Github 연동\n\n- Title : AWS 연습하자 2탄 - Jenkins와 Github 연동\n- Date : 2020-02-25\n- Category: Infra\n\n> AWS 연습하자 시리즈\n>\n> - [AWS 연습하자 1탄 - AWS EC2 인스턴스에 Jenkins 서버 구축하기](/post/2020-02-24-how-to-use-aws)\n\nAWS 연습하기 2탄에서는 추가 설정과 Jenkins와 Github을 연동하는 과정을 다뤄보겠습니다.\n\n# Git 설치\n\n연동에 앞서 Jenkins 서버에 git을 설치해두겠습니다.\n\n```\nsudo yum install git\n```\n\n# SSH 키 생성 및 등록\n\n젠킨스와 깃허브를 연동하는 작업은 [기억보다 기록을 - Jenkins로 Beanstalk + Multi Module 배포하기 - Jenkins와 Github 연동하기](https://jojoldu.tistory.com/291?category=777282)를 99% 참고하여 진행했습니다.\n\nssh 키를 생성합니다.\n\n```\nsudo ssh-keygen -t rsa -f id_rsa\n```\n\n아래 커맨드를 이용해 id_rsa 내용을 확인한 후 복사해둡니다.\n\n```\nsudo cat id_rsa\n```\n\n그 다음 다시 젠킨스 페이지로 돌아와서 **Credentials -> System -> Global credentials -> Add Credentials**를 선택합니다.\n\n아래와 같이 설정한 후 저장합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/19.PNG)\n\n이제 공개키(id_rsa.pub)를 Github에 등록하겠습니다.\nJenkins로 관리할 Github 프로젝트로 이동한 뒤 **Settings탭 -> Deploy keys -> Add deploy key** 를 차례로 클릭합니다.\n\nTitle에는 Jenkins 입력, key에는 아래 커맨드를 실행한 결과 값을 붙여넣습니다.\n\n```\nsudo cat id_rsa.pub\n```\n\nAllow write access는 체크 해제한 후 Add Key를 클릭합니다.\n\n이 작업만 해도 Build, Test, Code Clone 등을 다 할 수 있긴 합니다. PUSH 발생시에도 젠킨스가 PUSH 이벤트를 받을 수 있도록 Webhooks를 추가하겠습니다.\n\n**Settings 탭 -> Webhooks -> Add webhook** 을 클릭합니다.\n\nPayload URL에 http://Jenkins도메인/github-webhook/ 을 입력하고 Content type은 **application/json** 으로 변경해줍니다. Add webhook을 클릭하여 추가를 완료합니다.\n\n# Nodejs 설정\n\n제가 연결할 프로젝트는 express 프레임워크가 적용된 nodejs 서버입니다. 우선 Node.js 툴을 설치해줘야합니다. **메인페이지 -> Jenkins 관리 -> 플러그인 관리 -> 설치가능 탭** 을 클릭한 후 검색 창에 **nodejs** 라고 입력합니다. 리스트에서 NodeJS Plugin이 보이면 체크박스 선택 후 재시작없이 설치하기를 클릭합니다. 설치가 완료되면 다시 메인 페이지로 돌아갑니다.\n\n이제 Node.js 툴 설정을 진행하겠습니다. **Jenkins 관리 -> Global Tool Confituration** 을 선택합니다.\n\n**NodeJS 섹션 -> NodeJS installations..** 를 클릭합니다.\n\n아래와 같이 입력한 후 저장합니다.\n저는 로컬에서 노드 버전이 12.14.1 여서 다음과 같이 선택했습니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/16.PNG)\n\n# Item 생성 및 파이프라인 작성\n\n**새로운 Item -> 적당한 이름 입력 -> Pipeline** 선택 후 OK를 눌러줍니다.\n\nBuild Triggers가 Github hook과 연동되도록 다음과 같이 선택합니다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-24-img/20.PNG)\n\nPipeline 섹션에 Definition은 Pipeline script로 한 후 아래와 같이 입력하고 저장합니다. Pipeline 스크립트를 jenkinsfile로 관리하는 것은 뒤에서 다루도록 하겠습니다.\n\n```\npipeline {\n   agent any\n\n   tools {\n      nodejs \"node\"\n   }\n\n   stages {\n      stage('Build') {\n         steps {\n            git 'https://github.com/devgaram/express-project-blog.git'\n         }\n      }\n\n      stage('Install dependencies') {\n          steps {\n              sh 'npm install -g yarn'\n              sh 'yarn install'\n          }\n      }\n      stage('Test') {\n          steps {\n              echo 'test..'\n              // yarn test\n          }\n      }\n      stage('Upload S3') {\n          steps {\n              echo 'upload s3'\n          }\n      }\n      stage('Deploy') {\n          steps {\n              echo 'deploy'\n          }\n      }\n   }\n   post {\n        success {\n            echo 'successed'\n        }\n        failure {\n            echo 'failed'\n        }\n   }\n}\n\n```\n\n생성된 아이템으로 이동한 후 Build Now 버튼을 눌렀을 때 에러없이 완료되면 Github 연동은 성공적으로 된 것입니다.\n\n[AWS 연습하자 3탄 - Jenkins와 S3 버킷 & AWS codeDeploy 연동으로 배포하기](/post/2020-02-26-how-to-use-aws) 으로 이어집니다.\n\n[참고 블로그](https://medium.com/@gustavo.guss/jenkins-starting-with-pipeline-doing-a-node-js-test-72c6057b67d4)\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"baf3d7f1d92d3ddf097652b4412ef8feb523af76","text":"# 완전 초보를 위한 가상화 개념\n\n- Title : 완전 초보를 위한 가상화 개념\n- Date : 2020-02-19\n- Category: Infra\n\n이 포스팅은 완전 초보를 위한 글로 \"무슨 이거까지 설명해?\" 라는 생각이 들 수 있어요. 초보가 정리한 거라 오류가 있을 수도 있으니 발견하시면 코멘트 주세요! 😊\n\n> Windows 운영체제 위에서 Linux를 사용하기 위해 가상머신을 설치해본 적이 있나요? 주로 VM웨어사가 만든 하이퍼바이저 기반 가상머신 소프트웨어인 VM웨어 워크스테이션을 사용했을 거예요. 이처럼 하이퍼바이저(hypervisor)는 호스트 컴퓨터(여기선 윈도우 환경)에서 리눅스와 같은 다수의 운영체제를 동시에 실행할 수 있는 플랫폼을 제공해줘요.\n\n위 글에서 언급된 **가상화**, **가상머신**, **하이퍼바이저**를 설명할 수 있나요? 있다면, 고수네요. 부럽..🤣 초보인 저와 또 다른 초보를 위해 차근차근 정리해볼게요.\n\n<br/>\n\n---\n\n<br/>\n\n## 1. 가상화(virtualization)\n\n가상화는 컴퓨팅 리소스(서버, 데이터베이스, 스토리지, 애플리케이션 등)를 **추상화**하여 다수의 운영 체제 또는 애플리케이션 이미지를 하나의 물리적 서버에서 공유할 수 있도록 하는 프로세스예요. 물리적 컴퓨터 수를 줄일 수 있어 **비용 절감**에 효과적인데요. 대부분의 서버는 단지 용량의 10~15%만 사용하는 데 가상화를 통해 서버 효용률을 70% 이상으로 올릴 수 있기 때문이죠.\n\n## 2. 가상 머신(virtual machine, VM)\n\n**가상머신**은 컴퓨팅 환경을 소프트웨어로 구현한 것으로 컴퓨터를 **에뮬레이션**하는 소프트웨어예요.\n에뮬레이터 역할을 하는 거죠. 가상 머신은 CPU를 포함한 모든 하드웨어를 가상화하여 가상머신상에서 운영체제나 응용 프로그램을 설치하고 실행할 수 있게 해요.\n\n<span class=\"clr-grey\">에뮬레이션은 한 시스템을 복제하여 그 시스템을 흉내 내는 것으로 가상화 구현에서는 CPU를 포함한 모든 하드웨어를 가상화하는 것을 말해요. 즉, 옵코드가 달라도 실행 가능하죠. PC에서 실행되는 수많은 게임 에뮬레이터도 이런 가상화 기술 중 하나예요. 느리다는 단점이 있긴 하죠.</span>\n\n## 3. 하이퍼바이저(hypervisor)\n\n호스트 컴퓨터에서 다수의 게스트 OS를 동시에 실행할 수 있게 하는 소프트웨어로 가상화 머신 모니터 또는 가상화 머신 매니저라고 불러요. 하이퍼바이저는 아래와 같이 2가지 타입으로 나눠져요.\n<br/><br/>\n\n<div style=\"text-align:center\">\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Infra/images/2020-02-19-img/Hyperviseur.png)\n<br/>\n<span class=\"clr-grey\">위키피디아 하이퍼바이저</span>\n\n</div>\n<br/>\n\n### 타입 2 (호스트형)\n\n일반 프로그램과 같이 하이퍼바이저는 호스트 OS 위에서 실행돼요. VM 내부에서 동작되는 게스트 OS는 하드웨어에서 3번째 수준으로 실행되는 거죠. 타입1에 비해 오버헤드가 크지만, 게스트 OS 종류에 대한 제약이 없고 데스크탑, 노트북에서도 운영할 수 있어요.\n\n<BR/>\n\n### 타입 1 (native 또는 bare-metal)\n\n타입2와 달리 **호스트 OS 없이** 하드웨어 위에 하이퍼바이저가 바로 위치해요. 별도의 호스트 OS가 없기에 오버헤드가 적고 하드웨어를 직접 제어하기 때문에 효율적으로 리소스를 사용할 수 있어요. 하지만 여러 하드웨어 드라이버를 세팅해야 하므로 설치가 어려워요. VM 내부의 게스트 OS는 하드웨어 위에서 2번째 수준으로 실행되는 거죠.\n\n<span class=\"clr-grey\">네이티브형 하이퍼바이저는 전가상화, 반가상화 방식으로 세분화할 수 있어요. 하이퍼바이저를 통해 가상 머신 내의 게스트 OS가 호스트 시스템을 활용한다는 점을 같지만, 하드웨어와 인터랙션하는 방식에 차이가 있어요.</span>\n\n**1) 전가상화(Full-virtualization, Native-virtualization)**\n\n동일한 아키텍처에서 실행되는 게스트 OS를 **수정없이** 그대로 띄워주는데 필요한 하드웨어를 모두 에뮬레이션 하는 형식으로 가상화해요.\n\n- 게스트 OS는 하드웨어에 직접 액세스 하는 것으로 인식해요. 사실 이 하드웨어는 하이퍼 바이저가 하드웨어를 에뮬레이션한 복제품이죠. 그래서 게스트 OS는 하드웨어를 자신이 소유하고 있는 걸로 인식해요.\n- 하이퍼바이저는 게스트 OS가 하드웨어에 주는 명령을 감시해 \"하드웨어를 독점\"하는 명령이 발생하면 별도로 핸들링 해줘야 해요. 즉, 하이퍼바이저가 게스트 OS와 하드웨어 사이의 **중재자** 역할을 하죠. 그 전에 모든 게스트 OS는 \"DOM 0\"이라는 관리 머신을 거쳐 하이퍼바이저와 통신해요\n- 매번 하이퍼바이저와 통신하므로 CPU와 RAM처럼 I/O가 잦은 자원을 컨트롤 하기에는 번거롭기에 아래의 반가상화 방식이 출현했어요.\n\n**2) 반가상화(Para-virtualization)**\n\n하드웨어 에뮬레이션 없이 하이퍼바이저를 통해 하이퍼바이저가 제공하는 API를 이용한 OS를 실행할 수 있는 가상화해요. **게스트 OS를 하이퍼바이저의 API를 이용할 수 있도록 수정**해야해요. 게스트 OS를 수정해야 하므로 좀 번거롭죠.\n\n- 게스트 OS는 하드웨어에 하이퍼바이저가 제공한 API를 통해서 엑세스할 수 있어요.\n- 게스트 OS 입장에선 하드웨어를 소유하고 있지 않다는 것을 알고 있으므로 하드웨어를 독점하는 명령을 하지 않아요.\n- 각각의 게스트 OS는 필요한 자원을 직접 API를 통해 요청할 수 있으므로 모든 요청을 \"DOM 0\"가 한꺼번에 처리하여 하드웨어를 제어하는 전가상화 방식에 비해 성능이 좋아요.\n\n## 4. 컨테이너 기반의 가상화(도커) - 추후 추가예정\n\nOS레벨 가상화(OperatingSystem-level virtualization)는 OS상에서 같은 OS를 하나 더 사용하는것 처럼 꾸며주는 가상화로 가상화로 인한 속도저하가 없다고 생각해도 무방해요. 특히 OS레벨 가상화는 요즘 가장 핫한 방식인데, Container 를 사용해 SaaS, PaaS를 제공하는 Docker 와, 수많은 Container 관리를 용이하게 해주는 Kubernetes가 그 중심에 있다.\n"}}}},"pageContext":{"id":"a235f572d3b9bbda67147d2603cbeadcb82d0eda","previousPostId":"5a30bac6bb7fcaecb510c9cd70735f33591e0b4c","nextPostId":"baf3d7f1d92d3ddf097652b4412ef8feb523af76"}},"staticQueryHashes":["2841359383"]}