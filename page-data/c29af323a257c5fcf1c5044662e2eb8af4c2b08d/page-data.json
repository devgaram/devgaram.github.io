{"componentChunkName":"component---src-templates-blog-post-js","path":"/c29af323a257c5fcf1c5044662e2eb8af4c2b08d","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"c29af323a257c5fcf1c5044662e2eb8af4c2b08d","text":"# [생활코딩] Javascript 입문3\n\n- Title : [생활코딩] Javascript 입문3\n- Date : 2018-01-11\n- Category: Javascript\n\n생활코딩 javscript 과정 중 정규표현식 내용을 정리했습니다.\n\n# 정규표현식(Regular Expression)\n\n- 문자열에서 특정 문자를 찾을 때 사용 .. \\* 나중에 생활코딩 정규표현식 강의도 듣기!! & 전화번호 때 사용했던 경험 넣기\n- 컴파일 -> 실행 단계로 이뤄진다.\n- 컴파일 : 찾고 싶은 패턴을 만듬.\n- 실행 : 문자열에서 패턴을 추출.\n\n## 정규표현식 객체를 만드는 방법\n\n1. var pattern = /a/\n2. var pattern = new RegExp('a');\n\n## 패턴 추출\n\n1. pattern.exec('abcdef') // [\"a\"]; a배열 추출\n2. pattern.exec('bcdefg') // null a가 없어서.\n3. pattern.test('abcdef') // true\n4. pattern.test('bcdefg') // false\n\n## 문자열 객체의 메소드에서 정규표현식 사용하기\n\nString.match()  \nString.replace()\n\n```javascript\n\"abcdef\".match(pattern); // [\"a\"]\n\"bcdefg\".match(pattern); // null\n\"abcdef\".replace(pattern, \"A\"); // Abcdef\n```\n\n## 옵션\n\ni 대소문자 구분 안함\n\n```javascript\nvar oi = /a/i;\n\"Abcdef\".match(oi); //[\"A\"]\n```\n\ng 검색된 모든 결과 리턴\n\n```\nvar og = /a/g;\n\"abcdea\".match(og);    //[\"a\",\"a\"]\n```\n\n## 치환\n\n```\nvar pattern = /(\\w+)\\s(\\w+)/;    //()는 그룹, \\s는 공백, +는 1개이상, \\w는 문자(0-9,a-z,A-Z)\nvar str = \"coding everybody\";\nvar result = str.replace(pattern, \"$2, $1\");    //$N는 N번째 그룹.\nconsole.log(result);\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e8be63527de9580685e34fc4299ba081b8713fe7","text":"# [생활코딩] javascript 객체지향2\n\n- Title : [생활코딩] javascript 객체지향2\n- Date : 2018-01-13\n- Category: Javascript\n\n생활코딩 객체지향 파트 중 상속과 프로토타입에 대한 내용을 정리했습니다.\n\n# 1. 상속\n\n상속을 하기 위한 준비 작업\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.name = null;\nPerson.prototype.introduce = function() {\n  return \"My name is\" + this.name;\n};\n\nvar p1 = new Person(\"egoing\");\ndocument.write(p1.introduce()); //My name is egoing\n```\n\n객체의 프로퍼티 정의 방법은 생성자를 이용하는 것과 프로토타입을 이용하는 것이 있다.  \nPerson 객체에는 prototype이라는 속성이 있는 데 그 안에는 어떤 객체가 있다.  \n.name을 통해 그 객체에 값을 줄 수 있다.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.name = null;\nPerson.prototype.introduce = function() {\n  return \"My name is\" + this.name;\n};\nfunction Programmer(name) {\n  this.name = name;\n}\nfunction Designer(name) {\n  this.name = name;\n}\n\n/**상속방법**/\nDesigner.prototype = new Person();\nDesigner.prototype.design = function() {\n  return \"beautiful!\";\n};\nProgrammer.prototype = new Person();\nProgrammer.prototype.coding = function() {\n  return \"hello world!\";\n};\n\nvar p1 = new Programmer(\"egoing\");\ndocument.write(p1.introduce() + \"\"); //My name is egoing이 출력됨\ndocument.write(p1.coding() + \"\"); //hello world!\n\nvar p2 = new Desiner(\"leezche\");\ndocument.write(p2.design() + \"\"); //beautiful!\n```\n\nProgrammer에는 introduce 속성이 정의되어 있지않은데 어떻게 사용할 수 있었을까?  \nPerson의 introduce를 상속받았기 때문이다.\n\n객체를 생성할 때, 자바스크립트는 생성자 함수가 prototype라는 프로퍼티를 갖고 있는 지 확인한다.  \n그리고 생성자 함수에 들어있는 객체와 똑같은 객체를 만들어서 생성자의 결과로 리턴을 해준다.\n\nname과 introduce라는 프로퍼티가 prototype이라는 객체가 가지고 있다.  \n즉, prototype이라는 객체를 리턴한다?  \n그래서 Programmer의 prototype이라는 프로퍼티에 저장된다.\n\n<span class=\"clr-note\">\n*생성자의 prototype에 상속받을 객체를 new 한다.    \n*Programmer.prototype = new Person()\n</span>\n\n기본적으로 가지고있는 property를 가진 객체를 생성하기 위해서 객체 리터럴 대신, new라는 키워드를 사용한다.\n\n# 2. prototype\n\n```javascript\nfunction Ultra() {}\nUltra.prototype.ultraProp = true;\n\nfunction Super() {}\nSuper.prototype = new Ultra();\n\nfunction sub() {}\nSub.prototype = new Super();\n\nvar o = new Sub();\nconsole.log(o.ultraProp); //true출력됨.\n\n//1)\no.ultraProp = 1;\nconsole.log(o.ultraProp); //1\n```\n\no.ultraProp o라는 객체가 ultraProp를 가지고 있는지 찾는다. 그래서 1이 출력됨.\n\n```javascript\nfunction Ultra() {}\nUltra.prototype.ultraProp = true;\n\nfunction Super() {}\nSuper.prototype = new Ultra();\n\nfunction sub() {}\nSub.prototype = new Super();\nSub.prototype.ultraProp = 2;\n\nvar o = new Sub();\nconsole.log(o.ultraProp); //2가 출력됨\n```\n\no객체에 ultraProp 프로퍼티를 찾는다. 없으면 o라는 객체의 생성자를 알아 낸후, 이 생성자의 프로토타입 객체를 뒤져서 그 객체의 propery에 ultraProp가 있는 지 찾는다.\n\n```javascript\nfunction Ultra() {}\nUltra.prototype.ultraProp = true;\n\nfunction Super() {}\nSuper.prototype = new Ultra();\n\nfunction sub() {}\nvar s = new Super();\ns.ultraProp = 3;\nSub.prototype = s;\n\nvar o = new Sub();\nconsole.log(o.ultraProp); //3이 출력됨\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"44697f284e26d813ce79450c2a5dbdfef4955f6d","text":"# [생활코딩] javascript 함수지향1\n\n- Title : [생활코딩] javascript 함수지향1\n- Date : 2018-01-11\n- Category: Javascript\n\n생활코딩 함수지향 파트 중 변수의 유효범위에 대한 내용을 정리했습니다.\n\n# 변수의 유효범위\n\n예제1) 지역변수와 전역변수의 구분1\n\n```javascript\nvar vscope = \"global\"; //전역변수\nfunction fscope() {\n  alert(vscope);\n}\nfscope(); //global\n```\n\n<span class=\"clr-grey\">\n**Note:** 전역변수 : 애플리케이션 전역에서 접근 가능한 변수    \n**Note:** 지역변수 : 함수 내에서만 접근 가능한 변수    \n*변수에 접근할 때, 지역변수를 우선적으로 찾는다.\n</span>\n\n</br>\n예제2) 지역변수와 전역변수의 구분2\n```javascript\nvar vscope = 'global';   \nfunction fscope(){\n   var vscope = 'local';    //지역변수\n   var lv = 'local value';   //지역변수\n   alert(vscope);\n}\nfscope();    //local\nalert(lv);    //undefined\n```\n\n예제3) 지역변수와 전역변수의 구분3\n\n```javascript\nfunction a() {\n  i = 0;\n}\nfor (var i = 0; i < 5; i++) {\n  // i는 전역변수\n  a();\n  document.write(i);\n}\n```\n\nfor문의 i는 전역변수기 때문에 해당 코드는 계속 실행되다가 브라우저가 멈춘다.\n\n예제4) 전역변수 안쓰는 방법1\n\n```javascript\nvar MYAPP = {};\nMYAPP.calculator = {\n  //객체의 속성(calculator)에도 객체를 생성.\n  left: null,\n  right: null\n};\nMYAPP.coordinate = {\n  left: null,\n  right: null\n};\n\nMYAPP.calculator.left = 10;\nMYAPP.calculator.right = 20;\nfunction sum() {\n  return MYAPP.calculator.left + MYAPP.calculator.right;\n}\ndocument.write(sum()); //30\n```\n\nMYAPP 전역변수 하나만 생성하고, 그 안에 필요한 전역변수를 정의한다.\n\n예제5) 전역변수 안쓰는 방법2\n\n```javascript\n(function() {\n  var MYAPP = {};\n  MYAPP.calculator = {\n    //객체의 속성(calculator)에도 객체를 생성.\n    left: null,\n    right: null\n  };\n  MYAPP.coordinate = {\n    left: null,\n    right: null\n  };\n\n  MYAPP.calculator.left = 10;\n  MYAPP.calculator.right = 20;\n  function sum() {\n    return MYAPP.calculator.left + MYAPP.calculator.right;\n  }\n  document.write(sum()); //30\n})(); //익명함수\n```\n\n전역변수가 절대 존재하지 않게 개발할 때, 익명함수. 일회성함수를 이용한다.  \nJquery와 같은 라이브러리에서 모듈화 기법으로 많이 사용한다.\n\n예제6) 자바와의 차이점. for문 안에서의 변수.\n\n```javascript\nfor (var i = 0; i < 1; i++) {\n  var name = \"local no!\";\n}\nalert(name); //local no!\n```\n\n자바는 반복문, 조건문 안에서 선언된 변수를 지역변수 취급하기 때문에 위와 같은 로직으로 실행시키면 에러가 난다.  \n그러나 자바스크립트에서 해당 변수는 전역변수이다.\n\n예제7) 정적 유효범위\n\n```javascript\nvar i = 5;\nfunction a() {\n  var i = 10;\n  b();\n}\nfunction b() {\n  document.write(i); //누구의 i일까?\n}\na(); //5가 출력된다!\n```\n\n함수에서 변수를 찾을 때, 함수 내 지역변수를 먼저 찾고. 전역변수를 찾는다.  \n<span class=\"clr-note\">\n\\*\\*사용(호출)될 때가 아니라 정의될 때의 전역변수가 사용된다. -> 정적 유효범위\n</span>\n"}}}},"pageContext":{"id":"c29af323a257c5fcf1c5044662e2eb8af4c2b08d","previousPostId":"e8be63527de9580685e34fc4299ba081b8713fe7","nextPostId":"44697f284e26d813ce79450c2a5dbdfef4955f6d"}},"staticQueryHashes":["2685952063","2841359383"]}