{"componentChunkName":"component---src-templates-blog-post-js","path":"/d4a60dea091fb5b6e0163278ddd1345bb5131c7c","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d4a60dea091fb5b6e0163278ddd1345bb5131c7c","text":"# Pattern Searching - KMP Algorithm\n\n- Title : Pattern Searching - KMP Algorithm\n- Date : 2020-03-11\n- Category: Algorithm\n\n## KMP\n\nkmp 알고리즘은 Pattern Searching - Naive Alogorithm(TIL 알고리즘 파트에서 내용을 볼 수 있음)과 비슷하나 0~N(탐색문자길이) 탐색 중 적절하게 문자를 건너뛴다. 아래 예시로 이해해보자.\n\n- txt[] = ABABCAAA\n- pat[] = ABABD\n\n첫번째 윈도우 탐색 결과 패턴을 찾지는 못했다.\n\n- txt[] = `ABABC`AAA\n- pat[] = `ABABD`\n\nNaive 알고리즘 방식대로 이어서 두번째 윈도우를 탐색해보자.\n\n- txt[] = A`BABCA`AA\n- pat[] = `ABABD`\n\nNaive 알고리즘 방식대로 이어서 세번째 윈도우를 탐색해보자.\n\n- txt[] = AB`ABCAA`A\n- pat[] = `ABABD`\n\n하지만 KMP 알고리즘은 적절하게 문자를 건너뛰어서 첫번째 윈도우 후 다음으로 탐색할 두번째 윈도우는 아래와 같다.\n\n- txt[] = AB`ABCAA`A\n- pat[] = `ABABD`\n\n첫번째 윈도우 탐색 결과 ABAB까지는 패턴과 일치하는 것을 이용한 것이다. 패턴의 부분 문자열이기도한 ABAB는 접두사 AB와 접미사 AB가 일치한다. 다음 패턴의 시작점을 접미사의 시작점으로 할 수가 있는 거다.\n\n## lps[] 란?\n\n- lps 배열의 크기는 패턴의 길이와 같고 패턴 탐색 시 몇 개의 문자를 건너뛸지를 결정한다.\n- lps[i]는 패턴의 0~ i 까지의 부분 문자열에서의 접두어(prefix)와 접미어(suffix)가 같은 부분 문자열 중 가장 긴 것의 길이다. 단 접두어로 전체 문자열은 허용하지않는다.\n\n## Ips[] 예시\n\n\"AAAA\"\n\n- \"A\" : Ips[0] = **0** (prefix는 전체 문자열이 안됨)\n- \"AA\" : lps[1] = **1** ( prefix `A` suffix `A` )\n- \"AAA\" : lps[2] = **2** ( prefix `AA` suffix `AA` )\n- \"AAAA\" : lps[3] = **3** ( prefix `AAA` suffix `AAA` )\n\n\"ABCDE\"\n\n- \"A\" : Ips[0] = **0**\n- \"AB\" : lps[1] = **0**\n- \"ABC\" : lps[2] = **0**\n- \"ABCD\" : lps[3] = **0**\n- \"ABCDE\" : lps[4] = **0**\n\n\"AABAACAABAA\"\n\n- \"A\" : lps[0] = 0\n- \"`A` `A`\" : lps[1] = 1\n- \"AAB\" : lps[2] = 0\n- \"`A`AB`A`\" : lps[3] = 1\n- \"`AA`B`AA`\" : lps[4] = 2\n- \"AABAAC\" : lps[5] = 0\n- \"`A`ABAAC`A`\" : lps[6] = 1\n- \"`AA`BAAC`AA`\" : lps[7] = 2\n- \"`AAB`AAC`AAB`\" : lps[8] = 3\n- \"`AABA`AC`AABA`\" : lps[9] = 4\n- \"`AABAA`C`AABAA`\" : lps[10] = 5\n\n## lps를 이용해 탐색하기\n\n- 현재 txt 윈도우에서 pat[j] j는 0부터 비교를 시작하기\n- txt[i]와 pat[j]가 일치하면 i와 j를 증가하기\n- txt[i]와 pat[j]가 일치하지않으면\n  - 패턴 0~j-1과 탐색문자 i-j~i-1 까지는 일치한다는 것은 알고 있다.\n  - lps[j-1]은 패턴의 0~j-1 부분 문자열의 접두어 접미어가 일치하는 부분 문자열 중 길이가 가장 긴 값이라는 것은 위 정의를 통해 이미 알고 있다.\n  - 현재 윈도우 txt[i-j~i-1]에서 lps[j-1]만큼은 탐색할 필요는 없다.\n\n## C++\n\n\"AABAACAABAA\"\n\n- lps[0] = 0\n- i = 1, len = 0 ⇒ **lps[1] = 1**\n  - pat[1] == pat[0] , len=1, lps[1] = 1, i = 2\n- i = 2, len = 1\n  - pat[2] != pat[1] && len ! = 0, len = lps[1-1] =lps[0] = 0\n- i = 2, len = 0 ⇒ **lps[2] = 0**\n  - pat[2] ≠ pat[0] && len == 0, lps[2] = 0, i = 3\n\n```cpp\n    #include <iostream>\n    #include <cstring>\n    using namespace std;\n\n    void computeLPSArray(char* pat, int M, int *lps) {\n    \t// 현재까지 계산한 lps 중 가장 큰 값\n    \tint len = 0;\n    \t// 부분문자열 길이가 1이면 lps 값은 언제나 0\n    \tlps[0] = 0;\n\n    \t// i ~ M - 1 까지 계산\n    \tint i = 1;\n    \twhile (i < M) {\n    \t\tif (pat[i] == pat[len]) {\n    \t\t\tlen++;\n    \t\t\tlps[i] = len;\n    \t\t\ti++;\n    \t\t} else {\n    \t\t\tif (len != 0) {\n    \t\t\t\tlen = lps[len - 1];\n    \t\t\t} else {\n    \t\t\t\tlps[i] = 0;\n    \t\t\t\ti++;\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    void KMPSearch(char* pat, char* txt) {\n    \tint M = strlen(pat);\n    \tint N = strlen(txt);\n\n    \tint lps[M];\n\n    \tcomputeLPSArray(pat, M, lps);\n\n    \tint i = 0, j = 0;\n    \twhile (i < N) {\n    \t\tif (pat[j] == txt[i]) {\n    \t\t\tj++;\n    \t\t\ti++;\n    \t\t}\n    \t\tif (j == M) {\n    \t\t\tcout << \"Found Pattern at index \" << (i - j) << endl;\n    \t\t\tj = lps[j - 1];\n    \t\t}\n    \t\t// 패턴이 일치하지않으면\n    \t\telse if (i < N && pat[j] != txt[i]) {\n    \t\t\t// 미스매칭이 1~M이면\n    \t\t\tif (j != 0)\n    \t\t\t\tj = lps[j - 1];\n    \t\t\telse // 첫 문자부터 미스매칭\n    \t\t\t\ti = i + 1;\n    \t\t}\n    \t}\n    }\n    int main() {\n    \tchar txt[] = \"AABAACAADAABAABA\";\n    \tchar pat[] = \"AABA\";\n    \tKMPSearch(pat, txt);\n    \treturn 0;\n    }\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"cf3a7b61b8bfe799d47adca29daf2b3c341d13a4","text":"# REST API에 대해\n\n- Title : REST API에 대해\n- Date : 2020-03-16\n- Category: Web\n\n## ✨ REST API 란?\n\nREST(Representational State Transfer)는 웹처럼 HTTP 기반의 시스템에 필요한 자원(리소스, DBMS 데이터, 이미지, 동영상, 서비스..등)에 접근하는 방식을 정해놓은 아키텍쳐다.\n\n### REST 구성\n\n- 자원(RESOURCE) - URI\n  - 리소스명은 동사보다는 명사를 사용\n- 행위(Verb) - HTTP METHOD(GET, POST, PUT, DELETE)\n- 표현(Representations)\n\n### REST 특징\n\n- **클라이언트/서버 구조** : REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로 간 의존성이 줄어든다.\n- **무상태성(Stateless)** : 클라이언트 컨텍스트(세션, 쿠키)는 서버에 저장되어서는 안 된다. API 서버는 단순히 들어오는 요청만을 처리한다.\n- **캐시 처리 가능(Cacheable)** : HTTP가 가진 캐싱 기능 적용이 가능하다. 클라이언트 응답을 캐싱할 수 있어야 한다.\n- **계층화(Layered System)** : REST 서버는 다중 계층으로 구성될 수 있다. 하지만 클라이언트는 REST 서버에 직접 연결되었는지, 또는 중간 서버를 통해 연결되었는 지를 알 수 없게 해야한다. 중간 서버는 로드 밸런싱 기능이나 공유 캐시 기능을 제공함으로써 시스템 규모 확장성을 향상시키는 데 유용하다.\n- **유니폼 인터페이스(Uniform)** : URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말한다.\n\n### URI 설계 시 주의할 점\n\n- 슬래시 구분자(/)는 계층 관계를 나타내는 데 사용한다.\n- URI 마지막 문자로 슬래시(/)를 포함하지 않는다.\n- 하이픈(-)은 URI 가독성을 높이는데 사용한다.\n- 밑줄(\\_)은 URI에 사용하지 않는다.\n- URI 경로에는 소문자가 적합하다.\n- 파일 확장자는 URI에 포함시키지 않는다.\n\n### 리소스 간의 관계 표현하는 방법\n\n사용자가 좋아하는 디바이스 목록 가져오기\n\n    GET : /users/{userid}/likes/devices\n\n### 자원을 표현하는 Collection과 Document\n\n- Collection: 문서들의 집합, 객체들의 집합\n- Document: 문서, 객체\n\n예시로 이해하기\n\n- sports, players: 컬렉션\n- soccer, 13: 다큐먼트\n\n  http:// restapi.example.com/sports/soccer/players/13\n\n**참고 99.9%**\n\n[REST API 제대로 알고 사용하기 : TOAST Meetup](https://meetup.toast.com/posts/92)\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e1d99f9a899dc585ce4b9625b8729cc326c3da77","text":"# Pattern Searching - Naive algorithm\n\n- Title : Pattern Searching - Naive algorithm\n- Date : 2020-03-10\n- Category: Algorithm\n\n## Naive algorithm\n\n문자열 인덱스 0부터 패턴 문자열은 하나씩 비교해가는 방법. 가장 직관적이면서 순수(?)하다.\n\n```cpp\n    #include <iostream>\n    #include <cstring>\n    using namespace std;\n\n    void search(char* pat, char* txt) {\n    \tint M = strlen(pat);\n    \tint N = strlen(txt);\n\n    \tfor (int i=0; i<=N-M; i++) {\n    \t\tint j;\n    \t\tfor (j=0; j<M; j++) {\n    \t\t\tif (txt[i + j] != pat[j]) break;\n    \t\t}\n    \t\tif (j == M)\n    \t\t\tcout << \"Pattern found at index \" << i << endl;\n    \t}\n    }\n    int main() {\n    \tchar txt[] = \"AABAACAADAABAABA\";\n    \tchar pat[] = \"AABA\";\n    \tsearch(pat, txt);\n    \treturn 0;\n    }\n```\n\n## 시간 복잡도\n\n### 최선의 시간 복잡도\n\n- txt[] = \"AABCCAADDEE\"\n- pat[] = \"FAA\"\n\n패턴의 첫번째 문자 'F'가 일치하는 경우가 없어서 `O(n)`의 시간 복잡도를 가진다. n: 탐색 문자열의 길이\n\n### 최악의 시간 복잡도\n\n- txt[] = \"AAAAAAAAAAAAAAAAAA\"\n- pat[] = \"AAAAB\"\n\n패턴의 마지막 문자 'B'만 다를 경우 `O(m*(n-m+1))`의 시간 복잡도를 가진다. m: 패턴 문자열의 길이, n: 탐색 문자열의 길이\n"}}}},"pageContext":{"id":"d4a60dea091fb5b6e0163278ddd1345bb5131c7c","previousPostId":"cf3a7b61b8bfe799d47adca29daf2b3c341d13a4","nextPostId":"e1d99f9a899dc585ce4b9625b8729cc326c3da77"}},"staticQueryHashes":["2685952063","2841359383"]}