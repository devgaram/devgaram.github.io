{"componentChunkName":"component---src-templates-blog-post-js","path":"/57230c4640ec299d7d03355c2e48f3f78fad5edf","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"57230c4640ec299d7d03355c2e48f3f78fad5edf","text":"# 운영체제의 역사 - 일괄처리부터 시분할시스템까지 운영체제 변천의 역사\n\n- Title : 운영체제의 역사 - 일괄처리부터 시분할시스템까지 운영체제 변천의 역사\n- Date : 2019-12-23\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # Batch processing system(일괄처리)\n\n최초의 운영체제로 과거 오퍼레이터가 했던 일련의 작업들을 <span class=\"clr-note\">메모리에 상주시켜 일괄처리</span>한다. 메모리에 상주시킨 작은 프로그램을 <code class=\"codetainer\">레지던트 모니터(resident monitor)</code>라고 한다.\n\n# # Multiprogramming system(다중프로그래밍)\n\n## 멀티프로그래밍 시스템 등장 배경은??\n\n배치 프로세싱 시스템은 메모리에 운영체제와 **하나의** 사용자 프로그램(컴파일러, 게임 등..)만 올릴 수 있다. 하나만 올린다는 건 비싼 컴퓨터를 낭비하는 일이다. 예를 들어 +, \\*와 같은 연산 작업(CPU)과 화면에 입/출력하는 작업(I/O)을 하는 간단한 C 프로그램을 생각해보자. 프로그램을 실행하면 연산 작업에서는 빠른 CPU를 사용하고 입/출력 작업에서 느린 I/O를 사용한다. 즉, I/O 작업 중에는 CPU가 놀게 되는 것이다. 비싼 CPU를 쉬게 만든다니 너무나 아까운 일이다. 그래서 메모리에 여러 프로그램을 올리는 다중 프로그래밍 시스템이 등장하게 된 것이다.\n\n## 동작 방식은??\n\n이제 메모리에 여러 개의 사용자 프로그램이 올라갈 수 있게 된다. user1, user2, user3 프로그램이 메모리에 올라가있고 user1을 실행 중이라고 가정해보자. user1이 연산작업을 위해 CPU를 사용하다가 I/O를 사용하게 되면 바로 user2 프로그램을 실행한다. user2에서도 CPU를 사용하다가 I/O를 사용하게 되면 user3를 실행한다. 이렇게 프로그램이 I/O 작업을 하는 동안 또 다른 프로그램을 실행시켜 CPU를 사용하게 만들어 CPU 낭비를 줄인다.\n\n## 다중 프로그래밍에서 생각해야할 점이 있는데??\n\n바로 <span class=\"clr-note\">CPU scheduling, 메모리 관리, 보호</span>이다. 성능을 위해 각 사용자 프로그램을 최적의 순서로 실행해야하는 데 이를 <code class=\"codetainer\">CPU 스케줄링</code>이라고 한다. 이는 나중에 배운다. 또한, 각 사용자 프로그램을 메모리에 어떻게 배치하고 관리<code class=\"codetainer\">(메모리 관리)</code>할지도 고민해야하며 다른 프로그램 영역을 침범하는 경우를 막아야 한다.<code class=\"codetainer\">(보호)</code>\n\n# # Time-sharing system(시공유 시스템)\n\n## 시공유 시스템 등장 배경은??\n\n모니터와 키보드가 나오면서 대화형(Interactive system) 컴퓨터가 등장했고 컴퓨터 하나에 여러 개의 단말기(terminal)를 연결하여 여러 사람이 동시에 컴퓨터를 사용할 수 있게 되었다. 그런데 다중 프로그래밍 운영체제로는 동시에 컴퓨터를 사용할 수가 없다. user1 프로그램이 실행되는 동안 user2 프로그램을 실행할 수 없다는 것을 생각해보면 이해가 될 것이다. 시공유 시스템이 등장하게 된 배경이 바로 여기에 있다.\n\n## 동작 방식은??\n\n간단하게 1/100(초)마다 user1, user2, user3 프로그램을 스위칭한다고 생각하면 된다. 1/100(초) 동안 user1을 실행하고 그 다음 1/100(초) 동안 user2를 실행한다. 다중 프로그래밍이 I/O에 스위칭하는 것과 달리 시공유 시스템은 특정 시간마다 강제 전환한다. 더 나아가 1초를 기준으로 생각해보자. 1초동안 스위칭이 100번 일어나고 세 개의 프로그램이 메모리에 올라가있으므로 각 프로그램은 1초동안 33번 CPU에 할당된다. 워낙 빠르게 스위칭되어 여러 사용자가 하나의 컴퓨터를 사용하고 있음에도 혼자서 컴퓨터를 사용하는 것처럼 느껴진다.\n\n## 생각해봐야할 점은??\n\n바로 <span class=\"clr-note\">프로세스간 통신, 동기화, 가상 메모리</span>다. 하나의 컴퓨터를 여러명이 사용하다보면 서로 간에 데이터를 주고 받고 싶어진다. <code class=\"codetainer\">프로세스간 통신</code>의 등장 이유다. 또, user1, user2, user3가 거의 동시에 실행되므로 누가 앞서서 실행되는 지를 정해야하는 데 이를 <code class=\"codetainer\">동기화</code>라고 한다. 마지막으로 유저가 많아지면 메모리에 올린 프로그램이 많아져 메인 메모리가 부족해지는 경우가 생긴다. 이러한 문제를 해결하기 위해 하드디스크의 일부를 메인 메모리처럼 사용하는 <code class=\"codetainer\">가상 메모리 기술</code>이 등장했다.\n\n위에서 언급된 cpu 스케줄링, 프로세스간 통신 등은 뒤에서 상세히 공부할 예정이다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"7597906a0b776c9b2fe7ef84398e8890c40f630f","text":"# 운영체제 서론 - 운영체제의 정의와 역할\n\n- Title : 운영체제 서론 - 운영체제의 정의와 역할\n- Date : 2019-12-23\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # 운영체제가 없는 컴퓨터의 전원을 키면 어떤 일이 일어날까??\n\n운영체제가 하는 일을 알면 운영체제가 없는 PC에서 어떤 일이 일어나는 지 알 수 있다. 결론부터 말하자면, 컴퓨터는 **한 마디로 야.생.마.** 가 되어 제어할 수 없게 된다. 아래에서 운영체제의 역할을 살펴보며 왜 야생마가 되는 지 알아보자.\n\n## 알아보기 전, 간단히 컴퓨터 구조를 살펴보자!\n\n컴퓨터에는 <code class=\"codetainer\">프로세스(처리기)</code>와 <code class=\"codetainer\">메인 메모리</code>가 있다. 우리는 어떤 프로그램을 실행하기 전에 메모리에 명령들(Instructions)을 기록하는 데 이 명령어의 집합을 <code class=\"codetainer\">프로그램</code>이라고 한다. 이렇게 프로그램을 미리 내장해놓고 실행하며 이런 구조의 컴퓨터를 프로그램 내장형 컴퓨터라고 한다. 정리하자면, 전원을 키면 프로세스는 메인 메모리에서 명령어를 가져와서 실행하고 또 그 다음 명령어를 가져와서 실행한다.\n\n## 운영체제가 없는 PC의 전원을 켰을 때, 메인 메모리의 상태는??\n\n멋대로의, 임의의 값이 들어있기에 프로세스가 하는 일이 의미가 없다. 마치 전혀 제어가 안되는 야생마와 같다.\n\n## 운영체제는 프로그램을 어떻게 실행시킬까??\n\n<span class=\"clr-note\">프로그램은 컴퓨터의 하드디스크 안에 실행 파일 형태로 모여있으며 이 파일이 메모리에 올라가야 실제로 실행될 수 있다.</span> 하드디스크의 실행 파일을 메모리에 올리는 것은 운영체제가 담당하기 때문에 운영체제가 없으면 실행 파일을 메모리에 올릴 수가 없다. 메인 메모리에 여러 개의 프로그램이 동시에 올라가있고 프로세스는 한 개 라면 동시에 어떻게 실행시킬까? 사실 이 것도 운영체제가 처리해준다.\n\n## 그 외에\n\n<span class=\"clr-note\">프린터에 인쇄 명령, 하드 디스크에 저장</span> 등 <span class=\"clr-grey\">(즉, 하드웨어 관리)</span>도 운영체제가 처리해준다. 따라서 운영체제가 없으면 위에 언급한 내용들을 처리할 수 없어서 컴퓨터를 제대로 사용할 수가 없다.\n\n## 정리하자면!\n\n운영체제는 컴퓨터의 하드웨어(프로세스, 메모리, 디스크, 키보드, 마우스, 모니터, 네트워크, 스피커, 마이크, GPS..) 등을 잘 관리하여 성능을 높이고 사용자에게 편의성을 제공하는 역할을 담당한다.\n\n# # 부팅(Booting)\n\n## 알아보기 전, 메모리에 대해 간단히 살펴보자!\n\n메인 메모리는 일반적으로 <code class=\"codetainer\">RAM</code>과 <code class=\"codetainer\">ROM</code>으로 나눠지는 데 ROM은 극히 일부분을 차지하고 대부분은 RAM이다. RAM은 휘발성 메모리라서 전원을 껐다 키면 내용이 사라지지만 ROM과 하드디스크는 전원 상관 없이 내용이 유지된다.\n\n## 극히 일부분인 ROM이 하는 일은 무엇일까??\n\n전원을 키면 프로세스는 제일 먼저 <code class=\"codetainer\">ROM</code>의 명령어를 읽어와서 실행한다. <span class=\"clr-grey\">ROM은 전원을 처음 켰을 때 한번만 필요.</span> ROM의 프로그램 중, <code class=\"codetainer\">POST(Power-On Self-Test: 컴퓨터가 환경 설정이 제대로 되어 있는지, 프린터 키보드 연결 여부 및 메인 메모리 크기 등을 테스트)</code>를 제일 먼저 실행하고 그 다음 <code class=\"codetainer\">부트로더(Boot loader)</code>를 실행한다.\n\n## ROM의 부트로더가 하는 일은??\n\n부트로더는 하드디스크에 있는 OS를 메인 메모리에 올리는 역할을 한다. OS가 메인 메모리에 올라가면 ROM은 필요가 없다.\n\n## 그 후의 이야기..\n\nOS가 메인 메모리에 올라오면 윈도우즈라면 윈도우즈 초기화면이 나타나고 리눅스는 로그인 프롬트가 나타난다. 즉 <span class=\"clr-note\">OS가 메인 메모리에 상주되어 모든 명령어를 받아드릴 준비가 된다.</span> OS는 다른 프로그램과 달리 전원을 끌 때까지 메모리에 상주한다.\n\n# # 커널(kernel) vs 명령 해석기(shell, command interpreter)\n\n운영체제는 여러가지 하드웨어 장치를 관리하는 프로그램으로 OS 중 핵심 부분을 <code class=\"codetainer\">커널(kernel)</code>이라고 한다. 반대로 <code class=\"codetainer\">명령 해석기(shell, command interpreter)</code>는 os의 껍질로 사용자로부터 명령을 받고 그 명령을 해석하여 결과를 보여주는 역할을 한다. 예를 들어, 리눅스에서 <code class=\"codetainer\">\\$who</code>라는 명령을 내려 사용자 목록을 보여주는 데, 이 것을 쉘이 담당한다.\n\n## 하드웨어 > 운영체제 > 애플리케이션\n\n하드웨어 위에 운영체제, 운영체제 위에서 애플리케이션이 실행된다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f7b2c7b228ce7a27b8514b7c18d789d9be5fc783","text":"# 운영체제 - 인터럽트 기반 운영체제\n\n- Title : 운영체제 - 인터럽트 기반 운영체제\n- Date : 2019-12-23\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # 인터럽트 기반 시스템(Interrupt-Based System)\n\n현대 운영체제는 인터럽트 기반 시스템이다.\n\n## 전원을 키면?\n\n메인메모리가 비워져 있는 상태에서 CPU가 ROM의 부트로더를 실행하면 하드디스크의 운영체제가 메인 메모리에 올라가게 된다. 운영체제가 메인 메모리에 올라간 것을 <code class=\"codetainer\">부팅</code>이라고 부른다.\n\n## 부팅 끝난 후 운영체제의 상태는?\n\n부팅이 끝나면 운영체제는 메모리에 상주하게 되고 이벤트(인터럽트)를 기다리는 대기 상태가 된다. 이 운영체제에는 여러 개의 코드가 있고 이 코드는 인터럽트(하드웨어, 소프트웨어, 내부)가 발생할 때 실행된다.\n\n## 하드웨어 인터럽트 - 키보드, 마우스..\n\n마우스로 예를 들어 보자. 우리가 마우스를 움직이면 마우스에서 전기 신호가 발생하여 그 신호가 CPU의 인터럽트 선으로 전달된다. <span class=\"clr-note\">CPU는 인터럽트 신호를 받으면 지금 하던 일을 중지하고 운영체제에 있는 인터럽트 서비스 루틴(ISR)을 실행시킨다.</span> <code class=\"codetainer\">인터럽트 서비스 루틴</code>은 해당 인터럽트가 오면 어떤 일을 수행할 지 코드해놓은 프로그램이다. 우리는 이 인터럽트와 인터럽트 서비스 루틴 덕분에 마우스를 움직이면 화면의 마우스 커서가 움직이게 할 수 있는 것이다. 다른 예시로 hwp 아이콘을 더블 클릭하는 경우를 생각해보자. 더블 클릭으로 인터럽트가 발생하면 CPU는 OS의 더블클릭 ISR을 실행한다. 더블 클릭 인터럽트 서비스 루틴은 하드디스크의 HWP 실행 파일을 메인 메모리에 올려서 CPU가 실행할 수 있도록 한다.\n\n## 소프트웨어 인터럽트\n\nhwp 프로그램 실행 중 memo.hwp 파일을 읽어오고 싶은 경우를 생각해보자. 하드디스크를 뒤져서 memo.hwp를 메모리에 올려야하는 데 이 작업은 hwp 프로그램이 직접 수행하지않는다. 인터럽트를 발생시켜 운영체제의 ISR을 실행하여 메모리에 올리는 것이다. ISR이 실행되어 memo.hwp를 다 읽으면 다시 hwp 프로그램으로 돌아온다. <span class=\"clr-note\">정리하자면, 사용자 프로그램에서 소프트웨어 인터럽트를 걸면 운영체제 안의 특정 코드(ISR)를 실행하고 이 코드 실행이 끝나면 다시 사용자 프로그램으로 돌아온다.</span>\n\n## 내부 인터럽트\n\n하나의 예시로 <span class=\"clr-note\">divide by zero</span>를 들 수 있다. <code class=\"codetainer\">int i=5, j=0; i=i/j;</code> 다음과 같이 0으로 나누는 연산을 하면 i에 값을 저장할 수 없게 된다. 이는 곧 그 다음 코드를 실행할 수 없다는 의미다. 컴퓨터는 이러한 경우, 프로그램을 강제 종료시키고 싶어진다. 그래서 CPU는 내부적으로 인터럽트를 발생한 것으로 인식하여 프로그램을 종료시키는 ISR을 실행시킨다.\n"}}}},"pageContext":{"id":"57230c4640ec299d7d03355c2e48f3f78fad5edf","previousPostId":"7597906a0b776c9b2fe7ef84398e8890c40f630f","nextPostId":"f7b2c7b228ce7a27b8514b7c18d789d9be5fc783"}},"staticQueryHashes":["2685952063","2841359383"]}