{"componentChunkName":"component---src-templates-blog-post-js","path":"/3de93d97b060a371fac7a45301b7aad6da6295fb","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"3de93d97b060a371fac7a45301b7aad6da6295fb","text":"# Destructuring assignment\n\n- Title : destructuring assignment\n- Date : 2020-06-06\n- Category : Javascript\n\n# 구조 분해 할당\n\n## 1. 배열 구조 분해 할당\n\n```jsx\nlet arr = ['garam', 'lee']\n\n// let firstName = arr[0]\n// let lastName = arr[1]\n// 위와 같은 작업을 구조 분해 할당으로 간단히 할 수 있다.\n\nlet [firstName, lastName] = arr;\n```\n\n`split` 메소드처럼 배열을 리턴하는 함수를 사용할 때 구조 분해 할당을 사용하면 좋다.\n\n```jsx\nlet [firstName, lastName] = 'garam lee'.split(' ');\n```\n\n### 1) 원본 배열에 영향을 주지 않는다.\n\n구조 분해 할당은 원본 배열을 복사해서 각 변수에 할당하여 원본 배열에 영향이 없다.\n\n```jsx\nlet arr = ['garam', 'lee'];\nlet [firstName, lastName] = arr;\nconsole.log(arr); // [\"garam\", \"lee\"]\n```\n\n### 2) `,`를 사용하여 배열의 요소를 생략할 수 있다.\n\n```jsx\nlet [firstName, , title] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\nconsole.log(firstName, title); // Julius Consul\n```\n\n### 3) 배열이 아닌 **iterable 가능한 객체**들도 구조 분해 할당을 할 수 있다.\n\n```jsx\nlet [a, b, c] = \"abc\"; // [\"a\", \"b\", \"c\"];\nlet [one, two, three] = new Set([1, 2, 3]); // [1, 2, 3]\n```\n\n### 4) 객체의 속성에도 할당을 할 수 있다.\n\n```jsx\nlet user = {};\n[user.firstName, user.lastName] = \"garam lee\".split(\" \");\nconsole.log(user); // {firstName: \"garam\", lastName: \"lee\"}\n```\n\n### 5) 객체의 key-value 로 루프를 돌릴 때 구조 분해 할당을 함께 사용할 수 있다.\n\n```jsx\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\nfor (let [key, value] of Object.entries(user)) {\n  console.log(`${key}:${value}`); // name:John, then age:30\n}\n\nlet user2 = new Map();\nuser2.set(\"name\", \"John\");\nuser2.set(\"age\", \"30\");\n\nfor (let [key, value] of user2) {\n  console.log(`${key}:${value}`); // name:John, then age:30\n}\n```\n\n### 6) 변수를 SWAP할 때 사용할 수 있다.\n\n두 변수에 대한 배열을 생성한 후에 구조 분해 할당을 하기 때문에 swap이 가능하다.\n\n```jsx\nlet guest = \"Jane\";\nlet admin = \"Pete\";\n\n[guest, admin] = [admin, guest];\nconsole.log(guest, admin); // Pete Jane\n```\n\n### 7)  `...` 를 사용하여 배열의 남은 요소를 할당할 수 있다.\n\n```jsx\nlet [name1, name2, ...rest] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\nconsole.log(name1, name2); // Julius Caesar\nconsole.log(rest, rest.length); // [\"Consul\", \"of the Roman Republic\"] 2\n```\n\n### 8) default value 할당하기\n\n할당될 값이 없을 때 default value로 설정한 값이 변수에 할당된다.\n\n```jsx\nlet [firstName, surname] = []; // undefined, undefined\nlet [firstName = \"Guest\", surname = \"Anonymous\"] = []; // Guest, Anonymous\n```\n\n## 2. 객체 구조 분해 할당\n\n```jsx\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\nlet {title, width, height} = options;\n```\n\n### 1) `{ 객체의 프로퍼티: 변수 이름 }` 과 같은 형식으로 변수 이름을 변경할 수 있다.\n\n```jsx\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\nlet {width: w, height: h, title} = options;\nconsole.log(w, h, title); // 100, 200, \"Menu\"\n```\n\n### 2) `=` 을 이용하여 default value 할당할 수 있다.\n\n```jsx\nlet options = {\n  title: \"Menu\"\n};\n\nlet {width = 100, height = 200, title} = options;\nconsole.log(width, height, title); // 100, 200, \"Menu\"\n\n// 이름 변경도 동시에 가능\nlet {width: w = 100, height: h = 200, title} = options;\n```\n\n### 3) rest 패턴을 사용할 수 있다.\n\n```jsx\nlet options = {\n  title: \"Menu\",\n  height: 200,\n  width: 100\n};\n\nlet {title, ...rest} = options;\n\nconsole.log(title, rest.height, rest.width); // \"Menu\" 200 100\n```\n\n## 3. 중첩 구조 분해\n\n```jsx\nlet options = {\n  size: {\n    width: 100,\n    height: 200\n  },\n  items: [\"Cake\", \"Donut\"],\n  extra: true\n};\n\nlet { size: { width, height}, items: [item1, item2], title = \"Menu\" } = options\n/*\n size, items: is not defined\n width: 100\n height: 200\n item1: Cake\n item2: Donut\n title: Menu\n*/\n\n```\n\n## 4. 함수의 파라미타에 구조 분해 할당을 사용하자\n\n아래 함수의 경우는 파라미타의 순서를 기억 해야 한다는 단점이 있다. 더 많은 파라미타를 다뤄야 한다면..?\n\n```jsx\nfunction showMenu(title = \"Untitled\", width = 200, height = 100, items = []) {\n  // ...\n}\nshowMenu(\"My Menu\", undefined, undefined, [\"Item1\", \"Item2\"])\n```\n\n이 때 구조 분해 할당을 사용하면 좋다.\n\n```jsx\nlet options = {\n  title: \"My menu\",\n  items: [\"Item1\", \"Item2\"]\n};\n\nfunction showMenu({title = \"Untitled\", width = 200, height = 100, items = []}) {\n  alert( `${title} ${width} ${height}` ); // My Menu 200 100\n  alert( items ); // Item1, Item2\n}\n\nshowMenu(options);\n```\n\n만약 파라미타로 아무 값도 넘기고 싶지 않다면 아래와 같이 코드를 작성하면 된다.\n\n```jsx\nshowMenu({}); // 빈 객체를 보내면 된다. 하지만, 정말 아무 것도 보내고 싶지않다면?\nshowMenu(); // Error 발생\n```\n\n전체 argument 객체의 디폴트 객체로 {} 를 할당하면 에러를 잡을 수 있다.\n\n```jsx\nfunction showMenu({title = \"Untitled\", width = 200, height = 100, items = []} = {}) {\n  alert( `${title} ${width} ${height}` ); // My Menu 200 100\n  alert( items ); // Item1, Item2\n}\n\nshowMenu(); // 이제 에러가 발생하지 않는다.\n```\n\n참고\n[Destructuring assignment](https://javascript.info/destructuring-assignment)\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"b61a327c14326b17c25c930f6dee46d5be66b268","text":"# Rest 파라미터와 Spread 연산자\n\n- Title : Rest 파라미터와 Spread 연산자\n- Date : 2020-06-07\n- Category : Javascript\n\n# Rest 파라미터 `...`\n\n함수의 `arguments` 객체로 인해 유발되는 보일러 플레이트 코드를 줄일 목적으로 `Rest 파라미터` 가 도입되었다. `Rest 파라미터`는 함수의 마지막 파라미터 앞에 `...` 를 붙여 사용한다. 단 마지막에 한번만 사용해야 한다.\n\n아래 예제를 보면 arguments 객체 대신 rest 파라미터를 사용해야 하는 이유를 알 수 있다.\n\n```jsx\n// Rest 파라미터 이전에, \"arguments\" 는 다음을 사용해 일반적인 배열로 변환될 수 있음\nfunction f(a, b) {\n\n  var normalArray = Array.prototype.slice.call(arguments);\n  // -- 또는 --\n  var normalArray = [].slice.call(arguments);\n  // -- 또는 --\n  var normalArray = Array.from(arguments);\n\n  var first = normalArray.shift(); // OK, 첫 번째 인수를 반환\n  var first = arguments.shift(); // ERROR (arguments 가 일반적인 배열이 아님)\n\n}\n\n// 이제 rest 파라미터를 사용해 쉽게 일반적인 배열에 접근할 수 있음\n\nfunction f(...args) {\n  var normalArray = args;\n  var first = normalArray.shift(); // OK, 첫 번째 인수를 반환\n}\n```\n\n## 1. `Rest` 파라미터와 `arguments` 객체의 차이를 자세히 알아보자.\n\n- arguments 객체는 함수로 전달된 모든 인수를 포함한다. 즉 Rest 파라미터처럼 부분적으로 얻을 수 없다.\n- arguments 객체는 배열 형태의 객체라 Array에 있는 sort, map, forEach, pop 과 같은 메서드를 사용할 수 없다. 반면에 Rest는 표준 배열이라 해당 메서드를 사용할 수 있다.\n\n> 배열 형태의 객체는 length 속성과 더불어 0부터 인덱스 된 다른 속성을 가지고 있지만, Array의 forEach, map과 같은 내장 메서드를 가지고 있지 않다.\n\n> 화살표 함수는 arguments 객체가 없다. 만약 화살표 함수에서 arguments 객체에 접근한다면 스코프 체인을 따라 일반 함수의 arguments 값을 가져오게 된다. 뿐만 아니라 화살표 함수는 자체 this가 없다.\n\n## 2. 인자의 개수가 유동적일 때 Rest Parameter가 유용하다.\n\n아래 예제는 인자로 전달되는 숫자들의 합을 구하는 함수다. 만약 Rest Parameter를 쓰지 않았다면?..\n\n```jsx\nfunction sum(...theArgs) {\n  return theArgs.reduce((previous, current) => {\n    return previous + current;\n  });\n}\n\nconsole.log(sum(1, 2, 3));\n// expected output: 6\n\nconsole.log(sum(1, 2, 3, 4));\n// expected output: 10\n```\n\n## 3. Rest 파라미터는 배열로만 해체할 수 있다.\n\n```jsx\nfunction f(...[a, b, c]) {\n  return a + b + c;\n}\n\nf(1)          // NaN (b 와 c 는 undefined)\nf(1, 2, 3)    // 6\nf(1, 2, 3, 4) // 6 (4번 째 파라미터는 해체되지 않음)\n```\n\n## 4. 객체 구조 분해에서 Rest\n\n객체 구조 분해에서 rest 속성은 구조 분해 패턴으로 걸러 지지 않은 열거형 속성의 키를 가진 나머지 항목을 모은다.\n\n```jsx\nconst obj = { foo:1, bar: 2, baz: 3 };\nconst { foo, ...rest } = obj;\n```\n\nrest operator는 최대 한번만 사용 가능하며 객체 리터럴의 마지막에 나타나야 한다.\n\n```jsx\nconst {...rest, foo} = obj; // SyntaxError\nconst {foo, ...rest1, ...rest2} = obj; // SyntaxError\n```\n\n단, 중첩 구조 분해 할당을 할 경우에는 rest 연산자가 여러 번 나올 수 있다.\n\n```jsx\nconst obj = {\n    foo: {\n        a: 1,\n        b: 2,\n        c: 3,\n    },\n    bar: 4,\n    baz: 5,\n};\nconst {foo: {a, ...rest1}, ...rest2} = obj;\n\n// Same as:\n// const a = 1;\n// const rest1 = {b: 2, c: 3};\n// const rest2 = {bar: 4, baz: 5};\n```\n\n# Spread Syntax\n\n위에서는 파라미터 리스트에서 배열을 얻었다. 그럼 반대로 배열을 분해하여 리스트를 얻을 수도 있을까? spread 연산자를 사용하면 가능하다.\n\n## 1. 스프레드 연산자로 두 배열을 합쳐보기\n\n```jsx\nlet arr = [3, 5, 1];\nlet arr2 = [8, 9, 15];\n\nlet merged = [0, ...arr, 2, ...arr2]; // [0, 3, 5, 1, 2, 8, 9, 15];\n```\n\n## 2. 객체 리터럴에서 스프레드 연산자 사용하기\n\n객체 리터럴에서 스프레드 연산자는 객체의 모든 열거 가능한 속성들을 객체 리터럴에 넣는다.\n\n```jsx\nconst obj = {foo: 1, bar: 2, baz: 3};\nconst newObj = {...obj, qux: 4}; // {foo: 1, bar: 2, baz: 3, qux: 4}\n```\n\n키가 충돌되면 어떻게 될까? 나중에 나온 value 값이 키 값이 된다.\n\n```jsx\nconst obj = {foo: 1, bar: 2, baz: 3};\nconst newObj = { ...obj, foo: true }; //{foo: true, bar: 2, baz: 3}\nconst newObj2 = { foo: true, ...obj }; // {foo: 1, bar: 2, baz: 3}\n```\n\n## 3. `Math.max`의 인자로 배열의 값들을 전달하고 싶을 때\n\n```jsx\nlet arr = [3, 5, 1];\nconsole.log(Math.max(arr)); // NaN\nconsole.log(Math.max(arr[0], arr[1], arr[2]); // 5\n```\n\n배열의 요소가 많아질 때마다 arr[3], arr[4] ... 호출하는 건 좋은 코드가 아닐 거다. 이럴 때 스프레드 연산자를 사용한다. 스프레드 연산자는 배열을 분해하여 인자로 보낸다.\n\n```jsx\nlet arr = [3, 5, 1];\nconsole.log(Math.max(...arr)); // 5\n```\n\n## 4. iterable 객체는 구조 분해 될 수 있다.\n\n대표적으로 String 객체를 구조 분해한 예제를 살펴보자. \n\n```jsx\nlet str = \"Hello\";\nconsole.log([...str]); // [H, e, l, l, o]\nconsole.log(Array.from(str)) // [H, e, l, l, o]\n```\n\n1. 이 코드는 스프레드 연산자를 이용하여 str(String 객체 === iterable 객체)를 구조 분해한 후 배열을 초기화 하는 작업을 한다. 스프레드 연산자는 내부적으로 `iterator`을 사용하기 때문에 `for...of` 와 동작이 같다.\n2. 위 결과를 보면 `Array.from(str)`의 결과와 `[...str]`의 결과가 같다는 것을 알 수 있다. 하지만 작은 차이점이 있다. 스프레드 연산자는 오직 `iterable` 객체에만 적용될 수 있는 반면 `Array.from`은 `iterable` 객체 뿐만 아니라 배열 형태의 객체 에도 적용할 수 있다. 이러한 특성 때문에 `Array.from`을 더 선호하는 경향이 있다.\n\n# 정리\n\n`...` 는 Rest 파라미터 또는 Spread 구문 일 수 있다.\n\nRest Parameter\n\n- 함수의 마지막 인자에 `...`를 사용한다.\n- 함수의 인자들을 하나의 배열로 모은다.\n- 인자의 개수가 유동적인 함수를 만들 때 주로 사용한다.\n\nSpread syntax\n\n- `...` 를 함수를 호출할 때나 그 밖에 사용할 경우\n- 배열을 리스트로 분해하는 용도로 사용된다.\n- 일반적으로 많은 인자들을 요구하는 함수에 배열을 보낼 때 사용한다.\n\n참고\n\n[Rest parameters and spread syntax](https://javascript.info/rest-parameters-spread)\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"0dfe7484013b534a57d77a03dafae8490bb0d27b","text":"# 자바스크립트 async, await, promise\n\n- Title : 자바스크립트 async, await, promise\n- Date : 2020-05-20\n- Category : Javascript\n\n# Rules for Promise\n\n1. 비 동기나 블로킹 코드 작업을 하고 싶을 때 `Promise`를 사용하자.\n2. `resolve`는 `then`과  `reject`는  `catch` 와 맵핑된다.\n3. `.catch` `.then` 메소드를 사용하자.\n4. 꼭 실행 해야 할 코드가 있다면 `.finally` 를 사용하자.\n5. 여러 개의 `Promise`가 모두 완료 되었을 때 작업을 진행하고 싶다면 `Promise.all(iterable)`를 사용하자. `Promise.all`은 배열 내 모든 프로미스의 이행(또는  첫 번째 거부)를 기다린다.\n\n    ```jsx\n    const p1 = Promise.resolve(3);\n    const p2 = 1337;\n    const p3 = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        resolve(\"foo\");\n      }, 100);\n    }); \n\n    // p2는 프로미스가 아니지만 이행 결과 배열에는 포함된다.\n    Promise.all([p1, p2, p3]).then(values => { \n      console.log(values); // [3, 1337, \"foo\"] \n    });\n\n    // 매개변수 배열이 빈 것과 동일하게 취급하므로 이행함\n    const p4 = Promise.all([1,2,3]); // Promise {<resolved>: Array(3)} [1, 2, 3]\n\n    // 프로미스 거부됨\n    const p5 = Promise.all([1,2,3, Promise.reject(555)]); // Uncaught (in promise) 555\n    ```\n\n# Rules for async-await\n\n1. `async function` 은 `Promise`를 리턴한다.\n2. 코드에서 직접 `Promise`를 직접 리턴하지않았어도 async 함수는 Promise를 리턴한다는 것을 기억하자.\n3. `await` 블록은 `async` 함수 안에 위치한다.\n4. `async` 함수에는 두 개 이상의 `await` 구문을 사용할 수 있다.\n5. `async await`를 사용할 때, `try~catch`로 에러 핸들링을 하자.\n6. `iterator`과 `loop`에서 `await`를 사용하며 코드가 순차적으로 실행될 것 같지만 사실은 동시에 실행된다.\n7. `await`는 하나의 `Promise`를 위해서만 사용하자.\n8. `await` 블록은 항상 `async` 함수 내에 있다. `promise`가 `resolve`되면 다음 코드가 실행된다는 것을 기억하자. \n\n# Promise vs async-await\n\n1. `async` 함수는 `promise`를 반환하고 반대도 성립된다. 즉, `promise`를 반환하는 모든 함수는 `async` 함수로 사용할 수 있다.\n2. function2의 아웃풋이 function1의 아웃풋에 따라 달라진다면 `await`를 사용하자.\n3. 두 개의 함수가 순차적으로 실행될 필요가 없다면 `await`를 쓸 필요가 없다.\n4. Promise를 동시에 실행시키고 싶다면 `Promise.all`을 사용하자\n5. `await`는 `blocking code`를 만든다는 사실을 잊지 말자.\n6. 많은 await 구문이 있는 async 함수를 사용하는 것보다는 여러 개의 async 함수로 쪼개서 사용하자.\n    - 너무 많은 `blocking code`는 좋지 않다.\n    - 비동기 코드가 수평적으로 실행된다는 것을 강조할 수 있다.\n\n[JavaScript: Promises or async-await](https://medium.com/better-programming/should-i-use-promises-or-async-await-126ab5c98789)\n\n# Symbol\n\n```jsx\n// 위 코드는 매 번 새로운 심볼을 생성한다.\nconst sym1 = Symbol();\nconst sym2 = Symbol(\"foo\");\nconst sym3 = Symbol(\"foo\");\n```\n\n1. 이름 충돌의 위험 없이 **속성의 키**로 쓰기 위해 생성하고 사용할 수 있는 값이다.\n2. Boolean, String, Number 같이 원시 데이터 형의 일종이다.\n3. `Symbol()` 로 부터 반환되는 모든 심볼 값은 고유하다.\n4. 객체 속성에 대한 `식별자`로 사용할 수 있다.\n5. `Object.getOwnPropertySymbols()` 메서드를 이용하여 객체의 심볼 속성을 찾을 수 있다. 모든 객체는 심볼 속성이 없는 상태로 초기화 되기 때문에 해당 객체에 심볼 속성을 설정하기 전까지는 빈 배열을 반환한다는 점에 유의하자.\n"}}}},"pageContext":{"id":"3de93d97b060a371fac7a45301b7aad6da6295fb","previousPostId":"b61a327c14326b17c25c930f6dee46d5be66b268","nextPostId":"0dfe7484013b534a57d77a03dafae8490bb0d27b"}},"staticQueryHashes":["2841359383"]}