{"componentChunkName":"component---src-templates-blog-post-js","path":"/f7b2c7b228ce7a27b8514b7c18d789d9be5fc783","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f7b2c7b228ce7a27b8514b7c18d789d9be5fc783","text":"# 운영체제 - 인터럽트 기반 운영체제\n\n- Title : 운영체제 - 인터럽트 기반 운영체제\n- Date : 2019-12-23\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # 인터럽트 기반 시스템(Interrupt-Based System)\n\n현대 운영체제는 인터럽트 기반 시스템이다.\n\n## 전원을 키면?\n\n메인메모리가 비워져 있는 상태에서 CPU가 ROM의 부트로더를 실행하면 하드디스크의 운영체제가 메인 메모리에 올라가게 된다. 운영체제가 메인 메모리에 올라간 것을 <code class=\"codetainer\">부팅</code>이라고 부른다.\n\n## 부팅 끝난 후 운영체제의 상태는?\n\n부팅이 끝나면 운영체제는 메모리에 상주하게 되고 이벤트(인터럽트)를 기다리는 대기 상태가 된다. 이 운영체제에는 여러 개의 코드가 있고 이 코드는 인터럽트(하드웨어, 소프트웨어, 내부)가 발생할 때 실행된다.\n\n## 하드웨어 인터럽트 - 키보드, 마우스..\n\n마우스로 예를 들어 보자. 우리가 마우스를 움직이면 마우스에서 전기 신호가 발생하여 그 신호가 CPU의 인터럽트 선으로 전달된다. <span class=\"clr-note\">CPU는 인터럽트 신호를 받으면 지금 하던 일을 중지하고 운영체제에 있는 인터럽트 서비스 루틴(ISR)을 실행시킨다.</span> <code class=\"codetainer\">인터럽트 서비스 루틴</code>은 해당 인터럽트가 오면 어떤 일을 수행할 지 코드해놓은 프로그램이다. 우리는 이 인터럽트와 인터럽트 서비스 루틴 덕분에 마우스를 움직이면 화면의 마우스 커서가 움직이게 할 수 있는 것이다. 다른 예시로 hwp 아이콘을 더블 클릭하는 경우를 생각해보자. 더블 클릭으로 인터럽트가 발생하면 CPU는 OS의 더블클릭 ISR을 실행한다. 더블 클릭 인터럽트 서비스 루틴은 하드디스크의 HWP 실행 파일을 메인 메모리에 올려서 CPU가 실행할 수 있도록 한다.\n\n## 소프트웨어 인터럽트\n\nhwp 프로그램 실행 중 memo.hwp 파일을 읽어오고 싶은 경우를 생각해보자. 하드디스크를 뒤져서 memo.hwp를 메모리에 올려야하는 데 이 작업은 hwp 프로그램이 직접 수행하지않는다. 인터럽트를 발생시켜 운영체제의 ISR을 실행하여 메모리에 올리는 것이다. ISR이 실행되어 memo.hwp를 다 읽으면 다시 hwp 프로그램으로 돌아온다. <span class=\"clr-note\">정리하자면, 사용자 프로그램에서 소프트웨어 인터럽트를 걸면 운영체제 안의 특정 코드(ISR)를 실행하고 이 코드 실행이 끝나면 다시 사용자 프로그램으로 돌아온다.</span>\n\n## 내부 인터럽트\n\n하나의 예시로 <span class=\"clr-note\">divide by zero</span>를 들 수 있다. <code class=\"codetainer\">int i=5, j=0; i=i/j;</code> 다음과 같이 0으로 나누는 연산을 하면 i에 값을 저장할 수 없게 된다. 이는 곧 그 다음 코드를 실행할 수 없다는 의미다. 컴퓨터는 이러한 경우, 프로그램을 강제 종료시키고 싶어진다. 그래서 CPU는 내부적으로 인터럽트를 발생한 것으로 인식하여 프로그램을 종료시키는 ISR을 실행시킨다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"57230c4640ec299d7d03355c2e48f3f78fad5edf","text":"# 운영체제의 역사 - 일괄처리부터 시분할시스템까지 운영체제 변천의 역사\n\n- Title : 운영체제의 역사 - 일괄처리부터 시분할시스템까지 운영체제 변천의 역사\n- Date : 2019-12-23\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # Batch processing system(일괄처리)\n\n최초의 운영체제로 과거 오퍼레이터가 했던 일련의 작업들을 <span class=\"clr-note\">메모리에 상주시켜 일괄처리</span>한다. 메모리에 상주시킨 작은 프로그램을 <code class=\"codetainer\">레지던트 모니터(resident monitor)</code>라고 한다.\n\n# # Multiprogramming system(다중프로그래밍)\n\n## 멀티프로그래밍 시스템 등장 배경은??\n\n배치 프로세싱 시스템은 메모리에 운영체제와 **하나의** 사용자 프로그램(컴파일러, 게임 등..)만 올릴 수 있다. 하나만 올린다는 건 비싼 컴퓨터를 낭비하는 일이다. 예를 들어 +, \\*와 같은 연산 작업(CPU)과 화면에 입/출력하는 작업(I/O)을 하는 간단한 C 프로그램을 생각해보자. 프로그램을 실행하면 연산 작업에서는 빠른 CPU를 사용하고 입/출력 작업에서 느린 I/O를 사용한다. 즉, I/O 작업 중에는 CPU가 놀게 되는 것이다. 비싼 CPU를 쉬게 만든다니 너무나 아까운 일이다. 그래서 메모리에 여러 프로그램을 올리는 다중 프로그래밍 시스템이 등장하게 된 것이다.\n\n## 동작 방식은??\n\n이제 메모리에 여러 개의 사용자 프로그램이 올라갈 수 있게 된다. user1, user2, user3 프로그램이 메모리에 올라가있고 user1을 실행 중이라고 가정해보자. user1이 연산작업을 위해 CPU를 사용하다가 I/O를 사용하게 되면 바로 user2 프로그램을 실행한다. user2에서도 CPU를 사용하다가 I/O를 사용하게 되면 user3를 실행한다. 이렇게 프로그램이 I/O 작업을 하는 동안 또 다른 프로그램을 실행시켜 CPU를 사용하게 만들어 CPU 낭비를 줄인다.\n\n## 다중 프로그래밍에서 생각해야할 점이 있는데??\n\n바로 <span class=\"clr-note\">CPU scheduling, 메모리 관리, 보호</span>이다. 성능을 위해 각 사용자 프로그램을 최적의 순서로 실행해야하는 데 이를 <code class=\"codetainer\">CPU 스케줄링</code>이라고 한다. 이는 나중에 배운다. 또한, 각 사용자 프로그램을 메모리에 어떻게 배치하고 관리<code class=\"codetainer\">(메모리 관리)</code>할지도 고민해야하며 다른 프로그램 영역을 침범하는 경우를 막아야 한다.<code class=\"codetainer\">(보호)</code>\n\n# # Time-sharing system(시공유 시스템)\n\n## 시공유 시스템 등장 배경은??\n\n모니터와 키보드가 나오면서 대화형(Interactive system) 컴퓨터가 등장했고 컴퓨터 하나에 여러 개의 단말기(terminal)를 연결하여 여러 사람이 동시에 컴퓨터를 사용할 수 있게 되었다. 그런데 다중 프로그래밍 운영체제로는 동시에 컴퓨터를 사용할 수가 없다. user1 프로그램이 실행되는 동안 user2 프로그램을 실행할 수 없다는 것을 생각해보면 이해가 될 것이다. 시공유 시스템이 등장하게 된 배경이 바로 여기에 있다.\n\n## 동작 방식은??\n\n간단하게 1/100(초)마다 user1, user2, user3 프로그램을 스위칭한다고 생각하면 된다. 1/100(초) 동안 user1을 실행하고 그 다음 1/100(초) 동안 user2를 실행한다. 다중 프로그래밍이 I/O에 스위칭하는 것과 달리 시공유 시스템은 특정 시간마다 강제 전환한다. 더 나아가 1초를 기준으로 생각해보자. 1초동안 스위칭이 100번 일어나고 세 개의 프로그램이 메모리에 올라가있으므로 각 프로그램은 1초동안 33번 CPU에 할당된다. 워낙 빠르게 스위칭되어 여러 사용자가 하나의 컴퓨터를 사용하고 있음에도 혼자서 컴퓨터를 사용하는 것처럼 느껴진다.\n\n## 생각해봐야할 점은??\n\n바로 <span class=\"clr-note\">프로세스간 통신, 동기화, 가상 메모리</span>다. 하나의 컴퓨터를 여러명이 사용하다보면 서로 간에 데이터를 주고 받고 싶어진다. <code class=\"codetainer\">프로세스간 통신</code>의 등장 이유다. 또, user1, user2, user3가 거의 동시에 실행되므로 누가 앞서서 실행되는 지를 정해야하는 데 이를 <code class=\"codetainer\">동기화</code>라고 한다. 마지막으로 유저가 많아지면 메모리에 올린 프로그램이 많아져 메인 메모리가 부족해지는 경우가 생긴다. 이러한 문제를 해결하기 위해 하드디스크의 일부를 메인 메모리처럼 사용하는 <code class=\"codetainer\">가상 메모리 기술</code>이 등장했다.\n\n위에서 언급된 cpu 스케줄링, 프로세스간 통신 등은 뒤에서 상세히 공부할 예정이다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"45928151f5549a4a93a02b2feceeba608babf1aa","text":"# ES6를 모르면 React 배우기가 어려워요.\n\n- Title : ES6를 모르면 React 배우기가 어려워요.\n- Date : 2019-12-17\n- Category: Javascript\n\nReact를 배워볼까? 하고 두근거리는 마음으로 React 공식 문서에 방문해서 자습서부터 차근차근 읽어본 적이 있습니다.  \n그런데, 으잉? 이건 대체 뭐지? 제게 커다란 장벽이 나타났습니다. 그 것은 바로 바로... **ES6 문법!!!**  \n그래서 준비했습니다. <span class=\"clr-note\">\"ES6를 모르면 React 배우기가 어려워요!\"</span> 지금부터 저와 함께 ES6 최신 문법을 정리해봅시다!\n\n# 변수 선언하기\n\n## 1. const\n\n블록(중괄호 {}) 유효 범위의 상수를 선언하며 재할당 및 재선언이 불가능합니다.\n\n```javascript\nconst number = 42;\n\ntry {\n  number = 99;\n} catch (err) {\n  console.log(err); // TypeError: Assignment to constant variable.\n}\n\nconsole.log(number); // 42\n```\n\n## 2. let\n\n<code class=\"codetainer\">let</code> 키워드를 사용하면 변수의 유효 범위를 블록 {} 안으로 한정시킬 수 있고 글로벌 변수의 값을 보호할 수 있습니다.\n\n```javascript\nvar topic = \"js\";\nif (topic) {\n  var topic = \"리액트\";\n  console.log(\"블록\", topic); // 블록 리액트\n}\nconsole.log(\"글로벌\", topic); // 글로벌 리액트\n```\n\n위 예제의 if 블록 안의 topic 변수와 if 블록 밖의 topic 변수는 같은 변수입니다.  \n<code class=\"codetainer\">var</code> 키워드는 함수 유효 범위를 가지기 때문입니다. 자바스크립트의 호이스팅에 의해 함수 안에 정의된 변수는 함수의 맨 앞에서 정의되고 <code class=\"codetainer\">undefined</code>로 초기화되기 때문에 두 topic 변수가 사실상 같은 변수가 됩니다.\n<br/><br/>\n\n```javascript\nvar topic = \"js\";\nif (topic) {\n  let topic = \"리액트\";\n  console.log(\"블록\", topic); // 블록 리액트\n}\nconsole.log(\"글로벌\", topic); // 글로벌 js\n```\n\nif 블록 안의 변수가 if 블록 밖의 변수에 영향을 끼치지 않게 하려면 <code class=\"codetainer\">let</code> 키워드를 사용하면 됩니다. <code class=\"codetainer\">let</code>은 블록 유효 범위이므로 호이스팅 시 블록의 맨 앞에서 정의되고 초기화 됩니다.\n<br/><br/>\n\n```javascript\nconsole.log(name); // Uncaught ReferenceError: Cannot access 'name' before initialization\nlet name = \"lee\";\n\nconsole.log(age); // undefined\nvar age = \"20\";\n```\n\n단, var로 선언된 변수는 선언과 초기화가 동시에 진행되고 let을 선언된 변수는 호이스팅되어 선언 단계가 이뤄지나 초기화 단계는 실제 let이 사용된 코드에 도착할 때 이루어집니다. 그래서 let 키워드로 선언한 변수를 초기화 단계 이전에 접근하면 reference 에러가 발생합니다.\n\n## 3. 템플릿 문자열\n\n템플릿 문자열 덕분에 더하기 기호 + 없이 편하게 문자열과 변수를 이어 붙인 string을 생성할 수 있습니다.  \n<code class=\"codetainer\">\\${}</code> 안에는 자바스크립트 변수, 식 어떤 것이든 가능하며 템플릿 문자열은 공백, 탭, 개행 문자를 사용할 수 있습니다.\n\n```javascript\nconsole.log(`${lastName}, ${firstName} ${middleName}`);\n```\n\n<span class=\"clr-grey\"></span>\n<span class=\"clr-note\"></span>\n\n## 4. 디폴트 파라미터\n\n이제 함수를 호출 시 인자 값이 넘어오지 않았다면 디폴트 값을 사용할 수 있습니다.\n\n```javascript\nfunction func(name = \"lee\", age = \"20\") {\n  console.log(`${name} : ${age}`);\n}\nfunc(); // lee : 20\n```\n\n함수 호출 시 인자 넘기지 않아도 디폴트 값을 사용해 함수가 정상적으로 실행됩니다. 문자열뿐 아니라 객체 등 다양한 타입의 값을 디폴트로 사용할 수 있습니다.\n\n# 화살표 함수 =>\n\n화살표 함수를 사용하면 function 키워드 없이도 함수를 만들 수 있고 return을 사용하지 않아도 식을 계산한 값이 자동으로 반환됩니다.\n\n```javascript\nvar materials = [\"Hydrogen\", \"Helium\", \"Lithium\", \"Beryllium\"];\nmaterials.map(({ length }) => length); // [8, 6, 7, 9]\n```\n\n<br/>\n또한, <span class=\"clr-note\">화살표 함수는 this를 새로 바인딩 하지 않습니다.</span> 대신 코드에서 바로 바깥의 함수(혹은 class)의 this 값을 사용합니다. 뿐만 아니라 <code class=\"codetainer\">arguments, super, new.target</code>을 바인딩 하지 않습니다.\n\n```javascript\nvar obj = {\n  i: 10,\n  b: () => console.log(this.i, this),\n  c: function() {\n    console.log(this.i, this);\n  }\n};\nobj.b(); // prints undefined, Window\nobj.c(); // prints 10, Object {...}\n```\n\n<br/>\nthis를 바인딩 하지 않기 때문에 메소드 함수에는 사용하지 않아야 하며 생성자로서도 사용할 수 없기 때문에 <code class=\"codetainer\">new</code>와 함께 사용하면 오류가 발생합니다.\n\n```javascript\nvar Foo = () => {};\nvar foo = new Foo(); // TypeError: Foo is not a constructor\n```\n\n# ES6 객체와 배열\n\n## 1. 구조 분해(Destructuring)\n\n구조 분해를 사용하면 객체의 필드를 원하는 변수에 대입할 수 있습니다.\n\n다음은 sandwich를 분해해서 bread와 meat 필드를 같은 이름의 변수에 넣어주는 코드입니다. 두 변수의 값은 sandwich에 있는 같은 이름의 필드 값으로 초기화되지만, 두 변수를 변경해도 원래의 필드 값은 바뀌지는 않습니다.\n\n```javascript\nvar sandwich = {\n  bread: \"크런치\",\n  meat: \"참치\",\n  cheese: \"스위스\",\n  toppings: [\"상추\", \"토마토\", \"머스타드\"]\n};\n\nvar { bread, meat } = sandwich;\n\nconsole.log(bread, meat); // 크런치 참치\n```\n\n객체를 분해해서 함수의 인자로 넘길 수 있습니다.\n\n```javascript\nvar func = ({ firstName }) => {\n  console.log(`이름은 ${firstName}`);\n};\n\nfunc({\n  firstName: \"garam\",\n  lastName: \"lee\"\n}); // 이름은 lee\n```\n\n배열의 경우도 비슷합니다.\n\n```javascript\nvar x = [1, 2, 3, 4, 5];\nvar [y, z] = x;\nconsole.log(y, z); // 1 2\n```\n\n변수 선언이 분리되어도 값 할딩이 가능합니다.\n\n```javascript\nvar a, b;\n[a, b] = [1, 2];\nconsole.log(a, b); // 1 2\n```\n\n기본값을 할당하여 분해한 값이 undefined면 기본 값을 사용합니다.\n\n```javascript\nvar a, b;\n[a = 5, b = 7] = [1];\nconsole.log(a); // 1\nconsole.log(b); // 7\n```\n\n두 변수 값 교환이 가능합니다.\n\n```javascript\nvar a = 1;\nvar b = 3;\n\n[a, b] = [b, a];\nconsole.log(a); // 3\nconsole.log(b); // 1\n```\n\n불필요한 값을 콤마를 사용해 생략하는 리스트 매칭을 사용할 수 있습니다. 무시하고 싶은 원소 위치에 콤마를 넣으면 리스트 매칭이 됩니다.\n\n```javascript\nvar [, , third] = [\"a\", \"b\", \"c\"];\nconsole.log(third); // c\n```\n\n## 2. 객체 리터럴 개선\n\n구조 분해의 반대라고 할 수 있으며 객체 리터럴 개선을 사용하면 현재 영역에 있는 변수를 객체의 필드로 묶을 수 있습니다.\n\n```javascript\nvar name = \"lee\";\nvar age = \"20\";\nvar print = function() {\n  console.log(`${this.name} : ${this.age}`);\n};\nvar person = { name, age, print };\nperson.print(); // lee : 20\n```\n\n객체 리터럴 개선으로 변수를 객체의 필드로 대입할 수 있으며 function 키워드를 입력하지 않고 메서드를 정의할 수 있다.\n\n```javascript\n// 예전 방식\nvar obj = {\n  name: name,\n  age: age,\n  print: function() {\n    console.log(`${name} : ${age}`);\n  }\n};\n\n// 개선된 방식\nconst obj = {\n  name,\n  age,\n  print() {\n    console.log(`${name} : ${age}`);\n  }\n};\n```\n\n## 3. 스프레드 연산자\n\n스프레드 연산자는 세 개의 점(...)으로 이루어진 연산자로,\n<code class=\"codetainer\">함수호출, 배열 리터럴과 문자열, 객체 리터럴</code>에서 사용할 수 있습니다.\n\n이전에는 두 배열의 모든 원소가 들어간 새로운 배열을 만들기 위해서 <code class=\"codetainer\">push(), splice(), concat() </code> 등을 사용해야 했습니다. 이제 스프레드 연산자를 통해 쉽게 만들 수 있습니다.\n\n```javascript\n// 이전 방식\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\narr1 = arr1.concat(arr2);\n\n// 전개 방식\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\narr1 = [...arr1, ...arr2]; // arr1은 [0,1,2,3,4,5]\n\n// 새로운 배열 생성\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\nvar arr3 = [...arr1, ...arr2]; // [0,1,2,3,4,5]\n\n// 중간 조합도 가능\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, ...arr1, 4, 5]; // 3,0,1,2,4,5\n\n// 나머지 원소 얻기 가능\nvar arr1 = [0, 1, 2, 3];\nvar [first, ...rest] = arr1;\nconsole.log(rest); // 1,2,3\n```\n\n스프레드 연산자는 원본 배열을 변경하지 않고 복사본을 만듭니다.  \n다음 예제를 통해 실제로 확인해보자. arr1 배열의 마지막 원소를 변수에 담으려고 <code class=\"codetainer\">Array.reverse</code>를 이용해 배열을 뒤집고 첫번째 원소를 변수에 넣는 예제입니다.\n\n```javascript\n// 원본 배열이 변경된다.\nvar arr1 = [0, 1, 2];\nvar [last] = arr1.reverse();\nconsole.log(last); // 2\nconsole.log(arr1); // 2 1 0\n\n// 전개 연산을 통해 원본 배열 유지하기\nvar arr1 = [0, 1, 2];\nvar [last] = [...arr1].reverse();\nconsole.log(last); // 2\nconsole.log(arr1); // 0,1,2\n```\n\n객체에 사용할 수도 있습니다. 사용법은 배열과 유사합니다.\n\n```javascript\nvar obj1 = { foo: \"bar\", x: 42 };\nvar obj2 = { foo: \"baz\", y: 13 };\nvar obj3 = \"obj\";\nvar mergedObj = { ...obj1, ...obj2, obj3 };\nconsole.log(mergedObj); // { foo: \"baz\", x: 42, y: 13, obj3: \"obj\" }\n```\n\n함수 호출할 때도 사용할 수 있어서 배열의 엘리먼트를 함수의 인자로 사용하고자 할 때<code class=\"codetainer\">Function.prototype.apply()</code>를 대체할 수 있습니다.\n\n```javascript\n// 이전 방식\nfunction myFunction(x, y, z) {}\nvar args = [0, 1, 2];\nmyFunction.apply(null, args);\n\n// 전개 방식\nfunction myFunction(x, y, z) {}\nvar args = [0, 1, 2];\nmyFunction(...args);\n\n// new 키워드와 함께 사용할 수 있습니다.\nvar dateFields = [1970, 0, 1]; // 1 Jan 1970\nvar d = new Date(...dateFields);\n```\n\n# 클래스\n\n이전에는 공식적으로 클래스가 없어서 타입을 함수로 정의하고 그 함수 객체에 있는 프로토타입을 사용해 메서드를 정의했습니다. ES6부터 클래스 선언이 추가되어서 쉽게 클래스 패턴 생성이 가능해졌습니다.\n\n```javascript\nvar Foo = class {\n  constructor() {}\n  bar() {\n    return \"Hello World!\";\n  }\n};\n\nvar instance = new Foo();\ninstance.bar(); // \"Hello World!\"\nFoo.name; // \"\"\n```\n\nclass 키워드를 사용하더라도 내부적으로는 자바스크립트의 프로토타입 상속을 사용하고 있습니다. <code class=\"codetainer\">Foo.prototype</code>을 콘솔에 찍어보면 프로토타입에 생성자와 bar 메서드가 있는 것을 확인할 수 있을 것입니다.\n\n# ES6 모듈\n\n모듈은 다른 자바스크립트 파일의 코드를 쉽게 불러서 활용할 수 있는 재사용 가능한 코드 조각입니다. <code class=\"codetainer\">export</code>와 <code class=\"codetainer\">import</code> 키워드를 이용하면 됩니다.\n\n<code class=\"codetainer\">export</code>를 사용해 다른 모듈에서 활용할 수 있도록 이름(함수, 객체, 변수, 상수 등)을 외부에 익스포트할 수 있습니다.\n\n```javascript\n// export_1.js\n// print, log 함수를 외부에 export\n// 로컬 선언됨\nexport const print(message) => log(message, new Date())\nexport const log(message, timestamp) => console.log(`${timestamp.toString()} : ${message}`)\n\n// export_2.js\n// 단 하나의 이름만 외부에 export 하고 싶다면 export default 사용\nconst freel = new Date();\nexport default freel;\n```\n\n<code class=\"codetainer\">import</code>를 사용해 다른 자바스크립트 파일을 불러와 사용할 수 있습니다. 임포트 시 객체 구조 분해를 사용할 수 있으며, <code class=\"codetainer\">export default</code>를 사용한 경우 구조분해 없이 한 이름으로 부를 수 있습니다.\n\n```javascript\nimport { print, log } from ./export_1\nimport freel from ./export_2\n\n// import * 를 사용하여 다른 모듈에서 가져온 모든 이름을 사용자가 정한 로컬 이름 공간 안에 가둘 수 있음\nimport * from fns from ./export_1\n```\n\n# 커먼JS\n\n모든 버전의 노드에서 지원하는 일반적인 모듈 패턴입니다. 커먼 JS를 사용하여 객체를 <code class=\"codetainer\">module.exports</code>를 사용해 익스포트할 수 있습니다.\n\n```javascript\n//export.js\nconst print(message) => log(message, new Date())\nconst log(message, timestamp) => console.log(`${timestamp.toString()} : ${message}`)\n\nmodule.exports = {print, log}\n```\n\n```javascript\nconst { print, log } = require(\"./export\");\n```\n\n# ES6에서 비동기 프로그래밍\n\n나중에 따로 정리할 예정.\n\n## 1. promises\n\n## 2. 제너레이터\n"}}}},"pageContext":{"id":"f7b2c7b228ce7a27b8514b7c18d789d9be5fc783","previousPostId":"57230c4640ec299d7d03355c2e48f3f78fad5edf","nextPostId":"45928151f5549a4a93a02b2feceeba608babf1aa"}},"staticQueryHashes":["2841359383"]}