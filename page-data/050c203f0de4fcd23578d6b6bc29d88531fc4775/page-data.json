{"componentChunkName":"component---src-templates-blog-post-js","path":"/050c203f0de4fcd23578d6b6bc29d88531fc4775","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"050c203f0de4fcd23578d6b6bc29d88531fc4775","text":"# 알고리즘 개념 잡자 - 트리\n\n- Title : 알고리즘 개념 잡자 - 트리\n- Date : 2020-01-03\n- Category: Algorithm\n\n> 참고 서적<br/> > [코딩 인터뷰 완전분석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545) 트리와 그래프<br/> > [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539) 제 7장 트리, 제 8장 우선순위 큐\n\n# 1. 트리(Tree)\n\n- 트리는 노드(node)와 간선(edge)로 이루어진 자료구조이다.\n- 트리는 하나의 루트 노드를 가진다.\n- 루트 노드는 0개 이상의 자식 노드를 가진다.\n- 그 자식 노드 또한 0개 이상의 자식 노드를 가진다.\n- 그 자식의 자식 노드 또한..\n- 노드들은 특정 순서대로 나열될 수도 있고 없을 수도 있다.\n- 각 노드는 어떤 자료형으로도 표현이 가능하다.\n- 각 노드는 부모 노드로의 연결이 있을 수도 있고 없을 수도 있다.\n\n## 용어 정리\n\n- 트리에는 **사이클(cycle)**이 존재할 수 없다.\n- 자식이 없는 노드는 **말단 노드(leaf node)**라고 부른다.\n- **차수(degree)**는 자식 노드의 개수로 자식 노드가 3개면 그 노드의 차수는 3이다. 트리의 차수는 트리가 가지고 있는 노드의 차수 중에서 가장 큰 차수이다.\n- **레벨(level)**은 트리의 각 층에 번호를 매긴 것으로 루트의 레벨은 1이 되고 한 층씩 내려갈수록 1씩 증가한다\n- 트리의 **높이(height)**는 트리가 가진 최대 레벨이다.\n\n예시) 노드 클래스\n\n```java\nclass Node {\n  public String name;\n  public Node[] children;\n}\n```\n\n예시) 트리 클래스\n\n```java\nclass Tree {\n  public Node root;\n}\n```\n\n## 이진 트리(Binary tree)와 이진 탐색 트리(Binary search tree)\n\n- 이진트리\n  - 이진 트리의 노드는 최대 2개까지의 자식 노드가 존재할 수 있고 모든 노드의 차수는 2 이하가 된다.\n  - n개의 노드를 가진 이진 트리는 n-1개의 간선을 가진다. 루트 노드를 제외한 노드들은 부모와 정확히 하나의 간선으로 이어져있기 때문이다.\n  - 높이가 h인 이진 트리는 최소 h개 노드를 가지고 최대 2<sup>h</sup>-1 노드를 가진다.\n  - 레벨 i에서 노드의 개수는 2<sup>i-1</sup> 다.\n  - n개의 노드를 가진 이진 트리의 최대 높이는 n이며 최소 높이는 log<sub>2</sub>(n+1) 이다.\n- 이진 탐색 트리\n  - 모든 노드 n은 <span class=\"clr-note\">모든 왼쪽 자식들 <= n < 모든 오른쪽 자식들</span> 속성을 만족한다.\n  - 이진 탐색 트리의 탐색, 삽입, 삭제 연산의 시간 복잡도는 트리의 높이를 h라고 했을 때 O(h)가 된다.\n  - n개의 노드를 가진 균형 잡힌 이진 트리의 높이는 log<sub>2</sub>n 이므로 평균적인 시간 복잡도는 O(log<sub>2</sub>n)\n  - 한쪽으로 치우친 이진 트리의 경우 트리의 높이가 노드의 개수 n과 같게 되어 시간복잡도는 선형 탐색과 같이 O(n)이 된다.\n\n## 이진 트리 표현 방법\n\n**1. 배열 이용** <br/><br/>\n![배열 이용](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-03-img/1.png)<br/>\n\n- 주로 포화 이진 트리나 완전 이진 트리의 경우에 많이 쓰인다.\n- 높이가 k인 완전 이진 트리로 가정하여 배열의 크기를 최대 노드 개수인 2<sup>k</sup>-1 로 할당한 다음 완전 이진 트리의 번호대로 노드를 저장한다.\n- 편한 계산을 위해 인덱스는 1부터 시작한다.\n- 오른쪽 그림처럼 일반 이진 트리의 경우 공간 낭비가 크다.\n\n> 부모 & 자식 노드 찾는 법 <br/><br/>\n> 현재 노드 i를 기준으로, <br/>\n> 부모 노드의 인덱스 = **i/2** <br/>\n> 왼쪽 자식 노드의 인덱스 = **i\\*2** <br/>\n> 오른쪽 자식 노드의 인덱스 = **i\\*2 + 1** <br/>\n\n<br/>\n\n**2. 연결리스트 이용** <br/><br/>\n\n- 노드가 자바에서는 클래스, C에서는 구조체로 표현되고 각 노드가 포인터를 가지고 있어서 이 포인터를 이용하여 노드와 노드를 연결하는 방법이다.\n- 하나의 노드가 왼쪽 자식 노드, 오른쪽 자식 노드를 필드로 가진다.\n\n## 트리가 '균형' 트리인지 아닌지 확인하는 방법\n\n<span class=\"clr-note\">O(log N)</span> 시간에 insert와 find를 할 수 있는 정도로 균형이 잘 잡혀있는 지 확인하면 된다. 꼭 완전 이진 트리처럼 완벽하게 균형 잡혀 있을 필요는 없다.\n\n> 예) 레드-블랙 트리와 AVL 트리\n\n## 이진 트리의 종류\n\n- 완전 이진 트리(complete binary tree) : 트리의 모든 높이에서 노드가 꽉 차 있다. 마지막 단계(level)은 꽉 차 있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져야 한다.\n- 전 이진 트리(full binary tree) : 자식노드가 0개 또는 2개인 경우다.\n- 포화 이진 트리(perfect binary tree) : 전 이진 트리면서 완전 이진 트리인 경우다. 모든 말단 노드는 같은 레벨에 있으며 마지막 레벨에서 노드의 개수가 최대가 되어야 한다. 노드의 개수는 정확히 2<sup>k-1</sup>(k는 트리의 레벨)\n\n## 이진 트리 순회 방법\n\n**중위 순회(in-order traversal)**는 <span class=\"clr-note\">왼쪽 가지(branch) - 현재 노드 - 오른쪽 가지</span> 순서로 노드를 방문하고 출력하는 방법이다.\n\n> 이진 탐색 트리를 이 방법으로 순회한다면? <span class=\"is-has-danger\">오름차순</span>으로 방문!\n\n```java\nvoid inOrderTraversal(TreeNode node) {\n  if (node != null) {\n    inOrderTraversal(node.left);\n    visit(node);\n    inOrderTraversal(node.right);\n  }\n}\n```\n\n<br/>\n\n**전위 순회(pre-order traversal)**는 <span class=\"clr-note\">현재 노드 - 왼쪽 가지(branch) - 오른쪽 가지</span> 순서로 노드를 방문하고 출력하는 방법이다.\n\n> 가장 먼저 방문할 노드는? 루트 노드!\n\n```java\nvoid preOrderTraversal(TreeNode node) {\n  if (node != null) {\n    visit(node);\n    preOrderTraversal(node.left);\n    preOrderTraversal(node.right);\n  }\n}\n```\n\n<br/>\n\n**후위 순회(post-order traversal)**는 <span class=\"clr-note\">왼쪽 가지(branch) - 오른쪽 가지 - 현재 노드</span> 순서로 노드를 방문하고 출력하는 방법이다. 예) 현재 디렉토리 용량 계산\n\n> 맨 마지막에 방문할 노드는? 루트 노드!\n\n```java\nvoid postOrderTraversal(TreeNode node) {\n  if (node != null) {\n    postOrderTraversal(node.left);\n    postOrderTraversal(node.right);\n    visit(node);\n  }\n}\n```\n\n<br/>\n\n**레벨 순회(level traversal)**는 각 노드를 레벨 순으로 순회하는 방법이다. 레벨 1에서 시작하며 동일한 레벨의 경우에는 왼쪽에서 오른쪽으로 순으로 방문한다.\n\n> 중위, 전위, 후위는 스택을 사용하며 레벨 순회는 **큐**를 이용한다.\n\n## 이진 트리 순회의 응용\n\n**수식 트리(expression tree)**를 처리하는 데 사용\n<br/>\n\n![수식 트리 예제](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-03-img/2.png)<br/>\n\n- 루트 노드는 연산자이고 서브 트리가 피연산자이므로 서브 트리를 계산하면 전체 수식을 계산할 수 있다.\n- 위 표에 나와있듯이 가장 적합한 순회 방식은 **후위 순회**다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"146c143b5de337f212dc8e01ca9473a2a201a1a5","text":"# 알고리즘 개념 잡자 - 트라이\n\n- Title : 알고리즘 개념 잡자 - 트라이\n- Date : 2020-01-03\n- Category: Algorithm\n\n> 참고 서적<br/> > [코딩 인터뷰 완전분석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545) 트리와 그래프<br/>\n> [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539) 제 7장 트리, 제 8장 우선순위 큐\n\n# 3. 트라이(접두사 트리, prefix tree)\n\n> 참조 링크 [wikipedia](https://en.wikipedia.org/wiki/Trie)\n\n![트라이](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-03-img/4.png)\n\n- n-차 트리의 변종으로 각 노드에 문자를 저장하는 자료구조이다.\n- 문자열 탐색에 효율적인 자료구조이다.\n- 트리를 아래쪽으로 순회하면 단어 하나가 나온다.\n- TerminatingTrieNode로 널 노드를 표현한 경우, 트라이에서 각 노드는 1개 ~ 문자열 길이 + 1개 까지 자식을 가질 수 있다.\n- 널 노드 대신 불린 플래그로 표현한 경우, 각 노드는 0개 ~ 문자열 길이개까지 자식을 가질 수 있다.\n\n> **널 노드(\\* 노드)**\n>\n> - 단어의 끝을 나타낸다.\n> - 예) MANY 이후에 널 노드가 나오면 MANY라는 단어가 완성되었다는 의미다.\n>\n> **널 노드 구현 방법**\n>\n> - TrieNode를 상속한 TerminatingTrieNode로 표현하기\n> - 널 노드의 부모 노드 안에 불린 플래그를 새로 정의함으로써 표현하기\n\n**어디에 사용할까?**\n\n- 자동 완성\n- 문자열이 어떤 문자열의 접두사인지 확인하고 싶을 때 <span class=\"clr-grey\">cf) 단순 삽입/조회만 한다면 해시테이블 사용을 권장</span>\n- 예: 'a', 'axe'로 시작하는 단어를 찾고 싶을 때\n\n> 예시, M, MA, MAN, MANY를 차례대로 살펴보는 경우 트리의 현재 노드를 참조값으로 넘김으로써 루트 노드에서 시작할 필요가 없고 단순히 Y가 MAN의 자식인지만 확인해보면 된다.\n\n## 트라이 VS 해시테이블\n\n- 최악의 경우, 시간복잡도는?\n  - 트라이 : O(K) (K: 가장 긴 문자열)\n  - 해시테이블 : 충돌이 자주 발생되었다면 O(N)의 시간복잡도를 가진다. (N: 키의 개수) 또한 입력 문자열을 기반으로 해시 계산을 하므로 O(K)의 시간이 걸린다.\n  - cf) 탐색할 문자열이 트라이에 없는 경우에는 문자열 길이 K보다 시간이 덜 걸린다.\n\n> **트라이와 해시의 시간복잡도가 비슷하다..?** <br/>\n> 길이가 K인 무자열이 주어졌을 때 트라이는 O(K) 시간에 해당 문자열이 유효한 접두사인지 확인할 수 있다. 이 시간은 해시테이블 사용했을 때와 정확히 같은 수행 시간이다. 우리가 종종 해시테이블을 검색하는 시간이 O(1)이라고 하지만 완전히 맞는 말은 아니다. 해시테이블도 입력 문자열은 전부 읽어야 하므로 길이가 K인 단어를 검색하는 데 걸리는 시간은 O(K)가 된다.\n\n- 알파벳 정렬?\n\n  - 일반적으로 자료구조에 문자열을 저장한다면 각 문자열의 순서가 중요하기도 하다. 트라이는 노드를 저장할 때 왼쪽에서 오른쪽으로 사전 순으로 저장한다면 쉽게 정렬이 가능하다.\n\n- 기타\n  - 트라이는 삭제가 직관적이며 해시 함수가 필요 없으나 해시 테이블 보다는 많은 공간을 차지한다.\n\n## 트라이 구현\n\n```javascript\nclass Trie {\n  constructor(key) {\n    this.is_terminal = false;\n    this.key = key;\n    this.trie_child = Array(26).fill(null);\n  }\n\n  char_to_index(key) {\n    return key.charCodeAt(0) - \"a\".charCodeAt(0);\n  }\n\n  // 새로운 문자열을 트라이에 추가\n  insert(key) {\n    let current_trie = this;\n    for (let i = 0; i < key.length; i++) {\n      let index = this.char_to_index(key[i]);\n      if (current_trie.trie_child[index] === null)\n        current_trie.trie_child[index] = new Trie(key.slice(0, i + 1));\n      current_trie = current_trie.trie_child[index];\n    }\n    current_trie.is_terminal = true;\n  }\n\n  // 트라이 출력\n  print(trie, dep) {\n    console.log(dep, trie.key);\n    if (trie.is_terminal) return;\n    for (let i = 0; i < 26; i++) {\n      if (trie.trie_child[i] !== null) this.print(trie.trie_child[i], dep + 1);\n    }\n  }\n\n  // key를 접두어로 가지고 있는지, 가지고 있으면 해당 접두어가 끝나는 부분의 위치를 반환\n  find(key) {\n    let current_trie = this;\n    for (let i = 0; i < key.length; i++) {\n      let index = this.char_to_index(key[i]);\n      if (current_trie.trie_child[index] === null) return false;\n      else current_trie = current_trie.trie_child[index];\n    }\n    return current_trie;\n  }\n\n  // key를 포함하는 지, 포함하면 true\n  exist(key) {\n    let current_trie = this;\n    for (let i = 0; i < key.length; i++) {\n      let index = this.char_to_index(key[i]);\n      if (current_trie.trie_child[index] === null) return false;\n      else current_trie = current_trie.trie_child[index];\n    }\n    return current_trie.is_terminal;\n  }\n}\n\nvar trie = new Trie(null);\nvar arr = [\"to\", \"tea\", \"ted\", \"ten\", \"a\", \"inn\"];\narr.forEach(str => trie.insert(str));\n// trie.print(trie, 0)\nconsole.log(trie.exist(\"tea\")); // true\nconsole.log(trie.exist(\"aaa\")); // false\nconsole.log(trie.exist(\"a\")); // true\nconsole.log(trie.find(\"te\")); // Trie {is_terminal: false, key: \"te\", trie_child: Array(26)}\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"badecf2a1d8b27736ed2d861abdb95aeffc07070","text":"# 프로그래머스 - lv3 네트워크, lv2 짝지어 제거하기\n\n- Title : 프로그래머스 - lv3 네트워크, lv2 짝지어 제거하기\n- Date : 2019-12-30\n- Category: 알고리즘 풀이\n\n# # LV3 네트워크\n\n각 행을 순회해서 컬럼 값이 1일 때, 해당 col을 row로 하여 또 순회하는 식으로 해결했다.\n\n```javascript\nfunction solution(n, computers) {\n  var answer = 0;\n  var arr = [];\n  arr = computers.reduce((acc, cur) => {\n    acc.push(cur.includes(1));\n    return acc;\n  }, []);\n\n  for (let i = 0; i < n; i++) {\n    if (arr[i]) {\n      dfs(i);\n      answer++;\n    }\n  }\n\n  function dfs(row) {\n    if (!arr[row]) return;\n    arr[row] = false;\n    for (let i = 0; i < n; i++) {\n      if (computers[row][i] > 0) {\n        computers[row][i] = 0;\n        dfs(i);\n      }\n    }\n  }\n\n  return answer;\n}\n```\n\n# # lv2 짝지어 제거하기\n\n스택을 생각해냈으면 쉽게 해결할 수 있다.\n\n```javascript\nfunction solution(s) {\n  var stack = [];\n  stack.push(s[0]);\n  for (let i = 1; i < s.length; i++) {\n    if (stack[stack.length - 1] === s[i]) stack.pop();\n    else stack.push(s[i]);\n  }\n  return stack.length ? 0 : 1;\n}\n```\n"}}}},"pageContext":{"id":"050c203f0de4fcd23578d6b6bc29d88531fc4775","previousPostId":"146c143b5de337f212dc8e01ca9473a2a201a1a5","nextPostId":"badecf2a1d8b27736ed2d861abdb95aeffc07070"}},"staticQueryHashes":["2685952063","2841359383"]}