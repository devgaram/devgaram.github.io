{"componentChunkName":"component---src-templates-blog-post-js","path":"/d3dc616060fb13934c41fc45065d110b9e8704ee","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d3dc616060fb13934c41fc45065d110b9e8704ee","text":"# 시스템 설계 및 규모 확장성 문제 5 - 판매순위\n\n- Title : [코딩인터뷰] 시스템 설계 및 규모 확장성 문제 5 - 판매순위\n- Date : 2019-08-31\n- Category: Algorithm\n\n> 코딩 인터뷰 완전분석 (CRACKING THE CODING INTERVIEW 6/E) / 게일 라크만 맥도웰 지음 / 인사이트\n\n# Q. 판매순위 : 한 전자상거래 회사는 가장 잘 팔리는 제품의 리스트(전체에서 그리고 각 목록별로)를 알고 싶어 한다. 예를 들어, 어떤 제품은 전체 제품 중에서 1,506번째로 잘 팔리지만 운동 장비 중에서는 13번째로 잘 팔리고, 안전용품 중에서는 24번째로 잘 팔릴 수 있다. 이 시스템을 어떻게 설계할지 설명하라.\n\n## 내풀이\n\n각 제품 정보에 판매수량을 저장을 하고 리스트 조회할 때마다 정렬하는 건 좀 그럴거 같긴한뎁,,\n동시에 전체 중 ~위 운동 장비 중 ~위.. 이런식으로 표현하게 되면 정렬을 넘 많이 하게 되는 듯싶은뎅\n구입할 때마다 리스트의 맨앞에..?음..\n매번 순위 조회할때마다 정렬해야되니깐 이건 좀 별루고\n아예 전체 연결리스트를 순서가 유지되게 하는 게 좋을 듯\n삽입 삭제가 빈번하니깐 연결리스트가 좋을거같고...\n\n## 책풀이\n\n**1단계 : 문제 범위를 한정하고 합리적인 가정을 하자**\n\n구현하려는 시스템을 다음과 같이 정의했다.\n\n- 잘 팔린다는 것은 판매량이 많다는 것을 의미한다.\n- 판매량은 평생/지난달/저번주 판매량인지 명확하게 정의할 것이다. 여기서는 저번주 판매량으로 한정한다.\n- 각 제품은 여러 목록에 포함될 수 있고 하위목록 개념은 없다고 가정한다.\n\n다음과 같은 합리적인 가정을 세웠다.\n\n- 통계 결과가 언제나 100% 최신 데이터가 아닐 수 있다고 가정할 것이다.\n- 인기 있는 제품의 경우 정확도가 중요하나 인기 없는 제품은 약간의 오차가 있어도 괜찮다.\n- 가장 인기 있는 제품의 경우 한 시간마다 갱신이 이루어진다고 가정할 것이다.\n\n**2단계 : 주요 구성요소 그리기**\n\n![1](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2019-08-30-img/5-1.jpg) <br/>\n\n**3단계 : 핵심문제 파악**\n\n1. 분석은 비용이 비싸다.\n2. 데이터베이스에 너무 자주 기록한다.\n3. join 비용이 비싸다\n\n2번 데이터베이스에 너무 자주 기록된다.  \n구매할 때마다 판매량 정보 테이블을 업데이트하기보다는 모아서 일괄적(batch)으로 한번에 데이터베이스에 쓰는 방법을 쓴다.  \n즉, 곧바로 데이터베이스에 자료를 집어넣기보단, 메모리 내의 캐시와 같은 저장소에 구매 정보와 백업용 로그 파일을 저장해 놓은 뒤 주기적으로 로그/캐시 데이터를 모아서 한 번에 데이터베이스에 넣는 것이다. (특정 시점까지의 자료만 데이터베이스에 넣는 식)\n\n3번 join 비용이 비싸다.  \n수천 개의 제품 목록을 제품 ID에 join 하는 작업은 고비용이다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"b98232c7cb9b2f596542f32029a4d9e3db9cc08c","text":"# JVM 메모리 구조\n\n- Title : JVM 메모리 구조\n- Date : 2019-10-16\n- Category: Java\n\n예전 면접에서 JVM 메모리 구조에 관한 질문을 받은 적이 있었다...  \n횡설수설하며 대답하긴 했지만 좀 더 깔끔한 답변을 위해 정리해야할 필요성을 느꼈다..!!!\n\n우선, JVM이 뭘까?\n\nJVM(Java Virtual Machine) 은 자바로 작성된 애플리케이션을 실행하기 위해서 반드시 필요한 가상머신이다!\n\n![1](https://raw.githubusercontent.com/devgaram/TIL/master/Java/images/2019-10-16-img/memory01.png) <br/>\n\n위 그림을 보면 일반 애플리케이션 코드는 OS만 거치고 하드웨어로 전달되지만 자바 애플리케이션은 JVM을 한번 더 거친다.\n그래서 자바는 속도가 느린 단점이 있다고 한다.\n\n왜??? 이유를 알기 위해 잠시 자바 응용 프로그램의 실행되는 과정을 살펴볼 필요가 있다.\n\n1. 응용프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.\n2. javac.exe (자바 컴파일러)가 자바소스를 바이트 코드(\\*.class)로 컴파일한다.\n3. Class Loader가 JVM에 클래스 파일을 로드시킨다.\n4. java.exe (자바인터프리터, 실행엔진)이 컴파일된 바이트 코드를 해석한다.\n5. 해석된 바이트 코드는 Runtime Data Areas에 배치되어 실행된다.\n\n위와 같이 하드웨어에 맞게 완전히 컴파일된 상태가 아닌 바이트 코드로 컴파일된 상태고 실행 시에 해석되기 때문에 느리다.\n그래도 요즘엔 바이트 코드를 하드웨어의 기계어로 바로 변환해주는 JIT 컴파일러와 향상된 최적화 기술이 적용되어서 속도 문제가 많이 개선되었다고 한다.\n\n장점으로는 JVM 덕분에 자바 애플리케이션은 OS에 종속되지 않는 점이 있다.  \n그래도 JVM은 OS에 종속되니깐 OS에 맞는 JVM이 필요하다.\n\n## JVM 메모리 구조\n\n![1](https://raw.githubusercontent.com/devgaram/TIL/master/Java/images/2019-10-16-img/JvmSpec7.png) <br/>\n[JVM스펙](https://ko.wikipedia.org/wiki/자바_가상_머신)\n\n이 중 3가지 주요 영역에 대해 알아보자.\n\n## 메서드 영역\n\n메서드 영역(Method area = static area = Class area)은 JVM이 \\*.class을 해석하여 얻은 클래스 정보(클래스 데이터)가 저장되는 공간이다. 이 때, 클래스 변수(static 멤버변수)도 같이 저장된다.  \n클래스정보에는 멤버변수의 이름/데이터 타입/접근 제어자 정보, 메소드의 이름/리턴 타입/매개변수/접근제어자 정보, 클래스인지 인터페이스인지 여부, 전체이름들이 해당된다.\n\n## 힙\n\n힙(Heap) 영역은 프로그램 실행 중에 생성되는 인스턴스(객체)가 저장되는 공간이다.  \n즉 new 키워드로 생성된 객체와 배열을 저장한다. 물론 인스턴스 변수도 같이 저장된다.\n\n## 호출스택\n\n호출 스택(call stack 또는 execution stack)은 호출된 메서드를 위한 메모리가 할당되는 곳으로 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함), 연산의 중간 결과, 리턴 값들을 저장하는 데 사용한다. 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워진다.\n\n참고서적) 자바의 정석  \n참고블로그) [https://asfirstalways.tistory.com/158](https://asfirstalways.tistory.com/158)\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"a1f625269928ae850f3014fdc0614633e4ee091c","text":"# 시스템 설계 및 규모 확장성 문제 1 - 중복 URL\n\n- Title : [코딩인터뷰] 시스템 설계 및 규모 확장성 문제 1 - 중복 URL\n- Date : 2019-08-30\n- Category: Algorithm\n\n> 코딩 인터뷰 완전분석 (CRACKING THE CODING INTERVIEW 6/E) / 게일 라크만 맥도웰 지음 / 인사이트\n\n# Q. 중복 URL : 100억 개의 URL이 있다. 중복된 문서를 찾으려면 어떻게 해야 하는가? 여기서 '중복'이란 '같은 URL'이라는 뜻이다.\n\n## 내풀이\n\n만약 100억 개의 URL을 저장할 수 있는 충분한 공간이 있다면, 리스트를 정렬한 후 중복된 값 찾으면 될 것 같다.  \n아니면 100억 개의 URL을 해시테이블에 저장하는 전처리 과정을 하면 전처리 과정 중에도 중복된 문서를 찾을 수 있고\n그 후 데이터가 추가될 때도 쉽게 중복 여부를 확인할 수 있을 것 같다.\n\n## 책풀이\n\n## 1단계 : 합당한 가정을 세운다.\n\n책은 100억 개의 URL을 처리하기위한 공간을 계산하기위해 다음과 같은 합당한 가정을 세운다.\n\n- 각 URL이 평균적으로 100개의 문자로 구성되어 있고 각 문자는 4바이트라고 가정한다.\n- 100(문자) _ 4(bytes) _ 100억(url개수) = 4,000,000,000,000 bytes = 4 \\* 10<sup>12</sup> = 4TB\n- 즉, 100억 개의 URL을 처리하기위해서는 4TB 정도의 메모리 공간이 필요하다.\n\n## 2단계 : 현실적 제약을 무시한다.\n\n모든 데이터를 메모리에 보관할 수 있다고 가정한 후 문제에 접근한다.\n\n이미 살펴본 URL에 대해 true를 반환하는 해시테이블을 사용하여 문제를 해결할 수 있다.  \n리스트를 정렬하는 방식은 시간도 더 들고 장점도 없다.\n\n## 3단계 : 현실로 돌아온다.\n\n4TB의 데이터를 메모리(RAM)에 전부 올릴 수 없는 상황에서 어떻게 해야하는지 생각한다.\n\n**해법 #1 : 디스크 저장**\n\n각 URL을 .txt 파일에 저장한다.  \n.txt 파일의 크기는 1GB(10<sup>9</sup>)로 4TB URL을 저장하기위해서는 4000개의 파일이 필요하다.  \nx = hash(u) % 4000로 저장할 .txt 파일을 결정한다.  \n같은 해시값을 갖는 URL은 같은 파일에 저장된다.  \n각 파일을 메모리에 올려 URL의 해시테이블을 생성한 다음에 중복이 존재하는 지 확인하면 된다.\n\n**해법 #2 : 데이터를 여러 서버에 분할**\n\n본질적으로는 해법1과 같으나, 여러 서버를 사용한다는 차이가 있다.  \nURL을 .txt라는 파일에 저장하는 대신 서버 x에 전송하는 것이다.\n\n- 장점 : 병렬처리가능\n- 단점 : 4000개의 서버가 완벽 동작해야함(비현실적)\n"}}}},"pageContext":{"id":"d3dc616060fb13934c41fc45065d110b9e8704ee","previousPostId":"b98232c7cb9b2f596542f32029a4d9e3db9cc08c","nextPostId":"a1f625269928ae850f3014fdc0614633e4ee091c"}},"staticQueryHashes":["2841359383"]}