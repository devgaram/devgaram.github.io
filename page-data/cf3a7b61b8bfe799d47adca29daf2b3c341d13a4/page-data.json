{"componentChunkName":"component---src-templates-blog-post-js","path":"/cf3a7b61b8bfe799d47adca29daf2b3c341d13a4","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"cf3a7b61b8bfe799d47adca29daf2b3c341d13a4","text":"# REST API에 대해\n\n- Title : REST API에 대해\n- Date : 2020-03-16\n- Category: Web\n\n## ✨ REST API 란?\n\nREST(Representational State Transfer)는 웹처럼 HTTP 기반의 시스템에 필요한 자원(리소스, DBMS 데이터, 이미지, 동영상, 서비스..등)에 접근하는 방식을 정해놓은 아키텍쳐다.\n\n### REST 구성\n\n- 자원(RESOURCE) - URI\n  - 리소스명은 동사보다는 명사를 사용\n- 행위(Verb) - HTTP METHOD(GET, POST, PUT, DELETE)\n- 표현(Representations)\n\n### REST 특징\n\n- **클라이언트/서버 구조** : REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로 간 의존성이 줄어든다.\n- **무상태성(Stateless)** : 클라이언트 컨텍스트(세션, 쿠키)는 서버에 저장되어서는 안 된다. API 서버는 단순히 들어오는 요청만을 처리한다.\n- **캐시 처리 가능(Cacheable)** : HTTP가 가진 캐싱 기능 적용이 가능하다. 클라이언트 응답을 캐싱할 수 있어야 한다.\n- **계층화(Layered System)** : REST 서버는 다중 계층으로 구성될 수 있다. 하지만 클라이언트는 REST 서버에 직접 연결되었는지, 또는 중간 서버를 통해 연결되었는 지를 알 수 없게 해야한다. 중간 서버는 로드 밸런싱 기능이나 공유 캐시 기능을 제공함으로써 시스템 규모 확장성을 향상시키는 데 유용하다.\n- **유니폼 인터페이스(Uniform)** : URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말한다.\n\n### URI 설계 시 주의할 점\n\n- 슬래시 구분자(/)는 계층 관계를 나타내는 데 사용한다.\n- URI 마지막 문자로 슬래시(/)를 포함하지 않는다.\n- 하이픈(-)은 URI 가독성을 높이는데 사용한다.\n- 밑줄(\\_)은 URI에 사용하지 않는다.\n- URI 경로에는 소문자가 적합하다.\n- 파일 확장자는 URI에 포함시키지 않는다.\n\n### 리소스 간의 관계 표현하는 방법\n\n사용자가 좋아하는 디바이스 목록 가져오기\n\n    GET : /users/{userid}/likes/devices\n\n### 자원을 표현하는 Collection과 Document\n\n- Collection: 문서들의 집합, 객체들의 집합\n- Document: 문서, 객체\n\n예시로 이해하기\n\n- sports, players: 컬렉션\n- soccer, 13: 다큐먼트\n\n  http:// restapi.example.com/sports/soccer/players/13\n\n**참고 99.9%**\n\n[REST API 제대로 알고 사용하기 : TOAST Meetup](https://meetup.toast.com/posts/92)\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"aca141df670b8b9c9474fa873d833730c6d80a8f","text":"# [자바스크립트] 이벤트 위임(Event delegation)\n\n- Title : [자바스크립트] 이벤트 위임(event delegation)\n- Date : 2020-03-20\n- Category : Javascript\n\n# Why?\n\n웹 개발자라면 이벤트 핸들러를 등록할 때 **캡처링**과 **버블링**을 적절하게 선택할 수 있어야 하지 않을까?\n```javascript\n    // 이벤트 캡처\n    element1.addEventListener('click',doSomething2,true)\n    // 이벤트 버블링\n    element2.addEventListener('click',doSomething,false)\n```\n> 🔊 익명함수로 이벤트 핸들러를 정의할 수 있는 데 이 때 화살표 함수의 this 컨텍스트는 event.currentTarget이 아님을 알고 있어야 한다. function (e) {} 형태로 정의해야 this 컨텍스트가 event.currentTarget이 된다.\n\n# addEventListener 동작 방식\n\naddEventListener() 메서드의 마지막 argument의 값으로 이벤트 전파 방식을 지정할 수 있다. true면 캡쳐, false(기본값)면 버블링으로 이벤트가 전파된다. 아래 예시로 이해를 어떤식으로 전파되는 지 이해해보자.\n```html\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <meta charset=\"utf-8\">\n      <meta name=\"viewport\" content=\"width=device-width\">\n      <title>JS Bin</title>\n    </head>\n    <body>\n      <div id=\"element1\">\n        element1\n        <div id=\"element2\">\n           element2\n          <div id=\"element3\">element3</div\n        </div>\n      </div>\n    </body>\n    </html>\n```\n```javascript\n    var element1 = document.getElementById(\"element1\");\n    var element2 = document.getElementById(\"element2\");\n    var element3 = document.getElementById(\"element3\");\n    function doSomething1(){\n      console.log(\"doSomething1\");\n    }\n    function doSomething2(){\n      console.log(\"doSomething2\");\n    }\n    function doSomething3(){\n      console.log(\"doSomething3\");\n    }\n```\n🎈 3개의 element가 버블링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,false)\n    element3.addEventListener('click',doSomething3,false)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething2`→ `doSomething1`\n- element3 클릭시 출력 :  `doSomething3`→ `doSomething2` -> `doSomething1`\n\n🎈 3개의 element가 캡처링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,true)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,true)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething1`→ `doSomething2`\n- element3 클릭시 출력 :  `doSomething1`→ `doSomething2` -> `doSomething3`\n\n🎈 맨 밖의 엘리먼트는 버블링 내부 엘리먼트는 캡처링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,true)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething2`→ `doSomething1`\n- element3 클릭시 출력 :  `doSomething2`→ `doSomething3` -> `doSomething1`\n\n🎈 섞여있으면..?\n```javascript\n    document.body.addEventListener('click',doSomething0,true)\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,false)\n```\nelement3 클릭시 출력 :  `doSomething0`→ `doSomething2` -> `doSomething3` → `doSomething1`\n\n### 테스트 결과\n\n- 이벤트 타켓에 이벤트가 발생하면 이벤트가 다른 이벤트 타켓(이벤트 핸들러가 등록된)으로 전파된다.\n- 이벤트 캡처는 이벤트 타켓의 최상위 요소(단, 이벤트 핸들러가 등록된)부터 이벤트 타켓까지 이벤트 핸들러를 처리한다.\n- 이벤트 버블링은 캡처와 반대로 이벤트 타켓부터 최상위 요소까지 이벤트 핸들러를 처리한다.\n- 섞여있으면 캡처링 우선인 이벤트 타켓부터 처리한 후 버블링을 수행한\n\n# 이벤트 버블링과 캡쳐\n\n아래 사진은 DOM 트리에서 일어나는 이벤트 전파 방법이다.\n\n[UI Events](https://www.w3.org/TR/DOM-Level-3-Events/#event-flow)\n\n![Event%20delegation/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/Untitled.png)\n\n캡처와 버블링은 두 요소(엘리먼트)가 해당 이벤트에 대한 핸들(함수)를 등록한 경우, 다른 요소 내에 중첩된 요소에서 발생하는 이벤트를 전파하는 방법이다. 이벤트 전파 모드로 요소가 이벤트를 수신하는 순서를 판별한다.\n\n## 이벤트 전파..? 신경쓰기 싫어!\n\n현재 이벤트 이후의 이벤트 전파(캡처링, 버블링)를 막고 싶다면 **`event.stopPropagation()`** 메서드를 사용하면 된다.\n\n## 이벤트는 취소하고 전파는 하고 싶어!\n\n**`event.preventDefault()`** 는 이벤트를 취소하지만 이벤트 전파를 막지 않는다. 전파를 막으려면 `event.stopPropagation()`을 사용해야한다.  주로 `a` 태그나 `submit` 태그 등 고유의 동작을 막고 원하는 이벤트 핸들러를 실행할 때 사용한다.\n\n## 메모리 이슈\n\n루프의 각 반복마다 새로운 익명 행들러 함수가 생성되는 방식으로 이벤트를 등록하지 말자. 따로 이벤트 핸들러를 생성한 후 등록하는 방식을 사용해야 메모리 소비가 줄고 `removeEventListener()`를 호출할 수 있다. 익명 함수는 참조가 유지되지않기에 이벤트 리스너를 제거할 수 없다.\n\n# 이벤트 위임(Event delegation)\n\n이벤트 발생 시 document 레벨까지 버블링 되어 올라가는 것을 활용하는 것으로 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식이다.\n\n- 동적인 엘리먼트에 대한 이벤트 처리 수월\n- 하위 엘리먼트는 자유롭게 추가 삭제 가능\n- 동일한 이벤트를 한 곳에서 관리할 수 있고 이벤트 핸들러 관리 쉽다.\n- 생성되는 이벤트 핸들러 함수가 줄어 메모리 사용량이 줄고 메모리 누수 가능성이 감소된다.\n\n참조\n\n[왜 이벤트 위임(delegation)을 해야 하는가?](https://ui.toast.com/weekly-pick/ko_20160826/)\n\n[EventTarget.addEventListener()](https://developer.mozilla.org/ko/docs/Web/API/EventTarget/addEventListener)"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"146f5eb0b2e672cd66e3c67c69e36f8cac38be23","text":"# [Vue] 슬롯(Slots)\n\n- Title : [Vue] 슬롯(Slots)\n- Date : 2020-03-09\n- Category: Vue\n\n## Why?\n\n요즘 vue 프로젝트를 하면서 Vuetify 공식 문서를 매일 같이 들락날락 하고 있다. 크롬 탭 한켠에 켜놓고 Vuetify 죠아..🤩하며 잘 쓰고 있던 중 낯선 예제가 눈에 밟혔다. 바로 아래의 `<v-menu>` 컴포넌트의 예시 코드다.\n\n```ts\n    <v-menu offset-y>\n    \t<template v-slot:activator=\"{ on }\">\n    \t  <v-btn\n    \t    color=\"primary\"\n          dark\n          v-on=\"on\"\n    \t   >\n    \t     Dropdown\n    \t\t </v-btn>\n       </template>\n       <v-list>\n         <v-list-item\n           v-for=\"(item, index) in items\"\n           :key=\"index\"\n           @click=\"\"\n         >\n           <v-list-item-title>{{ item.title }}</v-list-item-title>\n         </v-list-item>\n       </v-list>\n     </v-menu>\n```\n\n**`<template v-slot:activator=\"{ on }>`** 음.. slot이 컴포넌트 렌더링할 때 베이스 컴포넌트의 `<slot>` 에 부모 컴포넌트가 들어가는 거 였는 데...? 근데 예제에서 어떻게 리스트를 보였다 숨겼다 하는 거지? 라는 생각이 들었고 지식의 짧음을 깨달아 곧장 Vue 공식 문서를 방문했다.\n\n[슬롯(Slots) - Vue.js](https://kr.vuejs.org/v2/guide/components-slots.html)\n\n## 슬롯?\n\n### A 컴포넌트 안에 B(컴포넌트, 텍스트, HTML 템플릿..)를 넣고 싶을 때\n\n예시로 페이지마다 쓰이는 레이아웃(헤더, 푸터) 컴포넌트에 페이지마다 달라지는 컨텐츠 컴포넌트를 넣고 싶다고 하자.\n\n레이아웃(Layout) 컴포넌트는 아래와 같다.\n\n```ts\n<template>\n  <Header />\n  <main>\n    <slot></slot>\n  </main>\n  <Footer />\n</template>\n```\n\n이제 콘텐츠(Content) 컴포넌트를 Layout 컴포넌트의 `<slot></slot>` 부분에 넣어보자.\n\n콘텐츠(Content) 컴포넌트는 아래와 같다.\n\n```ts\n<template>\n  <Layout>\n    <div>매번 변경되는 컨텐츠들..</div>\n    <Shop />\n  </Layout>\n</template>\n```\n\n만약 레이아웃 컴포넌트에 `<slot>` 이 없으면 위 예제의 `<Layout>` 요소 안에 있는 내용은 무시된다.\n\n### 음 근데 A컴포넌트 안에 여러 `<slot>`을 만들고 싶은데?\n\n당근 가능하다. 위 예제에서 컨텐츠뿐만 아니라 헤더와 푸터도 `<slot>` 요소로 받을 수 있게 바꿔보자\n\n```ts\n<template>\n  <slot name=\"header\"></slot>\n  <main>\n    <slot></slot>\n  </main>\n  <slot name=\"footer\"></slot>\n</template>\n```\n\n자세히 살펴보면 `<slot>`이 name 속성을 가지고 있다. `<main>`안의 `<slot>`은 name이 지정되지 않았는 데 이때는 암묵적으로 \"default\" 이름을 갖는다.\n\n자 이제 레이아웃 컴포넌트에 헤더, 푸터 컴포넌트와 콘텐츠 내용을 전달해보자.\n\n```ts\n    <template>\n    \t<Layout>\n    \t\t<template v-slot:header><Header /></template>\n    \t\t<div>매번 변경되는 컨텐츠들..</div>\n    \t\t<Shop />\n    \t\t<template v-slot:footer><Footer/></template>\n    \t</Layout>\n    </template>\n```\n\nname 속성이 있는 슬롯에 내용을 전달하려면 `<template>`에 `v-slot` 디렉티브를 쓰고 속성에 앞에서 지정한 name을 넣으면 된다. 이제 `<template>` 요소들의 모든 내용들은 적절한 슬롯에 전달된다. `<template>`에 싸여있지 않은 내용들은 default 슬롯으로 간주하여 이름 없는 `<slot>`요소에 전달된다. v-slot:default로 명시적으로 표시할 수도 있는 데 아래 예제로 확인해보자. 아래 예제는 바로 위 예제와 동일하다.\n\n```ts\n    <template>\n    \t<Layout>\n    \t\t<template v-slot:header><Header /></template>\n    \t\t<template v-slot:default>\n    \t\t\t<div>매번 변경되는 컨텐츠들..</div>\n    \t\t\t<Shop />\n    \t\t</template>\n    \t\t<template v-slot:footer><Footer/></template>\n    \t</Layout>\n    </template>\n```\n\nv-slot만 `<template>` 태그에 추가할 수 있다는 점! 기억하기.\n\n### 슬롯에 전달될 내용이 없을 때 디폴트로 어떤 내용을 표시하고 싶으면?\n\n버튼 텍스트를 `<slot>` 요소로 전달 받으려면 아래와 같이 만들어야한다. 컴포넌트의 이름은 SubmitBtn으로 하자.\n\n```ts\n    <template>\n    \t<v-btn type=\"submit\" :color=\"color\">\n    \t\t<slot></slot>\n    \t</v-btn>\n    </template>\n```\n\n아래와 같이 `<slot>`을 \"저장\" 텍스트로 대체해보자\n\n```ts\n<template>\n  <SubmitBtn color=\"grey\">저장</SubmitBtn>\n</template>\n```\n\n근데 `<SubmitBtn>`안에 아무 것도 안적어도 `<slot>`요소가 \"submit\"으로 대체되게 하고 싶다면? SubmitBtn 컴포넌트를 아래와 같이 수정하자.\n\n```ts\n    <template>\n    \t<v-btn type=\"submit\" :color=\"color\">\n    \t\t<slot>submit</slot>\n    \t</v-btn>\n    </template>\n```\n\n이제 아무 내용이 없으면 submit이 렌더링 된다.\n\n```ts\n<template>\n  <SubmitBtn></SubmitBtn>\n</template>\n```\n\n위 코드의 렌더링 결과는 아래와 같다.\n\n```ts\n<v-btn type=\"submit\">submit</v-btn>\n```\n\n### 자. 여기까지 배운 상태에서 v-menu 예제를 다시 살펴보자.\n\n```ts\n    <v-menu offset-y>\n    \t<template v-slot:activator=\"{ on }\">\n    \t  <v-btn\n    \t    color=\"primary\"\n          dark\n          v-on=\"on\"\n    \t   >\n    \t     Dropdown\n    \t\t </v-btn>\n       </template>\n       <v-list>\n         <v-list-item\n           v-for=\"(item, index) in items\"\n           :key=\"index\"\n           @click=\"\"\n         >\n           <v-list-item-title>{{ item.title }}</v-list-item-title>\n         </v-list-item>\n       </v-list>\n     </v-menu>\n```\n\n이정도 해석은 가능할거다. `<v-menu>` 컴포넌트에 `<slot name=\"activator\"></slot>`이 존재하겠구나. 그래서 `<v-btn>` 요소는 \"activator\" 슬롯에 대체되고 `<template>`로 싸여있지않은 `<v-list>` 컴포넌트는 `<slot></slot>` 즉, 이름 없는 \"default\" 슬롯에 전달되겠네!\n\n그래도 여전히 의문이 남아있다. activator=\"{ on }\" 의 의미는 뭐지? `<v-btn>` 요소의 v-on 디렉티브에 on이 전달되는 데? 무슨 의미일까? 계속 슬롯에 대해 알아보자\n\n잠시 컴파일 범위를 짚고 넘어가보자.\n\n> 부모 템플릿 안에 있는 것은 부모 컴포넌트의 범위에 컴파일되고 자식 템플릿 안에 있는 것들은 자식 컴포넌트의 범위에 컴파일된다.\n\n무슨 의미인지 예제로 이해해보자. 우선 자식 컴포넌트를 살펴보자. 베이스 컴포넌트라고 이해해도 좋다. 일부러 아직 `<slot>` 요소를 넣지 않았다. 이 컴포넌트는 props로 items를 전달받고 v-for 디렉티브로 리스트 렌더링을 수행한다. 이 템플릿은 이 컴포넌트의 범위에서 컴파일된다. 즉, items는 이 컴포넌트 범위에 있으므로 `{{ item.name }}` 데이터 옵션이 정상적으로 'a', b', 'c'로 렌더링된다는 의미다.\n\n```ts\n    <template>\n    \t<ul>\n    \t\t<li v-for=\"item in items\" :key=\"item.name\">\n    \t\t\t{{ item.name }}\n    \t\t</li>\n    \t</ul>\n    </template>\n    <script>\n    export default {\n    \tprops: ['items']\n    }\n    /*\n    \titems = [\n    \t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t{ name: 'c', soldout: true, bestten: false  }\n    \t]\n    */\n    </script>\n```\n\n만약 어떤 컴포넌트에서는 soldout 이 true면 \"Sold Out a\" 이런식으로 렌더링하고 싶고 또 다른 컴포넌트에서는 bestten이 true인 아이템만 렌더링하고 싶다면? 물론 또 다른 props를 전달받아서 구분 값으로 사용하여 렌더링하는 방법도 있긴 하다. 하지만 item 속성에 따른 렌더링 방식에 더 다양해진다면 재사용성이 떨어질 것이다. 그럴 때 슬롯을 사용하면된다.\n\n하지만 부모 컴포넌트에서는 베이스 컴포넌트의 데이터를 사용할 수가 없다. items를 넘기므로 items야 물론 접근할 수 있다. 하지만 베이스 컴포넌트에서 렌더링되는 item에 접근할 수가 없는 거다. 컴파일 범위가 다르니 당연한 얘기다. 그럼 어떻게 해야할까? 바로 슬롯스코프를 사용하면 된다.\n\n```ts\n    <template>\n    \t<ul>\n    \t\t<li v-for=\"item in items\" :key=\"item.name\">\n    \t\t\t<slot name=\"item\" :item=\"item\">\n    \t\t\t\t{{ item.name }}\n    \t\t\t</slot>\n    \t\t</li>\n    \t</ul>\n    </template>\n    <script>\n    export default {\n    \tprops: ['items']\n    }\n    /*\n    \titems = [\n    \t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t{ name: 'c', soldout: true, bestten: false  }\n    \t]\n    */\n    </script>\n```\n\n위 코드의 `<slot name=\"item\" :item=\"item\">`에 주목해보자. 이렇게 item 속성으로 item 값을 내보냈다. 이렇게 `<slot>` 요소에 연결된 속성을 슬롯 속성(slot props)라고 한다. 이제 이 베이스 컴포넌트를 사용하는 부모 컴포넌트는 item에 접근할 수 있다. 아래는 베이스 컴포넌트를 사용하여 Sold Out 표시를 해주는 컴포넌트다. `<template v-slot:item=\"{ item }\">` 템플릿 v-slot에 슬롯 속성인 item을 쓰면 된다. 아래처럼 item의 slodout 속성에 접근할 수 있게 되었다.\n\n```ts\n    <template>\n    \t<ItemList v-bind:items=\"items\">\n    \t  <template v-slot:item=\"{ item }\">\n    \t    <span v-if=\"item.soldout\">Sold Out</span>\n    \t    {{ item.name }}\n    \t  </template>\n    \t</ItemList>\n    </template>\n    <script>\n    export default {\n    \tdata() {\n    \t\treturn {\n    \t\t\titems: [\n    \t\t\t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t\t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t\t\t{ name: 'c', soldout: true, bestten: false  }\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n    </script>\n```\n\n마찬가지로 bestten이 true인 경우에만 렌더링하는 컴포넌트에 사용할 수 있다.\n\n```ts\n    <template>\n    \t<ItemList v-bind:items=\"items\">\n    \t  <template v-slot:item=\"{ item }\">\n    \t    <span v-if=\"item.bestten\">{{ item.name }}</span>\n    \t  </template>\n    \t</ItemList>\n    </template>\n    <script>\n    export default {\n    \tdata() {\n    \t\treturn {\n    \t\t\titems: [\n    \t\t\t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t\t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t\t\t{ name: 'c', soldout: true, bestten: false  }\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n    </script>\n```\n\n사실 v-slot:item=\"{ item }\" 은 v-slot:item=\"slotProps\" 와 같은 데 ES6의 구조분해를 이용하여 { item } 처럼 사용한 거다.\n\n휴 거의 다했다. 이제 v-menu를 다시 살펴보자\n\n이제 v-menu 컴포넌트의 on(slotProps)를 부모 컴포넌트에서 사용할 수 있게 했구나. 라는 것이 이해될 것이다. 아마 v-menu에서 on은 이벤트 핸들러로 부모 컴포넌트에서 v-on 요소에 on을 연결하면 해당 컴포넌트가 클릭되면 default 슬롯이 보이도록 개발이 되어있을 것이다.\n\n```ts\n    <v-menu offset-y>\n    \t<template v-slot:activator=\"{ on }\">\n    \t  <v-btn\n    \t    color=\"primary\"\n          dark\n          v-on=\"on\"\n    \t   >\n    \t     Dropdown\n    \t\t </v-btn>\n       </template>\n       <v-list>\n         <v-list-item\n           v-for=\"(item, index) in items\"\n           :key=\"index\"\n           @click=\"\"\n         >\n           <v-list-item-title>{{ item.title }}</v-list-item-title>\n         </v-list-item>\n       </v-list>\n     </v-menu>\n```\n\n슬롯 정리 끝!\n"}}}},"pageContext":{"id":"cf3a7b61b8bfe799d47adca29daf2b3c341d13a4","previousPostId":"aca141df670b8b9c9474fa873d833730c6d80a8f","nextPostId":"146f5eb0b2e672cd66e3c67c69e36f8cac38be23"}},"staticQueryHashes":["2685952063","2841359383"]}