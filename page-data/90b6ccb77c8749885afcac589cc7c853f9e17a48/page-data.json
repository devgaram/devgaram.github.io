{"componentChunkName":"component---src-templates-blog-post-js","path":"/90b6ccb77c8749885afcac589cc7c853f9e17a48","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"90b6ccb77c8749885afcac589cc7c853f9e17a48","text":"# Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 2탄\n\n- Title : Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 2탄\n- Date : 2020-03-03\n- Category: Vue\n\n## Why?\n\n에 이어 오늘은 Typescript와 Vue를 설정할거다.\n\n## 5. Vue 설치 및 설정\n\n    npm install --save-dev vue vue-loader vue-template-compiler\n\n> vue 가 릴리즈 될 때 vue-template-compiler도 릴리즈된다. vue-template-compiler 버전이 vue 패키지와 동기되어야 vue-loader가 vue를 웹팩이 이해할 수 있는 코드로 생산할 수 있다. 즉 프로젝트에서 vue를 업그레이드 했으면 반드시 vue-template-compiler 버전도 맞춰줘야한다.\n\n- vue-loader : vue-loader는 rule 설정 외에 추가적으로 vue loader 플러그인을 설정해야한다. 예를 들어 **new VueLoaderPlugin()** 을 해야 .vue 파일의 `<script>` 블록이 웹팩의 /\\.js\\$/ 의 바벨 로더에도 적용될 수 있다.\n\nwebpack.config.js에 아래를 추가해주자.\n\n```js\nconst VueLoaderPlugin = require(\"vue-loader/lib/plugin\");\n\nmodule.exports = {\n  mode: \"development\",\n  plugins: [new VueLoaderPlugin()],\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: \"babel-loader\"\n      },\n      {\n        test: /\\.vue$/,\n        loader: \"vue-loader\"\n      }\n    ]\n  }\n};\n```\n\n.vue 파일의 `<style>` 블록과 .css 파일을 처리하기 위해 vue-style-loader와 css-loader 를 설치하자\n\n    npm install --save-dev vue-style-loader css-loader\n\nwebpack.config.js 파일에도 추가하자.\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\"vue-style-loader\", \"css-loader\"]\n      }\n    ]\n  }\n};\n```\n\nVue 루트 인스턴스를 `<div id=\"app\"></div>`에 마운트 시키려면 dist/index.html 에 위 DOM이 있어야 한다. 이 작업을 위해 public/index.html 파일을 만들고 아래와 같이 작성한다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Webpack App</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n  </body>\n</html>\n```\n\nwebpack.config.js의 HtmlWebpackPlugin에 template 옵션을 추가하여 위 html을 기반으로 index.html이 만들어지게 설정한다. npm run build를 해보면 dist/index.html 파일에 `<div id=\"app\"></div>`이 보일 것이다.\n\n```js\nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: \"public/index.html\"\n    })\n  ]\n};\n```\n\n테스트를 위해 간단히 vue-router가 적용된 vue앱을 만들어보자. 우선 vue-router을 설치한다.\n\n    npm install --save-dev vue-router\n\nsrc에 router/index.js 파일을 만들고 아래와 같이 입력한다.\n\n```js\n    // router/index.js\n    import Vue from \"vue\"\n    import VueRouter from \"vue-router\"\n    import Hello from \"../components/Hello.vue\"\n\n    Vue.use(VueRouter)\n\n    export default new VueRouter({\n      mode: \"history\",\n      base: process.env.BASE_URL,\n      routes: [\n        {\n          path: \"/\",\n          name: \"Hello\",\n          component: Hello\n        }\n      ]\n    })\n\n    // index.js\n    import Vue from \"vue\";\n    import App from \"./App.vue\";\n    import router from \"./router\";\n\n    new Vue({\n      render: h => h(App),\n      router\n    }).$mount(\"#app\");\n\n    // App.vue\n    <template>\n      <div id=\"app\">\n        <router-view></router-view>\n      </div>\n    </template>\n\n    // Hello.vue\n    <template>\n      <p>{{ greeting }} world!</p>\n    </template>\n    <script>\n    module.exports = {\n      data: function () {\n        return {\n          greeting: 'Hello'\n        }\n      }\n    }\n    </script>\n    <style scoped>\n    p {\n      font-size: 2em;\n      text-align: center;\n    }\n    </style>\n```\n\nnpm run start:dev 를 했을 때 아래 화면이 보이면 제대로 설정된 것이다.\n\n![Vue%20CLI%20Vue%20Typescript%20Babel%20Webpack%202/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Vue/images/2020-03-03-img/Untitled.png)\n\n**추가 설정**\n\nrouter/index.js 에서 import Hello from \"../components/Hello.vue\" 를 매번 ../ 식으로 쓰는 게 귀찮을 때! webpack resolve 설정을 통해 src를 기준으로 모듈을 찾을 수 있다. webpack.config.js 에 아래와 같이 추가하면 **import Hello from \"@/components/Hello.vue\"** 를 사용할 수 있다. 또 .vue 확장자를 빼고 입력하고 싶다면 extensions를 추가하면 된다. 웹팩이 알아서 파일 확장자를 처리해준다.\n\n```js\nmodule.exports = {\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"src\")\n    },\n    extensions: [\".js\", \".vue\"]\n  }\n};\n```\n\n- **resolve** : 모듈을 어떻게 처리할지 정의 만약 ES2015에서 import 'lodash' 를 사용한다면 웹팩에서 lodash를 어떻게 볼 것인지 lodash.js로 볼지 lodash.ts 로 볼 지 등을 정의한다.\n\n> 물론 이 외에도 설정할 게 많겠지만...... 일단은 여기까지 하고 Vue에서 Typescript 사용하는 방법을 이어가려고 한다. 나중에 이 설정을 기반으로 실제로 프로젝트를 진행하게 된다면 문제가 쏟아질 듯 싶다....\n\n## 6. Vue에서 Typescript 설치 및 설정\n\ntypescript와 ts-loader 패키지를 설치한다.\n\n    npm install --save-dev typescript ts-loader\n\n- typescript : 타입스크립트\n- ts-loader : 웹팩 로더 패키지\n\nwebpack.config.js 에 아래 내용을 추가한다. 이제 .vue 파일 안의 ts도 .ts 파일도 ts-loader에 의해 처리된다.\n\n```js\n    module.exports = {\n    \tentry: './src/index.ts',\n      module: {\n          {\n            test: /\\.ts$/,\n    \t\t\t\texclude: /node_modules/,\n            loader: 'ts-loader',\n            options: { appendTsSuffixTo: [/\\.vue$/] }\n          }\n        ]\n      },\n      resolve: {\n        extensions: ['.ts', 'tsx', '.js', '.vue']\n      }\n    };\n```\n\ntypescript 설정을 위해 프로젝트 루트 폴더에 tsconfig.json 파일을 생성하고 아래 내용을 입력한다.\n\n    {\n      \"compilerOptions\": {\n        \"outDir\": \"./dist/\",\n        \"strict\": true,\n        \"module\": \"es2015\",\n        \"target\": \"es5\",\n    \t\t\"moduleResolution\": \"node\",\n        \"sourceMap\": true,\n        \"allowSyntheticDefaultImports\": true\n      },\n      \"include\": [\n        \"src/**/*\"\n      ],\n      \"exclude\": [\n        \"node_modules\",\n        \"**/*.spec.ts\"\n      ]\n    }\n\n- allowSyntheticDefaultImports : export default 를 export 한 값들을 가지는 객체로 설정\n\n테스트를 위해 프로젝트 코드 수정하자. 우선 src/index.js, src/router/index.js → src/index.ts, src/router/index.ts 로 바꾼다. Hello.vue의 내용을 아래처럼 바꾼다. Vue 컴포넌트 안에서 Typescript를 사용하려면 Vue.component 또는 Vue.extend로 컴포넌트를 정의해야한다. 타입스크립트가 Vue 컴포넌트 타입 유추를 할 수 있게 하기 위해서다.\n\n```js\n    <template>\n      <p>{{ greeting }} world!</p>\n    </template>\n    <script lang=\"ts\">\n    import Vue from 'vue'\n    export default Vue.extend({\n      data: function () {\n        return {\n          greeting: 'Hello'\n        }\n      }\n    })\n    </script>\n    <style scoped>\n    p {\n      font-size: 2em;\n      text-align: center;\n    }\n    </style>\n```\n\n실행하려고 하면 .vue 파일이 import 되지 않는 오류를 발견할 것이다. ts 파일에 .vue 파일을 임포트하려면 추가적인 설정이 필요하다. src/shims-vue.d.ts 파일을 생성하여 이렇게 적자.\n\n```js\n    declare module \"*.vue\" {\n      import Vue from \"vue\";\n      export default Vue;\n    }\n```\n\n저장 후 실행해보면 잘된다.\n\n다음 TIL에서는 vue-class-component 데코레이터를 사용하여 컴포넌트를 선언할 때 클래스 기반 API를 이용하는 방식을 적용해봐야지!\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"eb4eae48978a7e276ad569a852c70fbe692ea9ad","text":"# [타입스크립트] 변수 선언과 타입\n\n- Title : [타입스크립트] 변수 선언과 타입\n- Date : 2020-03-08\n- Category: Typescript\n\n## 1. 변수 선언\n\n**var**\n\n- 호이스팅\n- 함수 레벨 스코프\n\n**let**\n\n- 변수를 초기화하기 전에는 변수에 접근할 수 없게 호이스팅 방지\n- 같은 블록 내에서 같은 이름의 변수 중복 선언 불가\n- 블록 레벨 스코프\n\n**const**\n\n- 호이스팅 안함\n- 블록 레벨 스코프\n- 변수를 상수로 선언할 때 사용(재할당되지 않는 읽기 전용 변수)\n- 객체로 초기화하는 경우 값 자체를 재할당할 수는 없으나 속성값의 변경은 허용\n\n> 호이스팅 - 선언한 변수가 스코프의 최상위로 끌어올림 되는 현상\n\n## 2. 타입 검사\n\n**정적 타입 검사**\n\n- 컴파일 타임에 타입 검사\n- 타입 검사하는 데 시간은 들지만 안정성 보장\n- 자바, C++\n\n**동적 타입 검사**\n\n- 실행 시간에 타입 검사 수행\n- 동적 타이핑 수행\n  - 동적 타이핑 : 값을 변수에 할당할 때 타입이 정해지는 것\n- 자바스크립트\n\n**점진적 타입 검사**\n\n- 컴파일 시간에 타입 검사를 수행\n- 타입 선언 생략 허용\n  - 생략시 암시적 형변환 발생\n  - 암시적 형변환 : 컴파일러가 알아서 데이터 타입 변환\n- 여러 타입을 결합해 새로운 타입을 정의하는 것 허용\n- 타입스크립트, 파이썬\n\n## 3. 타입 계층도\n\n- 타입스크립트는 자바스크립트에서 지원하는 내장 타입을 제공하며 크게 기본 타입, 객체 타입, 함수 타입이 있다.\n\n![200308/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Typescript/images/2020-03-08-img/Untitled.png)\n\n## 4. Primitive(기본) 타입\n\n### 1) string, number, boolean 타입\n\n```ts\n// string\nlet name: string = \"rami\"; // 큰 따옴표 사용 권장\nlet sentence: string = `안녕하세요 ${name}입니다.`;\n\n// number\nlet decimal: number = 6;\nlet hex: number = 0xf00d;\nlet binary: number = 0b1010;\nlet octal: number = 0o744;\n\n// boolean\nlet isShow: boolean = false;\n```\n\n### 2) enum 열거 타입\n\n- numberic 값 집합에 친숙한 이름을 부여하는 방법\n- 기본적으로 멤버 번호는 0부터 시작\n- 수동으로 값을 변경할 수도 있음\n\n```ts\nenum Color {\n  Red,\n  Green,\n  Blue\n}\nlet c: Color = Color.Green;\nconsole.log(c); // 1\nconsole.log(typeof Color); // object\n\n// 0대신 1로 시작할 수 있게 --> 1, 2, 3\nenum Color {\n  Red = 1,\n  Green,\n  Blue\n}\nlet c: Color = Color.Green;\n\n// 열거 형 모든 값 수동 설정\nenum Color {\n  Red = 1,\n  Green = 2,\n  Blue = 4\n}\nlet c: Color = Color.Green;\n\n// 2가 Color enum의 어떤 값과 매핑되는 지 모를 때 이름을 찾을 수 있음\nenum Color {\n  Red = 1,\n  Green,\n  Blue\n}\nlet colorName: string = Color[2];\nconsolo.log(colorName); // Green\n```\n\n**const enum**\n\n- 일반 열거형과 달리 컴파일하는 동안 완전히 제거됨\n\n```ts\n// typescript\nenum WeekDay {\n  Mon = 1,\n  Tue,\n  Wed,\n  Thu\n}\nconsole.log(WeekDay.Mon); // 1\nconsole.log(WeekDay[\"Mon\"]); // 1\nconsole.log(WeekDay[WeekDay.Mon]); // Mon\nlet day = WeekDay;\n// enum 객체의 키는 속성의 인덱스, 속성의 이름이 된다.\n// 따라서 객체에 할당되는 속성의 수는 enum 객체의 속성 개수보다 2배 많다.\nconsole.log(day); // {1: \"Mon\", 2: \"Tue\", 3: \"Wed\", 4: \"Thu\", Mon: 1, Tue: 2, Wed: 3, Thu: 4}\n\n// 컴파일 후 ES5\n\"use strict\";\nvar WeekDay;\n(function(WeekDay) {\n  WeekDay[(WeekDay[\"Mon\"] = 1)] = \"Mon\";\n  WeekDay[(WeekDay[\"Tue\"] = 2)] = \"Tue\";\n  WeekDay[(WeekDay[\"Wed\"] = 3)] = \"Wed\";\n  WeekDay[(WeekDay[\"Thu\"] = 4)] = \"Thu\";\n})(WeekDay || (WeekDay = {}));\n```\n\n```ts\n// typescript\nconst enum WeekDay {\n  Mon = 1,\n  Tue,\n  Wed,\n  Thu\n}\nconsole.log(WeekDay.Mon); // 1\nconsole.log(WeekDay[\"Mon\"]); // 1\nconsole.log(WeekDay[WeekDay.Mon]); // 에러, 문자열 리터럴을 이용해서만 접근 가능\nlet day = WeekDay; // 에러, 속성 또는 인덱스 표현식으로만 가능\n// 컴파일 후 ES5\n\"use strict\";\n```\n\n**기타 enum**\n\n```ts\n// 초기값으로 문자열 할당 가능\nenum WeekDay {\n  Mon = \"MON\",\n  Tue = \"TUE\",\n  Wed = \"WED\",\n  Thu = \"TUE\"\n}\nconsole.log(WeekDay.Mon); // MON\nconsole.log(WeekDay[\"Mon\"]); // MON\n// 리버스 매핑 적용 안됨\n// 문자열 할당하면 속성 값으로 속성 이름 알 수 없음\nconsole.log(WeekDay[WeekDay.Mon]); // 에러,\n\n// 문자열 또는 숫자 섞어서 가능\nenum WeekDay {\n  Mon = \"MON\",\n  Tue = 1,\n  Wed = \"WED\",\n  Thu = \"TUE\"\n}\n\n// boolean, 표현식 불가능\nenum WeekDay {\n  Mon = \"MON\",\n  Tue = 1,\n  Wed = true,\n  Thu = \"TUE\"\n}\nenum WeekDay {\n  Mon = \"MON\",\n  Tue = 1,\n  Wed = 1 + 2,\n  Thu = \"TUE\"\n}\n```\n\n### 3) symbol 타입\n\n- Symbol 생성자를 호출하여 생성\n- 불변 고유\n- 심벌 객체는 호출될 때마다 새로운 심벌 객체를 만듬\n- 객체 리터럴의 속성 키로 사용할 수 있음\n\n```ts\nlet hello = Symbol(\"key\");\nlet hello2 = Symbol(\"key\");\nconsole.log(hello === hello2); // false\nconsole.log(hello, hello2); // Symbol(key) Symbol(key)\nconsole.log(typeof hello); // symbol\n\nlet uniqueKey = Symbol();\nlet obj = {\n  [uniqueKey]: 1234,\n  title: \"hi\"\n};\nconsole.log(obj.uniqueKey); // undefined\nconsole.log(obj.title); // hi\nconsole.log(obj); // {title: \"hi\", Symbol(): 1234}\n```\n\n### 4) string literal 타입\n\n```ts\n// 사용자 정의 타입에 정의한 문자열만 할당 받을 수 있음\ntype EventType = \"keyup\" | \"mouseover\";\n```\n\n## 5. Object(객체) 타입\n\n### 1) Array(배열) 타입\n\n- 타입스크립트에서 배열 타입은 배열 타입과 제네릭 배열 타입으로 나뉜다\n\n```ts\nlet arr: string[] = [\"a\", \"b\", \"c\"];\nlet arr2: Array<string> = [\"a\", \"b\", \"c\"];\n```\n\n**배열 타입**\n\n- 요소 타입으로 string, boolean, number와 같은 자바스크립트 내장 타입뿐 아니라 클래스나 인터페이스도 올 수 있음\n\n```ts\nlet items: number[] = [1, 2, 3];\nlet fruits: string[] = [];\nfruits.push(\"banana\");\nfruits.push(\"apple\");\n\n// any 타입 지정하면 어떤 타입이든 배열의 요소로 추가 가능\nlet myVar: any[] = [1, \"hi\", true];\n\n// 유니언 타입\nlet myVar: (number | string | boolean)[] = [1, \"hi\", true];\n```\n\n**제네릭 배열**\n\n- Array<T> 형태로 선언 (T: 타입)\n- 제네릭 타입 인수로 사용된 타입은 컴파일 시점에 타입을 검사함\n\n```ts\nlet num: Array<number> = [1, 2, 3];\nlet num: Array<number | string> = [1, \"hello\"];\nlet num2: typeof num = [1, \"hello\"]; // 타입 쿼리로 num 변수의 타입을 참조\n\n// 배열요소로 익명 함수 받으려면\nlet nums: Array<() => string> = [() => \"one\", () => \"two\"];\nconsole.log(nums[0]()); // one 출력\n\n// 배열 선언 부분과 요소 추가하는 부분 분리\nlet num3: Array<number> = new Array<number>();\nnum3.push(1);\nnum3.push(2);\nnum4.push(3);\n```\n\n타입스크립트에서 배열 타입이든 제네릭 타입이든 컴파일 시 타입 검사를 위해 필요하며 컴파일 후(ES5)에는 타입이 제거된 배열만 남는다.\n\n### 2) Tuple(튜플) 타입\n\n- 배열 요소가 n개로 정해질 때 각 요소별로 타입을 지정함\n\n```ts\nlet x: [string, number];\nx = [\"tuple\", 100]; // 성공\nx = [10, \"tuple\"]; // 에러\nconsole.log(typeof x, typeof x[0], typeof x[1]); // object string number\nconsole.log(x[0].substring(1)); // uple\nconsole.log(x[1].substring(1)); // 에러\nx[3] = \"world\"; // 에러 - [string, number] 타입에서 3번째 속성이 없어서\n```\n\nFunction, 생성자, Class, Interface는 추후 정리\n\n## 6. Union 타입\n\n2개 이상의 타입을 하나의 타입으로 정의\n\n```ts\nlet x: string | number;\n```\n\n## 7. Intersection 타입\n\n두 타입을 합쳐 하나로 만들 수 있는 타입\n\n```ts\ninterface Cat {\n  leg: number;\n}\ninterface Bird {\n  wing: number;\n}\nlet birdCat: Cat & Bird = { leg: 4, wing: 2 };\n```\n\n## 8. Void 타입\n\n- 빈 값을 나타내는 타입\n- 함수의 반환값이 없을 때\n- null이나 undefined만 할당 가능\n  - void 타입이 null, undefined의 상위 타입이기 때문\n\n```ts\n// 반환값이 없는 함수\nfunction say(): void {\n  alert(\"hello!\");\n}\n// 반환값은 void이지만 실제로는 undefined가 할당됨\nlet mySay: void = say();\n\n// 변수에 undefined나 null 할당 -> 비추\nlet unusable: void = undefined;\nlet unusable; // 위 코드와 같은 의미\nlet unusable = null; // 쓰지 말자\n```\n\n> 변수를 선언할 때 값을 할당하지 않았음을 나타내기 위해 선언한 변수에 null을 할당하는 것은 권장하지 않음\n\n- null이나 undefined를 할당하면 컴파일러 오류가 발생하도록 tsconfig.json에 아래와 같이 설정한다.\n\n```ts\n    {\n    \t\"compilerOptions\": {\n    \t\t\"strictNullChecks\": true\n    \t}\n    }\n```\n\n## 9. null과 undefined 타입\n\n- 둘다 모든 타입의 하위타입\n- undefined는 선언은 됐지만 값이 할당되지 않은 것\n- null은 값은 할당됐지만 값이 빈 객체로 초기화되는 것\n\n```ts\nlet person = { name: \"happy\" };\nperson = null;\nconsole.log(typeof person); // object\n\n// undefined vs null\nlet testUndefined;\nconsole.log(testUndefined, typeof testUndefined); // undefined 'undefined'\n\nlet testUndefined2: undefined = undefined;\nconsole.log(testUndefined2, typeof testUndefined2); // undefined 'undefined'\n\nlet testNull: null = null;\nconsole.log(testNull, typeof testNull); // null 'object'\n\n// 비교\nconsole.log(undefined === null); // false\nconsole.log(undefined == null); // true\nconsole.log(undefined == undefined); // true\n```\n\n## 10. Any 타입\n\n- 제약이 없는 타입으로 어떤 타입의 값도 받아들일 수 있음\n- 최소한의 정적 타입 검사만 수행\n- 외부라이브러리의 연산 결과를 받는 것과 같이 타입 결과를 예측할 수 없을 때\n- 배열 값의 타입이 다양해서 한 가지 타입으로 고정할 수 없을 때\n\n```ts\nlet basket: any = 10;\nbasket = true;\nbasket = \"banana\";\nconsole.log(basket);\n\nlet vList: any[] = [1, false, \"happy\"];\nconsole.log(vList[0]);\n```\n\n### 1) **최소한의 정적 타입 검사...?**\n\n- any 타입으로 선언된 변수는 최소한의 정적 타입 검사만 수행\n\n아래 예를 보면 any 타입으로 선언한 경우, 존재하지않는 함수를 호출할 때 컴파일 에러는 안나지만 런타임 에러가 난다. 속성의 유무를 런타임 시에 검사하나보다..\n\n```ts\nlet number = 50;\nlet number2: any = 50;\n\nconsole.log(number.toFixed(2)); // 50.00\nconsole.log(number2.toFixed(2)); // 50.00\n\nnumber.notExistMethod(); // 컴파일 타임에 에러\nnumber2.notExistMethod(); // 컴파일 에러는 안나지만 런타임 에러\n```\n\n### 2) object 타입과의 차이...?\n\nobject도 any 처럼 타입 구분 없이 값을 할당할 수 있는 특성이 있다. 하지만 속성 유무를 검사하는 시간이 다름. any는 런타임 시에 검사, object는 컴파일 시간에 속성 유무 검사\n\n```ts\nlet number2: Object = 50;\n// 변수에 할당된 타입이 number인지 string인지 몰라서 컴파일 에러 뱉음\nnumber2.toFixed(1); // property 'toFixed' does not exist on type 'Object'\n```\n\n### 3) 비교\n\n```ts\nlet number1 = 50;\nlet number2: any = 50;\nlet number3: Object = 50;\nconsole.log(typeof number1); // number\nconsole.log(typeof number2); // number\nconsole.log(typeof number3); // number\nconsole.log(number1.toFixed(2)); // 50.00\nconsole.log(number2.toFixed(2)); // 50.00\nconsole.log(number3.toFixed(2)); // 컴파일 에러, Object에 tofixed가 없음\n```\n\n### 4) noImplicitAny 옵션\n\n타입을 생략하면 명시적으로 any 타입이 된다. any 타입임을 추론할 수는 있지만, 명시적으로 any 타입임을 선언하는 것이 더 명확하므로 any 타입을 강제하는 게 좋다. 이는 tsconfig.json 파일에서 noImplicitAny 속성을 true로 하면 된다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"5d8f5742317fc2443a1810a411eb106b455e189d","text":"# Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 1탄\n\n- Title : Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 1탄\n- Date : 2020-02-29\n- Category: Vue\n\n## Why?\n\nVue CLI로 프로젝트를 생성해왔는데 문뜩 웹팩과 바벨에 대한 이해가 부족한듯 싶었다. 그래서😎 오늘은 Vue, Typescript, Babel, Webpack을 사용해서 Vue CLI 없이 프로젝트를 설정해보면서 공부한 내용을 정리해보기로 했다. 1탄은 웹팩과 바벨에 대한 설정과 개념을 잡아보고 2탄에서 Vue와 Typescript 설정을 진행할 거다.\n\n## 1. 프로젝트 생성\n\n```\n    $ mkdir vue-typescript\n    $ cd vue-typescript\n    $ mkdir src\n    $ cd src\n    $ mkdir components\n    $ cd ..\n```\n\n## 2. package.json 파일 생성\n\n> **npm(node package manager)** 은 자바스크립트 패키지 매니저다. Node.js에서 사용할 수 있는 모듈들을 패키지화하여 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI(Common line interface)를 제공한다. 비슷한 패키지 매니저인 페이스북이 만든 **yarn**은 npm보다 더 빠르고 안전하다. 둘 다 package.json 파일에 선언된 semver rule을 만족하는 최신 버전을 설치한다.\n\n```\n    $ npm init\n```\n\n**package.json란?**\n\n- 프로젝트가 의존하고 있는 패키지들의 리스트를 보여준다.\n- semantic versioning rule에 따라 프로젝트에 의존한 패키지들의 버전을 설정할 수 있다.\n- 빌드를 재현할 수 있어 좀 더 쉽게 다른 개발자와 공유할 수 있다.\n\n> **—save-dev** 란? —production 빌드 시 포함될 필요가 없는 패키지는 —save-dev 옵션을 사용하여 package.json의 devDependencies에 패키지 정보를 저장한다.\n\n## 3. Webpack 설치 및 초기 설정\n\n> 웹팩은 자바스크립트 애플리케이션을 위한 **정적 모듈 번들러**다. 자바스크립트 코드를 하나의 파일로 관리하는 것과 여러개의 파일로 관리하는 것은 각각 단점이 있다. 우선 각 파일을 브라우저에 로딩하면 그만큼 네트워크 비용이 커진다. 또한 각 파일이 서로의 스코프를 침범하여 변수 충돌의 위험이 생길 수도 있다. 물론 해결 방법이 있다. 자바스크립트는 함수 스코프를 사용하니 즉시호출함수를 사용해 모듈을 만들면 된다. 그러나 모듈을 모두 즉시호출함수로 변경하여 하나의 파일로 묶는 것을 일일이 작업하면 귀찮지않을까? 웹팩이 등장한 배경이 바로 여기에 있다.\n\n    npm install --save-dev webpack webpack-cli webpack-dev-server html-webpack-plugin\n\n- webpack : 웹팩\n- webpack-cli : 커맨드 라인에서 웹팩을 구동시키기위한 패키지\n- webpack-dev-server : 실시간 리로드를 제공하는 개발 서버로 localhost에서 테스트하고 싶을 때 사용\n- html-webpack-plugin : 웹팩 번들을 서비스하기 위한 HTML 파일을 만들어주는 패키지로 컴파일할 때마다 이름이 변하는 번들파일을 HTML 파일에 넣어줄 때 유용하다.\n\n설치가 완료되면 src 폴더에 index.js 파일을 만들고 package.json 파일의 scripts에 **\"build\": \"webpack\"** 와 **\"start:dev\": \"webpack-dev-server\"** 를 추가한다.\n\n```\n    {\n      \"name\": \"vue-typescript\",\n      \"version\": \"1.0.0\",\n      \"description\": \"\",\n      \"main\": \"index.js\",\n      \"scripts\": {\n    \t\t\"start:dev\": \"webpack-dev-server\",\n    \t\t\"build\": \"webpack\",\n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n      },\n      \"author\": \"\",\n      \"license\": \"ISC\",\n      \"devDependencies\": {\n        \"html-webpack-plugin\": \"^3.2.0\",\n        \"webpack\": \"^4.42.0\",\n        \"webpack-cli\": \"^3.3.11\",\n        \"webpack-dev-server\": \"^3.10.3\"\n      }\n    }\n```\n\n웹팩4는 webpack.config.js 파일이 없어도 파일을 번들할 수 있다. 커맨드 라인에서 **npm run build** 를 치면 dist 폴더에 번들된 파일인 main.js를 볼 수 있다. 또한 **npm run start:dev** 로 치면 8080포트로 개발서버가 동작한다. 하지만 index.html 파일이 없어서 localhost:8080에서 제대로 된 화면을 볼 수 없다. index.html 파일을 직접 dist 폴더에 만들어서 main.js 파일을 **<script src=\"main.js\"></script>** 로 로딩시켜서 동작시킬 수는 있다. 하지만 번들 파일의 이름이 매번 바뀐다면? 또 번들 파일이 많다면? 매우 귀찮을 거다. 그래서 **html-webpack-plugin** 을 이용하여 자동으로 index.html 파일을 생성시키고 번들 파일들을 주입시킬 거다. 설정을 위해 프로젝트 루트에 프로젝트 루트에 webpack.config.js 파일을 생성한 후 아래와 같이 작성한다.\n\n```js\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  entry: \"./src/index.js\",\n  plugins: [new HtmlWebpackPlugin()],\n  output: {\n    filename: \"main.js\",\n    path: path.resolve(__dirname, \"dist\")\n  }\n};\n```\n\n- **entry** : 자바스크립트가 로딩하는 모듈이 많아질수록 모듈간의 의존성은 증가한다. 웹팩에서 의존성 그래프의 시작점을 엔트리(entry)라고 한다.\n- **output** : entry에 설정한 main.ts을 시작으로 의존되어있는 모든 모듈을 하나로 묶은(번들된) 결과의 위치를 output에 정의한다. webpack을 실행하면 /dist 폴더에 main.bundle.js란 이름으로 파일이 생성될 것이다.\n\n**npm run build** 를 실행시키면 dist 폴더에 index.html 파일이 생성되고 `<script type=\"text/javascript\" src=\"main.js\">`로 번들 파일이 주입된다.\n\nwebpack-dev-server 에 대한 추가적인 설정을 하려면 devServer 옵션을 이용하면 된다.\n\n```js\nmodule.exports = {\n  devServer: {\n    hot: true,\n    contentBase: path.join(__dirname, \"dist\"),\n    compress: true,\n    port: 9000\n  }\n};\n```\n\nhot: true 는 핫로더, contentBase는 대상 위치, compress는 파일 gzip 압축, port는서버 포트 설정이다.\n\n[DevServer | webpack](https://webpack.js.org/configuration/dev-server/)\n\n    DevTools failed to parse SourceMap: webpack:///node_modules/sockjs-client/dist/sockjs.js.map\n\n[localhost:9000](http://localhost:9000) 에서 콘솔 창을 확인하면 devtools을 설정하지 않아 위와 같은 경고 문구가 뜬다. devtools 옵션으로 소스맵 생성을 정의할 수 있다. 소스맵은 번들링된 파일과 원래 파일을 맵핑하여 에러 추적할 때 용이하다. 예를 들어 세개의 js 파일을 번들링한 main.js 파일이 있다고 하자. 콘솔 창을 확인해보니 main.js 파일에서 에러가 났다. 만약 소스맵을 사용하지않는다면 세 개의 파일 중 어디서 에러가 났는 지 알 수가 없다. _여러가지 종류가 있지만 inline-source-map 을 추천한다길래 얘를 사용했다. 나중에 각 옵션의 차이점도 알아봐야겠다._\n\n```js\nmodule.exports = {\n  devtool: \"inline-source-map\"\n};\n```\n\n## 4. Babel로 ES6를 ES5로 변환하기\n\n> 구형 브라우저(IE)에서는 ES6 코드가 호환되지 않는다. 그렇다고 ES5로 코드를 짤 수도 없는 노릇. ES2015+ 문법을 ES5로 바꿔주는 녀석이 없을까? 바로 바벨이 그 역할을 한다.\n\n먼저 바벨 패키지를 설치한다.\n\n```\n    npm install --save-dev babel-loader @babel/core @babel/preset-env\n```\n\n- babel-loader : 웹팩에서 ES6로 된 파일을 ES5로 변환할 때 사용\n- @babel/core\n\n웹팩에게 빌드하기전 자바스크립트 파일을 ES5로 트랜스파일링하라고 말해야한다. 웹팩의 Loaders를 이용하여 이를 설정할 수 있다.\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: \"babel-loader\"\n      }\n    ]\n  }\n};\n```\n\n- **loader** : 웹팩은 자바스크립트, 이미지, 폰트, 스타일시트도 전부 모듈로 관리한다. 하지만 웹팩은 자바스크립트만 아는 녀석이라서 웹팩이 자바스크립트 파일이 아닌 파일들을 이해할 수 있게끔 변경해야하는데 로더(loader)가 그런 역할을 한다. 위 코드를 보면 test에 로딩할 파일, use에 적용할 로더, exclude는 제외할 파일를정의한 것을 알 수 있다.\n\n바벨 설정을 완료했지만 사실 바벨은 아무 것도 하지않는다. 프로젝트 루트에 .babelrc 파일을 만들어 설정을 해야한다. 그 전에 ES2015+를 트랜스파일링하기위해 필요한 프리셋과 플러그인을 모은 모듈을 다운받는다. @babel/preset-env는 자동으로 브라우저 polyfill 을 맞춘다.\n\n    npm install @babel/preset-env --save-dev\n\n.babelrc에 아래와 같이 입력한다.\n\n    {\n      \"presets\": [\"@babel/preset-env\"]\n    }\n\n따로 .babelrc 파일을 만들지않고 웹팩에서도 설정 가능하다.\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: \"babel-loader\",\n          options: {\n            presets: [\"@babel/preset-env\"]\n          }\n        }\n      }\n    ]\n  }\n};\n```\n\n실제로 트랜스파일링되는지 테스트하기위해 index.js에 아래와 같이 작성하고 npm run build하면 es5 문법으로 바뀐 것을 알 수 있다.\n\n```js\nconst myconst = 123;\nlet mylet = 456;\n```\n\n![Vue%20CLI%20Vue%20Typescript%20Babel%20Webpack%201/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Vue/images/2020-02-29-img/Untitled.png)\n\n추가로 @babel/preset-env에서 타켓에 옵션으로 브라우저 버전을 직접 설정할 수도 있다. options을 쓰거나 package.json에 작성하는 방법도 있지만 공식문서는 **.browserslistrc** 파일을 만들어서 설정하는 것을 추천하고 있다. 프로젝트 루트 폴더에 .browserslistrc를 만든 후 아래의 내용을 작성하자. 각 브라우저에서 최근 2개의 버전까지, 1% 이상 사용되는 브라우저를 타켓으로 한다. 디폴트는 _> 0.5%, last 2 versions, Firefox ESR, not dead_ 다.\n\n    > 1%\n    last 2 versions\n\n### ES6 메서드나 생성자 지원하려면?\n\nindex.js 에 console.log(Array.from('foo')); 을 입력한 후 IE11에서 확인해보자.\n\n```js\nconsole.log(Array.from(\"foo\"));\n```\n\n콘솔 창을 보면 개체가 'from' 속성이나 메서드를 지원하지 않습니다. 라는 에러 문구를 보게될 것이다. 바벨로 ES5로 바꿨는 데 왜 그러지??? 라는 혼란이 생길 것이다.😨😨\n\n방금까지는 바벨을 이용하여 ES6 문법을 ES5로 문법 트랜스파일링만 한 거다. 그래서 Array.from()과 같이 ES6에만 있는 메서드나 생성자들은 구형 브라우저에서 동작하지 않는다. 이 문제를 해결하기 위해polyfill을 사용한다. **polyfill**은 code 조각으로 런타임에 존재하지 않는 nativeAPI의 복사본을 말한다. @babel/polyfill이나 @babel/plugin-transform-runtime를 사용하면 되지만 **@babel/polyfill** 은 7.4.0부터 deprecated 되서 **core-js@3**를 사용하는 것을 추천한다.\n\n**Babel-Polyfill vs Babel-Transform-Runtime**\n\n- Babel-Polyfill은 전역적으로 polyfill을 사용하여 전역 스코프를 오염시킬 수 있다. 또한 번들 파일에 포함되고 코드 상단에 **import 'babel-polyfill';** 을 추가해야 사용할 수 있다. 프로젝트에서 전역적으로 polyfill을 사용하거나 라이브러리 규모가 클 경우에 사용하는 게 유리하다.\n- Babel-Transform-Runtime는 플러그인으로 추가하면 되고 기능은babel-polyfill과 거의 비슷하나 array.includes()와 array.values() 같은 특정 함수를 제공하지않는다. core-js@3과 함께 사용하면 이 문제를 해결할 수 있다. 간단하게 라이브러리에서 사용하는 API를 래핑시킬 때 좋다.\n\n여기서는 core-js@3를 사용하며 @babel/preset-env의 옵션으로 폴리필을 설정한다. 우선 core-js를 설치해주자.\n\n    npm install core-js@3 --save\n\n.babelrc에 아래와 같이 추가한다. \"useBuiltIns\": \"usage\"는 트랜스파일 시 소스에서 쓰는 폴리필을 자동으로 넣어준다.\n\n    {\n      \"presets\": [\n        [\n          \"@babel/preset-env\",\n          {\n            \"useBuiltIns\": \"usage\",\n            \"corejs\": {\n              \"version\": 3,\n              \"proposals\": true\n            }\n          }\n        ]\n      ]\n    }\n\n구글 크롬 브라우저에 들어가보면 아래와 같이 트랜스 파일링 된 것을 알 수 있다.\n\n```js\n    /***/ \"./src/index.js\":\n    /*!**********************!*\\\n      !*** ./src/index.js ***!\n      \\**********************/\n    /*! no exports provided */\n    /***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n    \"use strict\";\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony import */ var core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.from */ \"./node_modules/core-js/modules/es.array.from.js\");\n    /* harmony import */ var core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0__);\n    /* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.string.iterator */ \"./node_modules/core-js/modules/es.string.iterator.js\");\n    /* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_1__);\n\n\n    console.log(Array.from('foo'));\n\n    /***/ }),\n```\n\nIE 11에서도 폴리필하려면 브라우저 타켓에 IE 11을 추가해야한다. .browserslistrc에 아래와 같이 추가하고 IE 브라우저를 확인하면 잘 동작하는 것을 볼 수 있다.\n\n    > 1%\n    last 2 versions\n    IE 11\n\n**참고**\n\n[웹팩의 기본 개념](http://jeonghwan-kim.github.io/js/2017/05/15/webpack.html)\n\n[[Tool] (번역)Babel에 대한 모든 것](https://jbee.io/etc/Everything-about-babel/)\n"}}}},"pageContext":{"id":"90b6ccb77c8749885afcac589cc7c853f9e17a48","previousPostId":"eb4eae48978a7e276ad569a852c70fbe692ea9ad","nextPostId":"5d8f5742317fc2443a1810a411eb106b455e189d"}},"staticQueryHashes":["2841359383"]}