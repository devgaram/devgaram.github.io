{"componentChunkName":"component---src-templates-blog-post-js","path":"/90b6ccb77c8749885afcac589cc7c853f9e17a48","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"90b6ccb77c8749885afcac589cc7c853f9e17a48","text":"# Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 2탄\n\n- Title : Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 2탄\n- Date : 2020-03-03\n- Category: Vue\n\n## Why?\n\n에 이어 오늘은 Typescript와 Vue를 설정할거다.\n\n## 5. Vue 설치 및 설정\n\n    npm install --save-dev vue vue-loader vue-template-compiler\n\n> vue 가 릴리즈 될 때 vue-template-compiler도 릴리즈된다. vue-template-compiler 버전이 vue 패키지와 동기되어야 vue-loader가 vue를 웹팩이 이해할 수 있는 코드로 생산할 수 있다. 즉 프로젝트에서 vue를 업그레이드 했으면 반드시 vue-template-compiler 버전도 맞춰줘야한다.\n\n- vue-loader : vue-loader는 rule 설정 외에 추가적으로 vue loader 플러그인을 설정해야한다. 예를 들어 **new VueLoaderPlugin()** 을 해야 .vue 파일의 `<script>` 블록이 웹팩의 /\\.js\\$/ 의 바벨 로더에도 적용될 수 있다.\n\nwebpack.config.js에 아래를 추가해주자.\n\n```js\nconst VueLoaderPlugin = require(\"vue-loader/lib/plugin\");\n\nmodule.exports = {\n  mode: \"development\",\n  plugins: [new VueLoaderPlugin()],\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: \"babel-loader\"\n      },\n      {\n        test: /\\.vue$/,\n        loader: \"vue-loader\"\n      }\n    ]\n  }\n};\n```\n\n.vue 파일의 `<style>` 블록과 .css 파일을 처리하기 위해 vue-style-loader와 css-loader 를 설치하자\n\n    npm install --save-dev vue-style-loader css-loader\n\nwebpack.config.js 파일에도 추가하자.\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\"vue-style-loader\", \"css-loader\"]\n      }\n    ]\n  }\n};\n```\n\nVue 루트 인스턴스를 `<div id=\"app\"></div>`에 마운트 시키려면 dist/index.html 에 위 DOM이 있어야 한다. 이 작업을 위해 public/index.html 파일을 만들고 아래와 같이 작성한다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Webpack App</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n  </body>\n</html>\n```\n\nwebpack.config.js의 HtmlWebpackPlugin에 template 옵션을 추가하여 위 html을 기반으로 index.html이 만들어지게 설정한다. npm run build를 해보면 dist/index.html 파일에 `<div id=\"app\"></div>`이 보일 것이다.\n\n```js\nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: \"public/index.html\"\n    })\n  ]\n};\n```\n\n테스트를 위해 간단히 vue-router가 적용된 vue앱을 만들어보자. 우선 vue-router을 설치한다.\n\n    npm install --save-dev vue-router\n\nsrc에 router/index.js 파일을 만들고 아래와 같이 입력한다.\n\n```js\n    // router/index.js\n    import Vue from \"vue\"\n    import VueRouter from \"vue-router\"\n    import Hello from \"../components/Hello.vue\"\n\n    Vue.use(VueRouter)\n\n    export default new VueRouter({\n      mode: \"history\",\n      base: process.env.BASE_URL,\n      routes: [\n        {\n          path: \"/\",\n          name: \"Hello\",\n          component: Hello\n        }\n      ]\n    })\n\n    // index.js\n    import Vue from \"vue\";\n    import App from \"./App.vue\";\n    import router from \"./router\";\n\n    new Vue({\n      render: h => h(App),\n      router\n    }).$mount(\"#app\");\n\n    // App.vue\n    <template>\n      <div id=\"app\">\n        <router-view></router-view>\n      </div>\n    </template>\n\n    // Hello.vue\n    <template>\n      <p>{{ greeting }} world!</p>\n    </template>\n    <script>\n    module.exports = {\n      data: function () {\n        return {\n          greeting: 'Hello'\n        }\n      }\n    }\n    </script>\n    <style scoped>\n    p {\n      font-size: 2em;\n      text-align: center;\n    }\n    </style>\n```\n\nnpm run start:dev 를 했을 때 아래 화면이 보이면 제대로 설정된 것이다.\n\n![Vue%20CLI%20Vue%20Typescript%20Babel%20Webpack%202/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Vue/images/2020-03-03-img/Untitled.png)\n\n**추가 설정**\n\nrouter/index.js 에서 import Hello from \"../components/Hello.vue\" 를 매번 ../ 식으로 쓰는 게 귀찮을 때! webpack resolve 설정을 통해 src를 기준으로 모듈을 찾을 수 있다. webpack.config.js 에 아래와 같이 추가하면 **import Hello from \"@/components/Hello.vue\"** 를 사용할 수 있다. 또 .vue 확장자를 빼고 입력하고 싶다면 extensions를 추가하면 된다. 웹팩이 알아서 파일 확장자를 처리해준다.\n\n```js\nmodule.exports = {\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"src\")\n    },\n    extensions: [\".js\", \".vue\"]\n  }\n};\n```\n\n- **resolve** : 모듈을 어떻게 처리할지 정의 만약 ES2015에서 import 'lodash' 를 사용한다면 웹팩에서 lodash를 어떻게 볼 것인지 lodash.js로 볼지 lodash.ts 로 볼 지 등을 정의한다.\n\n> 물론 이 외에도 설정할 게 많겠지만...... 일단은 여기까지 하고 Vue에서 Typescript 사용하는 방법을 이어가려고 한다. 나중에 이 설정을 기반으로 실제로 프로젝트를 진행하게 된다면 문제가 쏟아질 듯 싶다....\n\n## 6. Vue에서 Typescript 설치 및 설정\n\ntypescript와 ts-loader 패키지를 설치한다.\n\n    npm install --save-dev typescript ts-loader\n\n- typescript : 타입스크립트\n- ts-loader : 웹팩 로더 패키지\n\nwebpack.config.js 에 아래 내용을 추가한다. 이제 .vue 파일 안의 ts도 .ts 파일도 ts-loader에 의해 처리된다.\n\n```js\n    module.exports = {\n    \tentry: './src/index.ts',\n      module: {\n          {\n            test: /\\.ts$/,\n    \t\t\t\texclude: /node_modules/,\n            loader: 'ts-loader',\n            options: { appendTsSuffixTo: [/\\.vue$/] }\n          }\n        ]\n      },\n      resolve: {\n        extensions: ['.ts', 'tsx', '.js', '.vue']\n      }\n    };\n```\n\ntypescript 설정을 위해 프로젝트 루트 폴더에 tsconfig.json 파일을 생성하고 아래 내용을 입력한다.\n\n    {\n      \"compilerOptions\": {\n        \"outDir\": \"./dist/\",\n        \"strict\": true,\n        \"module\": \"es2015\",\n        \"target\": \"es5\",\n    \t\t\"moduleResolution\": \"node\",\n        \"sourceMap\": true,\n        \"allowSyntheticDefaultImports\": true\n      },\n      \"include\": [\n        \"src/**/*\"\n      ],\n      \"exclude\": [\n        \"node_modules\",\n        \"**/*.spec.ts\"\n      ]\n    }\n\n- allowSyntheticDefaultImports : export default 를 export 한 값들을 가지는 객체로 설정\n\n테스트를 위해 프로젝트 코드 수정하자. 우선 src/index.js, src/router/index.js → src/index.ts, src/router/index.ts 로 바꾼다. Hello.vue의 내용을 아래처럼 바꾼다. Vue 컴포넌트 안에서 Typescript를 사용하려면 Vue.component 또는 Vue.extend로 컴포넌트를 정의해야한다. 타입스크립트가 Vue 컴포넌트 타입 유추를 할 수 있게 하기 위해서다.\n\n```js\n    <template>\n      <p>{{ greeting }} world!</p>\n    </template>\n    <script lang=\"ts\">\n    import Vue from 'vue'\n    export default Vue.extend({\n      data: function () {\n        return {\n          greeting: 'Hello'\n        }\n      }\n    })\n    </script>\n    <style scoped>\n    p {\n      font-size: 2em;\n      text-align: center;\n    }\n    </style>\n```\n\n실행하려고 하면 .vue 파일이 import 되지 않는 오류를 발견할 것이다. ts 파일에 .vue 파일을 임포트하려면 추가적인 설정이 필요하다. src/shims-vue.d.ts 파일을 생성하여 이렇게 적자.\n\n```js\n    declare module \"*.vue\" {\n      import Vue from \"vue\";\n      export default Vue;\n    }\n```\n\n저장 후 실행해보면 잘된다.\n\n다음 TIL에서는 vue-class-component 데코레이터를 사용하여 컴포넌트를 선언할 때 클래스 기반 API를 이용하는 방식을 적용해봐야지!\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f9911ac03613c935962bb92b556860145926df9d","text":"# 최단 경로 알고리즘 - Floyd\n\n- Title : 최단 경로 알고리즘 - Floyd\n- Date : 2020-03-04\n- Category: Algorithm\n\n## Why?\n\n## Floyd 알고리즘\n\n그래프에 존재하는 **모든** 정점 사이의 최단 경로를 한 번에 **모두** 찾아주는 알고리즘이다. 다익스트라는 모든 정점 사이의 최단 경로를 구하려면 정점의 수만큼 다익스트라 알고리즘을 반복 실행한다.\n\n- 2차원 배열 weight를 이용하여 3중 반복으로 구성되어 있다.\n- 초기 배열 weight에서 i==j 면 weight[i][j] = 0, i j 사이의 직접 간선 없으면 weight[i][j]=INF, i j 사이 간선 있으면 weight[i][j] = 가중치값\n- 정점 0부터 n까지 반복을 돌린다. 정점 0을 거치는 경우..1을 거치는 경우..\n- weight[i][j] = min(weight[i][j], weight[i][k] + weight[k][j])\n\n![Floyd/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-04-img/Untitled.png)\n\n## 백준 문제 풀이\n\n11404번 플로이드\n\n[11404번: 플로이드](https://www.acmicpc.net/problem/11404)\n\n```cpp\n    #include <iostream>\n    #include <algorithm>\n    using namespace std;\n\n    int main() {\n    \tint n, m;\n    \tcin >> n >> m;\n\n    \tint graph[n+1][n+1];\n    \tfill(&graph[1][1], &graph[n][n], 10000001);\n    \tfor (int i=1; i<n+1; i++)\n    \t\tgraph[i][i] = 0;\n\n    \tint a, b, c;\n    \twhile (m--) {\n    \t\tcin >> a >> b >> c;\n    \t\tgraph[a][b] = min(graph[a][b], c);\n    \t}\n\n    \tfor (int k=1; k<n+1; k++) {\n    \t\tfor (int i=1; i<n+1; i++) {\n    \t\t\tif (k == i) continue;\n    \t\t\tfor (int j=1; j<n+1; j++) {\n    \t\t\t\tif (k == j) continue;\n    \t\t\t\tgraph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \tfor (int i=1; i<n+1; i++) {\n    \t\tfor (int j=1; j<n+1; j++) {\n    \t\t\tif (graph[i][j] == 10000001) cout << 0 << \" \";\n    \t\t\telse cout << graph[i][j] << \" \";\n    \t\t}\n\n    \t\tcout << \"\\n\";\n    \t}\n\n    \treturn 0;\n    }\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"5219daaeb39e005c6bc68059ba819110107f2daf","text":"# 최단 경로 알고리즘 - Dijkstra\n\n- Title : 최단 경로 알고리즘 - Dijkstra\n- Date : 2020-03-01\n- Category: Algorithm\n\n## Why?\n\n[1753번: 최단경로](https://www.acmicpc.net/problem/1753)\n\n> 최단 경로 문제는 네트워크에서 정점 u와 정점 v를 연결하는 경로 중에서 간선들의 가중치 합이 최소가 되는 경로를 찾는 문제다.\n\n## Dijkstra의 최단 경로 알고리즘\n\n네트워크에서 **하나의** 시작 정점으로부터 **모든** 다른 정점까지의 최단 경로를 찾는 알고리즘이다. 최단 경로는 경로의 길이순으로 구해진다.\n\n- 집합 S는 정점 v로부터의 최단 경로가 이미 발견된 정점들의 집합이다.\n- distance[]는 시작 정점에서 집합 S에 있는 정점을 거쳐서 다른 정점으로 가는 최단 거리를 기록한 배열이다.\n- distance 배열의 초깃값은 시작 정점이 v라면 distance[v] = 0 이고 다른 정점에 대한 distance 값은 v와 해당 정점 간의 가중치가 된다. 정점 v와 w와 직접 간선이 없다면 무한대 값을 저장한다.\n- 알고리즘 매 단계에서 집합 S에 없는 정점 중 가장 distance 값이 작은 정점을 S에 추가한다. 왜냐하면 현재 정점 u에서 x, y, z 중 y의 가중치가 최소라면 u → y가 u → x → y 또는 u → y → x 등 어떤 정점을 거쳐서 y로 가든 u → y 가 최단 경로이기 때문이다.\n- 새로운 정점 x가 S에 추가되면 S에 있지 않은 다른 정점들의 distance 값을 수정한다. 새로 추가된 정점 x를 거쳐 다른 정점까지 가는 거리와 기존의 거리를 비교하여 더 작은 거리로 distance 값을 수정한다. **distance[w] = min(distance[w], distance[x] + weight[x][w])** 식과 같다.\n\n![Dijkstra/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-01-img/Untitled.png)\n\n네트워크에 n개의 정점이 있다면, 다익스트라 최단 경로 알고리즘은 주 반복문을 n번 반복하고 내부 반복문을 2n번 반복하므로 **O(n²)** 의 복잡도를 가진다. distance를 배열이 아닌 **우선순위 큐**를 사용하면 더 빠르게 수행할 수 있다.\n\n### 백준 문제 풀이\n\n**1753번 최단경로**\n\n[1753번: 최단경로](https://www.acmicpc.net/problem/1753)\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #include <queue>\n    #define MAX_W 98765432\n    using namespace std;\n\n    vector<pair<int, int> > graph[20001];\n\n    vector<int> dijkstra (int s, int cv) {\n    \tvector<int> dis(cv, MAX_W);\n    \tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n    \tpq.push(make_pair(0, s));\n    \tdis[s] = 0;\n\n    \twhile (!pq.empty()) {\n    \t\tint cost = pq.top().first;\n    \t\tint v = pq.top().second;\n    \t\tpq.pop();\n    \t\tif (dis[v] < cost) continue;\n\n    \t\tfor (int i=0; i<graph[v].size(); i++) {\n    \t\t\tif (dis[graph[v][i].second] >= cost + graph[v][i].first) {\n    \t\t\t\tpq.push(make_pair(cost + graph[v][i].first, graph[v][i].second));\n    \t\t\t\tdis[graph[v][i].second] = cost + graph[v][i].first;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn dis;\n    }\n    int main() {\n    \tint v, e, s;\n    \tint a, b, c;\n\n    \tscanf(\"%d %d\", &v, &e);\n    \tscanf(\"%d\", &s);\n\n    \twhile (e--) {\n    \t\tscanf(\"%d %d %d\", &a, &b, &c);\n    \t\tgraph[a].push_back(make_pair(c, b));\n    \t}\n\n    \tvector<int> dis = dijkstra(s, v + 1);\n\n    \tfor (int i=1; i<v+1; i++) {\n    \t\tif (dis[i] == MAX_W)\n    \t\t\tprintf(\"INF\\n\");\n    \t\telse\n    \t\t\tprintf(\"%d\\n\", dis[i]);\n    \t}\n\n    \treturn 0;\n    }\n```\n\n**참고**\n\n[C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539)\n"}}}},"pageContext":{"id":"90b6ccb77c8749885afcac589cc7c853f9e17a48","previousPostId":"f9911ac03613c935962bb92b556860145926df9d","nextPostId":"5219daaeb39e005c6bc68059ba819110107f2daf"}},"staticQueryHashes":["2685952063","2841359383"]}