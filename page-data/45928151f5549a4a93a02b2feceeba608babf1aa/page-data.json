{"componentChunkName":"component---src-templates-blog-post-js","path":"/45928151f5549a4a93a02b2feceeba608babf1aa","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"45928151f5549a4a93a02b2feceeba608babf1aa","text":"# ES6를 모르면 React 배우기가 어려워요.\n\n- Title : ES6를 모르면 React 배우기가 어려워요.\n- Date : 2019-12-17\n- Category: Javascript\n\nReact를 배워볼까? 하고 두근거리는 마음으로 React 공식 문서에 방문해서 자습서부터 차근차근 읽어본 적이 있습니다.  \n그런데, 으잉? 이건 대체 뭐지? 제게 커다란 장벽이 나타났습니다. 그 것은 바로 바로... **ES6 문법!!!**  \n그래서 준비했습니다. <span class=\"clr-note\">\"ES6를 모르면 React 배우기가 어려워요!\"</span> 지금부터 저와 함께 ES6 최신 문법을 정리해봅시다!\n\n# 변수 선언하기\n\n## 1. const\n\n블록(중괄호 {}) 유효 범위의 상수를 선언하며 재할당 및 재선언이 불가능합니다.\n\n```javascript\nconst number = 42;\n\ntry {\n  number = 99;\n} catch (err) {\n  console.log(err); // TypeError: Assignment to constant variable.\n}\n\nconsole.log(number); // 42\n```\n\n## 2. let\n\n<code class=\"codetainer\">let</code> 키워드를 사용하면 변수의 유효 범위를 블록 {} 안으로 한정시킬 수 있고 글로벌 변수의 값을 보호할 수 있습니다.\n\n```javascript\nvar topic = \"js\";\nif (topic) {\n  var topic = \"리액트\";\n  console.log(\"블록\", topic); // 블록 리액트\n}\nconsole.log(\"글로벌\", topic); // 글로벌 리액트\n```\n\n위 예제의 if 블록 안의 topic 변수와 if 블록 밖의 topic 변수는 같은 변수입니다.  \n<code class=\"codetainer\">var</code> 키워드는 함수 유효 범위를 가지기 때문입니다. 자바스크립트의 호이스팅에 의해 함수 안에 정의된 변수는 함수의 맨 앞에서 정의되고 <code class=\"codetainer\">undefined</code>로 초기화되기 때문에 두 topic 변수가 사실상 같은 변수가 됩니다.\n<br/><br/>\n\n```javascript\nvar topic = \"js\";\nif (topic) {\n  let topic = \"리액트\";\n  console.log(\"블록\", topic); // 블록 리액트\n}\nconsole.log(\"글로벌\", topic); // 글로벌 js\n```\n\nif 블록 안의 변수가 if 블록 밖의 변수에 영향을 끼치지 않게 하려면 <code class=\"codetainer\">let</code> 키워드를 사용하면 됩니다. <code class=\"codetainer\">let</code>은 블록 유효 범위이므로 호이스팅 시 블록의 맨 앞에서 정의되고 초기화 됩니다.\n<br/><br/>\n\n```javascript\nconsole.log(name); // Uncaught ReferenceError: Cannot access 'name' before initialization\nlet name = \"lee\";\n\nconsole.log(age); // undefined\nvar age = \"20\";\n```\n\n단, var로 선언된 변수는 선언과 초기화가 동시에 진행되고 let을 선언된 변수는 호이스팅되어 선언 단계가 이뤄지나 초기화 단계는 실제 let이 사용된 코드에 도착할 때 이루어집니다. 그래서 let 키워드로 선언한 변수를 초기화 단계 이전에 접근하면 reference 에러가 발생합니다.\n\n## 3. 템플릿 문자열\n\n템플릿 문자열 덕분에 더하기 기호 + 없이 편하게 문자열과 변수를 이어 붙인 string을 생성할 수 있습니다.  \n<code class=\"codetainer\">\\${}</code> 안에는 자바스크립트 변수, 식 어떤 것이든 가능하며 템플릿 문자열은 공백, 탭, 개행 문자를 사용할 수 있습니다.\n\n```javascript\nconsole.log(`${lastName}, ${firstName} ${middleName}`);\n```\n\n<span class=\"clr-grey\"></span>\n<span class=\"clr-note\"></span>\n\n## 4. 디폴트 파라미터\n\n이제 함수를 호출 시 인자 값이 넘어오지 않았다면 디폴트 값을 사용할 수 있습니다.\n\n```javascript\nfunction func(name = \"lee\", age = \"20\") {\n  console.log(`${name} : ${age}`);\n}\nfunc(); // lee : 20\n```\n\n함수 호출 시 인자 넘기지 않아도 디폴트 값을 사용해 함수가 정상적으로 실행됩니다. 문자열뿐 아니라 객체 등 다양한 타입의 값을 디폴트로 사용할 수 있습니다.\n\n# 화살표 함수 =>\n\n화살표 함수를 사용하면 function 키워드 없이도 함수를 만들 수 있고 return을 사용하지 않아도 식을 계산한 값이 자동으로 반환됩니다.\n\n```javascript\nvar materials = [\"Hydrogen\", \"Helium\", \"Lithium\", \"Beryllium\"];\nmaterials.map(({ length }) => length); // [8, 6, 7, 9]\n```\n\n<br/>\n또한, <span class=\"clr-note\">화살표 함수는 this를 새로 바인딩 하지 않습니다.</span> 대신 코드에서 바로 바깥의 함수(혹은 class)의 this 값을 사용합니다. 뿐만 아니라 <code class=\"codetainer\">arguments, super, new.target</code>을 바인딩 하지 않습니다.\n\n```javascript\nvar obj = {\n  i: 10,\n  b: () => console.log(this.i, this),\n  c: function() {\n    console.log(this.i, this);\n  }\n};\nobj.b(); // prints undefined, Window\nobj.c(); // prints 10, Object {...}\n```\n\n<br/>\nthis를 바인딩 하지 않기 때문에 메소드 함수에는 사용하지 않아야 하며 생성자로서도 사용할 수 없기 때문에 <code class=\"codetainer\">new</code>와 함께 사용하면 오류가 발생합니다.\n\n```javascript\nvar Foo = () => {};\nvar foo = new Foo(); // TypeError: Foo is not a constructor\n```\n\n# ES6 객체와 배열\n\n## 1. 구조 분해(Destructuring)\n\n구조 분해를 사용하면 객체의 필드를 원하는 변수에 대입할 수 있습니다.\n\n다음은 sandwich를 분해해서 bread와 meat 필드를 같은 이름의 변수에 넣어주는 코드입니다. 두 변수의 값은 sandwich에 있는 같은 이름의 필드 값으로 초기화되지만, 두 변수를 변경해도 원래의 필드 값은 바뀌지는 않습니다.\n\n```javascript\nvar sandwich = {\n  bread: \"크런치\",\n  meat: \"참치\",\n  cheese: \"스위스\",\n  toppings: [\"상추\", \"토마토\", \"머스타드\"]\n};\n\nvar { bread, meat } = sandwich;\n\nconsole.log(bread, meat); // 크런치 참치\n```\n\n객체를 분해해서 함수의 인자로 넘길 수 있습니다.\n\n```javascript\nvar func = ({ firstName }) => {\n  console.log(`이름은 ${firstName}`);\n};\n\nfunc({\n  firstName: \"garam\",\n  lastName: \"lee\"\n}); // 이름은 lee\n```\n\n배열의 경우도 비슷합니다.\n\n```javascript\nvar x = [1, 2, 3, 4, 5];\nvar [y, z] = x;\nconsole.log(y, z); // 1 2\n```\n\n변수 선언이 분리되어도 값 할딩이 가능합니다.\n\n```javascript\nvar a, b;\n[a, b] = [1, 2];\nconsole.log(a, b); // 1 2\n```\n\n기본값을 할당하여 분해한 값이 undefined면 기본 값을 사용합니다.\n\n```javascript\nvar a, b;\n[a = 5, b = 7] = [1];\nconsole.log(a); // 1\nconsole.log(b); // 7\n```\n\n두 변수 값 교환이 가능합니다.\n\n```javascript\nvar a = 1;\nvar b = 3;\n\n[a, b] = [b, a];\nconsole.log(a); // 3\nconsole.log(b); // 1\n```\n\n불필요한 값을 콤마를 사용해 생략하는 리스트 매칭을 사용할 수 있습니다. 무시하고 싶은 원소 위치에 콤마를 넣으면 리스트 매칭이 됩니다.\n\n```javascript\nvar [, , third] = [\"a\", \"b\", \"c\"];\nconsole.log(third); // c\n```\n\n## 2. 객체 리터럴 개선\n\n구조 분해의 반대라고 할 수 있으며 객체 리터럴 개선을 사용하면 현재 영역에 있는 변수를 객체의 필드로 묶을 수 있습니다.\n\n```javascript\nvar name = \"lee\";\nvar age = \"20\";\nvar print = function() {\n  console.log(`${this.name} : ${this.age}`);\n};\nvar person = { name, age, print };\nperson.print(); // lee : 20\n```\n\n객체 리터럴 개선으로 변수를 객체의 필드로 대입할 수 있으며 function 키워드를 입력하지 않고 메서드를 정의할 수 있다.\n\n```javascript\n// 예전 방식\nvar obj = {\n  name: name,\n  age: age,\n  print: function() {\n    console.log(`${name} : ${age}`);\n  }\n};\n\n// 개선된 방식\nconst obj = {\n  name,\n  age,\n  print() {\n    console.log(`${name} : ${age}`);\n  }\n};\n```\n\n## 3. 스프레드 연산자\n\n스프레드 연산자는 세 개의 점(...)으로 이루어진 연산자로,\n<code class=\"codetainer\">함수호출, 배열 리터럴과 문자열, 객체 리터럴</code>에서 사용할 수 있습니다.\n\n이전에는 두 배열의 모든 원소가 들어간 새로운 배열을 만들기 위해서 <code class=\"codetainer\">push(), splice(), concat() </code> 등을 사용해야 했습니다. 이제 스프레드 연산자를 통해 쉽게 만들 수 있습니다.\n\n```javascript\n// 이전 방식\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\narr1 = arr1.concat(arr2);\n\n// 전개 방식\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\narr1 = [...arr1, ...arr2]; // arr1은 [0,1,2,3,4,5]\n\n// 새로운 배열 생성\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\nvar arr3 = [...arr1, ...arr2]; // [0,1,2,3,4,5]\n\n// 중간 조합도 가능\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, ...arr1, 4, 5]; // 3,0,1,2,4,5\n\n// 나머지 원소 얻기 가능\nvar arr1 = [0, 1, 2, 3];\nvar [first, ...rest] = arr1;\nconsole.log(rest); // 1,2,3\n```\n\n스프레드 연산자는 원본 배열을 변경하지 않고 복사본을 만듭니다.  \n다음 예제를 통해 실제로 확인해보자. arr1 배열의 마지막 원소를 변수에 담으려고 <code class=\"codetainer\">Array.reverse</code>를 이용해 배열을 뒤집고 첫번째 원소를 변수에 넣는 예제입니다.\n\n```javascript\n// 원본 배열이 변경된다.\nvar arr1 = [0, 1, 2];\nvar [last] = arr1.reverse();\nconsole.log(last); // 2\nconsole.log(arr1); // 2 1 0\n\n// 전개 연산을 통해 원본 배열 유지하기\nvar arr1 = [0, 1, 2];\nvar [last] = [...arr1].reverse();\nconsole.log(last); // 2\nconsole.log(arr1); // 0,1,2\n```\n\n객체에 사용할 수도 있습니다. 사용법은 배열과 유사합니다.\n\n```javascript\nvar obj1 = { foo: \"bar\", x: 42 };\nvar obj2 = { foo: \"baz\", y: 13 };\nvar obj3 = \"obj\";\nvar mergedObj = { ...obj1, ...obj2, obj3 };\nconsole.log(mergedObj); // { foo: \"baz\", x: 42, y: 13, obj3: \"obj\" }\n```\n\n함수 호출할 때도 사용할 수 있어서 배열의 엘리먼트를 함수의 인자로 사용하고자 할 때<code class=\"codetainer\">Function.prototype.apply()</code>를 대체할 수 있습니다.\n\n```javascript\n// 이전 방식\nfunction myFunction(x, y, z) {}\nvar args = [0, 1, 2];\nmyFunction.apply(null, args);\n\n// 전개 방식\nfunction myFunction(x, y, z) {}\nvar args = [0, 1, 2];\nmyFunction(...args);\n\n// new 키워드와 함께 사용할 수 있습니다.\nvar dateFields = [1970, 0, 1]; // 1 Jan 1970\nvar d = new Date(...dateFields);\n```\n\n# 클래스\n\n이전에는 공식적으로 클래스가 없어서 타입을 함수로 정의하고 그 함수 객체에 있는 프로토타입을 사용해 메서드를 정의했습니다. ES6부터 클래스 선언이 추가되어서 쉽게 클래스 패턴 생성이 가능해졌습니다.\n\n```javascript\nvar Foo = class {\n  constructor() {}\n  bar() {\n    return \"Hello World!\";\n  }\n};\n\nvar instance = new Foo();\ninstance.bar(); // \"Hello World!\"\nFoo.name; // \"\"\n```\n\nclass 키워드를 사용하더라도 내부적으로는 자바스크립트의 프로토타입 상속을 사용하고 있습니다. <code class=\"codetainer\">Foo.prototype</code>을 콘솔에 찍어보면 프로토타입에 생성자와 bar 메서드가 있는 것을 확인할 수 있을 것입니다.\n\n# ES6 모듈\n\n모듈은 다른 자바스크립트 파일의 코드를 쉽게 불러서 활용할 수 있는 재사용 가능한 코드 조각입니다. <code class=\"codetainer\">export</code>와 <code class=\"codetainer\">import</code> 키워드를 이용하면 됩니다.\n\n<code class=\"codetainer\">export</code>를 사용해 다른 모듈에서 활용할 수 있도록 이름(함수, 객체, 변수, 상수 등)을 외부에 익스포트할 수 있습니다.\n\n```javascript\n// export_1.js\n// print, log 함수를 외부에 export\n// 로컬 선언됨\nexport const print(message) => log(message, new Date())\nexport const log(message, timestamp) => console.log(`${timestamp.toString()} : ${message}`)\n\n// export_2.js\n// 단 하나의 이름만 외부에 export 하고 싶다면 export default 사용\nconst freel = new Date();\nexport default freel;\n```\n\n<code class=\"codetainer\">import</code>를 사용해 다른 자바스크립트 파일을 불러와 사용할 수 있습니다. 임포트 시 객체 구조 분해를 사용할 수 있으며, <code class=\"codetainer\">export default</code>를 사용한 경우 구조분해 없이 한 이름으로 부를 수 있습니다.\n\n```javascript\nimport { print, log } from ./export_1\nimport freel from ./export_2\n\n// import * 를 사용하여 다른 모듈에서 가져온 모든 이름을 사용자가 정한 로컬 이름 공간 안에 가둘 수 있음\nimport * from fns from ./export_1\n```\n\n# 커먼JS\n\n모든 버전의 노드에서 지원하는 일반적인 모듈 패턴입니다. 커먼 JS를 사용하여 객체를 <code class=\"codetainer\">module.exports</code>를 사용해 익스포트할 수 있습니다.\n\n```javascript\n//export.js\nconst print(message) => log(message, new Date())\nconst log(message, timestamp) => console.log(`${timestamp.toString()} : ${message}`)\n\nmodule.exports = {print, log}\n```\n\n```javascript\nconst { print, log } = require(\"./export\");\n```\n\n# ES6에서 비동기 프로그래밍\n\n나중에 따로 정리할 예정.\n\n## 1. promises\n\n## 2. 제너레이터\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f7b2c7b228ce7a27b8514b7c18d789d9be5fc783","text":"# 운영체제 - 인터럽트 기반 운영체제\n\n- Title : 운영체제 - 인터럽트 기반 운영체제\n- Date : 2019-12-23\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # 인터럽트 기반 시스템(Interrupt-Based System)\n\n현대 운영체제는 인터럽트 기반 시스템이다.\n\n## 전원을 키면?\n\n메인메모리가 비워져 있는 상태에서 CPU가 ROM의 부트로더를 실행하면 하드디스크의 운영체제가 메인 메모리에 올라가게 된다. 운영체제가 메인 메모리에 올라간 것을 <code class=\"codetainer\">부팅</code>이라고 부른다.\n\n## 부팅 끝난 후 운영체제의 상태는?\n\n부팅이 끝나면 운영체제는 메모리에 상주하게 되고 이벤트(인터럽트)를 기다리는 대기 상태가 된다. 이 운영체제에는 여러 개의 코드가 있고 이 코드는 인터럽트(하드웨어, 소프트웨어, 내부)가 발생할 때 실행된다.\n\n## 하드웨어 인터럽트 - 키보드, 마우스..\n\n마우스로 예를 들어 보자. 우리가 마우스를 움직이면 마우스에서 전기 신호가 발생하여 그 신호가 CPU의 인터럽트 선으로 전달된다. <span class=\"clr-note\">CPU는 인터럽트 신호를 받으면 지금 하던 일을 중지하고 운영체제에 있는 인터럽트 서비스 루틴(ISR)을 실행시킨다.</span> <code class=\"codetainer\">인터럽트 서비스 루틴</code>은 해당 인터럽트가 오면 어떤 일을 수행할 지 코드해놓은 프로그램이다. 우리는 이 인터럽트와 인터럽트 서비스 루틴 덕분에 마우스를 움직이면 화면의 마우스 커서가 움직이게 할 수 있는 것이다. 다른 예시로 hwp 아이콘을 더블 클릭하는 경우를 생각해보자. 더블 클릭으로 인터럽트가 발생하면 CPU는 OS의 더블클릭 ISR을 실행한다. 더블 클릭 인터럽트 서비스 루틴은 하드디스크의 HWP 실행 파일을 메인 메모리에 올려서 CPU가 실행할 수 있도록 한다.\n\n## 소프트웨어 인터럽트\n\nhwp 프로그램 실행 중 memo.hwp 파일을 읽어오고 싶은 경우를 생각해보자. 하드디스크를 뒤져서 memo.hwp를 메모리에 올려야하는 데 이 작업은 hwp 프로그램이 직접 수행하지않는다. 인터럽트를 발생시켜 운영체제의 ISR을 실행하여 메모리에 올리는 것이다. ISR이 실행되어 memo.hwp를 다 읽으면 다시 hwp 프로그램으로 돌아온다. <span class=\"clr-note\">정리하자면, 사용자 프로그램에서 소프트웨어 인터럽트를 걸면 운영체제 안의 특정 코드(ISR)를 실행하고 이 코드 실행이 끝나면 다시 사용자 프로그램으로 돌아온다.</span>\n\n## 내부 인터럽트\n\n하나의 예시로 <span class=\"clr-note\">divide by zero</span>를 들 수 있다. <code class=\"codetainer\">int i=5, j=0; i=i/j;</code> 다음과 같이 0으로 나누는 연산을 하면 i에 값을 저장할 수 없게 된다. 이는 곧 그 다음 코드를 실행할 수 없다는 의미다. 컴퓨터는 이러한 경우, 프로그램을 강제 종료시키고 싶어진다. 그래서 CPU는 내부적으로 인터럽트를 발생한 것으로 인식하여 프로그램을 종료시키는 ISR을 실행시킨다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"5912e74405510659e7c8587081bb3e7ed7afe56f","text":"# 백준 분수찾기 Java\n\n- Title : 백준 분수찾기 Java\n- Date : 2019-12-10\n- Category: 알고리즘 풀이\n\n# 문제\n\n[분수찾기](https://www.acmicpc.net/problem/1193)\n\n# 내 풀이\n\n자세히 살펴보면 다음과 같은 규칙이 있다.\n\n1/1 => 1 layer (이 라인에서 제일 큰 번호 : 1)  \n1/2 2/1 => 2 layer (이 라인에서 제일 큰 번호 : 3)  \n3/1 2/2 1/3 => 3 layer (이 라인에서 제일 큰 번호 : 6)  \n1/4 2/3 3/2 4/1 => 4 layer (이 라인에서 제일 큰 번호 : 10)  \n5/1 4/2 3/3 2/4 1/5 => 5 layer (이 라인에서 제일 큰 번호 : 15)\n\n- x layer에는 x 개의 분수가 있다.\n- x layer에서 제일 큰 번호는 1 + 2 + 3 + ... + x 이다. 즉 x \\* (x + 1) / 2\n- layer 번호가 짝수면, 제일 큰 번호의 분수를 기준으로 분자는 -1, 분모는 +1 을 한다.\n- layer 번호가 홀수면, 제일 큰 번호의 분수를 기준으로 분자는 +1, 분모는 -1 을 한다.\n\n위의 규칙을 이용하여 입력 N이 있는 layer와 그 layer의 제일 큰 번호를 찾고 layer의 홀/짝 여부를 통해 분자, 분모를 1 빼거나 더하면 된다.\n\n```java\nimport java.util.Scanner;\n\npublic class P1193 {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tSystem.out.println(Solution(N));\n\t}\n\n\tpublic static String Solution(int N) {\n\t\tint a = 1, b = 1;\n\t\tint num = 1, number = 1;\n\t\tint r = 0;\n\t\tint[] cal_a = {-1, 1};\n\t\tint[] cal_b = {1, -1};\n\n\t\twhile (number < N) {\n\t\t\tnum++;\n\t\t\tnumber += num;\n\n\t\t}\n\t\tr = num % 2;\n\t\tif (r == 0) a = num;\n\t\telse b = num;\n\n\t\twhile (number != N) {\n\t\t\ta += cal_a[r];\n\t\t\tb += cal_b[r];\n\t\t\tnumber--;\n\n\t\t}\n\t\treturn a+\"/\"+b;\n\t}\n}\n```\n"}}}},"pageContext":{"id":"45928151f5549a4a93a02b2feceeba608babf1aa","previousPostId":"f7b2c7b228ce7a27b8514b7c18d789d9be5fc783","nextPostId":"5912e74405510659e7c8587081bb3e7ed7afe56f"}},"staticQueryHashes":["2685952063","2841359383"]}