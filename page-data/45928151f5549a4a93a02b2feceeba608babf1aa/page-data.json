{"componentChunkName":"component---src-templates-blog-post-js","path":"/45928151f5549a4a93a02b2feceeba608babf1aa","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"45928151f5549a4a93a02b2feceeba608babf1aa","text":"# ES6를 모르면 React 배우기가 어려워요.\n\n- Title : ES6를 모르면 React 배우기가 어려워요.\n- Date : 2019-12-17\n- Category: Javascript\n\nReact를 배워볼까? 하고 두근거리는 마음으로 React 공식 문서에 방문해서 자습서부터 차근차근 읽어본 적이 있습니다.  \n그런데, 으잉? 이건 대체 뭐지? 제게 커다란 장벽이 나타났습니다. 그 것은 바로 바로... **ES6 문법!!!**  \n그래서 준비했습니다. <span class=\"clr-note\">\"ES6를 모르면 React 배우기가 어려워요!\"</span> 지금부터 저와 함께 ES6 최신 문법을 정리해봅시다!\n\n# 변수 선언하기\n\n## 1. const\n\n블록(중괄호 {}) 유효 범위의 상수를 선언하며 재할당 및 재선언이 불가능합니다.\n\n```javascript\nconst number = 42;\n\ntry {\n  number = 99;\n} catch (err) {\n  console.log(err); // TypeError: Assignment to constant variable.\n}\n\nconsole.log(number); // 42\n```\n\n## 2. let\n\n<code class=\"codetainer\">let</code> 키워드를 사용하면 변수의 유효 범위를 블록 {} 안으로 한정시킬 수 있고 글로벌 변수의 값을 보호할 수 있습니다.\n\n```javascript\nvar topic = \"js\";\nif (topic) {\n  var topic = \"리액트\";\n  console.log(\"블록\", topic); // 블록 리액트\n}\nconsole.log(\"글로벌\", topic); // 글로벌 리액트\n```\n\n위 예제의 if 블록 안의 topic 변수와 if 블록 밖의 topic 변수는 같은 변수입니다.  \n<code class=\"codetainer\">var</code> 키워드는 함수 유효 범위를 가지기 때문입니다. 자바스크립트의 호이스팅에 의해 함수 안에 정의된 변수는 함수의 맨 앞에서 정의되고 <code class=\"codetainer\">undefined</code>로 초기화되기 때문에 두 topic 변수가 사실상 같은 변수가 됩니다.\n<br/><br/>\n\n```javascript\nvar topic = \"js\";\nif (topic) {\n  let topic = \"리액트\";\n  console.log(\"블록\", topic); // 블록 리액트\n}\nconsole.log(\"글로벌\", topic); // 글로벌 js\n```\n\nif 블록 안의 변수가 if 블록 밖의 변수에 영향을 끼치지 않게 하려면 <code class=\"codetainer\">let</code> 키워드를 사용하면 됩니다. <code class=\"codetainer\">let</code>은 블록 유효 범위이므로 호이스팅 시 블록의 맨 앞에서 정의되고 초기화 됩니다.\n<br/><br/>\n\n```javascript\nconsole.log(name); // Uncaught ReferenceError: Cannot access 'name' before initialization\nlet name = \"lee\";\n\nconsole.log(age); // undefined\nvar age = \"20\";\n```\n\n단, var로 선언된 변수는 선언과 초기화가 동시에 진행되고 let을 선언된 변수는 호이스팅되어 선언 단계가 이뤄지나 초기화 단계는 실제 let이 사용된 코드에 도착할 때 이루어집니다. 그래서 let 키워드로 선언한 변수를 초기화 단계 이전에 접근하면 reference 에러가 발생합니다.\n\n## 3. 템플릿 문자열\n\n템플릿 문자열 덕분에 더하기 기호 + 없이 편하게 문자열과 변수를 이어 붙인 string을 생성할 수 있습니다.  \n<code class=\"codetainer\">\\${}</code> 안에는 자바스크립트 변수, 식 어떤 것이든 가능하며 템플릿 문자열은 공백, 탭, 개행 문자를 사용할 수 있습니다.\n\n```javascript\nconsole.log(`${lastName}, ${firstName} ${middleName}`);\n```\n\n<span class=\"clr-grey\"></span>\n<span class=\"clr-note\"></span>\n\n## 4. 디폴트 파라미터\n\n이제 함수를 호출 시 인자 값이 넘어오지 않았다면 디폴트 값을 사용할 수 있습니다.\n\n```javascript\nfunction func(name = \"lee\", age = \"20\") {\n  console.log(`${name} : ${age}`);\n}\nfunc(); // lee : 20\n```\n\n함수 호출 시 인자 넘기지 않아도 디폴트 값을 사용해 함수가 정상적으로 실행됩니다. 문자열뿐 아니라 객체 등 다양한 타입의 값을 디폴트로 사용할 수 있습니다.\n\n# 화살표 함수 =>\n\n화살표 함수를 사용하면 function 키워드 없이도 함수를 만들 수 있고 return을 사용하지 않아도 식을 계산한 값이 자동으로 반환됩니다.\n\n```javascript\nvar materials = [\"Hydrogen\", \"Helium\", \"Lithium\", \"Beryllium\"];\nmaterials.map(({ length }) => length); // [8, 6, 7, 9]\n```\n\n<br/>\n또한, <span class=\"clr-note\">화살표 함수는 this를 새로 바인딩 하지 않습니다.</span> 대신 코드에서 바로 바깥의 함수(혹은 class)의 this 값을 사용합니다. 뿐만 아니라 <code class=\"codetainer\">arguments, super, new.target</code>을 바인딩 하지 않습니다.\n\n```javascript\nvar obj = {\n  i: 10,\n  b: () => console.log(this.i, this),\n  c: function() {\n    console.log(this.i, this);\n  }\n};\nobj.b(); // prints undefined, Window\nobj.c(); // prints 10, Object {...}\n```\n\n<br/>\nthis를 바인딩 하지 않기 때문에 메소드 함수에는 사용하지 않아야 하며 생성자로서도 사용할 수 없기 때문에 <code class=\"codetainer\">new</code>와 함께 사용하면 오류가 발생합니다.\n\n```javascript\nvar Foo = () => {};\nvar foo = new Foo(); // TypeError: Foo is not a constructor\n```\n\n# ES6 객체와 배열\n\n## 1. 구조 분해(Destructuring)\n\n구조 분해를 사용하면 객체의 필드를 원하는 변수에 대입할 수 있습니다.\n\n다음은 sandwich를 분해해서 bread와 meat 필드를 같은 이름의 변수에 넣어주는 코드입니다. 두 변수의 값은 sandwich에 있는 같은 이름의 필드 값으로 초기화되지만, 두 변수를 변경해도 원래의 필드 값은 바뀌지는 않습니다.\n\n```javascript\nvar sandwich = {\n  bread: \"크런치\",\n  meat: \"참치\",\n  cheese: \"스위스\",\n  toppings: [\"상추\", \"토마토\", \"머스타드\"]\n};\n\nvar { bread, meat } = sandwich;\n\nconsole.log(bread, meat); // 크런치 참치\n```\n\n객체를 분해해서 함수의 인자로 넘길 수 있습니다.\n\n```javascript\nvar func = ({ firstName }) => {\n  console.log(`이름은 ${firstName}`);\n};\n\nfunc({\n  firstName: \"garam\",\n  lastName: \"lee\"\n}); // 이름은 lee\n```\n\n배열의 경우도 비슷합니다.\n\n```javascript\nvar x = [1, 2, 3, 4, 5];\nvar [y, z] = x;\nconsole.log(y, z); // 1 2\n```\n\n변수 선언이 분리되어도 값 할딩이 가능합니다.\n\n```javascript\nvar a, b;\n[a, b] = [1, 2];\nconsole.log(a, b); // 1 2\n```\n\n기본값을 할당하여 분해한 값이 undefined면 기본 값을 사용합니다.\n\n```javascript\nvar a, b;\n[a = 5, b = 7] = [1];\nconsole.log(a); // 1\nconsole.log(b); // 7\n```\n\n두 변수 값 교환이 가능합니다.\n\n```javascript\nvar a = 1;\nvar b = 3;\n\n[a, b] = [b, a];\nconsole.log(a); // 3\nconsole.log(b); // 1\n```\n\n불필요한 값을 콤마를 사용해 생략하는 리스트 매칭을 사용할 수 있습니다. 무시하고 싶은 원소 위치에 콤마를 넣으면 리스트 매칭이 됩니다.\n\n```javascript\nvar [, , third] = [\"a\", \"b\", \"c\"];\nconsole.log(third); // c\n```\n\n## 2. 객체 리터럴 개선\n\n구조 분해의 반대라고 할 수 있으며 객체 리터럴 개선을 사용하면 현재 영역에 있는 변수를 객체의 필드로 묶을 수 있습니다.\n\n```javascript\nvar name = \"lee\";\nvar age = \"20\";\nvar print = function() {\n  console.log(`${this.name} : ${this.age}`);\n};\nvar person = { name, age, print };\nperson.print(); // lee : 20\n```\n\n객체 리터럴 개선으로 변수를 객체의 필드로 대입할 수 있으며 function 키워드를 입력하지 않고 메서드를 정의할 수 있다.\n\n```javascript\n// 예전 방식\nvar obj = {\n  name: name,\n  age: age,\n  print: function() {\n    console.log(`${name} : ${age}`);\n  }\n};\n\n// 개선된 방식\nconst obj = {\n  name,\n  age,\n  print() {\n    console.log(`${name} : ${age}`);\n  }\n};\n```\n\n## 3. 스프레드 연산자\n\n스프레드 연산자는 세 개의 점(...)으로 이루어진 연산자로,\n<code class=\"codetainer\">함수호출, 배열 리터럴과 문자열, 객체 리터럴</code>에서 사용할 수 있습니다.\n\n이전에는 두 배열의 모든 원소가 들어간 새로운 배열을 만들기 위해서 <code class=\"codetainer\">push(), splice(), concat() </code> 등을 사용해야 했습니다. 이제 스프레드 연산자를 통해 쉽게 만들 수 있습니다.\n\n```javascript\n// 이전 방식\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\narr1 = arr1.concat(arr2);\n\n// 전개 방식\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\narr1 = [...arr1, ...arr2]; // arr1은 [0,1,2,3,4,5]\n\n// 새로운 배열 생성\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\nvar arr3 = [...arr1, ...arr2]; // [0,1,2,3,4,5]\n\n// 중간 조합도 가능\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, ...arr1, 4, 5]; // 3,0,1,2,4,5\n\n// 나머지 원소 얻기 가능\nvar arr1 = [0, 1, 2, 3];\nvar [first, ...rest] = arr1;\nconsole.log(rest); // 1,2,3\n```\n\n스프레드 연산자는 원본 배열을 변경하지 않고 복사본을 만듭니다.  \n다음 예제를 통해 실제로 확인해보자. arr1 배열의 마지막 원소를 변수에 담으려고 <code class=\"codetainer\">Array.reverse</code>를 이용해 배열을 뒤집고 첫번째 원소를 변수에 넣는 예제입니다.\n\n```javascript\n// 원본 배열이 변경된다.\nvar arr1 = [0, 1, 2];\nvar [last] = arr1.reverse();\nconsole.log(last); // 2\nconsole.log(arr1); // 2 1 0\n\n// 전개 연산을 통해 원본 배열 유지하기\nvar arr1 = [0, 1, 2];\nvar [last] = [...arr1].reverse();\nconsole.log(last); // 2\nconsole.log(arr1); // 0,1,2\n```\n\n객체에 사용할 수도 있습니다. 사용법은 배열과 유사합니다.\n\n```javascript\nvar obj1 = { foo: \"bar\", x: 42 };\nvar obj2 = { foo: \"baz\", y: 13 };\nvar obj3 = \"obj\";\nvar mergedObj = { ...obj1, ...obj2, obj3 };\nconsole.log(mergedObj); // { foo: \"baz\", x: 42, y: 13, obj3: \"obj\" }\n```\n\n함수 호출할 때도 사용할 수 있어서 배열의 엘리먼트를 함수의 인자로 사용하고자 할 때<code class=\"codetainer\">Function.prototype.apply()</code>를 대체할 수 있습니다.\n\n```javascript\n// 이전 방식\nfunction myFunction(x, y, z) {}\nvar args = [0, 1, 2];\nmyFunction.apply(null, args);\n\n// 전개 방식\nfunction myFunction(x, y, z) {}\nvar args = [0, 1, 2];\nmyFunction(...args);\n\n// new 키워드와 함께 사용할 수 있습니다.\nvar dateFields = [1970, 0, 1]; // 1 Jan 1970\nvar d = new Date(...dateFields);\n```\n\n# 클래스\n\n이전에는 공식적으로 클래스가 없어서 타입을 함수로 정의하고 그 함수 객체에 있는 프로토타입을 사용해 메서드를 정의했습니다. ES6부터 클래스 선언이 추가되어서 쉽게 클래스 패턴 생성이 가능해졌습니다.\n\n```javascript\nvar Foo = class {\n  constructor() {}\n  bar() {\n    return \"Hello World!\";\n  }\n};\n\nvar instance = new Foo();\ninstance.bar(); // \"Hello World!\"\nFoo.name; // \"\"\n```\n\nclass 키워드를 사용하더라도 내부적으로는 자바스크립트의 프로토타입 상속을 사용하고 있습니다. <code class=\"codetainer\">Foo.prototype</code>을 콘솔에 찍어보면 프로토타입에 생성자와 bar 메서드가 있는 것을 확인할 수 있을 것입니다.\n\n# ES6 모듈\n\n모듈은 다른 자바스크립트 파일의 코드를 쉽게 불러서 활용할 수 있는 재사용 가능한 코드 조각입니다. <code class=\"codetainer\">export</code>와 <code class=\"codetainer\">import</code> 키워드를 이용하면 됩니다.\n\n<code class=\"codetainer\">export</code>를 사용해 다른 모듈에서 활용할 수 있도록 이름(함수, 객체, 변수, 상수 등)을 외부에 익스포트할 수 있습니다.\n\n```javascript\n// export_1.js\n// print, log 함수를 외부에 export\n// 로컬 선언됨\nexport const print(message) => log(message, new Date())\nexport const log(message, timestamp) => console.log(`${timestamp.toString()} : ${message}`)\n\n// export_2.js\n// 단 하나의 이름만 외부에 export 하고 싶다면 export default 사용\nconst freel = new Date();\nexport default freel;\n```\n\n<code class=\"codetainer\">import</code>를 사용해 다른 자바스크립트 파일을 불러와 사용할 수 있습니다. 임포트 시 객체 구조 분해를 사용할 수 있으며, <code class=\"codetainer\">export default</code>를 사용한 경우 구조분해 없이 한 이름으로 부를 수 있습니다.\n\n```javascript\nimport { print, log } from ./export_1\nimport freel from ./export_2\n\n// import * 를 사용하여 다른 모듈에서 가져온 모든 이름을 사용자가 정한 로컬 이름 공간 안에 가둘 수 있음\nimport * from fns from ./export_1\n```\n\n# 커먼JS\n\n모든 버전의 노드에서 지원하는 일반적인 모듈 패턴입니다. 커먼 JS를 사용하여 객체를 <code class=\"codetainer\">module.exports</code>를 사용해 익스포트할 수 있습니다.\n\n```javascript\n//export.js\nconst print(message) => log(message, new Date())\nconst log(message, timestamp) => console.log(`${timestamp.toString()} : ${message}`)\n\nmodule.exports = {print, log}\n```\n\n```javascript\nconst { print, log } = require(\"./export\");\n```\n\n# ES6에서 비동기 프로그래밍\n\n나중에 따로 정리할 예정.\n\n## 1. promises\n\n## 2. 제너레이터\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f7b2c7b228ce7a27b8514b7c18d789d9be5fc783","text":"# 운영체제 - 인터럽트 기반 운영체제\n\n- Title : 운영체제 - 인터럽트 기반 운영체제\n- Date : 2019-12-23\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # 인터럽트 기반 시스템(Interrupt-Based System)\n\n현대 운영체제는 인터럽트 기반 시스템이다.\n\n## 전원을 키면?\n\n메인메모리가 비워져 있는 상태에서 CPU가 ROM의 부트로더를 실행하면 하드디스크의 운영체제가 메인 메모리에 올라가게 된다. 운영체제가 메인 메모리에 올라간 것을 <code class=\"codetainer\">부팅</code>이라고 부른다.\n\n## 부팅 끝난 후 운영체제의 상태는?\n\n부팅이 끝나면 운영체제는 메모리에 상주하게 되고 이벤트(인터럽트)를 기다리는 대기 상태가 된다. 이 운영체제에는 여러 개의 코드가 있고 이 코드는 인터럽트(하드웨어, 소프트웨어, 내부)가 발생할 때 실행된다.\n\n## 하드웨어 인터럽트 - 키보드, 마우스..\n\n마우스로 예를 들어 보자. 우리가 마우스를 움직이면 마우스에서 전기 신호가 발생하여 그 신호가 CPU의 인터럽트 선으로 전달된다. <span class=\"clr-note\">CPU는 인터럽트 신호를 받으면 지금 하던 일을 중지하고 운영체제에 있는 인터럽트 서비스 루틴(ISR)을 실행시킨다.</span> <code class=\"codetainer\">인터럽트 서비스 루틴</code>은 해당 인터럽트가 오면 어떤 일을 수행할 지 코드해놓은 프로그램이다. 우리는 이 인터럽트와 인터럽트 서비스 루틴 덕분에 마우스를 움직이면 화면의 마우스 커서가 움직이게 할 수 있는 것이다. 다른 예시로 hwp 아이콘을 더블 클릭하는 경우를 생각해보자. 더블 클릭으로 인터럽트가 발생하면 CPU는 OS의 더블클릭 ISR을 실행한다. 더블 클릭 인터럽트 서비스 루틴은 하드디스크의 HWP 실행 파일을 메인 메모리에 올려서 CPU가 실행할 수 있도록 한다.\n\n## 소프트웨어 인터럽트\n\nhwp 프로그램 실행 중 memo.hwp 파일을 읽어오고 싶은 경우를 생각해보자. 하드디스크를 뒤져서 memo.hwp를 메모리에 올려야하는 데 이 작업은 hwp 프로그램이 직접 수행하지않는다. 인터럽트를 발생시켜 운영체제의 ISR을 실행하여 메모리에 올리는 것이다. ISR이 실행되어 memo.hwp를 다 읽으면 다시 hwp 프로그램으로 돌아온다. <span class=\"clr-note\">정리하자면, 사용자 프로그램에서 소프트웨어 인터럽트를 걸면 운영체제 안의 특정 코드(ISR)를 실행하고 이 코드 실행이 끝나면 다시 사용자 프로그램으로 돌아온다.</span>\n\n## 내부 인터럽트\n\n하나의 예시로 <span class=\"clr-note\">divide by zero</span>를 들 수 있다. <code class=\"codetainer\">int i=5, j=0; i=i/j;</code> 다음과 같이 0으로 나누는 연산을 하면 i에 값을 저장할 수 없게 된다. 이는 곧 그 다음 코드를 실행할 수 없다는 의미다. 컴퓨터는 이러한 경우, 프로그램을 강제 종료시키고 싶어진다. 그래서 CPU는 내부적으로 인터럽트를 발생한 것으로 인식하여 프로그램을 종료시키는 ISR을 실행시킨다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"0e6c91a0a899db4d2998ba6ee8189e54a606fb9b","text":"# 알고리즘 개념 잡자 - 연결리스트\n\n- Title : [코딩인터뷰] 연결리스트\n- Date : 2019-12-12\n- Category: Algorithm\n\n코딩 인터뷰 완전분석 연결리스트 파트 예제 문제 풀이\n\n# 배열\n\n## Random access\n\n배열의 엘리먼트들은 메모리에 연속적으로 저장되므로 어떤 엘리먼트도 첫번째 엘리먼트의 주소에 각 엘리먼트 크기를 더해서 접근할 수 있다.  \n각 엘리먼트가 4byte고 세번째 엘리먼트 접근하려면 첫번째 주소 + 4\\*3 이다.  \n즉, 첫번째 탐색이나 마지막 엘리먼트 탐색 시간 차이가 없다. 탐색 시간 O(1) 가능하다.\n\n## 메모리 낭비\n\n개발자가 메모리를 얼마나 사용할 지 모르는 상태에서 배열의 크기를 초기화해야한다.\n\n## 삽입 삭제 연산 느림\n\n첫번째 또는 중간 삽입의 경우 삽입 엘리먼트 공간 확보를 위해 배열을 한칸씩 뒤로 이동시켜야한다.  \n삭제는 반대로 한칸씩 앞으로 이동시켜야하고 배열의 크기를 재조정해야 한다.  \n즉, n개의엘리먼트를 이동시켜야하므로 O(n) 단 맨끝 삭제는 o(1)\n\n# 연결리스트\n\n## Iterate access\n\n배열과 달리 메모리에 연속적 공간 갖지않고 첫번째 노드의 포인터부터 순회해야한다.  \n즉, 탐색은 O(n) 시간복잡도를 가져서 배열보다 탐색이 느리다.\n\n## 리스트 크기를 미리 정의해놓을필요가없음\n\n## 삽입 삭제 연산 빠름\n\n중간노드 끝노드의 경우 위치 찾는데는 o(n) 이지만 실제 삽.삭은 포인터만 업데이트하면되니깐 o(1)이다.  \n단, 맨 앞 노드는 o(1)\n\n# 2.1 중복 없애기 : 정렬되어 있지 않은 연결리스트가 주어졌을 때 이 리스트에서 중복되는 원소를 제거하는 코드를 작성하자. 임시 버퍼를 사용할 수 없는 경우도 생각해보자.\n\n1. 임시버퍼를 사용할 수 있다면, 중복을 허용하지 않는 Set 컬렉션을 이용해서 해결할 수 있다. 이 경우는 O(N)의 시간 복잡도를 갖는다.\n2. 임시버퍼를 사용할 수 없다면, 이중 반복문을 통해 중복 노드를 찾은 후 제거하면 된다. 이 경우는 O(N^2)의 시간 복잡도를 갖는다.\n\n## 자바스크립트 풀이\n\n```javascript\n\"use strict\";\n\nclass Node {\n  constructor(data, next) {\n    this.data = data;\n    this.next = next;\n  }\n}\n\nclass LinkedList {\n  constructor(head) {\n    this.head = head;\n  }\n\n  display() {\n    let cur = this.head;\n    while (cur != null) {\n      console.log(cur.data);\n      cur = cur.next;\n    }\n  }\n}\n\nfunction makeList() {\n  let n6 = new Node(4);\n  let n5 = new Node(5, n6);\n  let n4 = new Node(3, n5);\n  let n3 = new Node(5, n4);\n  let n2 = new Node(4, n3);\n  let n1 = new Node(5, n2);\n  let list = new LinkedList(n1);\n  return list;\n}\n\n// O(n) n: 연결리스트 길이\nfunction solution() {\n  const list = makeList();\n  const set = new Set();\n  let cur = list.head;\n  let pre = null;\n  while (cur != null) {\n    if (set.has(cur.data)) {\n      pre.next = cur.next;\n    } else {\n      set.add(cur.data);\n      pre = cur;\n    }\n    cur = cur.next;\n  }\n  list.display();\n}\n\n// O(N^2) 버퍼 없이\nfunction solution_2() {\n  const list = makeList();\n  let cur = list.head;\n\n  while (cur != null) {\n    let mn = cur;\n\n    while (mn.next != null) {\n      if (cur.data === mn.next.data) {\n        mn.next = mn.next.next;\n      } else {\n        mn = mn.next;\n      }\n    }\n    cur = cur.next;\n  }\n\n  list.display();\n}\n\nsolution();\nsolution_2();\n```\n\n**자바스크립트의 null과 undefined**  \n자바스크립트에서 '없음'을 나타내는 값에 null과 undefined가 있다. 값이 대입되지 않은 변수나 속성의 경우는 undefined이며 객체가 없는 경우는 null로 나타낸다.  \n자바스크립트의 === 등호는 값이 정확히 같을 때 true를 반환하나 == 등호는 그렇지 않을 때가 많다. 보통의 경우는 === 를 권장하나 null check 할 때는 == 쓰면 값이 null 또는 undefined의 경우 false를 리턴 받을 수 있다.\n\n**자바스크립트의 class**  \nES6의 클래스 선언은 호이스팅이 되지 않아서 클래스를 사용하기 위해서는 클래스를 먼저 선언해야 한다. class body는 {}로 묶여 있는 안쪽 부분으로 constructor(생성자)가 있는 곳이다. 객체를 생성하고 초기화하는 메소드로 클래스 안에 한 개만 존재할 수 있다. 부모 생성자를 호출하기 위해 super 키워드를 사용할 수도 있다.\n\n**자바스크립트에서 오토박싱**  \nnon-strict 모드에서 this 값이 null 혹은 undefined 일 경우 window 객체로 자동으로 변환을 해주는 것을 오토박싱이라고 한다. 그래서 일반 메서드에서 this 값이 window 객체가 된다. class 문법 안에 있는 코드는 항상 strict mode로 실행되기 때문에 클래스 메서드 호출에서 this의 초기값은 undefined다.\n\n**자바에서 오토박싱**  \n자바에는 int, float와 같은 기본형(primitive type)과 Integer, Float와 같은 래퍼 클래스가 있다. 래퍼 클래스는 기본형을 객체로 다루어야 할 경우에 사용할 수 있다. 컬렉션에서 엘리먼트는 객체가 되어야 되서 int 기본형을 사용하지 않고 Integer를 사용하는 것을 본 적이 있을 거다. 박싱은 기본형을 참조형으로 변환하는 것이고 언박싱은 반대로 참조형을 기본형으로 바꾸는 것이다. 예제를 통해 확실히 이해해보자.\n\n```java\nint pa = 1;\nInteger wa = pa; // 오토박싱\n\nInteger wb = new Integer(2);\nint pb = wb; // 오토언박싱\n\n```\n\n## 자바 풀이\n\n**리스트 반복하면서 삭제하기**  \nfor(;;)를 이용한 방법은 반복 도중 엘리먼트가 삭제되면 반복문의 크기가 변한다. 또한 삭제된 엘리먼트 자리를 채우기 위해 모든 인덱스가 하나씩 이동하게 된다. 생각대로 동작하지 않는 것 당연하다.\n\nfor-each문 안에서 엘리먼트를 삭제하게 되면 **java.util.ConcurrentModificationException** 에러를 보게 된다. Iterator로 반복 중인 리스트를 수정하려 하면 이 에러가 발생된다. for-each 문은 내부적으로 iterator를 실행하므로 remove()나 add()를 할 경우 에러가 발생되는 것이다.\n\n그래서 반복을 하면서 삭제를 하려면 Itertor 인터페이스를 사용하거나 Collection 인터페이스의 removeif 메서드를 사용한다.\n\n```java\n  public static void main(String[] args) {\n\t\tLinkedList<Integer> list = new LinkedList<>(Arrays.asList(5,4,2,3,5,4));\n\t\tsolution(list);\n\t}\n\n\tpublic static void solution(LinkedList<Integer> list) {\n\t\t// 1번 iterator 사용\n\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\tIterator<Integer> it = list.iterator();\n\n\t\twhile(it.hasNext()) {\n\t\t\tint next = it.next();\n\t\t\tif (set.contains(next)) it.remove();\n\t\t\telse set.add(next);\n\t\t}\n\n\t\t// 2번 removeif 사용\n\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\tlist.removeIf(num -> {\n\t\t\tif (set.contains(num)) return true;\n\t\t\telse {\n\t\t\t\tset.add(num);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}\n```\n\n# 2.2 뒤에서 K번째 원소 구하기: 단방향 연결리스트가 주어졌을 때 뒤에서 K번째 원소를 찾는 알고리즘을 구현하라.\n\n## 내 풀이\n\n리스트의 크기를 구하기 위해 한번 순회한 다음, 리스트 크기에 k만큼 뺀 index까지 반복을 돌려 원소를 찾았다.  \n시간 복잡도는 O(N)\n\n```javascript\nfunction solution_2(k) {\n  const list = makeList();\n\n  let cur = list.head;\n  let len = 0;\n  while (cur != null) {\n    len++;\n    cur = cur.next;\n  }\n\n  cur = list.head;\n  for (let i = 0; i < len - k; i++) {\n    cur = cur.next;\n  }\n\n  if (len - k < 0) return null;\n  else return cur.data;\n  //console.log(`뒤에서 ${k}번째 원소 값 : ${cur.data}`);\n}\n```\n\n## 반복문을 한번만 돌릴 수 있다면?\n\nRunner 기법을 사용했다. 연결리스트 문제에서 많이 활용되는 기법으로 순회할 때 두 개의 포인터를 동시에 사용하는 방법이다. 이 때 한 포인트가 다른 포인터보다 앞서도록 하며 앞선 포인터가 따라오는 포인터보다 **항상 지정된 개수만큼** 앞서거나, 따라오는 포인터를 **여러 노드를 한번에 뛰어넘도록** 설정할 수 있다.\n\n시간복잡도는 O(N) 이다.\n\n```javascript\nfunction solution_2_1(k) {\n  const list = makeList();\n\n  let cur = list.head;\n  let runner = cur;\n  let len = 0;\n  while (cur != null) {\n    if (len++ >= k) runner = runner.next;\n    cur = cur.next;\n  }\n  if (len - k < 0) return null;\n  else return runner.data;\n  // console.log(`뒤에서 ${k}번째 원소 값 : ${runner.data}`);\n}\n```\n\n# 2.3 중간 노드 삭제: 단방향 연결리스트가 주어졌을 때 중간(정확히 가운데 노드일 필요는 없고 처음과 끝 노드만 아니면 된다)에 있는 노드 하나를 삭제하는 알고리즘을 구현해라. 단, 삭제할 노드에만 접근할 수 있다.\n\nRunner 기법으로 중간 노드를 찾고 찾은 노드의 data와 next 값을 바로 다음 노드의 값으로 바꾼 다음 다음 노드의 next를 찾은 노드의 next로 지정한다.\n\n```javascript\nfunction solution_3() {\n  const list = makeList();\n  let cur = list.head;\n  let runner = list.head;\n  let len = 0;\n  while (cur != null) {\n    cur = cur.next;\n    if (++len % 2 == 0) runner = runner.next;\n  }\n\n  if (runner.next == null) {\n    runner.data = null;\n  } else {\n    runner.data = runner.next.data;\n    runner.next = runner.next.next;\n  }\n\n  list.display();\n}\n```\n\n```javascript\nfunction solution_3() {\n  const list = makeList();\n\n  let cur = list.head;\n  let prerunner = null;\n  let runner = list.head;\n  let len = 0;\n  while (cur != null && cur.next != null) {\n    cur = cur.next.next;\n    prerunner = runner;\n    runner = runner.next;\n  }\n  if (cur != null) {\n    prerunner = runner;\n    runner = runner.next;\n  }\n  // 노드 갯수가 2 이하일 때, 처음/끝 노드가 삭제되는 것을 막기 위해\n  if (prerunner == null || runner.next == null) return;\n\n  prerunner.next = runner.next;\n  list.display();\n}\n```\n\n# 2.4 분할: 값 x가 주어졌을 때 x보다 작은 노드들을 x보다 크거나 같은 노드들보다 앞에 오도록 하는 코드를 작성하라. 만약 x가 리스트에 있다면 x는 그보다 작은 원소들보다 뒤에 나오기만 하면 된다. 즉, 원소 x는 '오른쪽 그룹' 어딘가에만 존재하면 된다. 왼쪽과 오른쪽 그룹 사이에 있을 필요는 없다.\n\n- 입력: 3->5->8->5->10->2->1 (분할값 x = 5)\n- 출력: 3->1->2->10->5->5->8\n\n순회를 하면서 data 값이 x보다 작은 경우에는 무조건 맨 앞으로 이동시키는 식으로 해결했다.\n\n```javascript\nfunction solution_4(x) {\n  const list = makeList();\n  let cur, pre;\n  if (list.head.data < x) {\n    cur = list.head.next;\n    pre = list.head;\n  } else {\n    cur = list.head;\n    pre = null;\n  }\n\n  while (cur != null) {\n    if (cur.data < x) {\n      pre.next = cur.next;\n      cur.next = list.head;\n      list.head = cur;\n      cur = pre.next;\n    } else {\n      pre = cur;\n      cur = cur.next;\n    }\n  }\n\n  list.display();\n}\n```\n\n## 그렇다면 원소의 순서를 유지하면서 x보다 작은 노드들을 x의 앞에 위치하게 하고 싶다면?\n\n두 개의 연결리스트를 만들어서 하나는 x보다 작은 노드들을 삽입하고 다른 하나는 x보다 크거나 같은 노드들을 넣는다. 모든 작업이 완료된 후 두 리스트를 합하면 된다.\n\n# 2.5 리스트의 합: 연결리스트로 숫자를 표현할 때 각 노드가 자릿수 하나를 가리키는 방식으로 표현할 수 있다. 각 숫자는 역순으로 배열되어 있는데, 첫 번째 자릿수가 리스트의 맨 앞에 위치하도록 배열된다는 뜻이다. 이와 같은 방식으로 표현된 숫자 두 개가 있을 때, 이 두 수를 더하여 그 합을 연결리스트로 반환하는 함수를 작성하라\n\n- 입력: (7->1->6) + (5->9->2) 즉, 617 + 295\n- 출력: 2->1->9 즉, 912\n\n```javascript\nfunction solution_5(list_1, list_2) {\n  let cur_1 = list_1.head,\n    cur_2 = list_2.head;\n  let c = 0;\n  let newListHead = null;\n  let newList = null;\n  while (cur_1 != null || cur_2 != null) {\n    if (cur_1 == null || cur_2 == null) {\n      newList.next = cur_1 == null ? cur_2 : cur_1;\n      break;\n    }\n    let sum = cur_1.data + cur_2.data + c;\n    if (newList == null) {\n      newList = new Node(sum % 10);\n      newListHead = new LinkedList(newList);\n    } else {\n      newList.next = new Node(sum % 10);\n      newList = newList.next;\n    }\n    c = parseInt(sum / 10);\n    cur_1 = cur_1.next;\n    cur_2 = cur_2.next;\n  }\n\n  newListHead.display();\n}\n```\n\n## 각 자릿수가 정상적으로 배열된다고 가정하고 같은 문제를 풀면?\n\n- 입력: (6->1->7) + (2->9->5) 즉, 617+295\n- 출력: 9->1->2 즉, 912\n\n재귀로 순회해서 끝에서 부터 더해가면 된다. 단, 리스트의 길이가 다를 경우가 있으므로 이 부분을 고려해야 한다.\n재귀 안에서 해결해볼까 했는 데, 복잡해져서 아예 길이를 같게 만드는 방법으로 해보았다.\n\n```javascript\nfunction solution_5_1(list_1, list_2) {\n  let list_1_len = getSize(list_1.head),\n    list_2_len = getSize(list_2.head);\n\n  while (list_1_len > list_2_len) {\n    list_2.head = new Node(0, list_2.head);\n    list_2_len++;\n  }\n  while (list_1_len < list_2_len) {\n    list_1.head = new Node(0, list_1.head);\n    list_1_len++;\n  }\n\n  let newList = null;\n  recursion(list_1.head, list_2.head);\n\n  newList.display();\n  function recursion(cur_1, cur_2) {\n    if (cur_1 == null && cur_2 == null) return 0;\n    let sum = cur_1.data + cur_2.data + recursion(cur_1.next, cur_2.next);\n    if (newList == null) {\n      newList = new LinkedList(new Node(sum % 10));\n    } else {\n      newList.head = new Node(sum % 10, newList.head);\n    }\n    return parseInt(sum / 10);\n  }\n\n  function getSize(list) {\n    let cur = list;\n    let len = 0;\n    while (cur != null) {\n      len++;\n      cur = cur.next;\n    }\n    return len;\n  }\n}\n```\n\n# 회문: 주어진 연결리스트가 회문인지 검사하는 함수를 작성하라\n\n회문이란? 순서를 거꾸로 읽어도 제대로 읽은 것과 같은 단어와 문장을 말한다.  \n예시) level, sos\n\n```javascript\nfunction solution_6(list) {\n  let cur = list.head;\n  return recursion(list.head);\n\n  function recursion(list) {\n    if (list == null) return true;\n    let chk = recursion(list.next) && cur.data === list.data;\n    cur = cur.next;\n    return chk;\n  }\n}\n```\n\n## 책 해법 1. 뒤집어서 비교하기\n\n연결리스트를 순회하면서 새 리스트의 맨 앞에 삽입하면서 역순 리스트를 만든 후 비교한다.\n\n## 책 해법 2. runner와 스택 이용\n\n```javascript\nfunction solution_6_1(list) {\n  let cur = list.head;\n  let runner = cur;\n  let len = 0;\n  let array = Array();\n  while (cur != null && cur.next != null) {\n    len++;\n    array.push(runner.data);\n    runner = runner.next;\n    cur = cur.next.next;\n  }\n\n  if (len % 2 === 0) runner = runner.next;\n\n  while (runner != null) {\n    if (array.pop() !== runner.data) return false;\n    runner = runner.next;\n  }\n  return true;\n}\n```\n\n# 교집합: 단방향 연결리스트 두 개가 주어졌을 때 이 두 리스트의 교집합 노드를 찾은 뒤 반환하는 코드를 작성하라. 여기서 교집합이란 노드의 값이 아니라 노드의 주소가 완전히 같은 경우를 말한다. 즉, 첫 번째 리스트에 있는 k번째 노드와 두 번째 리스트에 있는 j번째 노드가 주소까지 완전히 같다면 이 노드는 교집합의 원소가 된다.\n\n두 연결리스트에서 교집합이 있다는 것은.. 그 교집합 노드 뒤부터는 같은 노드라는 것, 즉 마지막 노드가 같다.\n\n```javascript\nfunction solution_7(list_1, list_2) {\n  let set = new Set();\n  let newList = null;\n  let cur = list_1.head;\n  while (cur != null) {\n    set.add(cur);\n    cur = cur.next;\n  }\n\n  cur = list_2.head;\n  while (cur != null) {\n    if (set.has(cur)) {\n      newList = cur;\n      break;\n    }\n    cur = cur.next;\n  }\n  if (newList == null) return null;\n  return new LinkedList(newList);\n}\n```\n\n## 책 풀이\n\n1. 두 연결리스트를 순회해서 마지막 노드와 사이즈를 구하고 각 마지막 노드가 같으면 교집합이 존재하며 다르면 교집합은 없다.\n2. 길이가 더 긴 연결리스트의 포인터를 이동시켜서 두 연결리스트 순회 길이가 같도록 포인터를 맞춘다.\n3. 동시에 두 연결리스트의 포인트를 이동시키면서 같은 노드가 발견되는 순간을 찾는다.\n\n# 루프발견: 순환 연결리스트가 주어졌을 때, 순환되는 부분의 첫째 노드를 반환하는 알고리즘을 작성하라. 순환 연결리스트란 노드의 next 포인터가 앞선 노드들 가운데 어느 하나를 가리키도록 설정되어 있는, 엄밀히 말해서 변질된 방식의 연결리스트를 의미한다.\n\n- 입력: A->B->C->D->E->C (앞에 나온 C와 같음)\n- 출력: C\n\n```javascript\nfunction solution_8(list) {\n  let set = new Set();\n  let cur = list.head;\n\n  while (cur != null) {\n    if (set.has(cur)) return cur.data;\n    set.add(cur);\n    cur = cur.next;\n  }\n  return null;\n}\n```\n\n# 끝!\n"}}}},"pageContext":{"id":"45928151f5549a4a93a02b2feceeba608babf1aa","previousPostId":"f7b2c7b228ce7a27b8514b7c18d789d9be5fc783","nextPostId":"0e6c91a0a899db4d2998ba6ee8189e54a606fb9b"}},"staticQueryHashes":["2685952063","2841359383"]}