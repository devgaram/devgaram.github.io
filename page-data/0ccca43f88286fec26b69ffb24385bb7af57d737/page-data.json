{"componentChunkName":"component---src-templates-blog-post-js","path":"/0ccca43f88286fec26b69ffb24385bb7af57d737","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"0ccca43f88286fec26b69ffb24385bb7af57d737","text":"# CORS\n\n- Title : CORS\n- Date : 2020-08-15\n- Category : 프론트\n\n# SOP(Same-Origin Policy)\n**동일 출처 정책**으로 한 출처(Origin)에서 로드된 문서나 스크립트가 다른 출처의 자원과 상호 작용을 못하도록 제한하는 것을 말한다. <br/>\n이 정책으로 의해 XMLHttpRequest 객체로 특정 웹 페이지 접근할 때, 해당 페이지와 동일한 출처의 페이지에만 접근이 가능한 것이다.\n\n# 동일 출처(Origin)란?\n`Protocol`, `Host`, `Port` 가 모두 같을 때 동일 출처다.\n\n# CORS(Cross-Origin Resource Sharing)\n다른 출처의 자원과의 상호 작용을 위해 SOP 예외 조건으로 CORS 정책이 생겼다.    \nCORS 정책을 위반하지 않는 다면 다른 출처의 리소스를 공유할 수 있다.\n\n## 어떻게 CORS 정책을 위반했는 지 판단할까?\n출처를 비교하는 로직은 서버가 아닌 **브라우저**에 구현되어 있다.    \nCORS 정책에 위반하는 리소스 요청을 하면 서버가 같은 출처만 받겠다는 로직이 있는 경우가 아니면 서버는 정상적인 응답을 하고,\n이후 브라우저가 응답 헤더를 분석하여 CORS 정책 위반이라고 판단되면 그 응답을 사용하지 않는다.\n\n1. HTTP 프로토콜을 사용하여 리소스 요청을 한다.\n2. 이 때 브라우저는 요청 헤더의 Origin 필드에 출처를 담아 보낸다.\n3. 서버는 응답 헤더의 Access-Control-Allow-Origin 필드에 해당 리소스에 대한 접근이 허용된 출처를 담아 응답한다.\n4. 브라우저는 응답의 Access-Control-Allow-Origin 과 요청 헤더의 Origin을 비교하여 응답이 유효한 지 판단한다.\n\n# CORS, SOP 정책 존재 이유는?\n다른 출처의 애플리케이션이 서로 통신하는 것에 대해 아무런 제약도 존재하지 않으면 \n해커가 `CSRF(Cross-Site Request Forgery)`나 `XSS(Cross-Site Scripting)`와 같은 방법으로 앱 코드가 실행된 것처럼 꾸며 \n사용자의 정보를 탈취하기 쉬워진다. 또 개발자가 신경써야 할 일이 늘어난다.\n\n# Preflight, Simple, Credential Request 에서 CORS\n## 1. Preflight Request\npreflight는 브라우저가 본 요청을 보내기 전에 보내는 예비 요청을 말하며 HTTP METHOD 중 OPTIONS를 사용한다.    \n예비 요청은 본 요청을 보내기 전에 브라우저 스스로 안전한 요청인지 확인하는 과정이다.\n\n## 2. Simple Request\n예비 요청 없이 바로 본 요청을 보내는 경우로 발생 조건이 까다로워 해당 요청이 발생하는 경우는 드물다.\n- 요청 메소드: GET, HEAD, POST 중 하나만 사용 가능\n- Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width를 제외한 헤더를 사용 불가\n- 만약 Content-Type를 사용하는 경우에는 application/x-www-form-urlencoded, multipart/form-data, text/plain만 허용\n\n## 3. Credentialed Request\n다른 출처 간 통신에서 좀 더 보안을 강화하고 싶을 때 사용한다.\n\n```javascript\nfetch(url, {\n  credentials: 'include', // 요청에 인증과 관련된 정보를 포함하겠다.\n});\n```\n위와 같이 설정하면 요청 시 브라우저의 쿠키 정보가 함께 보내진다.\n\n단, `credentials: include`를 사용하면 브라우저는 `Access-Control-Allow-Origin: *` 처럼 와일드 문자를 허용하지 않게 된다.\n인증 정보가 담겨있는 상태에서 다른 출처에 요청을 하고 싶다면 아래 두가지를 추가해야 CORS 정책 위반을 피할 수 있다.\n\n- `Access-Control-Allow-Origin`에는 *를 사용할 수 없으며, 명시적인 URL이어야한다.\n- 응답 헤더에는 반드시 `Allow-Control-Allow-Credentials: true`가 존재해야한다.\n\n# CORS 해결 방법\n1. 서버에서 Access-Control-Allow-Origin 헤더에 알맞은 값 세팅하기\n2. Webpack Dev Server로 리버스 프록싱\n\n```javascript\nmodule.exports = {\n  devServer: {\n    proxy: {\n      '/api': {\n        target: 'https://api.evan.com',\n        changeOrigin: true,\n        pathRewrite: { '^/api': '' },\n      },\n    }\n  }\n}\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"966ea5b2cd8e89dbab1723a18bec85539cbfa10a","text":"# SPA, SSR vs CSR\n- Title : SSR vs CSR vs SPA\n- Date : 2020-08-22\n- Category : 프론트\n# SPA(Single Page Application)\n\n- 앱에 필요한 모든 정적 리소스를 **최초 한번만** 받아 오고 이후에는 동적으로 DOM을 구성하여 렌더링 되는 화면만 바꾼다.\n- 페이지가 한번 로딩된 이후 데이터를 수정하거나 조회할 때, 페이지가 새로 고침되거나 다른 페이지로 넘어가지 않는다.\n- 클라이언트 렌더링 방식을 채택\n\n**장점**\n- 전체적인 트래픽을 감소시킨다.\n- 새로고침이 발생하지 않아 네이티브 앱과 유사한 사용자 경험을 제공한다. -> **모바일 퍼스트** 전략에 적합\n\n**단점**\n- 모든 정적 리소스를 최초에 한번 다운로드하기 때문에 초기 구동 속도가 상대적으로 느리다. -> 최초 첫 페이지(어느 정도 그려진)를 서버로부터 받는 SSR을 진행하여 속도를 개선할 수 있다.\n- SEO(검색엔진 최적화) 문제 -> SPA 프레임워크(앵귤러, 리액트..)에서 SSR을 지원하여 SEO에 대응할 수 있다.\n\n**전통적 Link Tag와 차이**\n- Link tag는 새로운 페이지를 요청할 때마다 정적 리소스를 다운 받고 전체 페이지를 다시 렌더링한다.   \n- 새로고침이 매번 발생되어 사용성이 좋지 않고 변경이 필요 없는 부분을 포함하여 전체 페이지를 갱식하므로 비효율적이다.\n\n# SSR(Server Side Rendering)\n**서버**가 사용자에게 보여줄 페이지를 모두 구성하여 사용자에게 페이지를 보여주는 방식이다.\n\n1. 브라우저가 서버에 페이지 요청한다.\n2. 서버는 DB에서 데이터를 가져오든 뭐든, 필요한 데이터를 모두 매핑시킨 HTML을 만들어 브라우저에 응답한다.\n3. 브라우저는 응답 받은 페이지를 렌더링한다. 이 때부터 **사용자는 페이지를 볼 수 있다.** 동시에 브라우저는 필요한 JS 파일들을 다운 받는다. [Viewable]\n4. 브라우저가 React를 실행한다.\n5. 드디어 페이지가 사용자와 상호 작용 할 수 있게 된다. [Interactable]\n\n# CSR(Client Side Rendering)\n데이터 없는 빈 HTML 파일을 받아오고 데이터는 문서와 여러 static 파일들이 로드된 후에 요청해서 받아오는 방식\n\n1. 서버가 아래와 같은 빈 HTML을 보내준다.\n\n```html\n<html>\n  <head>\n    <script src=\"client-side-framework.js\"></script>\n    <script src=\"app.js\"></script>\n  </head>\n  <body>\n    <div class=\"container\"></div>\n  </body>\n</html>\n```\n\n2. 브라우저는 JS 파일을 다운로드 받는다.\n3. 브라우저가 리액트를 실행한다.\n4. 드디어 사용자가 페이지를 볼 수 있고 상호 작용할 수 있다. [Viewable & Interactable]\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"a21d94a6b96cfbfbce523c164d6e7bd377c5c4b7","text":"# 자바스크립트의 실행 컨텍스트\n\nDate: Jul 11, 2020\n\n- Title : 실행 컨텍스트\n- Date : 2020-07-11\n- Category : Javascript\n\n이 글은 코어 자바스크립트 책의 실행 컨텍스트 부분을 정리한 내용입니다.\n\n# 실행 컨텍스트\n\n- 실행할 코드에 제공할 환경 정보들을 모아 놓은 객체다.\n- 자바 스크립트는 동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하여 콜 스택에 올린다. 가장 위에 쌓인 컨텍스트와 관련 코드를 실행하는 방법을 통해 전체 코드의 환경과 순서를 보장한다.\n- 실행 컨텍스트를 구성하는 방법은 `전역 공간`, `eval() 함수`, `함수` 등이 있다. `전역 공간`은 자동으로 생성되고 `eval()` 함수는 악마로 취급 되므로 **컨텍스트를 구성하기 위해 함수를 실행하는 방법을 흔히 사용**한다.\n\n## 실행 컨텍스트를 코드로 이해하기\n\n```jsx\n// (1)\nvar a = 1;\nfunction outer() {\n  function inner() {\n\t  console.log(a); // undefined\n\t  var a = 3;\n  }\n  inner(); // (2)\n  console.log(a); // 1\n}\nouter(); // (3)\nconsole.log(a); // 1\n```\n\n1. 처음 자바 스크립트 코드가 실행하는 순간(1) 전역 컨텍스트가 콜 스택에 담긴다.\n\n    참고로 전역 컨텍스트는 일반 실행 컨텍스트와 달리 함수가 아닌 전역 공간이기 때문에 arguments가 없고 전역 공간을 둘러싼 외부 스코프가 존재할 수 없기 때문에 스코프 체인 상에는 전역 스코프 하나만 존재한다.\n\n2. 콜 스택에 전역 컨텍스트 외에 다른 프레임이 없으므로 전역 컨텐스트와 관련된 코드들을 순차로 진행하다가 (3)에서 outer 함수를 호출하면 엔진은 outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성한 후 콜 스택에 담는다.\n3. 콜 스택의 맨 위에 outer 실행 컨텍스트가 놓인 상태이므로 전역 컨텍스트와 관련된 코드 실행을 일시 중단하고 outer 실행 컨텍스트와 관련된 코드(outer 함수 내부 코드)를 순차로 실행한다.\n4. (2)에서 inner 함수의 실행 컨텍스트가 콜 스택 가장 위에 담기면 outer 컨텍스트와 관련된 코드 실행을 중단하고 inner 함수 내부의 코드를 순서대로 실행한다.\n5. inner 함수의 실행이 종료되면 inner 실행 컨텍스트가 콜 스택에서 제거된다.\n6. outer 실행 컨텍스트가 콜 스택에 맨 위에 존재하게 되므로 중단했던 (2)의 다음 줄부터 이어서 실행한다.\n7. outer 함수의 실행이 종료되어 콜 스택에서 제거되면 전역 컨텍스트의 코드들을 실행하게 된다. 더 이상 실행할 코드가 남아 있지 않으면 전역 컨텍스트도 제거되어 콜 스택에는 아무 것도 남지 않은 상태로 종료된다.\n\n# 실행 컨텍스트에 담기는 정보들\n\n- VariableEnvironment: 현재 컨텍스트 내의 식별자에 대한 정보 + 외부 환경 정보, 선언 시점의 LexicalEnvironment의 스냅샷으로 변경 사항은 반영되지 않음\n- LexicalEnvironment: 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨\n- ThisBinding: this 식별자가 바라봐야 할 대상 객체\n\n## VariableEnvironment\n\nLexicalEnvironment에 담기는 내용과 같지만 VariableEnvironment는 **최초 실행 시의 스냅샷을 유지**한다는 점이 다르다. 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음 이를 그대로 복사해서 LexicalEnvironment를 만들고 이후에는 LexicalEnvironment를 주로 활용하게 된다.\n\n## LexicalEnvironment\n\n내부 구성\n\n- environmentRecode: 매개 변수의 이름, 함수 선언, 변수명 등이 담김\n- outerEnvironmentReference: 바로 직전 컨텍스트의 LexicalEnvironment 정보를 참조\n\n### environmentRecode\n\n컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어 나가며 순서대로 현재 컨텍스트와 관련된 코드의 식별자 정보들을 저장한다. 매개변수 식별자, 선언한 함수가 있을 경우 그 함수 자체(함수 선언문), var로 선언된 변수의 식별자가 식별자 정보에 해당된다.\n\n코드가 실행되기 전임에도 자바스크립트 엔진은 해당 컨텍스트에 속한 변수 명들을 모두 알고 있다. 즉, 자바스크립트 엔진은 **식별자들을 최 상단으로 끌어 올려 놓은 다음 실제 코드를 실행한다**라고 생각해도 된다. 여기서 호이스팅의 개념이 등장한다.\n\n자바 스크립트 엔진은 변수 선언과 값 할당이 동시에 이뤄진 문장은 **선언부**만을 호이스팅하고 할당 과정은 원래 자리에 둔다. 따라서 함수 선언문은 함수 전체가 호이스팅 되지만 함수 표현식은 변수 선언부만 호이스팅 된다.\n\n### outerEnvironmentReference\n\nouterEnvironmentReference는 **현재 호출된 함수가 선언될 당시**의 LexicalEnvironment를 참조하기 때문에 우리는 스코프 체인을 할 수 있다. \n\n코드 상에서 어떤 변수에 접근하려고 하면 현재 컨텍스트의 LexicalEnvironment를 탐색한다. 변수 값을 발견하면 그 값을 반환 하지만 발견하지 못하면 outerEnvironmentReference에 담긴 LexicalEnvironment를 탐색하는 과정을 거친다. 전역 컨텍스트의 LexicalEnvironment까지 탐색 해도 해당 변수를 찾지 못하면 undefined를 반환한다.\n\n> 스코프는 식별자에 대한 유효 범위로, 어떤 경계 A의 외부에서 선언한 변수는 A의 외부 뿐 아니라 A의 내부에서도 접근이 가능하지만, A의 내부에서 선언한 변수는 오직 A 내부에서만 접근할 수 있다는 개념으로 이해하면 된다. 이러한 식별자 유효 범위를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라고 한다.\n\n"}}}},"pageContext":{"id":"0ccca43f88286fec26b69ffb24385bb7af57d737","previousPostId":"966ea5b2cd8e89dbab1723a18bec85539cbfa10a","nextPostId":"a21d94a6b96cfbfbce523c164d6e7bd377c5c4b7"}},"staticQueryHashes":["2685952063","2841359383"]}