{"componentChunkName":"component---src-templates-blog-post-js","path":"/577478fb0b78d854a14f939dd2ff68114511aa30","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"577478fb0b78d854a14f939dd2ff68114511aa30","text":"# [안드로이드] 시작하기 앞서 기초 학습\n\n- Title : [안드로이드] 시작하기 앞서 기초 학습\n- Date : 2018-11-30\n- Category: Android\n\n안드로이드 학습을 시작하기 전에 간단히 자바 기본 개념을 정리했습니다.\n\n# 안드로이드 기초\n\n## 안드로이드 4대 구성요소\n\n- 액티비티  \n  화면 하나당 하나의 액티비티 가짐. 여러개의 액티비티 중 하나가 메인 액티비티가 되며 manifest에 정의된다.\n- 리시버  \n  전화&문자 수신, 배터리 부족 등의 브로드캐스트를 수신하는 객체\n- 프로바이더  \n  데이터베이스나 파일 등의 정보를 외부의 앱에 공개하기 위한 객체. ContentProvider 클래스를 상속받아 구현\n- 서비스  \n  백그라운드(음악재생, 파일다운로드)에서 오래 수행되어야 하는 앱. 화면 없음\n\n## 액티비티끼리 데이터를 주고받는 과정\n\n1. A 액티비티에서 startActivityForResult()로 B 액티비티 시작\n2. B 액티비티에서 setResult()로 결과를 A 액티비티로 전달\n3. A 액티비티의 onActivityResult()에서 B 액티비티에서 전달받은 데이터 처리\n\n# 자바 기초 개념\n\n---\n\n## 자바 상속과 인터페이스 개념 정리 [출처]\n\n1. 상속\n\n- 어떤 클래스보다 내용이 구체적인 새로운 클래스가 필요할 때 기존 클래스에서 물려받아 새로운 부분만 추가하거나 수정하려고 만든 개념이다.\n- 상속을 이용하면 슈퍼 클래스(부모)의 필드, 메서드를 상속받으며 서브 클래스(자식)에서 자신만의 필드나 메서드를 추가하여 구체화할 수 있다.\n  물론 상속받은 메서드를 재정의(오버라이딩)하는 것도 가능하다.\n- 상속은 클래스를 선언할 때 extends 키워드를 사용하여 정의한다.\n- 다른 객체지향 언어와 달리 다중 상속을 지원하지 않는다.\n- 다형성 : 슈퍼클래스가 같은 서브 클래스들이 동일한 요청(메서드)을 다르게 처리할 수 있는 특징을 말한다. 메서드를 오버라이딩(재정의)하여 구현한다.\n\n2. 클래스의 기본 구조\n\n- 패키지 : 자바 클래스들을 같은 성격으로 묶어서 관리하는 디렉토리 개념\n- 클래스 : 자바 프로그램의 기본 단위\n- 인스턴스 : 객체지향개념에 따라 클래스는 바로 사용할 수 없고 인스턴스로 사용해야한다. 인스턴스를 이용하여 메서드 호출 등 필요한 작업을 처리한다.\n- 생성자 : 클래스를 생성할 때 제일 먼저 실행되는 특수한 형태의 메서드, 리턴값이 없으며(데이터형 입력하면 안됨) 메서드 이름은 반드시 클래스 이름과 일치해야 한다.\n\n3. 접근 한정자의 종류와 접근 범위\n\n- public : 클래스 내부, 동일 패키지, 하위클래스, 그 외의 영역에서 접근 가능\n- protected : 클래스 내부, 동일 패키지, 하위클래스에서 접근 가능\n- default : 클래스 내부, 동일 패키지에서 접근 가능\n- private : 클래스 내부에서만 접근 가능\n\n4. 일반 한정자의 종류\n\n- static : 클래스 메서드와 클래스 변수를 선언하는 데 사용한다.\n  자바의 정적 영역에 할당되는 리소스를 선언하는 데 사용.\n  동일한 가상머신 상에서 실행 중인 모든 클래스에서 공유한다.\n  인스턴스를 생성하지 않고도 클래스의 메서드나 멤버에 접근할 수 있다.\n- final : 더 이상 변경할 수 없도록 선언하는 한정자. 클래스에서 사용하면 서브 클래스를 만들 수 없다. 메서드에서 사용하면 오버라이딩을 할 수 없다.\n  변수에 사용하면 저장된 값은 변할 수 없으므로 상수의 역할을 한다.\n- abstract : 추상 클래스를 선언하는 데 사용하는 한정사\n\n5. 인스턴스 변수와 클래스 변수\n\n- 인스턴스 변수는 클래스의 인스턴스로만 접근 가능한 변수(일반적인 멤버 변수), 클래스 외부에서 접근 차단하려고 private 키워드를 사용하기도 함.\n- 동일 클래스의 인스턴스라 해도 각 인스턴스의 변수는 값이 서로 다르고 서로에 영향을 주지 않는다.\n- 클래스 변수는 모든 클래스의 인스턴스로 공유되는 변수, static 키워드를 사용하여 선언한다.\n\n6. 자바 가상머신의 메모리 구조\n\n- Heap 영역 : 자바 객체, 인스턴스 변수\n- Stack 영역 : 메서드 파라미터, 지역 변수\n- Method 영역 : 메서드 바이트 코드, 클래스(static) 변수\n\n7. 추상 클래스와 인터페이스\n\n- 추상클래스\n  - 추상 메서드(정의만 한 메서드)를 하나 이상 포함한다, 추상 메서드가 포함된 클래스는 반드시 추상 클래스로 정의해야 한다.\n  - 그 자체를 인스턴스화(객체 생성)에 사용할 수 없다. 추상 클래스를 상속받는 클래스를 만든 후 추상클래스에 선언된 모든 추상 메서드를 오버라이딩해서 구현해야 한다.\n\n8. 인터페이스\n\n- 모두 추상 메서드로만 구성해야 한다.\n- 일반 멤버 필드는 없고, public, static, final로 선언한 상수만 있다.\n- 그 자체를 인스턴스화(객체 생성) 불가. 다른 클래스로 구현할 때는 implements 키워드로 구현을 선언해야한다.\n- 다중 상속 개념 지원하는 형태로 사용 가능\n\n9. 캡슐화\n\n- 외부에서 변수에 직접 접근할 수 없도록 하는 객체지향 프로그래밍 방법이다.\n- 캡슐화된 변수에 접근하려면 getter, setter 메서드를 만들어서 접근해야한다.\n\n[출처]: http://nyebo.net/2016/01/just-java-summary/\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f8ebac2b78438548ddb7207724467420f65eee08","text":"# [안드로이드] 어댑터뷰를 사용해보자\n\n- Title : [안드로이드] 어댑터뷰를 사용해보자\n- Date : 2018-12-02\n- Category: Android\n\n[될때까지 안드로이드] 어댑터뷰 파트의 내용을 정리한 글입니다.\n\nListView 와 GridView\n\n- 반복되고 양이 많은 데이터를 표시하고 싶을 때\n- 이미지와 같이 메모리를 차지하는 리소스를 표시하고 싶을 때\n- 모두 AdapterView 추상클래스를 상속받아 어댑터 패턴을 사용하여 데이터를 뷰에 표시한다.\n- ScrollView의 경우 한번에 모든 컨텐츠를 로드하므로 컨텐츠가 메모리를 많이 사용할 경우 메모리 부족으로 앱이 종료될 수 있다.\n\n# AdapterView\n\n---\n\nAdapterView를 상속받은 뷰들은 화면에 보이는 내용만 로드하는 기법을 사용한다.\n\n## 1. AdapterView의 구현\n\n데이터 준비하기\n\n```java\n//MainActivity.java\nArrayList<Weather> data = new ArrayList<Weather>()\ndata.add(new Weather(\"수원\", \"25도\", \"맑음\"));\ndata.add(new Weather(\"안양\", \"22도\", \"비\"));\ndata.add(new Weather(\"부천\", \"22도\", \"구름\"));\ndata.add(new Weather(\"성남\", \"24도\", \"맑음\"));\ndata.add(new Weather(\"서울\", \"28도\", \"구름\"));\ndata.add(new Weather(\"광주\", \"30도\", \"비\"));\ndata.add(new Weather(\"부산\", \"20도\", \"비\"));\n```\n\n데이터를 뷰에 연결해 줄 어댑터를 준비한다.\n\n```java\n//MainActivity.java\nMyFirstAdapter adapter = new MyFirstAdapter(data);\n```\n\n뷰에 어댑터를 붙인다.\n\n```java\n//MainActivity.java\nListView listView = (ListView) findViewById(R.id.list_view);\nlistView.setAdapter(adapter);\n```\n\n## 2. 클릭 이벤트 구현\n\npublic static interface AdapterView.OnItemClickListener  \n<span class=\"clr-grey\">android.widget.AdapterView.OnItemClickListener : 어댑터뷰의 아이템 클릭시 호출되는 콜백 메서드를 정의한 인터페이스</span>\n\npublic abstract void onItemClick (AdapterView<?> parent, View view, int position, long id)  \n<span class=\"clr-grey\">\nparent : 클릭이 일어난 AdapterView  \nview : AdapterView 안의 클릭된 View = 클릭된 아이템 뷰  \nposition : 클릭된 아이템 뷰의 위치  \nid : 클릭된 아이템 뷰의 row ID\n</span>\n\n```java\nlistView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n  @Override\n  public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n    Toast.makeText(MainActivity.this, position + \" 번째 아이템 선택\", Toast.LENGTH_SHORT).show();\n   }\n});\n```\n\n## 3. 예제 구성\n\n1. Weather.java\n   날씨를 표현하는 모델클래스  \n   <span class=\"clr-grey\"> toString() : 모든 클래스가 가지고 있는 기본메서디로 디버깅이나 로그에서 정보 확인을 위해 toString() 메서드 재정의한다. </span>\n\n2. MyFirstAdapter.java  \n   추상클래스인 BaseAdapter를 상속받는 클래스로 추상 메서드들을 구현해야 한다.  \n   <span class=\"clr-grey\"> Note: BaseAdapter는 어댑터의 기능을 추상화해 둔 추상 클래스, 각 메서드 재정의 필요 </span>\n\n```java\n @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        /**\n         * LayoutInflater 클래스란?\n         * Activity 이외의 클래스에서 Context를 통해 XML로 정의한 레이아웃을 로드하여 View로 반환해주는 클래스\n         */\n        ViewHolder holder;\n        if (convertView == null) {\n            holder = new ViewHolder();\n            convertView = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_weather, parent, false);\n            ImageView weatherImage = (ImageView) convertView.findViewById(R.id.weather_image);\n            TextView cityText = (TextView) convertView.findViewById(R.id.city_text);\n            TextView tempText = (TextView) convertView.findViewById(R.id.temp_text);\n            holder.cityText = cityText;\n            holder.tempText = tempText;\n            holder.weatherImage = weatherImage;\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n\n        Weather weather = mData.get(position);\n        holder.cityText.setText(weather.getCity());\n        holder.tempText.setText(weather.getTemp());\n        holder.weatherImage.setImageResource(mWeatherImageMap.get(weather.getWeather()));\n        return convertView;\n    }\n    static class ViewHolder {\n        ImageView weatherImage;\n        TextView cityText;\n        TextView tempText;\n    }\n```\n\n- 핵심메서드 getView() 작성\n  - 각 아이템이 화면에 표시될 때마다 호출되며, 여기서 화면에 표시할 레이아웃과 데이터를 모두 작성해야한다.\n  - ListView의 각 아이템에 해당되는 View는 화면에 보이는 만큼만 생성되고 스크롤 시에 안쓰이는 아이템은 새로 보이는 아이템의 View로 재사용된다.  \n    <span class=\"clr-grey\"> Note: 두번째 파라미터인 convertView가 재사용 시에 이전에 생성되었던 getView()가 반환했던 View </span>\n- LayoutInflater 추상 클래스\n  - Activity 이외의 클래스에서 Context를 통해 XML로 정의한 레이아웃을 로드하여 View로 반환해주는 클래스\n  - 레이아웃 XML 파일을 View 객체로 반환한다.\n  - LayoutInflater 인스턴스 받는 법 : **Activity.getLayoutInflater()** or **Context.getSystemService(Class)**\n  - Public methods  \n    <span class=\"clr-grey\">\n    -LayoutInflater.from(parent.getContext())  \n     현재 Context로부터 LayoutInflater 인스턴스를 반환받는다._static LayoutInflater_  \n     -LayoutInflater.from(parent.getContext()).inflate(R.layout.item_weather, parent, false);  \n     inflate(int resource, ViewGroup root, boolean attachToRoot)  \n     xml파일 item_weather을 View 객체 형태로 반환한다.\n    </span>\n- ViewHolder\n  자주 사용하는 뷰를 한번 로드하면 재사용하고 표시할 내용만 교체하기 위한 패턴 - View 안에 여러 데이터를 담고 싶을 때, getTag(), setTag()를 사용한다.  \n   <span class=\"clr-grey\">android.view.View, Tag는 Object 타입이라 다양한 용도로 사용가능</span>\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"1915e03780a46a3344b4cdf3bc8284ba7af6804e","text":"# npm Working with package.json\n\n- Title : npm Working with package.json\n- Date : 2018-04-16\n- Category: Nodejs\n\n# 5. Working with package.json\n\n로컬에 설치된 npm 패키지를 관리하는 최상의 방법은 package.json 파일을 생성하는 것입니다.\n\npackage.json 파일은 :\n\n- 프로젝트가 의존하고 있는 패키지들의 리스트를 보여줍니다.\n- semantic versioning rule에 따라 프로젝트에 의존한 패키지들의 버전을 설정할 수 있습니다.\n- 빌드를 재현할 수 있으므로, 좀 더 쉽게 다른 개발자와 공유할 수 있습니다.\n\n## 요구사항\n\npackage.json 파일이 반드시 가져야하는 것\n\n- \"name\"\n  - 소문자\n  - 한단어, 띄어쓰기 허용X\n  - -(dashes) 와 \\_ (underscores) 허용O\n- \"version\"\n  - x.x.x 형태\n  - semver spec을 따름\n\n```\n{\n \"name\" : \"my-awesome-package\",\n \"version\" : \"1.0.0\"\n}\n```\n\n## package.json 파일 생성하기\n\n```\n> npm init\n또는\n> npm init --yes\n#--yes === -y\n```\n\n위 명령어는 현재 디렉토리로부터 정보를 추출해서 해당 package.json 파일을 생성합니다.\n\n```\n{\n  \"name\": \"my_package\",\n  \"description\": \"\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/ashleygwilliams/my_package.git\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/ashleygwilliams/my_package/issues\"\n  },\n  \"homepage\": \"https://github.com/ashleygwilliams/my_package\"\n}\n```\n\n- name : 현재 디렉토리 이름\n- version : 항상 1.0.0\n- description : readme 정보 또는 \"\"\n- main : 항상 index.js\n- scripts : 기존적으로 빈 테스트 스크립트를 만든다.\n- keywords : empty\n- author : empty\n- license : ISC\n- bugs : 현재 디렉토리의 정보\n- homepage : 현재 디렉토리의 정보\n\n다음과 같이 명령어 실행시 옵션을 설정할 수 있습니다.\n\n```\n> npm set init.author.email \"wombat@npmjs.com\"\n> npm set init.author.name \"ag_dubs\"\n> npm set init.license \"MIT\"\n```\n\n## Dependencies 지정하기\n\n프로젝트가 의존하는 패키지를 지정하려면 package.json 파일에 사용할 패키지들을 나열해야합니다. 그리고 패키지들은 두 개의 타입으로 나열될 수 있습니다.\n\n- \"dependencies\" : 프로젝트 배포 시\n- \"devDependencies\" : 프로젝트 개발 또는 테스트 시\n\npackage.jsondp dependencies를 추가하는 더 쉬운 방법은 npm install 명령어 실행시 --save 또는 --save-dev 플래그를 사용하는 것 입니다.\n\n```\n> npm install <package_name> --save\n> npm install <package_name> --save-dev\n```\n"}}}},"pageContext":{"id":"577478fb0b78d854a14f939dd2ff68114511aa30","previousPostId":"f8ebac2b78438548ddb7207724467420f65eee08","nextPostId":"1915e03780a46a3344b4cdf3bc8284ba7af6804e"}},"staticQueryHashes":["2685952063","2841359383"]}