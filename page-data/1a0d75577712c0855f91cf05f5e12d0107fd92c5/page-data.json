{"componentChunkName":"component---src-templates-blog-post-js","path":"/1a0d75577712c0855f91cf05f5e12d0107fd92c5","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"1a0d75577712c0855f91cf05f5e12d0107fd92c5","text":"# Javascript module\n\nDate: Jun 20, 2020\n\n- Title : Javascript module\n- Date : 2020-06-20\n- Category : Javascript\n\n# ES6 module 등장 배경\n\n클라이언트 사이드 자바스크립트는 파일을 여러 개로 분리하여 `script` 태그로 로드 하여도 분리된 자바스크립트 파일들이 결국 하나의 자바스크립트 파일 내에 있는 것처럼 **하나의 전역 객체를 공유**한다. \n\n이런 상황을 해결하고자`CommonJS`와 `AMD` 가 등장했고 자바스크립트의 모듈화는 크게 `CommonJS`와 `AMD` 진영으로 나뉘게 되었다. 브라우저에서 모듈을 사용하기 위해서는 `CommonJS` 또는 `AMD`를 구현한 모듈 로더 라이브러리를 사용해야 했다.\n\n이러한 상황에서 ES6는 클라이언트 사이드 자바스크립트에서도 동작하는 모듈 기능을 추가하였다.  `<script>` 태그에 `type=\"module\"` 요소를 추가하면 로드 된 자바스크립트 파일은 모듈로서 동작하여 **모듈 스코프**를 갖는다. 추가적으로 ES6는 모듈의 파일 확장자를 `mjs`로 설정 하기를  권장하고 있다.\n\n```bash\n<script type=\"module\" src=\"main.mjs\"></script>\n```\n\n하지만 IE를 포함한 구형 브라우저의 경우는 ES6 모듈을 지원하지 않아서 사용하더라도 트랜스 파일링이나 번들링이 필요하다. 이러한 이유로 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 웹팩, 바벨 같은 모듈 기반 시스템을 사용한다.\n\n# Module\n\n- ES6 모듈은 명시적으로 `use strict` 를 쓰지 않아도 엄격 모드로 코드가 실행된다.\n- `import`와 `export` 문은 모듈 내에서만 사용할 수 있다. HTML에서 모듈을 사용하려면 아래와 같이 `<script>` 요소에 `type=\"module\"` 을 포함시켜야 한다.\n- 모듈 스크립트를 불러올 때 자동으로 `defer`로 설정된다.\n\n    > 브라우저는 `script` 태그를 만나면 우선 해당 스크립트를 받아 해석하고 실행할 때까지 웹 문서의 HTML 코드 파싱 작업을 잠시 미룬다. 따라서 용량이 큰 스크립트를 문서 해석 초기에 만나게 되면 해당 페이지를 불러오는 속도가 지체된다. 이러한 병목 현상을 막기 위해 `script` 태그의 `async`와 `defer`속성을 사용한다. `script`가 문서를 직접 만지고 조작하거나 서로 간 로딩 순서가 중요할 때에는 `defer` 속성을 쓰고, 그렇지 않다면 `async`속성을 써서 웹 페이지 로딩 속도를 줄일 수 있다.\n\n    ![Untitled](https://user-images.githubusercontent.com/34448538/85366790-01836700-b563-11ea-8163-c324bce13a66.png)\n\n## 실습\n\n### export\n\n```jsx\n// square.js\n\n// ...randowSquare 정의\n\nexport default randomSquare;\n\nexport const name = 'square';\n\nexport function draw(ctx, length, x, y, color) {\n  ctx.fillStyle = color;\n  ctx.fillRect(x, y, length, length);\n\n  return {\n    length: length,\n    x: x,\n    y: y,\n    color: color\n  };\n}\n```\n\n### import\n\n```jsx\n// main.js\nimport randomSquare, { name, draw } from './modules/square.js';\n```\n\n### default export 이름 변경\n\n```jsx\nimport {default as randomSquare} from './modules/square.js';\n```\n\n### named export 이름 변경\n\n```jsx\n// inside module.js\nexport {\n  function1 as newFunctionName,\n  function2 as anotherNewFunctionName\n};\n\n// inside main.js\nimport { newFunctionName, anotherNewFunctionName } from './modules/module.js';\n```\n\n```jsx\n// inside module.js\nexport { function1, function2 };\n\n// inside main.js\nimport { function1 as newFunctionName,\n         function2 as anotherNewFunctionName } from './modules/module.js';\n```\n\n참고\n\n[Module | PoiemaWeb](https://poiemaweb.com/es6-module)\n\n[script 태그의 async와 defer 속성](https://appletree.or.kr/blog/web-development/javascript/script-%ED%83%9C%EA%B7%B8%EC%9D%98-async%EC%99%80-defer-%EC%86%8D%EC%84%B1/)\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"3a69a280df0251492517e4cdc764f4c0e0040854","text":"# 자바스크립트 엔진과 이벤트 루프\n\nDate: Jul 1, 2020\n\n- Title : 자바스크립트 엔진과 이벤트 루프\n- Date : 2020-07-01\n- Category : Javascript\n\n![Untitled](https://user-images.githubusercontent.com/34448538/87217780-f49aac00-c387-11ea-9c33-5a77863c7f28.png)\n\n## V8 엔진\n\n자바 스크립트 엔진 중 하나로 구글이 개발한 오픈 소스다. C++로 개발되어 있으며 크롬과 NodeJS에서 사용된다.\n\n**V8 엔진은 크게 두 부분으로 구성된다.**\n\n- 메모리 힙 (Memory Heap) : 메모리 할당이 이루어지는 곳\n- 콜 스택 (Call Stack) : 코드가 실행 되면서 스택 프레임이 쌓이는 곳\n\n### 메모리 힙\n\n객체나 동적 데이터(배열, 객체...)가 저장되는 공간으로 메모리 영역에서 가장 큰 블록이면서 가비지 컬렉션(GC)가 발생하는 곳이다. 힙 메모리 전체에서 가비지 컬렉션이 실행되는 것은 아니고 Young과 Old 영역에서만 실행된다.\n\n### 콜 스택\n\n메서드, 함수 프레임, 원시 값, 객체 포인터를 포함한 정적 데이터가 저장되는 곳이다.\n자바 스크립트는 콜 스택을 하나만 가지고 있는 싱글 스레드 언어이다.\n\n> **스택 트레이스?**\n예외가 발생했을 때의 콜 스택의 상태\n**스택 날림(Blowing the stack)?**\n스택 프레임이 콜 스택의 최대 크기까지 쌓였을 때\n\n### V8 메모리 사용 (스택 vs 힙)\n\n```jsx\nclass Employee {\n    constructor(name, salary, sales) {\n        this.name = name;\n        this.salary = salary;\n        this.sales = sales;\n    }\n}\n\nconst BONUS_PERCENTAGE = 10;\n\nfunction getBonusPercentage(salary) {\n    const percentage = (salary * BONUS_PERCENTAGE) / 100;\n    return percentage;\n}\n\nfunction findEmployeeBonus(salary, noOfSales) {\n    const bonusPercentage = getBonusPercentage(salary);\n    const bonus = bonusPercentage * noOfSales;\n    return bonus;\n}\n\nlet john = new Employee(\"John\", 5000, 5);\njohn.bonus = findEmployeeBonus(john.salary, john.sales);\nconsole.log(john.bonus);\n```\n\n![stackheap](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-07-01-img/stack-heap.gif)\n\n# 이벤트 루프와 비동기 프로그래밍\n\n자바 스크립트는 스레드(콜 스택이 하나)가 하나라 수행 시간이 긴 코드를 실행하게 되면 브라우저는 아무 것도 할 수 없게 된다. 하지만 실제 자바 스크립트가 사용 되는 환경을 생각해보면 많은 작업이 동시에 처리되고 있다. 예를 들면, 웹 브라우저는 애니메이션 효과를 보여주면서 마우스 입력을 받아서 처리하고, NodeJs 기반의 웹 서버에서는 동시에 여러 개의 HTTP 요청을 처리 하기도 한다. \n\n싱글 스레드인데 어떻게 이런 일이 가능할까? 자바 스크립트는 어떻게 동시성(Concurrency)을 지원할까? 이에 대한 답은 `자바 스크립트는 이벤트 루프 기반의 비동기 방식으로 동시성을 지원 한다`로 정리할 수 있다.\n\n## Web APIs\n\n브라우저가 제공하는 웹 API로 DOM Events, XMLHttpRequest, setTimeout, addEventListener 등이 포함된다.\n\n## 이벤트 루프와 태스크 큐\n\nWeb API 중 하나인 `setTimeout` 함수는 태스크 큐에서 대기하고 있다가 이벤트 루프를 통해 실행된다.\n태스크 큐는 말 그대로 콜백 함수들이 대기하는 큐(FIFO) 형태의 배열이라 할 수 있고 이벤트 루프는 콜 스택이 비어질 때마다 큐에서 콜백 함수를 꺼내 와서 실행하는 역할을 한다.\n\n```jsx\nsetTimeout(baz, 10); // (1)\nfoo();\n```\n\n위의 예시의 코드가 처음 실행되면 `setTimeout` 함수는 브라우저에게 타이머 이벤트를 요청한 후 바로 콜 스택에서 제거된다. 그 후에 `foo` 함수가 콜 스택에 추가된다. 10ms가 지나면 브라우저의 타이머는 `baz` 함수를 태스크 큐에 추가한다. 이벤트 루프는 `foo` 함수가 실행을 마치고 콜 스택에서 사라지면 태스크 큐에서 대기 중인 `baz`를 실행하여 콜 스택에 추가한다.\n\n![image](https://user-images.githubusercontent.com/34448538/87217762-c74dfe00-c387-11ea-920e-87d0761c4fff.png)\n\n정리하자면 이벤트 루프는 **현재 실행 중인 태스크가 없는 지**와 **태스크 큐에 태스크가 있는지**를 반복적으로 확인하여 **현재 실행 중인 태스크가 없을 때**(주로 호출 스택이 비워졌을 때) 태스크 큐의 첫번째 태스크를 가져와 실행한다. 참고로 모든 브라우저의 비동기 API들은 작업이 완료되면 콜백 함수를 태스크 큐에 추가한다.\n\n### 마이크로 태스크\n\n일반 태스크보다 더 높은 우선 순위를 갖는 태스크로 태스크 큐에 대기 중인 태스크가 있더라도 마이크로 태스크가 먼저 실행된다. \n\n```jsx\nsetTimeout(function() { // (A)\n    console.log('A');\n}, 0);\nPromise.resolve().then(function() { // (B)\n    console.log('B');\n}).then(function() { // (C)\n    console.log('C');\n});\n```\n\nPromise 콜백 함수는 마이크로 태스크 큐에 추가되고 setTimeout 콜백 함수는 일반 태스크 큐에 추가되기에 이벤트 루프는 마이크로 태스크 큐에 있는 작업을 먼저 실행한 후 태스크 큐의 태스크를 실행한다. 즉 B → C → A 순으로 실행된다.\n\n \n참고\n[https://vimeo.com/96425312](https://vimeo.com/96425312)\n\n[https://meetup.toast.com/posts/89](https://meetup.toast.com/posts/89)\n\n[https://engineering.huiseoul.com/자바스크립트는-어떻게-작동하는가-v8-엔진의-내부-최적화된-코드를-작성을-위한-다섯-가지-팁-6c6f9832c1d9](https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-v8-%EC%97%94%EC%A7%84%EC%9D%98-%EB%82%B4%EB%B6%80-%EC%B5%9C%EC%A0%81%ED%99%94%EB%90%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%8B%A4%EC%84%AF-%EA%B0%80%EC%A7%80-%ED%8C%81-6c6f9832c1d9)\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"1d97f7e13119ff2ba29e19b7c06f0633ab1007fe","text":"# Git cherry-pick으로 필요한 커밋만 골라내기\n\nDate: Jun 17, 2020\n\n- Title : Git cherry-pick으로 필요한 커밋만 골라내기\n- Date : 2020-03-17\n- Category : Git\n\n# Git Cherry-pick\n\n현재 상황\n\n- feature/cherry에 작업한 결과를 Pull Request 보낸 상태\n- 브랜치가 꼬여서 해당 브랜치에서 작업한 커밋 외의 것도 보이는 상태\n\n원하는 결과\n\n- feature/cherry 에서 원하는 커밋만 남긴 후 다시 푸시 하고 싶음(PR 재 요청X)\n\n## 실습\n\n### feature/cherry 브랜치 로그 확인\n\n```bash\ngit log\n```\n\n`결과 예시: commit 4564415dfbdsfgsdgsd (feature/cherry)` \n\n### 커밋들을 저장할 임시 브랜치 생성(base branch에서 새 브랜치 생성)\n\n```bash\ngit checkout -b feature/cherry-correct\n```\n\n### cherry-pick 실행\n\n```bash\ngit cherry-pick 4564415dfbdsfgsdgsd(가져 가고 싶은 커밋넘버)\n```\n\n### feature/cherry 브랜치 reset\n\n```bash\ngit checkout feature/cherry\ngit reset feature/cherry-correct --hard\ngit push origin feature/cherry -f\n```\n\n`--hard` 옵션이 없을 경우 기존 브랜치에서 작업한 내용이 `unstaged`된 채 남아 있으니 필요한 경우가 아니라면 옵션을 추가 하는 것이 좋다.\n\n참고\n\n[https://medium.com/react-native-seoul/git-cherry-pick-사용법-fe1a3346bd27](https://medium.com/react-native-seoul/git-cherry-pick-%EC%82%AC%EC%9A%A9%EB%B2%95-fe1a3346bd27)\n"}}}},"pageContext":{"id":"1a0d75577712c0855f91cf05f5e12d0107fd92c5","previousPostId":"3a69a280df0251492517e4cdc764f4c0e0040854","nextPostId":"1d97f7e13119ff2ba29e19b7c06f0633ab1007fe"}},"staticQueryHashes":["2685952063","2841359383"]}