{"componentChunkName":"component---src-templates-blog-post-js","path":"/e1d99f9a899dc585ce4b9625b8729cc326c3da77","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e1d99f9a899dc585ce4b9625b8729cc326c3da77","text":"# Pattern Searching - Naive algorithm\n\n- Title : Pattern Searching - Naive algorithm\n- Date : 2020-03-10\n- Category: Algorithm\n\n## Naive algorithm\n\n문자열 인덱스 0부터 패턴 문자열은 하나씩 비교해가는 방법. 가장 직관적이면서 순수(?)하다.\n\n```cpp\n    #include <iostream>\n    #include <cstring>\n    using namespace std;\n\n    void search(char* pat, char* txt) {\n    \tint M = strlen(pat);\n    \tint N = strlen(txt);\n\n    \tfor (int i=0; i<=N-M; i++) {\n    \t\tint j;\n    \t\tfor (j=0; j<M; j++) {\n    \t\t\tif (txt[i + j] != pat[j]) break;\n    \t\t}\n    \t\tif (j == M)\n    \t\t\tcout << \"Pattern found at index \" << i << endl;\n    \t}\n    }\n    int main() {\n    \tchar txt[] = \"AABAACAADAABAABA\";\n    \tchar pat[] = \"AABA\";\n    \tsearch(pat, txt);\n    \treturn 0;\n    }\n```\n\n## 시간 복잡도\n\n### 최선의 시간 복잡도\n\n- txt[] = \"AABCCAADDEE\"\n- pat[] = \"FAA\"\n\n패턴의 첫번째 문자 'F'가 일치하는 경우가 없어서 `O(n)`의 시간 복잡도를 가진다. n: 탐색 문자열의 길이\n\n### 최악의 시간 복잡도\n\n- txt[] = \"AAAAAAAAAAAAAAAAAA\"\n- pat[] = \"AAAAB\"\n\n패턴의 마지막 문자 'B'만 다를 경우 `O(m*(n-m+1))`의 시간 복잡도를 가진다. m: 패턴 문자열의 길이, n: 탐색 문자열의 길이\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d4a60dea091fb5b6e0163278ddd1345bb5131c7c","text":"# Pattern Searching - KMP Algorithm\n\n- Title : Pattern Searching - KMP Algorithm\n- Date : 2020-03-11\n- Category: Algorithm\n\n## KMP\n\nkmp 알고리즘은 Pattern Searching - Naive Alogorithm(TIL 알고리즘 파트에서 내용을 볼 수 있음)과 비슷하나 0~N(탐색문자길이) 탐색 중 적절하게 문자를 건너뛴다. 아래 예시로 이해해보자.\n\n- txt[] = ABABCAAA\n- pat[] = ABABD\n\n첫번째 윈도우 탐색 결과 패턴을 찾지는 못했다.\n\n- txt[] = `ABABC`AAA\n- pat[] = `ABABD`\n\nNaive 알고리즘 방식대로 이어서 두번째 윈도우를 탐색해보자.\n\n- txt[] = A`BABCA`AA\n- pat[] = `ABABD`\n\nNaive 알고리즘 방식대로 이어서 세번째 윈도우를 탐색해보자.\n\n- txt[] = AB`ABCAA`A\n- pat[] = `ABABD`\n\n하지만 KMP 알고리즘은 적절하게 문자를 건너뛰어서 첫번째 윈도우 후 다음으로 탐색할 두번째 윈도우는 아래와 같다.\n\n- txt[] = AB`ABCAA`A\n- pat[] = `ABABD`\n\n첫번째 윈도우 탐색 결과 ABAB까지는 패턴과 일치하는 것을 이용한 것이다. 패턴의 부분 문자열이기도한 ABAB는 접두사 AB와 접미사 AB가 일치한다. 다음 패턴의 시작점을 접미사의 시작점으로 할 수가 있는 거다.\n\n## lps[] 란?\n\n- lps 배열의 크기는 패턴의 길이와 같고 패턴 탐색 시 몇 개의 문자를 건너뛸지를 결정한다.\n- lps[i]는 패턴의 0~ i 까지의 부분 문자열에서의 접두어(prefix)와 접미어(suffix)가 같은 부분 문자열 중 가장 긴 것의 길이다. 단 접두어로 전체 문자열은 허용하지않는다.\n\n## Ips[] 예시\n\n\"AAAA\"\n\n- \"A\" : Ips[0] = **0** (prefix는 전체 문자열이 안됨)\n- \"AA\" : lps[1] = **1** ( prefix `A` suffix `A` )\n- \"AAA\" : lps[2] = **2** ( prefix `AA` suffix `AA` )\n- \"AAAA\" : lps[3] = **3** ( prefix `AAA` suffix `AAA` )\n\n\"ABCDE\"\n\n- \"A\" : Ips[0] = **0**\n- \"AB\" : lps[1] = **0**\n- \"ABC\" : lps[2] = **0**\n- \"ABCD\" : lps[3] = **0**\n- \"ABCDE\" : lps[4] = **0**\n\n\"AABAACAABAA\"\n\n- \"A\" : lps[0] = 0\n- \"`A` `A`\" : lps[1] = 1\n- \"AAB\" : lps[2] = 0\n- \"`A`AB`A`\" : lps[3] = 1\n- \"`AA`B`AA`\" : lps[4] = 2\n- \"AABAAC\" : lps[5] = 0\n- \"`A`ABAAC`A`\" : lps[6] = 1\n- \"`AA`BAAC`AA`\" : lps[7] = 2\n- \"`AAB`AAC`AAB`\" : lps[8] = 3\n- \"`AABA`AC`AABA`\" : lps[9] = 4\n- \"`AABAA`C`AABAA`\" : lps[10] = 5\n\n## lps를 이용해 탐색하기\n\n- 현재 txt 윈도우에서 pat[j] j는 0부터 비교를 시작하기\n- txt[i]와 pat[j]가 일치하면 i와 j를 증가하기\n- txt[i]와 pat[j]가 일치하지않으면\n  - 패턴 0~j-1과 탐색문자 i-j~i-1 까지는 일치한다는 것은 알고 있다.\n  - lps[j-1]은 패턴의 0~j-1 부분 문자열의 접두어 접미어가 일치하는 부분 문자열 중 길이가 가장 긴 값이라는 것은 위 정의를 통해 이미 알고 있다.\n  - 현재 윈도우 txt[i-j~i-1]에서 lps[j-1]만큼은 탐색할 필요는 없다.\n\n## C++\n\n\"AABAACAABAA\"\n\n- lps[0] = 0\n- i = 1, len = 0 ⇒ **lps[1] = 1**\n  - pat[1] == pat[0] , len=1, lps[1] = 1, i = 2\n- i = 2, len = 1\n  - pat[2] != pat[1] && len ! = 0, len = lps[1-1] =lps[0] = 0\n- i = 2, len = 0 ⇒ **lps[2] = 0**\n  - pat[2] ≠ pat[0] && len == 0, lps[2] = 0, i = 3\n\n```cpp\n    #include <iostream>\n    #include <cstring>\n    using namespace std;\n\n    void computeLPSArray(char* pat, int M, int *lps) {\n    \t// 현재까지 계산한 lps 중 가장 큰 값\n    \tint len = 0;\n    \t// 부분문자열 길이가 1이면 lps 값은 언제나 0\n    \tlps[0] = 0;\n\n    \t// i ~ M - 1 까지 계산\n    \tint i = 1;\n    \twhile (i < M) {\n    \t\tif (pat[i] == pat[len]) {\n    \t\t\tlen++;\n    \t\t\tlps[i] = len;\n    \t\t\ti++;\n    \t\t} else {\n    \t\t\tif (len != 0) {\n    \t\t\t\tlen = lps[len - 1];\n    \t\t\t} else {\n    \t\t\t\tlps[i] = 0;\n    \t\t\t\ti++;\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    void KMPSearch(char* pat, char* txt) {\n    \tint M = strlen(pat);\n    \tint N = strlen(txt);\n\n    \tint lps[M];\n\n    \tcomputeLPSArray(pat, M, lps);\n\n    \tint i = 0, j = 0;\n    \twhile (i < N) {\n    \t\tif (pat[j] == txt[i]) {\n    \t\t\tj++;\n    \t\t\ti++;\n    \t\t}\n    \t\tif (j == M) {\n    \t\t\tcout << \"Found Pattern at index \" << (i - j) << endl;\n    \t\t\tj = lps[j - 1];\n    \t\t}\n    \t\t// 패턴이 일치하지않으면\n    \t\telse if (i < N && pat[j] != txt[i]) {\n    \t\t\t// 미스매칭이 1~M이면\n    \t\t\tif (j != 0)\n    \t\t\t\tj = lps[j - 1];\n    \t\t\telse // 첫 문자부터 미스매칭\n    \t\t\t\ti = i + 1;\n    \t\t}\n    \t}\n    }\n    int main() {\n    \tchar txt[] = \"AABAACAADAABAABA\";\n    \tchar pat[] = \"AABA\";\n    \tKMPSearch(pat, txt);\n    \treturn 0;\n    }\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"57c3c92534f9c78520f1c8b610b3d22a3d7fb7d8","text":"# 에라토스테네스의 체\n\n- Title : 에라토스테네스의 체\n- Date : 2020-03-07\n- Category: Algorithm\n\n## 에라토스테네스의 체\n\nN보다 작거나 같은 모든 소수를 찾는 알고리즘이다.\n\n- N이 1보다 작거나 같으면 소수가 없다.\n- 2부터 N까지의 모든 수를 나열한다 - 2부터 N까지 N-1 개를 저장할 수 있는 배열을 할당한다. 배열 참조번호와 소수가 일치하도록 배열의 크기는 N+1만큼 할당(인덱스 0, 1은 사용하지 않는다)\n- 검사는 2부터 sqrt(N) 전까지만 하면 된다.\n\n```cpp\n  void Eratos(int n) {\n    if (n <= 1) return;\n    bool arr[n+1];\n    fill(&arr[2], &arr[n+1], true);\n    for (int i=2; i*i<n+1; i++) {\n      if (arr[i]) {\n        for (int j = i*i; j<n+1; j+=i) {\n          arr[j] = false;\n        }\n      }\n    }\n  }\n```\n\n### **백준 문제 풀이**\n\n[2960번: 에라토스테네스의 체](https://www.acmicpc.net/problem/2960)\n\n```cpp\n    #include <iostream>\n    using namespace std;\n\n    int solve(int n, int k) {\n    \tint cnt = 0;\n    \tbool arr[n+1];\n    \tfill(&arr[0], &arr[n+1], true);\n    \tfor (int i=2; i<n+1; i++) {\n    \t\tif (!arr[i]) continue;\n    \t\tfor (int j=i; j<n+1; j=j+i) {\n    \t\t\tif (arr[j]) {\n    \t\t\t\tarr[j] = false;\n    \t\t\t\tif (++cnt == k) return j;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn -1;\n    }\n    int main() {\n    \tint n, k;\n    \tcin >> n >> k;\n    \tcout << solve(n, k);\n    \treturn 0;\n    }\n```\n\n[1644번: 소수의 연속합](https://www.acmicpc.net/problem/1644)\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    using namespace std;\n\n    vector<int> p;\n    int n, ans = 0;\n    void eratos() {\n    \tbool arr[n+1];\n    \tfill(&arr[2], &arr[n+1], true);\n    \tfor (int i=2; i*i<n+1; i++) {\n    \t\tif (arr[i]) {\n    \t\t\tfor (int j=i*i; j<n+1; j+=i) {\n    \t\t\t\tarr[j] = false;\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \tfor (int i=2; i<n+1; i++) {\n    \t\tif (arr[i]) {\n    \t\t\tp.push_back(i);\n    \t\t}\n    \t}\n    }\n\n    void solve() {\n    \tint s = 0, e = 0;\n    \tint sum = 0;\n    \twhile (s < p.size() && e < p.size()) {\n    \t\tsum += p[e++];\n    \t\tif (sum == n) {\n    \t\t\tans++;\n    \t\t}\n    \t\telse if (sum > n) {\n    \t\t\twhile (s < e) {\n    \t\t\t\tsum -= p[s++];\n    \t\t\t\tif (sum <= n) {\n    \t\t\t\t\tif (sum == n) {\n    \t\t\t\t\t\tans++;\n    \t\t\t\t\t}\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    int main() {\n    \tcin >> n;\n    \teratos();\n    \tsolve();\n    \tcout << ans;\n    \treturn 0;\n    }\n```\n\n**참고**\n\n[에라토스테네스의 체](https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4)\n"}}}},"pageContext":{"id":"e1d99f9a899dc585ce4b9625b8729cc326c3da77","previousPostId":"d4a60dea091fb5b6e0163278ddd1345bb5131c7c","nextPostId":"57c3c92534f9c78520f1c8b610b3d22a3d7fb7d8"}},"staticQueryHashes":["2685952063","2841359383"]}