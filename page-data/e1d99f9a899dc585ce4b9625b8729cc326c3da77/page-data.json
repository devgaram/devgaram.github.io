{"componentChunkName":"component---src-templates-blog-post-js","path":"/e1d99f9a899dc585ce4b9625b8729cc326c3da77","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e1d99f9a899dc585ce4b9625b8729cc326c3da77","text":"# Pattern Searching - Naive algorithm\n\n- Title : Pattern Searching - Naive algorithm\n- Date : 2020-03-10\n- Category: Algorithm\n\n## Naive algorithm\n\n문자열 인덱스 0부터 패턴 문자열은 하나씩 비교해가는 방법. 가장 직관적이면서 순수(?)하다.\n\n```cpp\n    #include <iostream>\n    #include <cstring>\n    using namespace std;\n\n    void search(char* pat, char* txt) {\n    \tint M = strlen(pat);\n    \tint N = strlen(txt);\n\n    \tfor (int i=0; i<=N-M; i++) {\n    \t\tint j;\n    \t\tfor (j=0; j<M; j++) {\n    \t\t\tif (txt[i + j] != pat[j]) break;\n    \t\t}\n    \t\tif (j == M)\n    \t\t\tcout << \"Pattern found at index \" << i << endl;\n    \t}\n    }\n    int main() {\n    \tchar txt[] = \"AABAACAADAABAABA\";\n    \tchar pat[] = \"AABA\";\n    \tsearch(pat, txt);\n    \treturn 0;\n    }\n```\n\n## 시간 복잡도\n\n### 최선의 시간 복잡도\n\n- txt[] = \"AABCCAADDEE\"\n- pat[] = \"FAA\"\n\n패턴의 첫번째 문자 'F'가 일치하는 경우가 없어서 `O(n)`의 시간 복잡도를 가진다. n: 탐색 문자열의 길이\n\n### 최악의 시간 복잡도\n\n- txt[] = \"AAAAAAAAAAAAAAAAAA\"\n- pat[] = \"AAAAB\"\n\n패턴의 마지막 문자 'B'만 다를 경우 `O(m*(n-m+1))`의 시간 복잡도를 가진다. m: 패턴 문자열의 길이, n: 탐색 문자열의 길이\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d4a60dea091fb5b6e0163278ddd1345bb5131c7c","text":"# Pattern Searching - KMP Algorithm\n\n- Title : Pattern Searching - KMP Algorithm\n- Date : 2020-03-11\n- Category: Algorithm\n\n## KMP\n\nkmp 알고리즘은 Pattern Searching - Naive Alogorithm(TIL 알고리즘 파트에서 내용을 볼 수 있음)과 비슷하나 0~N(탐색문자길이) 탐색 중 적절하게 문자를 건너뛴다. 아래 예시로 이해해보자.\n\n- txt[] = ABABCAAA\n- pat[] = ABABD\n\n첫번째 윈도우 탐색 결과 패턴을 찾지는 못했다.\n\n- txt[] = `ABABC`AAA\n- pat[] = `ABABD`\n\nNaive 알고리즘 방식대로 이어서 두번째 윈도우를 탐색해보자.\n\n- txt[] = A`BABCA`AA\n- pat[] = `ABABD`\n\nNaive 알고리즘 방식대로 이어서 세번째 윈도우를 탐색해보자.\n\n- txt[] = AB`ABCAA`A\n- pat[] = `ABABD`\n\n하지만 KMP 알고리즘은 적절하게 문자를 건너뛰어서 첫번째 윈도우 후 다음으로 탐색할 두번째 윈도우는 아래와 같다.\n\n- txt[] = AB`ABCAA`A\n- pat[] = `ABABD`\n\n첫번째 윈도우 탐색 결과 ABAB까지는 패턴과 일치하는 것을 이용한 것이다. 패턴의 부분 문자열이기도한 ABAB는 접두사 AB와 접미사 AB가 일치한다. 다음 패턴의 시작점을 접미사의 시작점으로 할 수가 있는 거다.\n\n## lps[] 란?\n\n- lps 배열의 크기는 패턴의 길이와 같고 패턴 탐색 시 몇 개의 문자를 건너뛸지를 결정한다.\n- lps[i]는 패턴의 0~ i 까지의 부분 문자열에서의 접두어(prefix)와 접미어(suffix)가 같은 부분 문자열 중 가장 긴 것의 길이다. 단 접두어로 전체 문자열은 허용하지않는다.\n\n## Ips[] 예시\n\n\"AAAA\"\n\n- \"A\" : Ips[0] = **0** (prefix는 전체 문자열이 안됨)\n- \"AA\" : lps[1] = **1** ( prefix `A` suffix `A` )\n- \"AAA\" : lps[2] = **2** ( prefix `AA` suffix `AA` )\n- \"AAAA\" : lps[3] = **3** ( prefix `AAA` suffix `AAA` )\n\n\"ABCDE\"\n\n- \"A\" : Ips[0] = **0**\n- \"AB\" : lps[1] = **0**\n- \"ABC\" : lps[2] = **0**\n- \"ABCD\" : lps[3] = **0**\n- \"ABCDE\" : lps[4] = **0**\n\n\"AABAACAABAA\"\n\n- \"A\" : lps[0] = 0\n- \"`A` `A`\" : lps[1] = 1\n- \"AAB\" : lps[2] = 0\n- \"`A`AB`A`\" : lps[3] = 1\n- \"`AA`B`AA`\" : lps[4] = 2\n- \"AABAAC\" : lps[5] = 0\n- \"`A`ABAAC`A`\" : lps[6] = 1\n- \"`AA`BAAC`AA`\" : lps[7] = 2\n- \"`AAB`AAC`AAB`\" : lps[8] = 3\n- \"`AABA`AC`AABA`\" : lps[9] = 4\n- \"`AABAA`C`AABAA`\" : lps[10] = 5\n\n## lps를 이용해 탐색하기\n\n- 현재 txt 윈도우에서 pat[j] j는 0부터 비교를 시작하기\n- txt[i]와 pat[j]가 일치하면 i와 j를 증가하기\n- txt[i]와 pat[j]가 일치하지않으면\n  - 패턴 0~j-1과 탐색문자 i-j~i-1 까지는 일치한다는 것은 알고 있다.\n  - lps[j-1]은 패턴의 0~j-1 부분 문자열의 접두어 접미어가 일치하는 부분 문자열 중 길이가 가장 긴 값이라는 것은 위 정의를 통해 이미 알고 있다.\n  - 현재 윈도우 txt[i-j~i-1]에서 lps[j-1]만큼은 탐색할 필요는 없다.\n\n## C++\n\n\"AABAACAABAA\"\n\n- lps[0] = 0\n- i = 1, len = 0 ⇒ **lps[1] = 1**\n  - pat[1] == pat[0] , len=1, lps[1] = 1, i = 2\n- i = 2, len = 1\n  - pat[2] != pat[1] && len ! = 0, len = lps[1-1] =lps[0] = 0\n- i = 2, len = 0 ⇒ **lps[2] = 0**\n  - pat[2] ≠ pat[0] && len == 0, lps[2] = 0, i = 3\n\n```cpp\n    #include <iostream>\n    #include <cstring>\n    using namespace std;\n\n    void computeLPSArray(char* pat, int M, int *lps) {\n    \t// 현재까지 계산한 lps 중 가장 큰 값\n    \tint len = 0;\n    \t// 부분문자열 길이가 1이면 lps 값은 언제나 0\n    \tlps[0] = 0;\n\n    \t// i ~ M - 1 까지 계산\n    \tint i = 1;\n    \twhile (i < M) {\n    \t\tif (pat[i] == pat[len]) {\n    \t\t\tlen++;\n    \t\t\tlps[i] = len;\n    \t\t\ti++;\n    \t\t} else {\n    \t\t\tif (len != 0) {\n    \t\t\t\tlen = lps[len - 1];\n    \t\t\t} else {\n    \t\t\t\tlps[i] = 0;\n    \t\t\t\ti++;\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    void KMPSearch(char* pat, char* txt) {\n    \tint M = strlen(pat);\n    \tint N = strlen(txt);\n\n    \tint lps[M];\n\n    \tcomputeLPSArray(pat, M, lps);\n\n    \tint i = 0, j = 0;\n    \twhile (i < N) {\n    \t\tif (pat[j] == txt[i]) {\n    \t\t\tj++;\n    \t\t\ti++;\n    \t\t}\n    \t\tif (j == M) {\n    \t\t\tcout << \"Found Pattern at index \" << (i - j) << endl;\n    \t\t\tj = lps[j - 1];\n    \t\t}\n    \t\t// 패턴이 일치하지않으면\n    \t\telse if (i < N && pat[j] != txt[i]) {\n    \t\t\t// 미스매칭이 1~M이면\n    \t\t\tif (j != 0)\n    \t\t\t\tj = lps[j - 1];\n    \t\t\telse // 첫 문자부터 미스매칭\n    \t\t\t\ti = i + 1;\n    \t\t}\n    \t}\n    }\n    int main() {\n    \tchar txt[] = \"AABAACAADAABAABA\";\n    \tchar pat[] = \"AABA\";\n    \tKMPSearch(pat, txt);\n    \treturn 0;\n    }\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"146f5eb0b2e672cd66e3c67c69e36f8cac38be23","text":"# [Vue] 슬롯(Slots)\n\n- Title : [Vue] 슬롯(Slots)\n- Date : 2020-03-09\n- Category: Vue\n\n## Why?\n\n요즘 vue 프로젝트를 하면서 Vuetify 공식 문서를 매일 같이 들락날락 하고 있다. 크롬 탭 한켠에 켜놓고 Vuetify 죠아..🤩하며 잘 쓰고 있던 중 낯선 예제가 눈에 밟혔다. 바로 아래의 `<v-menu>` 컴포넌트의 예시 코드다.\n\n```ts\n    <v-menu offset-y>\n    \t<template v-slot:activator=\"{ on }\">\n    \t  <v-btn\n    \t    color=\"primary\"\n          dark\n          v-on=\"on\"\n    \t   >\n    \t     Dropdown\n    \t\t </v-btn>\n       </template>\n       <v-list>\n         <v-list-item\n           v-for=\"(item, index) in items\"\n           :key=\"index\"\n           @click=\"\"\n         >\n           <v-list-item-title>{{ item.title }}</v-list-item-title>\n         </v-list-item>\n       </v-list>\n     </v-menu>\n```\n\n**`<template v-slot:activator=\"{ on }>`** 음.. slot이 컴포넌트 렌더링할 때 베이스 컴포넌트의 `<slot>` 에 부모 컴포넌트가 들어가는 거 였는 데...? 근데 예제에서 어떻게 리스트를 보였다 숨겼다 하는 거지? 라는 생각이 들었고 지식의 짧음을 깨달아 곧장 Vue 공식 문서를 방문했다.\n\n[슬롯(Slots) - Vue.js](https://kr.vuejs.org/v2/guide/components-slots.html)\n\n## 슬롯?\n\n### A 컴포넌트 안에 B(컴포넌트, 텍스트, HTML 템플릿..)를 넣고 싶을 때\n\n예시로 페이지마다 쓰이는 레이아웃(헤더, 푸터) 컴포넌트에 페이지마다 달라지는 컨텐츠 컴포넌트를 넣고 싶다고 하자.\n\n레이아웃(Layout) 컴포넌트는 아래와 같다.\n\n```ts\n<template>\n  <Header />\n  <main>\n    <slot></slot>\n  </main>\n  <Footer />\n</template>\n```\n\n이제 콘텐츠(Content) 컴포넌트를 Layout 컴포넌트의 `<slot></slot>` 부분에 넣어보자.\n\n콘텐츠(Content) 컴포넌트는 아래와 같다.\n\n```ts\n<template>\n  <Layout>\n    <div>매번 변경되는 컨텐츠들..</div>\n    <Shop />\n  </Layout>\n</template>\n```\n\n만약 레이아웃 컴포넌트에 `<slot>` 이 없으면 위 예제의 `<Layout>` 요소 안에 있는 내용은 무시된다.\n\n### 음 근데 A컴포넌트 안에 여러 `<slot>`을 만들고 싶은데?\n\n당근 가능하다. 위 예제에서 컨텐츠뿐만 아니라 헤더와 푸터도 `<slot>` 요소로 받을 수 있게 바꿔보자\n\n```ts\n<template>\n  <slot name=\"header\"></slot>\n  <main>\n    <slot></slot>\n  </main>\n  <slot name=\"footer\"></slot>\n</template>\n```\n\n자세히 살펴보면 `<slot>`이 name 속성을 가지고 있다. `<main>`안의 `<slot>`은 name이 지정되지 않았는 데 이때는 암묵적으로 \"default\" 이름을 갖는다.\n\n자 이제 레이아웃 컴포넌트에 헤더, 푸터 컴포넌트와 콘텐츠 내용을 전달해보자.\n\n```ts\n    <template>\n    \t<Layout>\n    \t\t<template v-slot:header><Header /></template>\n    \t\t<div>매번 변경되는 컨텐츠들..</div>\n    \t\t<Shop />\n    \t\t<template v-slot:footer><Footer/></template>\n    \t</Layout>\n    </template>\n```\n\nname 속성이 있는 슬롯에 내용을 전달하려면 `<template>`에 `v-slot` 디렉티브를 쓰고 속성에 앞에서 지정한 name을 넣으면 된다. 이제 `<template>` 요소들의 모든 내용들은 적절한 슬롯에 전달된다. `<template>`에 싸여있지 않은 내용들은 default 슬롯으로 간주하여 이름 없는 `<slot>`요소에 전달된다. v-slot:default로 명시적으로 표시할 수도 있는 데 아래 예제로 확인해보자. 아래 예제는 바로 위 예제와 동일하다.\n\n```ts\n    <template>\n    \t<Layout>\n    \t\t<template v-slot:header><Header /></template>\n    \t\t<template v-slot:default>\n    \t\t\t<div>매번 변경되는 컨텐츠들..</div>\n    \t\t\t<Shop />\n    \t\t</template>\n    \t\t<template v-slot:footer><Footer/></template>\n    \t</Layout>\n    </template>\n```\n\nv-slot만 `<template>` 태그에 추가할 수 있다는 점! 기억하기.\n\n### 슬롯에 전달될 내용이 없을 때 디폴트로 어떤 내용을 표시하고 싶으면?\n\n버튼 텍스트를 `<slot>` 요소로 전달 받으려면 아래와 같이 만들어야한다. 컴포넌트의 이름은 SubmitBtn으로 하자.\n\n```ts\n    <template>\n    \t<v-btn type=\"submit\" :color=\"color\">\n    \t\t<slot></slot>\n    \t</v-btn>\n    </template>\n```\n\n아래와 같이 `<slot>`을 \"저장\" 텍스트로 대체해보자\n\n```ts\n<template>\n  <SubmitBtn color=\"grey\">저장</SubmitBtn>\n</template>\n```\n\n근데 `<SubmitBtn>`안에 아무 것도 안적어도 `<slot>`요소가 \"submit\"으로 대체되게 하고 싶다면? SubmitBtn 컴포넌트를 아래와 같이 수정하자.\n\n```ts\n    <template>\n    \t<v-btn type=\"submit\" :color=\"color\">\n    \t\t<slot>submit</slot>\n    \t</v-btn>\n    </template>\n```\n\n이제 아무 내용이 없으면 submit이 렌더링 된다.\n\n```ts\n<template>\n  <SubmitBtn></SubmitBtn>\n</template>\n```\n\n위 코드의 렌더링 결과는 아래와 같다.\n\n```ts\n<v-btn type=\"submit\">submit</v-btn>\n```\n\n### 자. 여기까지 배운 상태에서 v-menu 예제를 다시 살펴보자.\n\n```ts\n    <v-menu offset-y>\n    \t<template v-slot:activator=\"{ on }\">\n    \t  <v-btn\n    \t    color=\"primary\"\n          dark\n          v-on=\"on\"\n    \t   >\n    \t     Dropdown\n    \t\t </v-btn>\n       </template>\n       <v-list>\n         <v-list-item\n           v-for=\"(item, index) in items\"\n           :key=\"index\"\n           @click=\"\"\n         >\n           <v-list-item-title>{{ item.title }}</v-list-item-title>\n         </v-list-item>\n       </v-list>\n     </v-menu>\n```\n\n이정도 해석은 가능할거다. `<v-menu>` 컴포넌트에 `<slot name=\"activator\"></slot>`이 존재하겠구나. 그래서 `<v-btn>` 요소는 \"activator\" 슬롯에 대체되고 `<template>`로 싸여있지않은 `<v-list>` 컴포넌트는 `<slot></slot>` 즉, 이름 없는 \"default\" 슬롯에 전달되겠네!\n\n그래도 여전히 의문이 남아있다. activator=\"{ on }\" 의 의미는 뭐지? `<v-btn>` 요소의 v-on 디렉티브에 on이 전달되는 데? 무슨 의미일까? 계속 슬롯에 대해 알아보자\n\n잠시 컴파일 범위를 짚고 넘어가보자.\n\n> 부모 템플릿 안에 있는 것은 부모 컴포넌트의 범위에 컴파일되고 자식 템플릿 안에 있는 것들은 자식 컴포넌트의 범위에 컴파일된다.\n\n무슨 의미인지 예제로 이해해보자. 우선 자식 컴포넌트를 살펴보자. 베이스 컴포넌트라고 이해해도 좋다. 일부러 아직 `<slot>` 요소를 넣지 않았다. 이 컴포넌트는 props로 items를 전달받고 v-for 디렉티브로 리스트 렌더링을 수행한다. 이 템플릿은 이 컴포넌트의 범위에서 컴파일된다. 즉, items는 이 컴포넌트 범위에 있으므로 `{{ item.name }}` 데이터 옵션이 정상적으로 'a', b', 'c'로 렌더링된다는 의미다.\n\n```ts\n    <template>\n    \t<ul>\n    \t\t<li v-for=\"item in items\" :key=\"item.name\">\n    \t\t\t{{ item.name }}\n    \t\t</li>\n    \t</ul>\n    </template>\n    <script>\n    export default {\n    \tprops: ['items']\n    }\n    /*\n    \titems = [\n    \t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t{ name: 'c', soldout: true, bestten: false  }\n    \t]\n    */\n    </script>\n```\n\n만약 어떤 컴포넌트에서는 soldout 이 true면 \"Sold Out a\" 이런식으로 렌더링하고 싶고 또 다른 컴포넌트에서는 bestten이 true인 아이템만 렌더링하고 싶다면? 물론 또 다른 props를 전달받아서 구분 값으로 사용하여 렌더링하는 방법도 있긴 하다. 하지만 item 속성에 따른 렌더링 방식에 더 다양해진다면 재사용성이 떨어질 것이다. 그럴 때 슬롯을 사용하면된다.\n\n하지만 부모 컴포넌트에서는 베이스 컴포넌트의 데이터를 사용할 수가 없다. items를 넘기므로 items야 물론 접근할 수 있다. 하지만 베이스 컴포넌트에서 렌더링되는 item에 접근할 수가 없는 거다. 컴파일 범위가 다르니 당연한 얘기다. 그럼 어떻게 해야할까? 바로 슬롯스코프를 사용하면 된다.\n\n```ts\n    <template>\n    \t<ul>\n    \t\t<li v-for=\"item in items\" :key=\"item.name\">\n    \t\t\t<slot name=\"item\" :item=\"item\">\n    \t\t\t\t{{ item.name }}\n    \t\t\t</slot>\n    \t\t</li>\n    \t</ul>\n    </template>\n    <script>\n    export default {\n    \tprops: ['items']\n    }\n    /*\n    \titems = [\n    \t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t{ name: 'c', soldout: true, bestten: false  }\n    \t]\n    */\n    </script>\n```\n\n위 코드의 `<slot name=\"item\" :item=\"item\">`에 주목해보자. 이렇게 item 속성으로 item 값을 내보냈다. 이렇게 `<slot>` 요소에 연결된 속성을 슬롯 속성(slot props)라고 한다. 이제 이 베이스 컴포넌트를 사용하는 부모 컴포넌트는 item에 접근할 수 있다. 아래는 베이스 컴포넌트를 사용하여 Sold Out 표시를 해주는 컴포넌트다. `<template v-slot:item=\"{ item }\">` 템플릿 v-slot에 슬롯 속성인 item을 쓰면 된다. 아래처럼 item의 slodout 속성에 접근할 수 있게 되었다.\n\n```ts\n    <template>\n    \t<ItemList v-bind:items=\"items\">\n    \t  <template v-slot:item=\"{ item }\">\n    \t    <span v-if=\"item.soldout\">Sold Out</span>\n    \t    {{ item.name }}\n    \t  </template>\n    \t</ItemList>\n    </template>\n    <script>\n    export default {\n    \tdata() {\n    \t\treturn {\n    \t\t\titems: [\n    \t\t\t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t\t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t\t\t{ name: 'c', soldout: true, bestten: false  }\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n    </script>\n```\n\n마찬가지로 bestten이 true인 경우에만 렌더링하는 컴포넌트에 사용할 수 있다.\n\n```ts\n    <template>\n    \t<ItemList v-bind:items=\"items\">\n    \t  <template v-slot:item=\"{ item }\">\n    \t    <span v-if=\"item.bestten\">{{ item.name }}</span>\n    \t  </template>\n    \t</ItemList>\n    </template>\n    <script>\n    export default {\n    \tdata() {\n    \t\treturn {\n    \t\t\titems: [\n    \t\t\t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t\t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t\t\t{ name: 'c', soldout: true, bestten: false  }\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n    </script>\n```\n\n사실 v-slot:item=\"{ item }\" 은 v-slot:item=\"slotProps\" 와 같은 데 ES6의 구조분해를 이용하여 { item } 처럼 사용한 거다.\n\n휴 거의 다했다. 이제 v-menu를 다시 살펴보자\n\n이제 v-menu 컴포넌트의 on(slotProps)를 부모 컴포넌트에서 사용할 수 있게 했구나. 라는 것이 이해될 것이다. 아마 v-menu에서 on은 이벤트 핸들러로 부모 컴포넌트에서 v-on 요소에 on을 연결하면 해당 컴포넌트가 클릭되면 default 슬롯이 보이도록 개발이 되어있을 것이다.\n\n```ts\n    <v-menu offset-y>\n    \t<template v-slot:activator=\"{ on }\">\n    \t  <v-btn\n    \t    color=\"primary\"\n          dark\n          v-on=\"on\"\n    \t   >\n    \t     Dropdown\n    \t\t </v-btn>\n       </template>\n       <v-list>\n         <v-list-item\n           v-for=\"(item, index) in items\"\n           :key=\"index\"\n           @click=\"\"\n         >\n           <v-list-item-title>{{ item.title }}</v-list-item-title>\n         </v-list-item>\n       </v-list>\n     </v-menu>\n```\n\n슬롯 정리 끝!\n"}}}},"pageContext":{"id":"e1d99f9a899dc585ce4b9625b8729cc326c3da77","previousPostId":"d4a60dea091fb5b6e0163278ddd1345bb5131c7c","nextPostId":"146f5eb0b2e672cd66e3c67c69e36f8cac38be23"}},"staticQueryHashes":["2685952063","2841359383"]}