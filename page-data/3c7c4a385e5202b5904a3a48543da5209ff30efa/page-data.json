{"componentChunkName":"component---src-templates-blog-post-js","path":"/3c7c4a385e5202b5904a3a48543da5209ff30efa","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"3c7c4a385e5202b5904a3a48543da5209ff30efa","text":"# Strict Mode\n\nDate: Jun 13, 2020\n\n- Title : Strict Mode\n- Date : 2020-06-13\n- Category : Javascript\n\n# Strict mode\n\n- Javscript ES5 이후로 권장하는 코딩 스타일 중 하나는 `Strict mode`를 사용하는 것이다.\n- Javascript 언어의 문법을 보다 엄격히 적용하여 기존에는 **무시 되던 오류를 발생**시킬 가능성이 높거나 Javascript **엔진의 최적화 작업에 문제**를 일으킬 수 있는 코드에 대해 **명시적인 에러**를 발생시킨다.\n- Strict mode는 ES5에 정의되어 있으며 브라우저가 Strict mode를 지원하지 않아도 실행하는 데 전혀 무관하니 Strict mode로 설정해서 개발하는 것이 좋다.\n- Strict mode를 지원하지 않는 IE9 이전 버전에서는 문자열로 무시되고 일반 모드로 실행된다.\n\n전역 strict mode 사용 방법(전역에 적용하는 것은 피하자!)\n\n```javascript\n\"use strict\";\n```\n\n파일 상단에 키워드를 넣으면 전체 소스 파일에 대해서 엄격 모드로 실행된다.\n\n함수 내부에서 strict mode 사용 방법\n\n```javascript\n(function() {\n\t\"use strict\";\n}());\n```\n\n즉시 실행 함수로 스크립트 전체를 감싸서 스코프를 구분하고 즉시 실행 함수의 선두에 strict mode를 적용한다.\n\n## 예시\n\nvar, const, let 없이 변수를 사용할 때 레퍼런스 오류 발생\n\n```javascript\n(function(){\n\t\"use strict\";\n\tx = 1;\n\tconsole.log(x); // Uncaught ReferenceError: x is not defined\n}());\n```\n\n변수나 함수를 삭제하려고 하면 문법 오류 발생\n\n```javascript\n(function(){\n\t\"use strict\";\n\tlet x = 1;\n\tfunction fun() {}\n\n\tdelete x;\n\tdelete fun;\n\t// SyntaxError: Delete of an unqualified identifier in strict mode.\n\n}());\n```\n\n중복되는 파라미터명이 있을 때 문법 오류 발생\n\n```javascript\n(function(win, doc, doc){\n\t\"use strict\";\n\tconsole.log(doc); // SyntaxError: Duplicate parameter name not allowed in this context\n}(window, document));\n```\n\nargument를 설정하려고 하면 문법 오류 발생\n\n```javascript\n(function(win, doc, doc){\n\t\"use strict\";\n\targuments = [1, 2, 3];\n\tconsole.log(arguments); // SyntaxError: Unexpected eval or arguments in strict mode\n}(window, document));\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"9314008e272f99650c004f6f321831099ce9a243","text":"# Arrow function\n\nDate: Jun 14, 2020\n\n- Title : Arrow function\n- Date : 2020-06-14\n- Category : Javascript\n\n# 화살표 함수\n\nES6에 익명 함수를 간단하게 표현할 수 있는 화살표 표현식이 추가되었다.\n\n## 기존 익명 함수 vs 화살표 함수\n\n콜백 함수로 실행될 때 기존의 익명 함수는 글로벌 컨텍스트에 접근 하였으나, 함수 화살표 표현식은 콜백 함수를 할당한 당시의 컨텍스트를 그대로 활용한다. \n\n```javascript\nvar name = 'global';\nfunction Person() {\n\tthis.name = 'garam';\n\n\tsetTimeout(() => alert(`my name is ${this.name}`), 100); //garam\n\tsetTimeout(function() {\n\t\talert(`Global name is ${this.name}`); // global\n\t}, 100);\n}\n\nlet person = new Person();\n```\n\n화살표 함수는 함수 선언 시 this가 바인딩 할 객체가 **정적**으로 결정된다. 즉 일반 함수와 달리 화살표 함수는 항상 **상위 스코프의 this**를 가리킨다. 이를 `Lexical this`라고 한다.\n\n> 자바 스크립트는 함수 호출 시 this가 바인딩 할 객체가 **동적**으로 결정된다. 함수 선언 시 this에 바인딩 할 객체가 정적으로 결정되는 것이 아니라 **함수를 호출할 때 함수가 어떻게 호출 되었는지에 따라 this가 바인딩할 객체를 동적**으로 결정한다.\n\n```javascript\nconst test = {\n  name: 'test object',\n  createAnonFunction: function() {\n    return function() {\n      console.log(this.name);\n      console.log(arguments);\n    };\n  },\n\n  createArrowFunction: function() {\n    return () => {\n      console.log(this.name);\n      console.log(arguments);\n    };\n  }\n};\n\nconst anon = test.createAnonFunction('hello', 'world'); \n// undefined\n// {}\nconst arrow = test.createArrowFunction('hello', 'world');\n// test object\n// { '0': 'hello', '1': 'world' }\n```\n\n기존 익명 함수는 함수가 호출 되었을 때의 컨텍스트를 가진다. 즉 `test.createAnonFunction`이 글로벌 컨텍스트에서 호출 되었기에 `this.name`과 `arguments` 객체를 얻을 수 없다. \n\n## 화살표 함수 언제 쓰지 말아야 할까?\n\n### 객체의 메소드를 정의할 때\n\n```javascript\nconst calculate = {\n  array: [1, 2, 3],\n  sum: () => {\n    console.log(this === window); // => true\n    return this.array.reduce((result, item) => result + item);\n  }\n};\nconsole.log(this === window); // => true\n// Throws \"TypeError: Cannot read property 'reduce' of undefined\"\ncalculate.sum();\n```\n\n메소드로 정의한 화살표 함수 내부의 this는 메소드를 소유한 객체를 가리키지 않고 상위 컨텍스트인 `window`를 가리킨다. 아래와 같이 사용 해야 한다.\n\n```javascript\nconst calculate = {  \n  array: [1, 2, 3],\n  sum() {\n    console.log(this === calculate); // => true\n    return this.array.reduce((result, item) => result + item);\n  }\n};\ncalculate.sum(); // => 6\n```\n\n### 프로토타입 방식으로 객체 메소드 정의할 때\n\n```javascript\nfunction MyCat(name) {\n  this.catName = name;\n}\nMyCat.prototype.sayCatName = () => {\n  console.log(this === window); // => true\n  return this.catName;\n};\nconst cat = new MyCat('Mew');\ncat.sayCatName(); // => undefined\n```\n\n```javascript\nfunction MyCat(name) {\n  this.catName = name;\n}\nMyCat.prototype.sayCatName = function() {\n  console.log(this === cat); // => true\n  return this.catName;\n};\nconst cat = new MyCat('Mew');\ncat.sayCatName(); // => 'Mew'\n```\n\n### 이벤트 리스너 콜백함수\n\n```javascript\nconst button = document.getElementById('myButton');\nbutton.addEventListener('click', () => {\n  console.log(this === window); // => true\n  this.innerHTML = 'Clicked button';\n});\n```\n\n`this`는 글로벌 컨텍스트에 바인딩 된다. 클릭 이벤트가 발생하면 브라우저는 버튼 컨텍스트와 함께 핸들러 함수를 실행 시킨다. 화살표 표현식으로 정의된 함수의 경우는 정적으로 `this`가 바인딩 되기 때문에 `this`가 동적으로 변경되는 이벤트 콜백 함수로 적절하지 않다.\n\n```javascript\nconst button = document.getElementById('myButton');\nbutton.addEventListener('click', function() {\n  console.log(this === button); // => true\n  this.innerHTML = 'Clicked button';\n});\n```\n\n기존 익명 함수는 타켓 엘리먼트에 의존하여 this를 바꾸는 것을 허용한다.\n\n### 생성자 함수\n\n모든 객체는 자신의 `prototype`으로 부터 `constructor` 속성을 상속하기 때문에 `prototype` 속성을 가지고 있어야 한다. 하지만 화살표 표현식으로 정의된 함수는 `prototype` 속성이 없어서 생성자 함수로 사용될 수 없다.\n\n```javascript\nconst Foo = () => {};\n\n// 화살표 함수는 prototype 프로퍼티가 없다\nconsole.log(Foo.hasOwnProperty('prototype')); // false\n\nconst foo = new Foo(); // TypeError: Foo is not a constructor\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"b61a327c14326b17c25c930f6dee46d5be66b268","text":"# Rest 파라미터와 Spread 연산자\n\n- Title : Rest 파라미터와 Spread 연산자\n- Date : 2020-06-07\n- Category : Javascript\n\n# Rest 파라미터 `...`\n\n함수의 `arguments` 객체로 인해 유발되는 보일러 플레이트 코드를 줄일 목적으로 `Rest 파라미터` 가 도입되었다. `Rest 파라미터`는 함수의 마지막 파라미터 앞에 `...` 를 붙여 사용한다. 단 마지막에 한번만 사용해야 한다.\n\n아래 예제를 보면 arguments 객체 대신 rest 파라미터를 사용해야 하는 이유를 알 수 있다.\n\n```jsx\n// Rest 파라미터 이전에, \"arguments\" 는 다음을 사용해 일반적인 배열로 변환될 수 있음\nfunction f(a, b) {\n\n  var normalArray = Array.prototype.slice.call(arguments);\n  // -- 또는 --\n  var normalArray = [].slice.call(arguments);\n  // -- 또는 --\n  var normalArray = Array.from(arguments);\n\n  var first = normalArray.shift(); // OK, 첫 번째 인수를 반환\n  var first = arguments.shift(); // ERROR (arguments 가 일반적인 배열이 아님)\n\n}\n\n// 이제 rest 파라미터를 사용해 쉽게 일반적인 배열에 접근할 수 있음\n\nfunction f(...args) {\n  var normalArray = args;\n  var first = normalArray.shift(); // OK, 첫 번째 인수를 반환\n}\n```\n\n## 1. `Rest` 파라미터와 `arguments` 객체의 차이를 자세히 알아보자.\n\n- arguments 객체는 함수로 전달된 모든 인수를 포함한다. 즉 Rest 파라미터처럼 부분적으로 얻을 수 없다.\n- arguments 객체는 배열 형태의 객체라 Array에 있는 sort, map, forEach, pop 과 같은 메서드를 사용할 수 없다. 반면에 Rest는 표준 배열이라 해당 메서드를 사용할 수 있다.\n\n> 배열 형태의 객체는 length 속성과 더불어 0부터 인덱스 된 다른 속성을 가지고 있지만, Array의 forEach, map과 같은 내장 메서드를 가지고 있지 않다.\n\n> 화살표 함수는 arguments 객체가 없다. 만약 화살표 함수에서 arguments 객체에 접근한다면 스코프 체인을 따라 일반 함수의 arguments 값을 가져오게 된다. 뿐만 아니라 화살표 함수는 자체 this가 없다.\n\n## 2. 인자의 개수가 유동적일 때 Rest Parameter가 유용하다.\n\n아래 예제는 인자로 전달되는 숫자들의 합을 구하는 함수다. 만약 Rest Parameter를 쓰지 않았다면?..\n\n```jsx\nfunction sum(...theArgs) {\n  return theArgs.reduce((previous, current) => {\n    return previous + current;\n  });\n}\n\nconsole.log(sum(1, 2, 3));\n// expected output: 6\n\nconsole.log(sum(1, 2, 3, 4));\n// expected output: 10\n```\n\n## 3. Rest 파라미터는 배열로만 해체할 수 있다.\n\n```jsx\nfunction f(...[a, b, c]) {\n  return a + b + c;\n}\n\nf(1)          // NaN (b 와 c 는 undefined)\nf(1, 2, 3)    // 6\nf(1, 2, 3, 4) // 6 (4번 째 파라미터는 해체되지 않음)\n```\n\n## 4. 객체 구조 분해에서 Rest\n\n객체 구조 분해에서 rest 속성은 구조 분해 패턴으로 걸러 지지 않은 열거형 속성의 키를 가진 나머지 항목을 모은다.\n\n```jsx\nconst obj = { foo:1, bar: 2, baz: 3 };\nconst { foo, ...rest } = obj;\n```\n\nrest operator는 최대 한번만 사용 가능하며 객체 리터럴의 마지막에 나타나야 한다.\n\n```jsx\nconst {...rest, foo} = obj; // SyntaxError\nconst {foo, ...rest1, ...rest2} = obj; // SyntaxError\n```\n\n단, 중첩 구조 분해 할당을 할 경우에는 rest 연산자가 여러 번 나올 수 있다.\n\n```jsx\nconst obj = {\n    foo: {\n        a: 1,\n        b: 2,\n        c: 3,\n    },\n    bar: 4,\n    baz: 5,\n};\nconst {foo: {a, ...rest1}, ...rest2} = obj;\n\n// Same as:\n// const a = 1;\n// const rest1 = {b: 2, c: 3};\n// const rest2 = {bar: 4, baz: 5};\n```\n\n# Spread Syntax\n\n위에서는 파라미터 리스트에서 배열을 얻었다. 그럼 반대로 배열을 분해하여 리스트를 얻을 수도 있을까? spread 연산자를 사용하면 가능하다.\n\n## 1. 스프레드 연산자로 두 배열을 합쳐보기\n\n```jsx\nlet arr = [3, 5, 1];\nlet arr2 = [8, 9, 15];\n\nlet merged = [0, ...arr, 2, ...arr2]; // [0, 3, 5, 1, 2, 8, 9, 15];\n```\n\n## 2. 객체 리터럴에서 스프레드 연산자 사용하기\n\n객체 리터럴에서 스프레드 연산자는 객체의 모든 열거 가능한 속성들을 객체 리터럴에 넣는다.\n\n```jsx\nconst obj = {foo: 1, bar: 2, baz: 3};\nconst newObj = {...obj, qux: 4}; // {foo: 1, bar: 2, baz: 3, qux: 4}\n```\n\n키가 충돌되면 어떻게 될까? 나중에 나온 value 값이 키 값이 된다.\n\n```jsx\nconst obj = {foo: 1, bar: 2, baz: 3};\nconst newObj = { ...obj, foo: true }; //{foo: true, bar: 2, baz: 3}\nconst newObj2 = { foo: true, ...obj }; // {foo: 1, bar: 2, baz: 3}\n```\n\n## 3. `Math.max`의 인자로 배열의 값들을 전달하고 싶을 때\n\n```jsx\nlet arr = [3, 5, 1];\nconsole.log(Math.max(arr)); // NaN\nconsole.log(Math.max(arr[0], arr[1], arr[2]); // 5\n```\n\n배열의 요소가 많아질 때마다 arr[3], arr[4] ... 호출하는 건 좋은 코드가 아닐 거다. 이럴 때 스프레드 연산자를 사용한다. 스프레드 연산자는 배열을 분해하여 인자로 보낸다.\n\n```jsx\nlet arr = [3, 5, 1];\nconsole.log(Math.max(...arr)); // 5\n```\n\n## 4. iterable 객체는 구조 분해 될 수 있다.\n\n대표적으로 String 객체를 구조 분해한 예제를 살펴보자. \n\n```jsx\nlet str = \"Hello\";\nconsole.log([...str]); // [H, e, l, l, o]\nconsole.log(Array.from(str)) // [H, e, l, l, o]\n```\n\n1. 이 코드는 스프레드 연산자를 이용하여 str(String 객체 === iterable 객체)를 구조 분해한 후 배열을 초기화 하는 작업을 한다. 스프레드 연산자는 내부적으로 `iterator`을 사용하기 때문에 `for...of` 와 동작이 같다.\n2. 위 결과를 보면 `Array.from(str)`의 결과와 `[...str]`의 결과가 같다는 것을 알 수 있다. 하지만 작은 차이점이 있다. 스프레드 연산자는 오직 `iterable` 객체에만 적용될 수 있는 반면 `Array.from`은 `iterable` 객체 뿐만 아니라 배열 형태의 객체 에도 적용할 수 있다. 이러한 특성 때문에 `Array.from`을 더 선호하는 경향이 있다.\n\n# 정리\n\n`...` 는 Rest 파라미터 또는 Spread 구문 일 수 있다.\n\nRest Parameter\n\n- 함수의 마지막 인자에 `...`를 사용한다.\n- 함수의 인자들을 하나의 배열로 모은다.\n- 인자의 개수가 유동적인 함수를 만들 때 주로 사용한다.\n\nSpread syntax\n\n- `...` 를 함수를 호출할 때나 그 밖에 사용할 경우\n- 배열을 리스트로 분해하는 용도로 사용된다.\n- 일반적으로 많은 인자들을 요구하는 함수에 배열을 보낼 때 사용한다.\n\n참고\n\n[Rest parameters and spread syntax](https://javascript.info/rest-parameters-spread)\n"}}}},"pageContext":{"id":"3c7c4a385e5202b5904a3a48543da5209ff30efa","previousPostId":"9314008e272f99650c004f6f321831099ce9a243","nextPostId":"b61a327c14326b17c25c930f6dee46d5be66b268"}},"staticQueryHashes":["2841359383"]}