{"componentChunkName":"component---src-templates-blog-post-js","path":"/71b6232e760cb058f53c92719edc32233daa262c","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"71b6232e760cb058f53c92719edc32233daa262c","text":"# c++로 알고리즘 풀 때 팁들\n\n- Title : c++로 알고리즘 풀 때 팁들\n- Date : 2020-01-28\n- Category: Algorithm\n\n# # 입출력\n\ncin, cout은 느려서 scanf, printf를 사용하는 걸 추천한다.\n\n```cpp\nint N, M, K;\nscanf(\"%d %d %d\", &N, &M, &K);\n```\n\n# # 2차원 배열\n\n1 2 3 4 5 <br/>\n2 3 4 5 6 <br/>\n... 방식의 입력을 받고 싶다면?\n\n```cpp\n#define MAX 10\nint A[MAX][MAX];\n\nint main() {\n\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n    }\n  }\n  return 0;\n}\n```\n\n## 2차원 deque 입력, 정렬\n\n```cpp\n#define MAX 10\ndeque<int> T[MAX][MAX];\n// ...\nint main() {\n  int x, y, age;\n\n  // 입력\n  for (int i=0; i<M; i++) {\n    scanf(\"%d %d %d\", &x, &y, &age);\n    T[--x][--y].push_back(age);\n  }\n\n  // 정렬 오름차순\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      if (T[i][j].size() > 1)\n        sort(T[i][j].begin(), T[i][j].end());\n\n    }\n  }\n\n  // 순회\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      deque<int> &tmp = T[i][j]; // 참조로 받기(수정하려면)\n      for(auto iter=tmp.begin(); iter != tmp.end();) {\n        int &t = *iter;\n        if () //삭제X\n          iter++;\n        else //삭제 O\n          iter = tmp.erase(iter); //다음 iter 받음\n\n      }\n    }\n  }\n  return 0;\n}\n```\n\n# 포인터와 참조\n\n```cpp\n// 새로운게임2 에서..\nstruct Horse {\n  int row, col, dir;\n};\n\n// 참조 변수 : 대상을 직접 할당\n// 선언과 동시에 초기화해야한다!\n// NULL 불가\nHorse &h = horse[0];\nh = horse[1]; // 에러!! (대상 변경 불가)\nprintf(\"%d\", h.row);\n\n// 포인터 변수 : 주소값 할당\nHorse *h = &horse[0];\nh = &horse[1];  // 대상 변경 가능!\nHorse *h = NULL; // NULL 가능\n\nif (h) printf(\"%d\", h->row);\n// 또는\nif (h) printf(\"%d\", (*h).row);\n```\n\n# 배열 초기화할 때, memset 함수 쓰자!\n\n- for문보다 더 빠른 속도가 나올 수 있다.\n- 특정 범위에 있는 **연속된 메모리**에 값을 지정하고 싶을 때 쓰자!\n- cstring 헤더\n\n```cpp\nvoid* memset(void *ptr, int value, size_t num);\n/*\nptr : 메모리 시작 포인터(주소) => 배열 이름\nvalue: 채울 값 => 값\nnum: 채우고자 하는 바이트 수(메모리 크기) => sizeof(배열이름)\n*/\n```\n\n```cpp\n#include <cstring>\nusing namespace std;\nint main() {\n  int C[21][21];\n  memset(C, 0, sizeof(C));\n  return 0;\n}\n```\n\n# 구조체 멤버 내용 복사하고 싶으면? memcpy를 쓰자\n\n```cpp\n#include <cstring>\nusing namespace std;\n\nstruct Horse {\n  int row, col, dir;\n};\n\nint main() {\n  Horse h1, h2;\n  h1.row = 1;\n  h1.col = 2;\n  h1.dir = 3\n\n  memcpy(&h2, &h1, sizeof(Horse)); // Horse 구조체 크기만큼 h1 내용을 h2에 복사\n  return 0;\n}\n```\n\n## 동적 할당된 경우는?\n\n```cpp\n#include <cstring>\nusing namespace std;\n\nstruct Horse {\n  int row, col, dir;\n};\n\nint main() {\n  Horse *h1 = malloc(sizeof(Horse));\n  Horse *h2= malloc(sizeof(Horse));\n  h1->row = 1;\n  h1->col = 2;\n  h1->dir = 3\n\n  memcpy(h2, h1, sizeof(Horse)); // Horse 구조체 크기만큼 h1 내용을 h2에 복사\n  return 0;\n}\n```\n\n## 또 다른 예\n\n```cpp\nHorse h1;\nHorse *h2= malloc(sizeof(Horse));\n\nmemcpy(h2, &h1, sizeof(Horse));    // 구조체 변수에서 동적 메모리로 복사\n```\n\n# 자료형\n\n정수 자료형 int는 4바이트 정보를 기록할 수 있는 자료형으로, signed int(부호가 있는 정수)를 기준으로 기록할 수 있는 양의 정수 범위는 0 ~ 2,147,483,647 (16진수로 7FFFFFFF)이다.\n\n## int 범위를 벗어나는 경우 자료형은 무엇을 쓸까?\n\n8바이트 크기를 가지는 정수 자료형 long long을 쓰는 게 좋다. signed long long을 기준으로 하면 최대 계산할 수 있는 양의 정수 범위는 0 ~ 9,223,372,036,854,775,807(16진수로 7FFFFFFFFFFFFFFF)다.\n\nlong long으로도 불가능하다면 BigInteger를 사용하면 된다.\n\n```cpp\ntypedef long long ll;\nll large, small;\n\n```\n\n# 순열관련 함수\n\nprev_permutation\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"77ee51be00a66cb386e84663fe372b319859e4f3","text":"# 알고리즘 개념 잡자 - 그래프\n\n- Title : 알고리즘 개념 잡자 - 그래프\n- Date : 2020-02-01\n- Category: Algorithm\n\n> 참고서적\n>\n> - [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539)\n\n<br/>\n\n# 1. 그래프(graph)란\n\n- 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조다.\n- 정점(vertex)과 간선(edge)들의 집합으로 구성된다 => G = (V, E)\n- 정점 == 객체 == 노드, 간선 == 관계 == 노드\n- 그래프로 표현할 수 있는 것들) 도로, 영역 간 인접 관계, 선수 과목\n- 간선의 종류에 따라 무방향 그래프와 방향 그래프로 구분된다.\n\n> **오일러 경로**\n>\n> - 모든 간선을 한번만 통과하면서 처음 정점으로 되돌아오는 경로다.\n> - 그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 오일러 경로가 존재한다.\n\n# 2. 그래프 용어정리\n\n- 가중치 그래프(네트워크) : 간선에 비용이나 가중치가 할당된 그래프\n- 차수(degree) : 정점이 가지고 있는 인접 링크의 수\n- 인접 정점(adjacent vertex) : 간선에 의해 직접 연결된 정점\n  - 무방향 그래프에서 정점의 차수(degree)는 인접 정점의 수다.\n  - 무방향 그래프에 존재하는 정점의 모든 차수를 합하면 그래프의 간선 수의 2배가 된다.\n- 방향 그래프 : 간선에 방향성이 존재하는 그래프\n  - 집입 차수(in-degree) : 외부에서 오는 간선 수\n  - 진출 차수(out-degree) : 외부로 향하는 간선 수\n  - 정점의 진입 차수와 진출 차수의 합은 방향 그래프의 간선의 수가 된다.\n- 경로 길이(path length) : 경로를 구성하는 데 사용된 간선의 수\n  - 단순 경로(simple path) : 경로 중에서 반복되는 간선이 없는 경우\n  - 사이클(cycle) : 단순 경로의 시작 정점과 종료 정점이 동일한 경우\n- 연결 그래프(connected graph) : 무방향 그래프에 있는 모든 정점에 대해 항상 경로가 존재하면 그래프는 연결되어 있다고 한다.\n  - 그래프의 어느 두 정점을 선택해도 그 사이에 경로가 존재하면 연결 그래프다.\n  - 트리는 그래프의 특수한 형태로 사이클을 가지지 않는 연결 그래프이다.\n- 완전 그래프(complete graph) : 그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프\n  - 무방향 완전 그래프의 정점 수가 n이면 하나의 정점은 n-1개의 다른 정점으로 연결되므로 간선의 수는 n x (n-1)/2가 된다.\n\n# 3. 그래프의 구현\n\n## 1) 인접 행렬(adjacency matrix)\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-23-img/1.png)<br/>\n\n- 2차원 배열로 표현\n- n개의 정점을 가지는 그래프를 표현하기 위해서는 n<sup>2</sup>의 메모리 공간이 필요해서 간선이 많이 존재하는 밀집 그래프를 표현하는 경우에 적합하다.\n- 간선 수가 적은 최소 그래프의 경우에는 메모리의 낭비가 크므로 부적합하다.\n- 두 정점을 연결하는 간선의 존재 여부를 O(1) 시간 안에 알 수 있다.\n- 정점의 차수는 인접 행렬의 행이나 열을 조사하면 알 수 있으므로 O(n)의 연산에 알 수 있다.\n- 정점 i에 대한 차수는 인접 행렬의 i번째 행에 있는 값을 모두 더하면 된다.\n- 그래프에 존재하는 모든 간선의 수를 알아내려면 인접 행렬 전체를 조사해야하므로 O(n<sup>2</sup>)의 시간이 요구된다.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n  int n, m; // n: 정점개수, m: 간선 개수\n  int v1, v2, d, c; // v1: 정점1, v2: 정점2, d: 0(무방향) 1(v1->v2), c: 간선 가중치 (1이상)\n  scanf(\"%d %d\", &n, &m);\n\n  int graph[n+1][n+1] = {0}; // 0으로 초기화\n\n  for (int i=0; i<m+1; i++) {\n    scanf(\"%d %d %d %d\", &v1, &v2, &d, &c);\n    if (d == 0) {\n      graph[v1][v2] = graph[v2][v1] = c;\n    } else {\n      graph[v1][v2] = c;\n    }\n  }\n\n  return 0;\n}\n```\n\n## 2) 인접 리스트(adjacency list)\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-23-img/2.png)<br/>\n\n- 각 정점에 인접한 정점들을 연결리스트로 표현\n- 각 연결 리스트들은 헤드 포인터를 가지고 있고 이 헤드 포인터들은 하나의 배열로 구성되어 있어 정점의 번호만 알면 이 번호를 배열의 인덱스로 하여 각 정점의 연결리스트에 쉽게 접근할 수 있다.\n- 정점의 수가 n개고 간선의 수가 e개인 무방향 그래프를 표시하기 위해서는 n개의 연결 리스트가 필요하고 n개의 헤드 포인터와 2e개의 노드가 필요하다.\n- 간선의 개수가 적은 희소 그래프의 표현에 적합하다.\n- 간선의 존재 여부나 정점 i의 차수를 알기 위해서는 정점 i의 연결리스트를 탐색해야 하므로 연결리스트에 있는 노드의 수만큼(정점 차수만큼)의 시간이 필요하다.\n- n개의 정점, e개의 간선을 가진 그래프의 전체 간선 수를 알아내려면 O(n+e)의 연산이 요구된다.\n\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main() {\n  int n, m;\n  int v1, v2, d, c;\n  scanf(\"%d %d\", &n, &m);\n\n  vector<pair<int, int> > graph[n+1];\n\n  for (int i=0; i<m+1; i++) {\n    scanf(\"%d %d %d %d\", &v1, &v2, &d, &c);\n    if (d == 0) { // 무방향\n      graph[v1].push_back(make_pair(v2, c));\n      graph[v2].push_back(make_pair(v1, c));\n    } else {\n      graph[v1].push_back(make_pair(v2, c));\n    }\n  }\n}\n```\n\n# 4. 그래프 탐색\n\n- 그래프에서 모든 노드를 방문하고 싶다면?\n  - DFS, BFS 중 아무거나 사용해도 상관없으나 DFS가 좀 더 간단하긴 하다.\n- 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶다면?\n  - BFS가 일반적으로 더 낫다.\n  - DFS는 경로를 찾을 수는 있겠지만 모든 노드를 탐색해야할지도 모르고 최단 경로가 아닐 수도 있다.\n\n## 1) 깊이 우선 탐색(DFS)\n\n> 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 가다가 더 이상 갈 수 없게 되면 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색을 진행하는 방법과 유사하다.\n\n- 순환 호출이나 명시적 스택을 사용한다.\n- 전위 순회를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류다.\n- 그래프 탐색의 경우는 어떤 노드를 방문했었는지 여부를 반드시 검사해야한다. 이를 검사하지 않으면 무한 루프에 빠질 위험이 있다.\n- 정점의 수가 n, 간선의 수가 e인 그래프를 깊이 우선 탐색하는 시간은? (힌트 : 모든 간선을 조사한다.)\n  - 인접리스트 : O(n+e)\n  - 인접행렬 : O(n<sup>2</sup>)\n\n**인접 행렬로 표현된 무방향 그래프 DFS**\n\n```cpp\n#include <iostream>\n#define MAX_V 20; // 정점 최대 값\nusing namespace std;\n\nint n; // 입력받은 정점의 수\n\nvoid dfs(int graph[][MAX_V], int visited[], int v) {\n  visited[v] = true;\n  printf(\"%d\", v);\n  for (int i=0; i<n+1; i++) {\n    if (graph[v][i] == 1 && !visited[i]) dfs(graph, visited, i);\n  }\n}\n```\n\n## 2) 너비 우선 탐색(BFS)\n\n- 큐를 사용한다.\n- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.\n\n**인접 행렬로 표현된 무방향 그래프 BFS**\n\n```cpp\n#include <iostream>\n#include <queue>\n#define MAX_V 20; // 정점 최대 값\nusing namespace std;\n\nint n; // 입력받은 정점의 수\n\nvoid bfs(int graph[][MAX_V], int visited[], int v) {\n  visited[v] = true;\n  queue<int> q;\n  q.push(v);\n\n  while(!q.empty()) {\n    int top = q.front();\n    q.pop();\n    printf(\"%d\", top);\n\n    for (int i=0; i<n+1; i++) {\n      if (graph[v][i] == 1 && !visited[i]) {\n        q.push(i);\n        visited[i] = true;\n      }\n    }\n  }\n\n}\n\n```\n\n## 3) 양방향 탐색\n\n- 출발지와 도착지 사이에 최단 경로를 찾을 때 사용한다.\n- 출발지, 도착지 두 노드에서 동시에 너비 우선 탐색을 수행한 뒤, 두 탐색 지점이 충돌하는 경우에 경로를 찾는 방법이다.\n- 두 탐색 알고리즘이 대략 d/2 단계(s와 t 사이의 중간 지점)에서 충돌하여 각 출발지와 도착지 노드의 방문 노드의 개수는 대략 k<sup>d/2</sup>가 된다. (k : 각 노드의 인접 노드의 개수)\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"3c55417e429710884ade0d6c7bca7c149081a2a3","text":"# 알고리즘 개념 잡자 - 재귀와 동적 프로그래밍\n\n- Title : 알고리즘 개념 잡자 - 재귀와 동적 프로그래밍\n- Date : 2020-01-09\n- Category: Algorithm\n\n> 참고 <br/>\n>\n> - [코딩 인터뷰 완전분석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545) 재귀와 동적 프로그래밍\n> - [Geeksforgeeks 바로가기](https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/)\n\n# 동적 프로그래밍\n\n- 주어진 문제를 부분 문제로 나눠 값을 계산하는 것\n- 중복되는 계산을 막기 위해 부분 문제의 결과 값을 저장함 - 메모이제이션(Memoization)과 타뷸레이션(Tabulation)\n\n## 메모이제이션(Memoization)과 타뷸레이션(Tabulation)\n\n- 메모이제이션 : 하향식 접근법 (Top Down) - 재귀적\n  - 테이블을 만들고 NIL(예, -1) 값을 넣음\n  - 서브 문제의 결과값을 구할 때, 먼저 테이블 검색\n  - 계산된 값이 있으면 얘를 리턴\n  - NIL이면 계산 실행하여 계산 결과를 테이블에 저장\n  - 요구가 있을 때 채워지므로 테이블에 데이터가 다 채워지지 않을 수도 있음\n- 타뷸레이션 : 상향식 접근법 (Bottom Up) - 순환적\n  - 테이블의 마지막 요소를 반환하는 구조\n  - 첫번째부터 전체가 채워지는\n\n## DP의 2가지 속성\n\n모든 DP 문제는 Overlapping subproblems 속성을 만족하고 대부분의 클래식 DP 문제는 Optimal Substructure 속성을 만족한다.\n\n**1. overlapping subproblems** <br/><br/>\n\n- 부분 문제들이 공통으로 겹치는 부분이 있는 지?<br/>\n\n  > <span class=\"clr-grey\">우리가 메모이제이션이나 타뷸레이션을 사용하는 이유는 부분 문제의 결과값을 저장해놔서 나중에 이를 활용하려고 사용하죠. 근데 겹치는 부분 문제가 없으면?? 이게 필요가 없음.</span>\n\n- 동적 프로그래밍과 분할 정복\n  - 문제를 나누는 방식에 차이가 있음 <br/><br/>\n  - 피보나치<br/>\n    ![피보나치](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-10-img/2.png)\n  - 이진탐색 <br/>\n    ![이진탐색](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-10-img/1.png)\n\n<br/>\n\n**2. Optimal Substructure** <br/>\n\n- 문제의 답을 부분 문제의 답에서 구할 수 있는 가?\n- 최단 경로 vs 최장 경로<br/>\n  - 경로안에 무수히 많은 경로가 있을 때, 중간 정점들이 각각 최단이 된다면 이를 모든 이은 경로 또한 최단이 된다. <br/><br/>\n    ![경로](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-10-img/3.gif)\n    - q -> t 최단 : q -> r + r -> t\n    - q -> t 최장 : q -> s -> t -> r + r -> q -> s -> t\n\n## 문제 푸는 방법\n\n**1. DP 문제인가?**\n\n- DP의 2가지 속성으로 판단하기\n\n**2. 상태 찾기**\n\n- 서브 문제마다 값이 달라지는 변수 찾기\n- 각 서브 문제를 구별하는 값\n- 파라미타들\n- 적을 수록 좋다.\n- DP(상태) = 결과값(예, 최고 이익, 경우의 수..)\n\n**3. 재귀 방법 알아내기 == 상태들의 관계 알아내기** <br/>\n\n- state(n) = state(n-1) + state(n-3) + state(n-5)\n\n**4. 메모이제이션과 타뷸레이션 쓰기**\n\n# 8.1 트리플 스텝\n\n어떤 아이가 n개의 계단을 오른다. 한 번에 1계단 오르기도 하고 2계단이나 3계단을 오르기도 한다. 계단을 오르는 방법이 몇 가지가 있는지 계산하는 메서드를 구현하라.\n\n- Step 1 : DP 문제인지 판별하기\n  - 느낌..\n- Step 2 : 부분 문제마다 값이 달라지는 변수 찾기\n  - N : 계단의 개수 => 매개변수\n  - DP[N] = N을 만족하는 경우의 수\n- Step 3 : 재귀 방법을 알아내기\n  - 조정할 수 있는 거, 오를 수 있는 계단 개수져\n  - upStair(n) = (n - 1) || (n - 2) || (n - 3)\n  - upStair(n) = (n - 1) + (n - 2) + (n - 3)\n- Step 4 : 메모이제이션, 타뷸레이션\n\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint solution(int n, vector<int>& memo) {\n  if (n < 0) return 0;\n  if (n == 0) return 1;\n  if (memo[n] > -1) return memo[n];\n  memo[n] = solution(n - 1, memo) + solution (n - 2, memo) + solution (n - 3, memo);\n  return memo[n];\n}\n\nint solution_BU(int n) {\n  vector<int> dp(n+1, -1);\n  dp[0] = 1;\n  dp[1] = 1;\n  dp[2] = 2;\n  for (int i=3; i<=n; i++) {\n    dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\n  }\n  return dp[n];\n}\n\nint main(){\n  int n = 10;\n  vector<int> memo(n+1, -1);\n  std::cout << solution(n, memo) << \",\";\n  std::cout << solution_BU(n) << std::endl;\n  return 0;\n}\n```\n\n# 8.11 코인\n\n쿼터(25센트), 다임(10센트), 니켈(5센트), 페니(1센트)의 네 가지 동전이 무한히 주어졌을 때, n센트를 표현하는 모든 방법의 수를 계산하는 코드를 작성하라\n\n- Step 1 : DP 문제인지 판별하기\n  - 10원 방법의 수는 5원 방법에 + 5를 더하는 것....\n  - 느낌..\n- Step 2 : 부분 문제마다 값이 달라지는 변수 찾기\n  - 부분 문제는 1원일 때 방법의 수... 2원일 때 방법의 수..3원일 때....N원일 때 방법의 수\n  - N : 구할 센트, => 매개변수, 상태값\n  - D[N] = 방법의 수\n- Step 3 : 재귀 방법을 알아내기\\*\\*\n  - 재귀의 방법을 조정할 수 있는 값은? 동전의 가치 (25, 10, 5, 1)\n  - D(n) = D(n - 25) + D(n - 10) + D(n - 5) + D(n - 1)\n- Step 4 : 메모이제이션, 타뷸레이션\n\n- 10센트 만들기 (D[0] = 1)\n  - 25센트로 : 0 0 0 0 0 0 0 0 0 0\n  - 10센트로 : 0 0 0 0 0 0 0 0 0 1\n  - 5센트로 : 0 0 0 0 1 0 0 0 0 2\n  - 1센트로 : 1 1 1 1 2 2 2 2 2 4\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint coin[4] = {25, 10, 5, 1};\nint solution(int n, int index, vector<vector<int> >& memo) {\n  if (index >= 3) return 1;\n  if (memo[n][index] > 0) return memo[n][index];\n  int answer = 0;\n  for (int i=0; i * coin[index] <= n; i++) {\n    answer += solution(n - i * coin[index], index + 1, memo);\n  }\n\n  memo[n][index] = answer;\n  return memo[n][index];\n}\n\nint solution_BU(int n) {\n  vector<int> dp(n+1, 0);\n  dp[0] = 1;\n  for (int i=0; i<4; i++) {\n    for (int j=1; j<=n; j++) {\n      if (j - coin[i] >= 0) dp[j] += dp[j-coin[i]];\n    }\n  }\n  return dp[n];\n}\n\nint main() {\n  int n = 10;\n  vector<vector<int> > memo(n + 1, vector<int>(4, 0));\n  int answer = solution(n, 0, memo);\n  std::cout << answer << std::endl;\n  int answer_2 = solution_BU(n);\n  std::cout << answer << std::endl;\n  return 0;\n}\n```\n\n# 8.7 중복 없는 순열\n\n문자열이 주어졌을 때 모든 경우의 순열을 계산하는 메서드를 작성하라. 단, 문자는 중복되어 나타날 수 없다.\n\n# 8.9 괄호\n\nn-쌍의 괄호로 만들 수 있는 모든 합당한(괄호가 적절히 열리고 닫힌) 조합을 출력하는 알고리즘을 구현하라\n\n```cpp\n#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\nvoid fnc(string result, int cur, int dep, int n, vector<string>& answer) {\n  if (cur < 0) return;\n  if (cur > 0 && n - dep < cur) return;\n  if (cur == 0 && dep == n) {\n    answer.push_back(result);\n    return;\n  }\n  fnc(result + \"(\", cur + 1, dep + 1, n, answer);\n  fnc(result + \")\", cur - 1, dep + 1, n, answer);\n}\n\nvector<string> solution(int n) {\n    vector<string> answer;\n    fnc(\"\", 0, 0, n*2, answer);\n    return answer;\n}\n\nvoid solution_2(int leftRem, int rightRem, int index, char *str, vector<string>& answer) {\n  if (leftRem < 0 || leftRem > rightRem) return;\n  if (leftRem == 0 && rightRem == 0) {\n    answer.push_back(str);\n    return;\n  }\n  str[index] = '(';\n  solution_2(leftRem - 1, rightRem, index+1, str, answer);\n\n  str[index] = ')';\n  solution_2(leftRem, rightRem - 1, index + 1, str, answer);\n}\n\nint main() {\n  int n;\n  cout << \"input:\";\n  cin >> n;\n  vector<string> answer = solution(n);\n  for (int i=0; i<answer.size(); i++) {\n    cout << answer[i] << \" \";\n  }\n  cout << endl;\n  vector<string> answer2;\n  char str[n*2];\n  solution_2(n, n, 0, str, answer2);\n  for (int i=0; i<answer2.size(); i++) {\n    cout << answer2[i] << \" \";\n  }\n\n  return 0;\n}\n\n```\n\n# 8.10 영역 칠하기\n\n화면(색이 칠해진 이차원 배열), 화면상의 한 지점, 새로운 색상이 주어졌을 때, 주어진 지점과 색이 같은 주변 영역을 새로운 색상으로 다시 칠하라\n\n- BFS\n\n```cpp\n#include <string>\n#include <vector>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint row[4] = {0, 0, -1, 1};\nint col[4] = {-1, 1, 0, 0};\n\nint solution(vector<vector<int> >& screen, pair<int, int>& point, int newColor) {\n\n  queue<pair<int, int> > q;\n  int next_row, next_col;\n  int pre_color = screen[point.first][point.second];\n  q.push(point);\n  while (!q.empty()) {\n    pair<int, int> pop = q.front();\n    screen[pop.first][pop.second] = newColor;\n    q.pop();\n    for (int i=0; i<4; i++) {\n      next_row = pop.first + row[i];\n      next_col = pop.second + col[i];\n      if (next_row < 0 || next_col < 0) continue;\n      if (next_row >= screen.size() || next_col >= screen[0].size()) continue;\n      if (screen[next_row][next_col] == pre_color) {\n        q.push(make_pair(next_row, next_col));\n      }\n    }\n  }\n  return 0;\n}\n\nint main() {\n  // vector<vector<int> > screen({\n  //   vector<int>({1, 1, 2, 3}),\n  //   vector<int>({2, 1, 2, 3}),\n  //   vector<int>({1, 1, 2, 2}),\n  //   vector<int>({2, 2, 2, 1})\n  // });\n  /*\n  1 2 2 3\n  2 1 2 3\n  1 1 2 2\n  2 2 2 1\n  */\n vector<vector<int> > screen(4, vector<int>(4));\n  screen[0][0] = 1;\n  screen[0][1] = 2;\n  screen[0][2] = 2;\n  screen[0][3] = 3;\n\n  screen[1][0] = 2;\n  screen[1][1] = 1;\n  screen[1][2] = 2;\n  screen[1][3] = 3;\n\n  screen[2][0] = 1;\n  screen[2][1] = 1;\n  screen[2][2] = 2;\n  screen[2][3] = 2;\n\n  screen[3][0] = 2;\n  screen[3][1] = 2;\n  screen[3][2] = 2;\n  screen[3][3] = 1;\n\n  pair<int, int> point = make_pair(1, 2);\n  for (int i=0; i<screen.size(); i++) {\n    for (int j=0; j<screen[0].size(); j++)\n      std::cout << screen[i][j] << \" \";\n    std::cout << std::endl;\n  }\n  solution(screen, point, 0);\n  std::cout << std::endl;\n  for (int i=0; i<screen.size(); i++) {\n    for (int j=0; j<screen[0].size(); j++)\n      std::cout << screen[i][j] << \" \";\n    std::cout << std::endl;\n  }\n  return 0;\n}\n```\n\n# 8.14 불린값 계산\n\n0(false), 1(true), &(AND), |(OR), ^(XOR)으로 구성된 불린 표현식과 원하는 계산 결과(불린값)이 주어졌을 때, 표현식에 괄호를 적절하게 추가하여 그 값이 원하는 결과값과 같게 만들 수 있는 모든 경우의 수 출력하기\n\n출력 예시\n\n- countEval(\"1^0|0|1\", false) -> 2개\n- countEval(\"0&0&0&1^1|0\", true) -> 10개\n\n- Step 1 : DP 문제인지 판별하기\n  - 뭔가.. 적절하게 조합해서 모든 경우 구하는 거라서.. dp같네..?\n- Step 2 : 부분 문제마다 값이 달라지는 변수 찾기\n  - 음.. 전체 수식을 쪼개니깐 수식이 부분문제마다 달라지넵, 매개변수로 쪼개진 수식을 보내야겠댜~\n- Step 3 : 재귀 방법을 알아내기\\*\\*\n  - 괄호를 추가한다라..\n  - 1^0|0|1 예시로 보면..\n  - 1 ^ (0|0|1) 처럼 괄호를 추가하고 싶다는 건데..\n  - 그럼 ^ 같은 표현식을 기준으로 왼쪽 오른쪽 나눠어..\n  - D[수식] = D[왼쪽 수식] \\* D[오른쪽 수식]\n  - 서로 연관있으니깐 \\*곱하기\n  - 표현식은 index 1, 3, 5, 7 ..에 위치\n- Step 4 : 메모이제이션, 타뷸레이션\n\n1 ^ 0|0|1  \n1^0 | 0|1  \n1^0|0 | 1\n\n```cpp\n#include <string>\n#include <vector>\n#include <iostream>\n#include <map>\n\nusing namespace std;\n\nint fnc(std::string exp, bool r, map<string, int>& memo) {\n  if (exp.length() == 1) return exp[0] == (r ? '1' : '0') ? 1 : 0;\n  if (memo.count(exp + (r ? \"-1\" : \"-0\")) == 1) return memo[exp + (r ? \"-1\" : \"-0\")];\n  int sum = 0;\n  for (int i=1; i<exp.length(); i+=2) {\n    char e = exp[i];\n    string left = exp.substr(0, i);\n    string right = exp.substr(i+1);\n    if (e == '^') {\n      if (r) {  // true\n        sum += fnc(left, r, memo) * fnc(right, r^1, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r, memo);\n      } else {\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r^1, memo);\n      }\n\n    } else if (e == '|') {\n      if (r) { // true\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n        sum += fnc(left, r, memo) * fnc(right, r^1, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r, memo);\n      } else { // false\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n      }\n    } else {\n      if (r) { // true\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n      } else { // false\n        sum += fnc(left, r, memo) * fnc(right, r, memo);\n        sum += fnc(left, r^1, memo) * fnc(right, r, memo);\n        sum += fnc(left, r, memo) * fnc(right, r^1, memo);\n      }\n\n    }\n  }\n  memo.insert(pair<string, int>(exp + (r ? \"-1\" : \"-0\") , sum));\n  return sum;\n}\n\nint countEval(std::string exp, bool result) {\n  map<string, int> map;\n  return fnc(exp, result, map);\n}\n\nint main() {\n  std::cout << countEval(\"1^0|0|1\", false) << std::endl;\n  std::cout << countEval(\"0&0&0&1^1|0\", true) << std::endl;\n  return 0;\n}\n```\n"}}}},"pageContext":{"id":"71b6232e760cb058f53c92719edc32233daa262c","previousPostId":"77ee51be00a66cb386e84663fe372b319859e4f3","nextPostId":"3c55417e429710884ade0d6c7bca7c149081a2a3"}},"staticQueryHashes":["2685952063","2841359383"]}