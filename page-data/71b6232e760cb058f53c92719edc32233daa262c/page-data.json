{"componentChunkName":"component---src-templates-blog-post-js","path":"/71b6232e760cb058f53c92719edc32233daa262c","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"71b6232e760cb058f53c92719edc32233daa262c","text":"# c++로 알고리즘 풀 때 팁들\n\n- Title : c++로 알고리즘 풀 때 팁들\n- Date : 2020-01-28\n- Category: Algorithm\n\n# # 입출력\n\ncin, cout은 느려서 scanf, printf를 사용하는 걸 추천한다.\n\n```cpp\nint N, M, K;\nscanf(\"%d %d %d\", &N, &M, &K);\n```\n\n# # 2차원 배열\n\n1 2 3 4 5 <br/>\n2 3 4 5 6 <br/>\n... 방식의 입력을 받고 싶다면?\n\n```cpp\n#define MAX 10\nint A[MAX][MAX];\n\nint main() {\n\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n    }\n  }\n  return 0;\n}\n```\n\n## 2차원 deque 입력, 정렬\n\n```cpp\n#define MAX 10\ndeque<int> T[MAX][MAX];\n// ...\nint main() {\n  int x, y, age;\n\n  // 입력\n  for (int i=0; i<M; i++) {\n    scanf(\"%d %d %d\", &x, &y, &age);\n    T[--x][--y].push_back(age);\n  }\n\n  // 정렬 오름차순\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      if (T[i][j].size() > 1)\n        sort(T[i][j].begin(), T[i][j].end());\n\n    }\n  }\n\n  // 순회\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      deque<int> &tmp = T[i][j]; // 참조로 받기(수정하려면)\n      for(auto iter=tmp.begin(); iter != tmp.end();) {\n        int &t = *iter;\n        if () //삭제X\n          iter++;\n        else //삭제 O\n          iter = tmp.erase(iter); //다음 iter 받음\n\n      }\n    }\n  }\n  return 0;\n}\n```\n\n# 포인터와 참조\n\n```cpp\n// 새로운게임2 에서..\nstruct Horse {\n  int row, col, dir;\n};\n\n// 참조 변수 : 대상을 직접 할당\n// 선언과 동시에 초기화해야한다!\n// NULL 불가\nHorse &h = horse[0];\nh = horse[1]; // 에러!! (대상 변경 불가)\nprintf(\"%d\", h.row);\n\n// 포인터 변수 : 주소값 할당\nHorse *h = &horse[0];\nh = &horse[1];  // 대상 변경 가능!\nHorse *h = NULL; // NULL 가능\n\nif (h) printf(\"%d\", h->row);\n// 또는\nif (h) printf(\"%d\", (*h).row);\n```\n\n# 배열 초기화할 때, memset 함수 쓰자!\n\n- for문보다 더 빠른 속도가 나올 수 있다.\n- 특정 범위에 있는 **연속된 메모리**에 값을 지정하고 싶을 때 쓰자!\n- cstring 헤더\n\n```cpp\nvoid* memset(void *ptr, int value, size_t num);\n/*\nptr : 메모리 시작 포인터(주소) => 배열 이름\nvalue: 채울 값 => 값\nnum: 채우고자 하는 바이트 수(메모리 크기) => sizeof(배열이름)\n*/\n```\n\n```cpp\n#include <cstring>\nusing namespace std;\nint main() {\n  int C[21][21];\n  memset(C, 0, sizeof(C));\n  return 0;\n}\n```\n\n# 구조체 멤버 내용 복사하고 싶으면? memcpy를 쓰자\n\n```cpp\n#include <cstring>\nusing namespace std;\n\nstruct Horse {\n  int row, col, dir;\n};\n\nint main() {\n  Horse h1, h2;\n  h1.row = 1;\n  h1.col = 2;\n  h1.dir = 3\n\n  memcpy(&h2, &h1, sizeof(Horse)); // Horse 구조체 크기만큼 h1 내용을 h2에 복사\n  return 0;\n}\n```\n\n## 동적 할당된 경우는?\n\n```cpp\n#include <cstring>\nusing namespace std;\n\nstruct Horse {\n  int row, col, dir;\n};\n\nint main() {\n  Horse *h1 = malloc(sizeof(Horse));\n  Horse *h2= malloc(sizeof(Horse));\n  h1->row = 1;\n  h1->col = 2;\n  h1->dir = 3\n\n  memcpy(h2, h1, sizeof(Horse)); // Horse 구조체 크기만큼 h1 내용을 h2에 복사\n  return 0;\n}\n```\n\n## 또 다른 예\n\n```cpp\nHorse h1;\nHorse *h2= malloc(sizeof(Horse));\n\nmemcpy(h2, &h1, sizeof(Horse));    // 구조체 변수에서 동적 메모리로 복사\n```\n\n# 자료형\n\n정수 자료형 int는 4바이트 정보를 기록할 수 있는 자료형으로, signed int(부호가 있는 정수)를 기준으로 기록할 수 있는 양의 정수 범위는 0 ~ 2,147,483,647 (16진수로 7FFFFFFF)이다.\n\n## int 범위를 벗어나는 경우 자료형은 무엇을 쓸까?\n\n8바이트 크기를 가지는 정수 자료형 long long을 쓰는 게 좋다. signed long long을 기준으로 하면 최대 계산할 수 있는 양의 정수 범위는 0 ~ 9,223,372,036,854,775,807(16진수로 7FFFFFFFFFFFFFFF)다.\n\nlong long으로도 불가능하다면 BigInteger를 사용하면 된다.\n\n```cpp\ntypedef long long ll;\nll large, small;\n\n```\n\n# 순열관련 함수\n\nprev_permutation\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"74f84e9d20d88dabd2edfd88b79237bc44153e4a","text":"# 백준 - 17142 연구소3(C++)\n\n- Title : 백준 - 17142 연구소3(C++)\n- Date : 2020-01-29\n- Category: 알고리즘 풀이\n\n## 입력 받기\n\n- 연구소 상태는 N x N 이니깐 int A[N][n] 형태로 입력을 저장해야겠다.\n- 입력을 받을 때, 선택 가능한 바이러스들(값이 2인)의 row, col 값을 따로 저장할 필요가 있겠네. pair<int, int> V[10] 형태로 저장해야겠다. 바이러스 개수는 최대 10이니깐 배열의 크기는 10으로 하자.\n- 퍼트릴 수 있는 빈 칸의 개수도 카운트 해놓자. 그래야 모든 빈칸에 바이러스를 퍼트렸는 지 알 수 있으니깐.\n- 아! 퍼트린 후 연구소 상태를 원상 복귀해야하니깐 int TMP[N][n] 형태의 2차원 배열을 만들어놔야지.\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nint main() {\n  int A[50][50]; // 연구소\n  int TMP[50][50]; // 연구소 결과 처리용\n  int N, M; // N: 연구소 크기, M: 활성화할 바이러스 수\n  int tcnt = 0; // 연구소 빈칸(0)의 개수\n  pair<int, int> V[10]; // 연구소 선택 가능한 바이러스(2)의 위치\n  int vcnt = 0; // V 배열을 위한 인덱스\n  int prow[4] = {-1, 1, 0, 0}; // 상하좌우 확산 시 사용 row\n  int pcol[4] = {0, 0, -1, 1}; // 상하좌우 확산 시 사용 col\n\n  // 입력받기\n  scanf(\"%d %d\", &N, &M);\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n      TMP[i][j] = A[i][j];\n      if (A[i][j] == 2) V[vcnt++] = make_pair(i, j);\n      if (A[i][j] == 0) tcnt++;\n    }\n  }\n}\n```\n\n## 활성화할 바이러스 선택하기\n\n- DFS로 할 수도 있지만 비트 마스크로 풀어봐야지\n- 만약 5개의 바이러스 중 3개를 선택해야한다면 범위는 00111 ~ 11100 이다.\n- 근데 사실, DFS로 하는 게 코드가 간단해서... DFS가 나을 듯,, 비트 마스크로 풀다가 실수를 너무 많이 했다.\n\n```cpp\n  unsigned int flag = (1 << M) - 1; // 시작 플래그, unsigned int는 양수 범위를 가짐\n  int tcc = M;\n  unsigned int fin = 0; // 종료 플래그\n  // 종료 플래그 만들기.\n  while (tcc-- > 0) {\n    fin |= (1 <<  (vcnt - 1 - tcc));\n  }\n  unsigned int curflag = 0; // 조작용\n  int fcnt = 0;\n  int pos = 0;\n  queue<pair<int, int> > q;\n  // 시작플래그 ~ 종료플래그\n  for (flag; flag<=fin; flag++) {\n    curflag = flag;\n    fcnt = 0;\n    // 1비트 개수 세기, M개 일때만 코드 진행\n    while (curflag > 0) {\n      if (curflag & 1 == 1) fcnt++;\n      if (fcnt > M) break;\n      curflag = curflag >> 1;\n    }\n    if (fcnt != M) continue;\n\t\t// 이제 고른 바이러스 표시하기\n    curflag = flag;\n    pos = 0;\n    while (curflag > 0) {\n      if (curflag & 1 == 1) {\n        TMP[V[pos].first][V[pos].second] = -1; // 바이러스 복제\n        // 큐에 선택한 바이러스 넣기 -> 퍼트리기에서 BFS로 사용할 예정\n        q.push(make_pair(V[pos].first, V[pos].second));\n      }\n      pos++;\n      curflag = curflag >> 1;\n    }\n    // ...바이러스 퍼트리기가 이어진다.\n  }\n```\n\n## 바이러스 퍼트리기\n\n- 만약 백준에서 제출 시 100%에서 틀린다면 비활성화 바이러스도 시간 체크했는 지 살펴봐야한다.\n  여기서 엄청 헤매서 시간 다 잡아먹었다ㅠㅠ\n- 쉽게 설명하자면 대부분 BFS로 q가 빌 때까지 반복을 돌릴텐데 만약 이미 빈칸(0)에는 다 전파했는 데 q에 비활성화(선택 못 받은 바이러스)가 있다면? 이 상황을 이해한다면 오류를 잡을 수 있을 거다.\n  > 반례가 있어야 이해가 되겠죠?  \n  > 5 1  \n  > 1 1 1 1 1  \n  > 1 1 1 1 1  \n  > 1 1 1 1 1  \n  > 2 0 0 2 0  \n  > 1 1 1 1 1  \n  > answer : 2\n- 사실 q에 시간 체크용 값도 넣어버려서.. 복잡하게 풀어버린 것 같다..\n- 더 간단히 풀 수 있을 듯..\n\n```cpp\n  // ..위에는 바이러스 선택하기\n  // 시간 체크용, 현재 q에는 선택된 바이러스가 있고 얘는 0초이므로 0을 넣어준다. -1은 구분 용\n  q.push(make_pair(-1, 0));\n  spread = 0; // 퍼진 바이러스\n  time = 0; // 시간\n  stopflag = false; // 빈칸에 다 퍼트렸으면 true로 바꿀거다.\n  while (!q.empty()) {\n    // c++에서 q.pop()은 void 메소드라서 q.front()로 값 가져온다.\n    pair<int, int> po = q.front();\n    q.pop();\n    if (po.first >= 0) { // 퍼트린 칸이면\n      if (A[po.first][po.second] == 0) spread++; // 해당 칸이 원래 빈칸(0)이면 값 증가\n      if (spread == tcnt) stopflag = true; // 빈칸에 다 퍼트리면 시간체크용 값 나올 때 스탑하려고\n      for (int i=0; i<4; i++) { // 상하좌우 처리\n        nextrow = po.first + prow[i];\n        nextcol = po.second + pcol[i];\n        if (nextrow < 0 || nextrow >= N || nextcol < 0 || nextcol >= N) continue; // 범위 밖\n        if (TMP[nextrow][nextcol] == -1 || TMP[nextrow][nextcol] == 1) continue;\n        q.push(make_pair(nextrow, nextcol)); // 큐에 넣자넣자!\n        TMP[nextrow][nextcol] = -1; // 퍼트렸다는(방문했다는) 표시!\n      }\n    } else { // 시간체크용\n      time = po.second;\n      if (!q.empty()) q.push(make_pair(-1, po.second + 1));\n      if (stopflag) break; // 이미 모든 빈칸에 퍼트렸으면 나오자!\n    }\n  }\n  while (!q.empty()) // 위 반복에서 stopflag에 의해 중간에 빠져나왔을 경우를 대비해서\n  {\n    q.pop();\n  }\n  // 시간 넣자!!\n  if (spread == tcnt && ans > time) ans = time;\n```\n\n## 원상복귀\n\n- TMP는 또 써야하니깐!\n\n```cpp\nfor (int i=0; i<N; i++) {\n  for (int j=0; j<N; j++) {\n    TMP[i][j] = A[i][j];\n  }\n}\n```\n\n## 전체 코드\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <limits>\nusing namespace std;\n\n\nint A[50][50];\nint TMP[50][50];\nint N, M;\nint vcnt = 0;\nint tcnt = 0;\npair<int, int> V[10];\nint prow[4] = {-1, 1, 0, 0};\nint pcol[4] = {0, 0, -1, 1};\n\nint main() {\n  // 입력받기\n  scanf(\"%d %d\", &N, &M);\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n      TMP[i][j] = A[i][j];\n      if (A[i][j] == 2) V[vcnt++] = make_pair(i, j);\n      if (A[i][j] == 0) tcnt++;\n    }\n  }\n  unsigned int flag = (1 << M) - 1; // 시작 플래그, unsigned int는 양수 범위를 가짐\n  int tcc = M;\n  unsigned int fin = 0; // 종료 플래그\n  // 종료 플래그 만들기.\n  while (tcc-- > 0) {\n    fin |= (1 <<  (vcnt - 1 - tcc));\n  }\n  unsigned int curflag = 0; // 조작용\n  int fcnt = 0;\n  int pos = 0;\n  int nextrow = 0, nextcol = 0;\n  queue<pair<int, int> > q;\n  int spread = 0, time = 0;\n  int ans = numeric_limits<int>::max();\n  bool stopflag = false;\n  // 시작플래그 ~ 종료플래그\n  for (flag; flag<=fin; flag++) {\n    curflag = flag;\n    fcnt = 0;\n    // 1비트 개수 세기, M개 일때만 코드 진행\n    while (curflag > 0) {\n      if (curflag & 1 == 1) fcnt++;\n      if (fcnt > M) break;\n      curflag = curflag >> 1;\n    }\n    if (fcnt != M) continue;\n\t\t// 이제 고른 바이러스 표시하기\n    curflag = flag;\n    pos = 0;\n    while (curflag > 0) {\n      if (curflag & 1 == 1) {\n        TMP[V[pos].first][V[pos].second] = -1; // 바이러스 복제\n        // 큐에 선택한 바이러스 넣기 -> 퍼트리기에서 BFS로 사용할 예정\n        q.push(make_pair(V[pos].first, V[pos].second));\n      }\n      pos++;\n      curflag = curflag >> 1;\n    }\n    q.push(make_pair(-1, 0));\n    spread = 0; // 퍼진 바이러스\n    time = 0; // 시간\n    stopflag = false; // 빈칸에 다 퍼트렸으면 true로 바꿀거다.\n    while (!q.empty()) {\n      // c++에서 q.pop()은 void 메소드라서 q.front()로 값 가져온다.\n      pair<int, int> po = q.front();\n      q.pop();\n      if (po.first >= 0) { // 퍼트린 칸이면\n        if (A[po.first][po.second] == 0) spread++; // 해당 칸이 원래 빈칸(0)이면 값 증가\n        if (spread == tcnt) stopflag = true; // 빈칸에 다 퍼트리면 시간체크용 값 나올 때 스탑하려고\n        for (int i=0; i<4; i++) { // 상하좌우 처리\n          nextrow = po.first + prow[i];\n          nextcol = po.second + pcol[i];\n          if (nextrow < 0 || nextrow >= N || nextcol < 0 || nextcol >= N) continue; // 범위 밖\n          if (TMP[nextrow][nextcol] == -1 || TMP[nextrow][nextcol] == 1) continue;\n          q.push(make_pair(nextrow, nextcol)); // 큐에 넣자넣자!\n          TMP[nextrow][nextcol] = -1; // 퍼트렸다는(방문했다는) 표시!\n        }\n      } else { // 시간체크용\n        time = po.second;\n        if (!q.empty()) q.push(make_pair(-1, po.second + 1));\n        if (stopflag) break; // 이미 모든 빈칸에 퍼트렸으면 나오자!\n      }\n    }\n    while (!q.empty()) // 위 반복에서 stopflag에 의해 중간에 빠져나왔을 경우를 대비해서\n    {\n      q.pop();\n    }\n    // 시간 넣자!!\n    if (spread == tcnt && ans > time) ans = time;\n    for (int i=0; i<N; i++) {\n      for (int j=0; j<N; j++) {\n        TMP[i][j] = A[i][j];\n      }\n    }\n  }\n  if (ans == numeric_limits<int>::max()) ans = -1;\n  printf(\"%d\", ans);\n  return 0;\n}\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"6c5737bcef4046d74738a7a56d218a7a8c80d728","text":"# 백준 - 16235 나무 재테크(C++)\n\n- Title : 백준 - 16235 나무 재테크(C++)\n- Date : 2020-01-28\n- Category: 알고리즘 풀이\n\n# 나무 재테크\n\n- 각 계절을 구현하는 데는 어려움이 없었으나 처음에 벡터 하나에 나무를 다 저장하고 매번 sort를 해서 시간 초과가 발생했었다.\n- 고민하다가 각 칸마다 deque에 나무 나이를 담는 식으로 바꿨다.\n- vector가 아닌 deque를 선택한 건 가을(번식)때 생성되는 나무는 나이가 1이므로 맨 앞에 추가되어야하기 때문이다.\n- vector는 배열이라 맨 앞 추가할 때 O(N)의 시간복잡도가 발생한다.\n- deque로 바꿨기에 처음 1번만 sort를 사용하여 효율성을 높였다.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <deque>\nusing namespace std;\n\n#define MAX 10\n\nint N, M, K;\nint A[MAX][MAX]; // 로봇 양분\nint L[MAX][MAX]; // 땅\ndeque<int> T[MAX][MAX]; // 각 땅의 나무 나이\n\nvoid addTree(int r, int c){\n\tif (r < 0 || c < 0 || r >= N || c >= N) return;\n\tT[r][c].push_front(1);\n}\n\nint main() {\n\tint x, y, age;\n\tscanf(\"%d %d %d\", &N, &M, &K);\n\n\tfor (int i=0; i<N; i++) {\n\t\tfor (int j=0; j<N; j++) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t\tL[i][j] = 5;\n\t\t}\n\t}\n\tfor (int i=0; i<M; i++) {\n\t\tscanf(\"%d %d %d\", &x, &y, &age);\n\t\tT[--x][--y].push_back(age);\n\t}\n\n\tfor (int i=0; i<N; i++) {\n\t\tfor (int j=0; j<N; j++) {\n\t\t\tif (T[i][j].size() > 1) {\n\t\t\t\tsort(T[i][j].begin(), T[i][j].end());\n\t\t\t}\n\t\t}\n\t}\n\n\tbool flag;\n\twhile(K-- > 0) {\n\n\t\t// 같은 칸이면 어린 순으로 나이만큼 양분먹고 나이 증가\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tdeque<int> &tmp = T[i][j];\n\t\t\t\tflag = true;\n\t\t\t\tfor(auto iter=tmp.begin(); iter != tmp.end();) {\n\t\t\t\t\tint &t = *iter;\n\t\t\t\t\tif (L[i][j] >= t && flag) {\n\t\t\t\t\t\tL[i][j] -= t;\n\t\t\t\t\t\tt += 1;\n\t\t\t\t\t\titer++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t// 여름 처리\n\t\t\t\t\t\tL[i][j] += t / 2;\n\t\t\t\t\t\titer = tmp.erase(iter);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\t// 나이 5의 배수 나무 번식\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tdeque<int> &tmp = T[i][j];\n\t\t\t\tfor(auto iter=tmp.begin(); iter != tmp.end(); iter++) {\n\t\t\t\t\tint t = *iter;\n\t\t\t\t\tif (t % 5 == 0) {\n\t\t\t\t\t\taddTree(i - 1, j - 1);\n\t\t\t\t\t\taddTree(i - 1, j);\n\t\t\t\t\t\taddTree(i - 1, j + 1);\n\t\t\t\t\t\taddTree(i, j - 1);\n\t\t\t\t\t\taddTree(i, j + 1);\n\t\t\t\t\t\taddTree(i + 1, j - 1);\n\t\t\t\t\t\taddTree(i + 1, j);\n\t\t\t\t\t\taddTree(i + 1, j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 로봇이 양분 추가\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tL[i][j] += A[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i=0; i<N; i++) {\n\t\tfor (int j=0; j<N; j++) {\n\t\t\tans += T[i][j].size();\n\t\t}\n\t}\n\tprintf(\"%d\", ans);\n\n\treturn 0;\n}\n```\n"}}}},"pageContext":{"id":"71b6232e760cb058f53c92719edc32233daa262c","previousPostId":"74f84e9d20d88dabd2edfd88b79237bc44153e4a","nextPostId":"6c5737bcef4046d74738a7a56d218a7a8c80d728"}},"staticQueryHashes":["2685952063","2841359383"]}