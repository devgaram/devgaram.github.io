{"componentChunkName":"component---src-templates-blog-post-js","path":"/2570d25c403b748053bcd53d0ff0e32d37cc4697","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"2570d25c403b748053bcd53d0ff0e32d37cc4697","text":"# Java Comparator과 Comparable\n\n- Title : Java Comparator과 Comparable\n- Date : 2019-10-18\n- Category: Java\n\nPS 문제를 풀다가 Arrays.sort()와 Collections.sort()를 오름차순(디폴트)이 아닌 다른 기준으로 정렬하고 싶을 때가 있었다. 찾아보니 Comparator 또는 Comparable을 사용하면 된다고 한다. 음.. 알아본 김에 잊어버리지않게 기록을 해야겠다!\n\n# 컬렉션을 입맛대로 정렬하고 싶다면?\n\n내맘대로 컬렉션의 정렬 기준을 정하고 싶다면 `Comparator`과 `Comparable` 인터페이스를 사용하면 된다.\n\n```java\nimport java.util.Comparator;\npublic interface Comparator {\n    int compare(Object o1, Object o2);\n    boolean equals(Object obj);\n}\n```\n\n<br/>\n\n```java\nimport java.lang.Comparable;\npublic interface Comparable {\n    public int compareTo(Object o); // 양수 : 내림차순, 음수 : 오름차순\n}\n```\n\n# 그럼 둘의 차이는 무엇일까?\n\nComparable을 구현한 클래스들은 기본적으로 오름차순으로 정렬되도록 구현되어있다.  \nInteger, Character와 같은 `wrapper` 클래스(int, long, float, double 등을 객체화한 클래스)와 `String, Date, File`과 같은 것이 Comparable을 구현한 대표적 클래스이다. 그 외 Java API 문서에서 클래스 목록을 확인할 수 있다.  \n그래서 우리가 `Arrays.sort(정렬대상)` 로 오름차순 정렬을 할 수 있는 것이다. 아하!\n\n```java\npublic final class Integer extends Number implements Comparable {\n    ...\n    public int compareTo(Object o) {\n        return compareTo((Integer) o);\n    }\n\n    public int compareTo(Integer anotherInteger) {\n        int thisVal = this.value;\n        int anotherVal = anotherInteger.value;\n        return (thisVal < anotherVal ? -1 : (thisVal ==anotherVal ? 0 : 1));\n    }\n}\n```\n\n실제 Integer 클래스의 일부이다.  \n보이는 것 처럼 Comparable 인터페이스를 구현하고 compareTo 메서드에서 오름차순으로 정렬되도록 정의해놓았다.\n\nComparator 인터페이스는 Comparable로 구현된 클래스를, 또는 커스텀 클래스를 기본 정렬 기준 외에 다른 기준으로 정렬하고자 할 때 사용하면 된다.  \n아래는 실제 예제로 백준 16236 아기 상어 문제를 풀 때 우선순위큐의 정렬기준을 Comparator을 이용해 정의한 것이다.\n\n```java\nPriorityQueue<Point> pq = new PriorityQueue<>(new Comparator<Point>() {\n\t@Override\n\tpublic int compare(Point o1, Point o2) {\n\t\tif (o1.dis != o2.dis) return o1.dis-o2.dis;\n\t\tif (o1.row != o2.row) return o1.row-o2.row;\n\t\treturn o1.col-o2.col;\n\t}\n});\n```\n\n또는 책의 예제를 보면 따로 클래스를 정의해서 사용할 수 있다.  \n이 예제는 Comparable을 구현한 클래스 String의 정렬 방식을 내림차순으로 바꾸는 방법이다.  \n단순히 -1을 곱해 반대의 값을 반환하게 구현했다.\n\n```java\n\nArrays.sort(strArr, new Descending());\n\nClass Descending implements Comparator {\n    public int compareTo(Object o1, Object o2) {\n        if (o1 instanceof Comparable && o2 instanceof Comparable) {\n            Comparable c1 = (Comparable) o1;\n            Comparable c2 = (Comparable) o2;\n            return c1.compareTo(c2) * -1;\n        }\n    }\n}\n```\n\n이제 내맘대로 정렬할 수 있게 되었담!!!!\n\n자바의 정석 책을 참고했습니다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"5c0786d6f1e1d8c7b84d2158fb2a236a354f6504","text":"# 프로그래머스 [3차] n진수게임 Javascript\n\n- Title : 프로그래머스 [3차] n진수게임 Javascript\n- Date : 2019-11-28\n- Category: 알고리즘 풀이\n\n# 문제 설명\n\n튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다.\n\n숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다.  \n10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다.  \n이렇게 게임을 진행할 경우,  \n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, …  \n순으로 숫자를 말하면 된다.\n\n한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는  \n0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, …  \n순으로 숫자를 말하면 된다.\n\n이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다.  \n숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다. 튜브의 프로그램을 구현하라.\n\n# 풀이\n\n```javascript\nfunction solution(n, t, m, p) {\n  var answer = \"\";\n  var game = new Array();\n  var number = 0;\n  while (game.length < t * m) {\n    let tmp = number;\n    let arrTmp = new Array();\n    while (tmp >= n) {\n      arrTmp.unshift(tmp % n); // 배열 맨 앞에 삽입\n      tmp = Math.floor(tmp / n); // Math.floor() 소숫점 내림\n    }\n    arrTmp.unshift(tmp);\n    game.push(...arrTmp); // game.push.apply(game, arrTmp);와 같음 확장연산자(e6)\n    //game = game.concat(arrTmp); // 배열 합치기 느리다.\n    number++;\n  }\n\n  for (let i = p - 1; i < game.length; i = i + m) {\n    answer += game[i].toString(n).toUpperCase(); // toString() number를 n진수 형태로 반환한다. abcdef를 소문자 형태로 반환해서 toUpperCase()를 사용했다.\n    if (answer.length == t) break;\n  }\n  return answer;\n}\n```\n\n## Number.prototype.toString([radix]]) 메서드\n\n- Number.prototype.toString() 은 Number 객체를 문자열로 반환하는 메서드다.\n- radix는 진수를 나타내는 기수의 값으로 2~36 범위의 정수다. 이 범위를 벗어나는 radix가 주어지면 RangeError가 발생한다. (default는 10진수)\n\nNumber 객체는 Object 객체의 toString() 메서드(**Object.prototype.toString()**)를 오버라이딩했다.\n그래서 Number 객체에서 toString() 메서드를 사용하면 특정 진수로 객체를 표현한 문자열을 리턴받을 수 있는 것이다.\n\n```javascript\nlet number = 254;\nconsole.log(number.toString(16)); // fe 출력\n```\n\n## Array.prototype.unshift([...elementN])\n\n새로운 요소를 배열의 맨 앞쪽에 추가하고, 배열의 길이를 리턴\n\n```javascript\nlet arr = [1, 2];\narr.unshift(0); // [0,1,2]\narr.unshift(-2, -1); // [-2, -1, 0, 1, 2]\n```\n\n## Array.prototype.push vs Array.prototype.concat\n\n처음에는 **game = game.concat(arrTmp)** 식으로 배열을 합쳤다. 근데 시간이 너무 많이 소요되길래 **game.push(...arrTmp)** 이렇게 바꿨더니 효율성이 좀 좋아진 듯 하다. 왜 그럴까?...\n\n[https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki](https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki) 이 글을 보면 알 수 있다.\n\n즉 concat은 .push로 원본 배열을 수정하면서 **새 배열**을 만들기때문에 느리고 push는 원본 배열의 뒤에 배열을 추가하며 원본 배열을 변경하기 때문에 concat 보다는 빠르다.\n\n## 다른 사람 풀이\n\n다른 사람 풀이를 봤더니 이렇게 간단하게도 풀 수 있다는 걸 알았다.\n\n```javascript\nfunction solution(n, t, m, p) {\n  let answer = \"\",\n    numbers = [],\n    j = 0;\n\n  for (let i = p; answer.length < t; i += m) {\n    let order = i - 1;\n\n    while (numbers[order] === undefined) {\n      j.toString(n)\n        .toUpperCase()\n        .split(\"\")\n        .forEach(v => numbers.push(v));\n      j++;\n    }\n    answer += numbers[order];\n  }\n  return answer;\n}\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"b98232c7cb9b2f596542f32029a4d9e3db9cc08c","text":"# JVM 메모리 구조\n\n- Title : JVM 메모리 구조\n- Date : 2019-10-16\n- Category: Java\n\n예전 면접에서 JVM 메모리 구조에 관한 질문을 받은 적이 있었다...  \n횡설수설하며 대답하긴 했지만 좀 더 깔끔한 답변을 위해 정리해야할 필요성을 느꼈다..!!!\n\n우선, JVM이 뭘까?\n\nJVM(Java Virtual Machine) 은 자바로 작성된 애플리케이션을 실행하기 위해서 반드시 필요한 가상머신이다!\n\n![1](https://raw.githubusercontent.com/devgaram/TIL/master/Java/images/2019-10-16-img/memory01.png) <br/>\n\n위 그림을 보면 일반 애플리케이션 코드는 OS만 거치고 하드웨어로 전달되지만 자바 애플리케이션은 JVM을 한번 더 거친다.\n그래서 자바는 속도가 느린 단점이 있다고 한다.\n\n왜??? 이유를 알기 위해 잠시 자바 응용 프로그램의 실행되는 과정을 살펴볼 필요가 있다.\n\n1. 응용프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.\n2. javac.exe (자바 컴파일러)가 자바소스를 바이트 코드(\\*.class)로 컴파일한다.\n3. Class Loader가 JVM에 클래스 파일을 로드시킨다.\n4. java.exe (자바인터프리터, 실행엔진)이 컴파일된 바이트 코드를 해석한다.\n5. 해석된 바이트 코드는 Runtime Data Areas에 배치되어 실행된다.\n\n위와 같이 하드웨어에 맞게 완전히 컴파일된 상태가 아닌 바이트 코드로 컴파일된 상태고 실행 시에 해석되기 때문에 느리다.\n그래도 요즘엔 바이트 코드를 하드웨어의 기계어로 바로 변환해주는 JIT 컴파일러와 향상된 최적화 기술이 적용되어서 속도 문제가 많이 개선되었다고 한다.\n\n장점으로는 JVM 덕분에 자바 애플리케이션은 OS에 종속되지 않는 점이 있다.  \n그래도 JVM은 OS에 종속되니깐 OS에 맞는 JVM이 필요하다.\n\n## JVM 메모리 구조\n\n![1](https://raw.githubusercontent.com/devgaram/TIL/master/Java/images/2019-10-16-img/JvmSpec7.png) <br/>\n[JVM스펙](https://ko.wikipedia.org/wiki/자바_가상_머신)\n\n이 중 3가지 주요 영역에 대해 알아보자.\n\n## 메서드 영역\n\n메서드 영역(Method area = static area = Class area)은 JVM이 \\*.class을 해석하여 얻은 클래스 정보(클래스 데이터)가 저장되는 공간이다. 이 때, 클래스 변수(static 멤버변수)도 같이 저장된다.  \n클래스정보에는 멤버변수의 이름/데이터 타입/접근 제어자 정보, 메소드의 이름/리턴 타입/매개변수/접근제어자 정보, 클래스인지 인터페이스인지 여부, 전체이름들이 해당된다.\n\n## 힙\n\n힙(Heap) 영역은 프로그램 실행 중에 생성되는 인스턴스(객체)가 저장되는 공간이다.  \n즉 new 키워드로 생성된 객체와 배열을 저장한다. 물론 인스턴스 변수도 같이 저장된다.\n\n## 호출스택\n\n호출 스택(call stack 또는 execution stack)은 호출된 메서드를 위한 메모리가 할당되는 곳으로 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함), 연산의 중간 결과, 리턴 값들을 저장하는 데 사용한다. 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워진다.\n\n참고서적) 자바의 정석  \n참고블로그) [https://asfirstalways.tistory.com/158](https://asfirstalways.tistory.com/158)\n"}}}},"pageContext":{"id":"2570d25c403b748053bcd53d0ff0e32d37cc4697","previousPostId":"5c0786d6f1e1d8c7b84d2158fb2a236a354f6504","nextPostId":"b98232c7cb9b2f596542f32029a4d9e3db9cc08c"}},"staticQueryHashes":["2685952063","2841359383"]}