{"componentChunkName":"component---src-templates-blog-post-js","path":"/2570d25c403b748053bcd53d0ff0e32d37cc4697","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"2570d25c403b748053bcd53d0ff0e32d37cc4697","text":"# Java Comparator과 Comparable\n\n- Title : Java Comparator과 Comparable\n- Date : 2019-10-18\n- Category: Java\n\nPS 문제를 풀다가 Arrays.sort()와 Collections.sort()를 오름차순(디폴트)이 아닌 다른 기준으로 정렬하고 싶을 때가 있었다. 찾아보니 Comparator 또는 Comparable을 사용하면 된다고 한다. 음.. 알아본 김에 잊어버리지않게 기록을 해야겠다!\n\n# 컬렉션을 입맛대로 정렬하고 싶다면?\n\n내맘대로 컬렉션의 정렬 기준을 정하고 싶다면 `Comparator`과 `Comparable` 인터페이스를 사용하면 된다.\n\n```java\nimport java.util.Comparator;\npublic interface Comparator {\n    int compare(Object o1, Object o2);\n    boolean equals(Object obj);\n}\n```\n\n<br/>\n\n```java\nimport java.lang.Comparable;\npublic interface Comparable {\n    public int compareTo(Object o); // 양수 : 내림차순, 음수 : 오름차순\n}\n```\n\n# 그럼 둘의 차이는 무엇일까?\n\nComparable을 구현한 클래스들은 기본적으로 오름차순으로 정렬되도록 구현되어있다.  \nInteger, Character와 같은 `wrapper` 클래스(int, long, float, double 등을 객체화한 클래스)와 `String, Date, File`과 같은 것이 Comparable을 구현한 대표적 클래스이다. 그 외 Java API 문서에서 클래스 목록을 확인할 수 있다.  \n그래서 우리가 `Arrays.sort(정렬대상)` 로 오름차순 정렬을 할 수 있는 것이다. 아하!\n\n```java\npublic final class Integer extends Number implements Comparable {\n    ...\n    public int compareTo(Object o) {\n        return compareTo((Integer) o);\n    }\n\n    public int compareTo(Integer anotherInteger) {\n        int thisVal = this.value;\n        int anotherVal = anotherInteger.value;\n        return (thisVal < anotherVal ? -1 : (thisVal ==anotherVal ? 0 : 1));\n    }\n}\n```\n\n실제 Integer 클래스의 일부이다.  \n보이는 것 처럼 Comparable 인터페이스를 구현하고 compareTo 메서드에서 오름차순으로 정렬되도록 정의해놓았다.\n\nComparator 인터페이스는 Comparable로 구현된 클래스를, 또는 커스텀 클래스를 기본 정렬 기준 외에 다른 기준으로 정렬하고자 할 때 사용하면 된다.  \n아래는 실제 예제로 백준 16236 아기 상어 문제를 풀 때 우선순위큐의 정렬기준을 Comparator을 이용해 정의한 것이다.\n\n```java\nPriorityQueue<Point> pq = new PriorityQueue<>(new Comparator<Point>() {\n\t@Override\n\tpublic int compare(Point o1, Point o2) {\n\t\tif (o1.dis != o2.dis) return o1.dis-o2.dis;\n\t\tif (o1.row != o2.row) return o1.row-o2.row;\n\t\treturn o1.col-o2.col;\n\t}\n});\n```\n\n또는 책의 예제를 보면 따로 클래스를 정의해서 사용할 수 있다.  \n이 예제는 Comparable을 구현한 클래스 String의 정렬 방식을 내림차순으로 바꾸는 방법이다.  \n단순히 -1을 곱해 반대의 값을 반환하게 구현했다.\n\n```java\n\nArrays.sort(strArr, new Descending());\n\nClass Descending implements Comparator {\n    public int compareTo(Object o1, Object o2) {\n        if (o1 instanceof Comparable && o2 instanceof Comparable) {\n            Comparable c1 = (Comparable) o1;\n            Comparable c2 = (Comparable) o2;\n            return c1.compareTo(c2) * -1;\n        }\n    }\n}\n```\n\n이제 내맘대로 정렬할 수 있게 되었담!!!!\n\n자바의 정석 책을 참고했습니다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"0e6c91a0a899db4d2998ba6ee8189e54a606fb9b","text":"# 알고리즘 개념 잡자 - 연결리스트\n\n- Title : [코딩인터뷰] 연결리스트\n- Date : 2019-12-12\n- Category: Algorithm\n\n코딩 인터뷰 완전분석 연결리스트 파트 예제 문제 풀이\n\n# 배열\n\n## Random access\n\n배열의 엘리먼트들은 메모리에 연속적으로 저장되므로 어떤 엘리먼트도 첫번째 엘리먼트의 주소에 각 엘리먼트 크기를 더해서 접근할 수 있다.  \n각 엘리먼트가 4byte고 세번째 엘리먼트 접근하려면 첫번째 주소 + 4\\*3 이다.  \n즉, 첫번째 탐색이나 마지막 엘리먼트 탐색 시간 차이가 없다. 탐색 시간 O(1) 가능하다.\n\n## 메모리 낭비\n\n개발자가 메모리를 얼마나 사용할 지 모르는 상태에서 배열의 크기를 초기화해야한다.\n\n## 삽입 삭제 연산 느림\n\n첫번째 또는 중간 삽입의 경우 삽입 엘리먼트 공간 확보를 위해 배열을 한칸씩 뒤로 이동시켜야한다.  \n삭제는 반대로 한칸씩 앞으로 이동시켜야하고 배열의 크기를 재조정해야 한다.  \n즉, n개의엘리먼트를 이동시켜야하므로 O(n) 단 맨끝 삭제는 o(1)\n\n# 연결리스트\n\n## Iterate access\n\n배열과 달리 메모리에 연속적 공간 갖지않고 첫번째 노드의 포인터부터 순회해야한다.  \n즉, 탐색은 O(n) 시간복잡도를 가져서 배열보다 탐색이 느리다.\n\n## 리스트 크기를 미리 정의해놓을필요가없음\n\n## 삽입 삭제 연산 빠름\n\n중간노드 끝노드의 경우 위치 찾는데는 o(n) 이지만 실제 삽.삭은 포인터만 업데이트하면되니깐 o(1)이다.  \n단, 맨 앞 노드는 o(1)\n\n# 2.1 중복 없애기 : 정렬되어 있지 않은 연결리스트가 주어졌을 때 이 리스트에서 중복되는 원소를 제거하는 코드를 작성하자. 임시 버퍼를 사용할 수 없는 경우도 생각해보자.\n\n1. 임시버퍼를 사용할 수 있다면, 중복을 허용하지 않는 Set 컬렉션을 이용해서 해결할 수 있다. 이 경우는 O(N)의 시간 복잡도를 갖는다.\n2. 임시버퍼를 사용할 수 없다면, 이중 반복문을 통해 중복 노드를 찾은 후 제거하면 된다. 이 경우는 O(N^2)의 시간 복잡도를 갖는다.\n\n## 자바스크립트 풀이\n\n```javascript\n\"use strict\";\n\nclass Node {\n  constructor(data, next) {\n    this.data = data;\n    this.next = next;\n  }\n}\n\nclass LinkedList {\n  constructor(head) {\n    this.head = head;\n  }\n\n  display() {\n    let cur = this.head;\n    while (cur != null) {\n      console.log(cur.data);\n      cur = cur.next;\n    }\n  }\n}\n\nfunction makeList() {\n  let n6 = new Node(4);\n  let n5 = new Node(5, n6);\n  let n4 = new Node(3, n5);\n  let n3 = new Node(5, n4);\n  let n2 = new Node(4, n3);\n  let n1 = new Node(5, n2);\n  let list = new LinkedList(n1);\n  return list;\n}\n\n// O(n) n: 연결리스트 길이\nfunction solution() {\n  const list = makeList();\n  const set = new Set();\n  let cur = list.head;\n  let pre = null;\n  while (cur != null) {\n    if (set.has(cur.data)) {\n      pre.next = cur.next;\n    } else {\n      set.add(cur.data);\n      pre = cur;\n    }\n    cur = cur.next;\n  }\n  list.display();\n}\n\n// O(N^2) 버퍼 없이\nfunction solution_2() {\n  const list = makeList();\n  let cur = list.head;\n\n  while (cur != null) {\n    let mn = cur;\n\n    while (mn.next != null) {\n      if (cur.data === mn.next.data) {\n        mn.next = mn.next.next;\n      } else {\n        mn = mn.next;\n      }\n    }\n    cur = cur.next;\n  }\n\n  list.display();\n}\n\nsolution();\nsolution_2();\n```\n\n**자바스크립트의 null과 undefined**  \n자바스크립트에서 '없음'을 나타내는 값에 null과 undefined가 있다. 값이 대입되지 않은 변수나 속성의 경우는 undefined이며 객체가 없는 경우는 null로 나타낸다.  \n자바스크립트의 === 등호는 값이 정확히 같을 때 true를 반환하나 == 등호는 그렇지 않을 때가 많다. 보통의 경우는 === 를 권장하나 null check 할 때는 == 쓰면 값이 null 또는 undefined의 경우 false를 리턴 받을 수 있다.\n\n**자바스크립트의 class**  \nES6의 클래스 선언은 호이스팅이 되지 않아서 클래스를 사용하기 위해서는 클래스를 먼저 선언해야 한다. class body는 {}로 묶여 있는 안쪽 부분으로 constructor(생성자)가 있는 곳이다. 객체를 생성하고 초기화하는 메소드로 클래스 안에 한 개만 존재할 수 있다. 부모 생성자를 호출하기 위해 super 키워드를 사용할 수도 있다.\n\n**자바스크립트에서 오토박싱**  \nnon-strict 모드에서 this 값이 null 혹은 undefined 일 경우 window 객체로 자동으로 변환을 해주는 것을 오토박싱이라고 한다. 그래서 일반 메서드에서 this 값이 window 객체가 된다. class 문법 안에 있는 코드는 항상 strict mode로 실행되기 때문에 클래스 메서드 호출에서 this의 초기값은 undefined다.\n\n**자바에서 오토박싱**  \n자바에는 int, float와 같은 기본형(primitive type)과 Integer, Float와 같은 래퍼 클래스가 있다. 래퍼 클래스는 기본형을 객체로 다루어야 할 경우에 사용할 수 있다. 컬렉션에서 엘리먼트는 객체가 되어야 되서 int 기본형을 사용하지 않고 Integer를 사용하는 것을 본 적이 있을 거다. 박싱은 기본형을 참조형으로 변환하는 것이고 언박싱은 반대로 참조형을 기본형으로 바꾸는 것이다. 예제를 통해 확실히 이해해보자.\n\n```java\nint pa = 1;\nInteger wa = pa; // 오토박싱\n\nInteger wb = new Integer(2);\nint pb = wb; // 오토언박싱\n\n```\n\n## 자바 풀이\n\n**리스트 반복하면서 삭제하기**  \nfor(;;)를 이용한 방법은 반복 도중 엘리먼트가 삭제되면 반복문의 크기가 변한다. 또한 삭제된 엘리먼트 자리를 채우기 위해 모든 인덱스가 하나씩 이동하게 된다. 생각대로 동작하지 않는 것 당연하다.\n\nfor-each문 안에서 엘리먼트를 삭제하게 되면 **java.util.ConcurrentModificationException** 에러를 보게 된다. Iterator로 반복 중인 리스트를 수정하려 하면 이 에러가 발생된다. for-each 문은 내부적으로 iterator를 실행하므로 remove()나 add()를 할 경우 에러가 발생되는 것이다.\n\n그래서 반복을 하면서 삭제를 하려면 Itertor 인터페이스를 사용하거나 Collection 인터페이스의 removeif 메서드를 사용한다.\n\n```java\n  public static void main(String[] args) {\n\t\tLinkedList<Integer> list = new LinkedList<>(Arrays.asList(5,4,2,3,5,4));\n\t\tsolution(list);\n\t}\n\n\tpublic static void solution(LinkedList<Integer> list) {\n\t\t// 1번 iterator 사용\n\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\tIterator<Integer> it = list.iterator();\n\n\t\twhile(it.hasNext()) {\n\t\t\tint next = it.next();\n\t\t\tif (set.contains(next)) it.remove();\n\t\t\telse set.add(next);\n\t\t}\n\n\t\t// 2번 removeif 사용\n\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\tlist.removeIf(num -> {\n\t\t\tif (set.contains(num)) return true;\n\t\t\telse {\n\t\t\t\tset.add(num);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}\n```\n\n# 2.2 뒤에서 K번째 원소 구하기: 단방향 연결리스트가 주어졌을 때 뒤에서 K번째 원소를 찾는 알고리즘을 구현하라.\n\n## 내 풀이\n\n리스트의 크기를 구하기 위해 한번 순회한 다음, 리스트 크기에 k만큼 뺀 index까지 반복을 돌려 원소를 찾았다.  \n시간 복잡도는 O(N)\n\n```javascript\nfunction solution_2(k) {\n  const list = makeList();\n\n  let cur = list.head;\n  let len = 0;\n  while (cur != null) {\n    len++;\n    cur = cur.next;\n  }\n\n  cur = list.head;\n  for (let i = 0; i < len - k; i++) {\n    cur = cur.next;\n  }\n\n  if (len - k < 0) return null;\n  else return cur.data;\n  //console.log(`뒤에서 ${k}번째 원소 값 : ${cur.data}`);\n}\n```\n\n## 반복문을 한번만 돌릴 수 있다면?\n\nRunner 기법을 사용했다. 연결리스트 문제에서 많이 활용되는 기법으로 순회할 때 두 개의 포인터를 동시에 사용하는 방법이다. 이 때 한 포인트가 다른 포인터보다 앞서도록 하며 앞선 포인터가 따라오는 포인터보다 **항상 지정된 개수만큼** 앞서거나, 따라오는 포인터를 **여러 노드를 한번에 뛰어넘도록** 설정할 수 있다.\n\n시간복잡도는 O(N) 이다.\n\n```javascript\nfunction solution_2_1(k) {\n  const list = makeList();\n\n  let cur = list.head;\n  let runner = cur;\n  let len = 0;\n  while (cur != null) {\n    if (len++ >= k) runner = runner.next;\n    cur = cur.next;\n  }\n  if (len - k < 0) return null;\n  else return runner.data;\n  // console.log(`뒤에서 ${k}번째 원소 값 : ${runner.data}`);\n}\n```\n\n# 2.3 중간 노드 삭제: 단방향 연결리스트가 주어졌을 때 중간(정확히 가운데 노드일 필요는 없고 처음과 끝 노드만 아니면 된다)에 있는 노드 하나를 삭제하는 알고리즘을 구현해라. 단, 삭제할 노드에만 접근할 수 있다.\n\nRunner 기법으로 중간 노드를 찾고 찾은 노드의 data와 next 값을 바로 다음 노드의 값으로 바꾼 다음 다음 노드의 next를 찾은 노드의 next로 지정한다.\n\n```javascript\nfunction solution_3() {\n  const list = makeList();\n  let cur = list.head;\n  let runner = list.head;\n  let len = 0;\n  while (cur != null) {\n    cur = cur.next;\n    if (++len % 2 == 0) runner = runner.next;\n  }\n\n  if (runner.next == null) {\n    runner.data = null;\n  } else {\n    runner.data = runner.next.data;\n    runner.next = runner.next.next;\n  }\n\n  list.display();\n}\n```\n\n```javascript\nfunction solution_3() {\n  const list = makeList();\n\n  let cur = list.head;\n  let prerunner = null;\n  let runner = list.head;\n  let len = 0;\n  while (cur != null && cur.next != null) {\n    cur = cur.next.next;\n    prerunner = runner;\n    runner = runner.next;\n  }\n  if (cur != null) {\n    prerunner = runner;\n    runner = runner.next;\n  }\n  // 노드 갯수가 2 이하일 때, 처음/끝 노드가 삭제되는 것을 막기 위해\n  if (prerunner == null || runner.next == null) return;\n\n  prerunner.next = runner.next;\n  list.display();\n}\n```\n\n# 2.4 분할: 값 x가 주어졌을 때 x보다 작은 노드들을 x보다 크거나 같은 노드들보다 앞에 오도록 하는 코드를 작성하라. 만약 x가 리스트에 있다면 x는 그보다 작은 원소들보다 뒤에 나오기만 하면 된다. 즉, 원소 x는 '오른쪽 그룹' 어딘가에만 존재하면 된다. 왼쪽과 오른쪽 그룹 사이에 있을 필요는 없다.\n\n- 입력: 3->5->8->5->10->2->1 (분할값 x = 5)\n- 출력: 3->1->2->10->5->5->8\n\n순회를 하면서 data 값이 x보다 작은 경우에는 무조건 맨 앞으로 이동시키는 식으로 해결했다.\n\n```javascript\nfunction solution_4(x) {\n  const list = makeList();\n  let cur, pre;\n  if (list.head.data < x) {\n    cur = list.head.next;\n    pre = list.head;\n  } else {\n    cur = list.head;\n    pre = null;\n  }\n\n  while (cur != null) {\n    if (cur.data < x) {\n      pre.next = cur.next;\n      cur.next = list.head;\n      list.head = cur;\n      cur = pre.next;\n    } else {\n      pre = cur;\n      cur = cur.next;\n    }\n  }\n\n  list.display();\n}\n```\n\n## 그렇다면 원소의 순서를 유지하면서 x보다 작은 노드들을 x의 앞에 위치하게 하고 싶다면?\n\n두 개의 연결리스트를 만들어서 하나는 x보다 작은 노드들을 삽입하고 다른 하나는 x보다 크거나 같은 노드들을 넣는다. 모든 작업이 완료된 후 두 리스트를 합하면 된다.\n\n# 2.5 리스트의 합: 연결리스트로 숫자를 표현할 때 각 노드가 자릿수 하나를 가리키는 방식으로 표현할 수 있다. 각 숫자는 역순으로 배열되어 있는데, 첫 번째 자릿수가 리스트의 맨 앞에 위치하도록 배열된다는 뜻이다. 이와 같은 방식으로 표현된 숫자 두 개가 있을 때, 이 두 수를 더하여 그 합을 연결리스트로 반환하는 함수를 작성하라\n\n- 입력: (7->1->6) + (5->9->2) 즉, 617 + 295\n- 출력: 2->1->9 즉, 912\n\n```javascript\nfunction solution_5(list_1, list_2) {\n  let cur_1 = list_1.head,\n    cur_2 = list_2.head;\n  let c = 0;\n  let newListHead = null;\n  let newList = null;\n  while (cur_1 != null || cur_2 != null) {\n    if (cur_1 == null || cur_2 == null) {\n      newList.next = cur_1 == null ? cur_2 : cur_1;\n      break;\n    }\n    let sum = cur_1.data + cur_2.data + c;\n    if (newList == null) {\n      newList = new Node(sum % 10);\n      newListHead = new LinkedList(newList);\n    } else {\n      newList.next = new Node(sum % 10);\n      newList = newList.next;\n    }\n    c = parseInt(sum / 10);\n    cur_1 = cur_1.next;\n    cur_2 = cur_2.next;\n  }\n\n  newListHead.display();\n}\n```\n\n## 각 자릿수가 정상적으로 배열된다고 가정하고 같은 문제를 풀면?\n\n- 입력: (6->1->7) + (2->9->5) 즉, 617+295\n- 출력: 9->1->2 즉, 912\n\n재귀로 순회해서 끝에서 부터 더해가면 된다. 단, 리스트의 길이가 다를 경우가 있으므로 이 부분을 고려해야 한다.\n재귀 안에서 해결해볼까 했는 데, 복잡해져서 아예 길이를 같게 만드는 방법으로 해보았다.\n\n```javascript\nfunction solution_5_1(list_1, list_2) {\n  let list_1_len = getSize(list_1.head),\n    list_2_len = getSize(list_2.head);\n\n  while (list_1_len > list_2_len) {\n    list_2.head = new Node(0, list_2.head);\n    list_2_len++;\n  }\n  while (list_1_len < list_2_len) {\n    list_1.head = new Node(0, list_1.head);\n    list_1_len++;\n  }\n\n  let newList = null;\n  recursion(list_1.head, list_2.head);\n\n  newList.display();\n  function recursion(cur_1, cur_2) {\n    if (cur_1 == null && cur_2 == null) return 0;\n    let sum = cur_1.data + cur_2.data + recursion(cur_1.next, cur_2.next);\n    if (newList == null) {\n      newList = new LinkedList(new Node(sum % 10));\n    } else {\n      newList.head = new Node(sum % 10, newList.head);\n    }\n    return parseInt(sum / 10);\n  }\n\n  function getSize(list) {\n    let cur = list;\n    let len = 0;\n    while (cur != null) {\n      len++;\n      cur = cur.next;\n    }\n    return len;\n  }\n}\n```\n\n# 회문: 주어진 연결리스트가 회문인지 검사하는 함수를 작성하라\n\n회문이란? 순서를 거꾸로 읽어도 제대로 읽은 것과 같은 단어와 문장을 말한다.  \n예시) level, sos\n\n```javascript\nfunction solution_6(list) {\n  let cur = list.head;\n  return recursion(list.head);\n\n  function recursion(list) {\n    if (list == null) return true;\n    let chk = recursion(list.next) && cur.data === list.data;\n    cur = cur.next;\n    return chk;\n  }\n}\n```\n\n## 책 해법 1. 뒤집어서 비교하기\n\n연결리스트를 순회하면서 새 리스트의 맨 앞에 삽입하면서 역순 리스트를 만든 후 비교한다.\n\n## 책 해법 2. runner와 스택 이용\n\n```javascript\nfunction solution_6_1(list) {\n  let cur = list.head;\n  let runner = cur;\n  let len = 0;\n  let array = Array();\n  while (cur != null && cur.next != null) {\n    len++;\n    array.push(runner.data);\n    runner = runner.next;\n    cur = cur.next.next;\n  }\n\n  if (len % 2 === 0) runner = runner.next;\n\n  while (runner != null) {\n    if (array.pop() !== runner.data) return false;\n    runner = runner.next;\n  }\n  return true;\n}\n```\n\n# 교집합: 단방향 연결리스트 두 개가 주어졌을 때 이 두 리스트의 교집합 노드를 찾은 뒤 반환하는 코드를 작성하라. 여기서 교집합이란 노드의 값이 아니라 노드의 주소가 완전히 같은 경우를 말한다. 즉, 첫 번째 리스트에 있는 k번째 노드와 두 번째 리스트에 있는 j번째 노드가 주소까지 완전히 같다면 이 노드는 교집합의 원소가 된다.\n\n두 연결리스트에서 교집합이 있다는 것은.. 그 교집합 노드 뒤부터는 같은 노드라는 것, 즉 마지막 노드가 같다.\n\n```javascript\nfunction solution_7(list_1, list_2) {\n  let set = new Set();\n  let newList = null;\n  let cur = list_1.head;\n  while (cur != null) {\n    set.add(cur);\n    cur = cur.next;\n  }\n\n  cur = list_2.head;\n  while (cur != null) {\n    if (set.has(cur)) {\n      newList = cur;\n      break;\n    }\n    cur = cur.next;\n  }\n  if (newList == null) return null;\n  return new LinkedList(newList);\n}\n```\n\n## 책 풀이\n\n1. 두 연결리스트를 순회해서 마지막 노드와 사이즈를 구하고 각 마지막 노드가 같으면 교집합이 존재하며 다르면 교집합은 없다.\n2. 길이가 더 긴 연결리스트의 포인터를 이동시켜서 두 연결리스트 순회 길이가 같도록 포인터를 맞춘다.\n3. 동시에 두 연결리스트의 포인트를 이동시키면서 같은 노드가 발견되는 순간을 찾는다.\n\n# 루프발견: 순환 연결리스트가 주어졌을 때, 순환되는 부분의 첫째 노드를 반환하는 알고리즘을 작성하라. 순환 연결리스트란 노드의 next 포인터가 앞선 노드들 가운데 어느 하나를 가리키도록 설정되어 있는, 엄밀히 말해서 변질된 방식의 연결리스트를 의미한다.\n\n- 입력: A->B->C->D->E->C (앞에 나온 C와 같음)\n- 출력: C\n\n```javascript\nfunction solution_8(list) {\n  let set = new Set();\n  let cur = list.head;\n\n  while (cur != null) {\n    if (set.has(cur)) return cur.data;\n    set.add(cur);\n    cur = cur.next;\n  }\n  return null;\n}\n```\n\n# 끝!\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"b98232c7cb9b2f596542f32029a4d9e3db9cc08c","text":"# JVM 메모리 구조\n\n- Title : JVM 메모리 구조\n- Date : 2019-10-16\n- Category: Java\n\n예전 면접에서 JVM 메모리 구조에 관한 질문을 받은 적이 있었다...  \n횡설수설하며 대답하긴 했지만 좀 더 깔끔한 답변을 위해 정리해야할 필요성을 느꼈다..!!!\n\n우선, JVM이 뭘까?\n\nJVM(Java Virtual Machine) 은 자바로 작성된 애플리케이션을 실행하기 위해서 반드시 필요한 가상머신이다!\n\n![1](https://raw.githubusercontent.com/devgaram/TIL/master/Java/images/2019-10-16-img/memory01.png) <br/>\n\n위 그림을 보면 일반 애플리케이션 코드는 OS만 거치고 하드웨어로 전달되지만 자바 애플리케이션은 JVM을 한번 더 거친다.\n그래서 자바는 속도가 느린 단점이 있다고 한다.\n\n왜??? 이유를 알기 위해 잠시 자바 응용 프로그램의 실행되는 과정을 살펴볼 필요가 있다.\n\n1. 응용프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.\n2. javac.exe (자바 컴파일러)가 자바소스를 바이트 코드(\\*.class)로 컴파일한다.\n3. Class Loader가 JVM에 클래스 파일을 로드시킨다.\n4. java.exe (자바인터프리터, 실행엔진)이 컴파일된 바이트 코드를 해석한다.\n5. 해석된 바이트 코드는 Runtime Data Areas에 배치되어 실행된다.\n\n위와 같이 하드웨어에 맞게 완전히 컴파일된 상태가 아닌 바이트 코드로 컴파일된 상태고 실행 시에 해석되기 때문에 느리다.\n그래도 요즘엔 바이트 코드를 하드웨어의 기계어로 바로 변환해주는 JIT 컴파일러와 향상된 최적화 기술이 적용되어서 속도 문제가 많이 개선되었다고 한다.\n\n장점으로는 JVM 덕분에 자바 애플리케이션은 OS에 종속되지 않는 점이 있다.  \n그래도 JVM은 OS에 종속되니깐 OS에 맞는 JVM이 필요하다.\n\n## JVM 메모리 구조\n\n![1](https://raw.githubusercontent.com/devgaram/TIL/master/Java/images/2019-10-16-img/JvmSpec7.png) <br/>\n[JVM스펙](https://ko.wikipedia.org/wiki/자바_가상_머신)\n\n이 중 3가지 주요 영역에 대해 알아보자.\n\n## 메서드 영역\n\n메서드 영역(Method area = static area = Class area)은 JVM이 \\*.class을 해석하여 얻은 클래스 정보(클래스 데이터)가 저장되는 공간이다. 이 때, 클래스 변수(static 멤버변수)도 같이 저장된다.  \n클래스정보에는 멤버변수의 이름/데이터 타입/접근 제어자 정보, 메소드의 이름/리턴 타입/매개변수/접근제어자 정보, 클래스인지 인터페이스인지 여부, 전체이름들이 해당된다.\n\n## 힙\n\n힙(Heap) 영역은 프로그램 실행 중에 생성되는 인스턴스(객체)가 저장되는 공간이다.  \n즉 new 키워드로 생성된 객체와 배열을 저장한다. 물론 인스턴스 변수도 같이 저장된다.\n\n## 호출스택\n\n호출 스택(call stack 또는 execution stack)은 호출된 메서드를 위한 메모리가 할당되는 곳으로 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함), 연산의 중간 결과, 리턴 값들을 저장하는 데 사용한다. 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워진다.\n\n참고서적) 자바의 정석  \n참고블로그) [https://asfirstalways.tistory.com/158](https://asfirstalways.tistory.com/158)\n"}}}},"pageContext":{"id":"2570d25c403b748053bcd53d0ff0e32d37cc4697","previousPostId":"0e6c91a0a899db4d2998ba6ee8189e54a606fb9b","nextPostId":"b98232c7cb9b2f596542f32029a4d9e3db9cc08c"}},"staticQueryHashes":["2685952063","2841359383"]}