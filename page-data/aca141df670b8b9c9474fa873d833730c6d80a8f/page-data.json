{"componentChunkName":"component---src-templates-blog-post-js","path":"/aca141df670b8b9c9474fa873d833730c6d80a8f","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"aca141df670b8b9c9474fa873d833730c6d80a8f","text":"# [자바스크립트] 이벤트 위임(Event delegation)\n\n- Title : [자바스크립트] 이벤트 위임(event delegation)\n- Date : 2020-03-20\n- Category : Javascript\n\n# Why?\n\n웹 개발자라면 이벤트 핸들러를 등록할 때 **캡처링**과 **버블링**을 적절하게 선택할 수 있어야 하지 않을까?\n```javascript\n    // 이벤트 캡처\n    element1.addEventListener('click',doSomething2,true)\n    // 이벤트 버블링\n    element2.addEventListener('click',doSomething,false)\n```\n> 🔊 익명함수로 이벤트 핸들러를 정의할 수 있는 데 이 때 화살표 함수의 this 컨텍스트는 event.currentTarget이 아님을 알고 있어야 한다. function (e) {} 형태로 정의해야 this 컨텍스트가 event.currentTarget이 된다.\n\n# addEventListener 동작 방식\n\naddEventListener() 메서드의 마지막 argument의 값으로 이벤트 전파 방식을 지정할 수 있다. true면 캡쳐, false(기본값)면 버블링으로 이벤트가 전파된다. 아래 예시로 이해를 어떤식으로 전파되는 지 이해해보자.\n```html\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <meta charset=\"utf-8\">\n      <meta name=\"viewport\" content=\"width=device-width\">\n      <title>JS Bin</title>\n    </head>\n    <body>\n      <div id=\"element1\">\n        element1\n        <div id=\"element2\">\n           element2\n          <div id=\"element3\">element3</div\n        </div>\n      </div>\n    </body>\n    </html>\n```\n```javascript\n    var element1 = document.getElementById(\"element1\");\n    var element2 = document.getElementById(\"element2\");\n    var element3 = document.getElementById(\"element3\");\n    function doSomething1(){\n      console.log(\"doSomething1\");\n    }\n    function doSomething2(){\n      console.log(\"doSomething2\");\n    }\n    function doSomething3(){\n      console.log(\"doSomething3\");\n    }\n```\n🎈 3개의 element가 버블링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,false)\n    element3.addEventListener('click',doSomething3,false)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething2`→ `doSomething1`\n- element3 클릭시 출력 :  `doSomething3`→ `doSomething2` -> `doSomething1`\n\n🎈 3개의 element가 캡처링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,true)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,true)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething1`→ `doSomething2`\n- element3 클릭시 출력 :  `doSomething1`→ `doSomething2` -> `doSomething3`\n\n🎈 맨 밖의 엘리먼트는 버블링 내부 엘리먼트는 캡처링을 사용한다면?\n```javascript\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,true)\n```\n- element1 클릭시 출력 :  `doSomething1`\n- element2 클릭시 출력 :  `doSomething2`→ `doSomething1`\n- element3 클릭시 출력 :  `doSomething2`→ `doSomething3` -> `doSomething1`\n\n🎈 섞여있으면..?\n```javascript\n    document.body.addEventListener('click',doSomething0,true)\n    element1.addEventListener('click',doSomething1,false)\n    element2.addEventListener('click',doSomething2,true)\n    element3.addEventListener('click',doSomething3,false)\n```\nelement3 클릭시 출력 :  `doSomething0`→ `doSomething2` -> `doSomething3` → `doSomething1`\n\n### 테스트 결과\n\n- 이벤트 타켓에 이벤트가 발생하면 이벤트가 다른 이벤트 타켓(이벤트 핸들러가 등록된)으로 전파된다.\n- 이벤트 캡처는 이벤트 타켓의 최상위 요소(단, 이벤트 핸들러가 등록된)부터 이벤트 타켓까지 이벤트 핸들러를 처리한다.\n- 이벤트 버블링은 캡처와 반대로 이벤트 타켓부터 최상위 요소까지 이벤트 핸들러를 처리한다.\n- 섞여있으면 캡처링 우선인 이벤트 타켓부터 처리한 후 버블링을 수행한\n\n# 이벤트 버블링과 캡쳐\n\n아래 사진은 DOM 트리에서 일어나는 이벤트 전파 방법이다.\n\n[UI Events](https://www.w3.org/TR/DOM-Level-3-Events/#event-flow)\n\n![Event%20delegation/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/Untitled.png)\n\n캡처와 버블링은 두 요소(엘리먼트)가 해당 이벤트에 대한 핸들(함수)를 등록한 경우, 다른 요소 내에 중첩된 요소에서 발생하는 이벤트를 전파하는 방법이다. 이벤트 전파 모드로 요소가 이벤트를 수신하는 순서를 판별한다.\n\n## 이벤트 전파..? 신경쓰기 싫어!\n\n현재 이벤트 이후의 이벤트 전파(캡처링, 버블링)를 막고 싶다면 **`event.stopPropagation()`** 메서드를 사용하면 된다.\n\n## 이벤트는 취소하고 전파는 하고 싶어!\n\n**`event.preventDefault()`** 는 이벤트를 취소하지만 이벤트 전파를 막지 않는다. 전파를 막으려면 `event.stopPropagation()`을 사용해야한다.  주로 `a` 태그나 `submit` 태그 등 고유의 동작을 막고 원하는 이벤트 핸들러를 실행할 때 사용한다.\n\n## 메모리 이슈\n\n루프의 각 반복마다 새로운 익명 행들러 함수가 생성되는 방식으로 이벤트를 등록하지 말자. 따로 이벤트 핸들러를 생성한 후 등록하는 방식을 사용해야 메모리 소비가 줄고 `removeEventListener()`를 호출할 수 있다. 익명 함수는 참조가 유지되지않기에 이벤트 리스너를 제거할 수 없다.\n\n# 이벤트 위임(Event delegation)\n\n이벤트 발생 시 document 레벨까지 버블링 되어 올라가는 것을 활용하는 것으로 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식이다.\n\n- 동적인 엘리먼트에 대한 이벤트 처리 수월\n- 하위 엘리먼트는 자유롭게 추가 삭제 가능\n- 동일한 이벤트를 한 곳에서 관리할 수 있고 이벤트 핸들러 관리 쉽다.\n- 생성되는 이벤트 핸들러 함수가 줄어 메모리 사용량이 줄고 메모리 누수 가능성이 감소된다.\n\n참조\n\n[왜 이벤트 위임(delegation)을 해야 하는가?](https://ui.toast.com/weekly-pick/ko_20160826/)\n\n[EventTarget.addEventListener()](https://developer.mozilla.org/ko/docs/Web/API/EventTarget/addEventListener)"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"cc4c2ba350ff2dcd7d43ee1ce312d69f9c1991b8","text":"# 백준 문제 - 문자열 처리\n\n- Title : [백준] 문자열 처리\n- Date : 2020-03-27\n- Category : 알고리즘 문제 풀기\n\n# Why?\n\nC++ 로 문자열 문제를 풀 때 입출력, 파싱 등 부분에서 막힌다는 생각이 들어서 연습겸 문자열 관련 문제만 풀어보았다. 난이도는 브론즈 정도?\n\n## 11654 아스키 코드\n\n알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하세요.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tchar c;\n    \tcin >> c;\n    \tcout << (int) c;\n    \treturn 0;\n    }\n\n> 'A' 는 65, 'a' 는 97\n\n## 1152 단어의 개수\n\n영어 대소문자와 띄어쓰기만으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \tint ans = 0;\n    \tgetline(cin, str);\n    \tcin.ignore();\n    \t\n    \tfor (int i=0; i<str.size(); i++) {\n    \t\tif (str[i] == ' ') ans++;\n    \t}\n    \t\n    \tif (str[str.size()-1] == ' ') ans--;\n    \tif (str[0] != ' ') ans++;\n    \t\n    \tcout << ans;\n    \treturn 0;\n    }\n\n> 문자열을 공백으로 파싱해야할 때\n\n    #include <iostream>\n    #include <vector>\n    #include <sstream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \t\n    \tgetline(cin, str);\n    \tcin.ignore();\n    \t\n    \tstring buf;\n    \tstringstream ss(str);\n    \tvector<string> tokens;\n    \t\n    \twhile (ss >> buf) {\n    \t\ttokens.push_back(buf);\n    \t}\n    \t\n    \tcout << tokens.size();\t\n    \t\n    \treturn 0;\n    }\n\n> `getline(cin, str)` 로 공백을 포함한 문자열을 입력받을 수 있다. 단, `\\n` 을 포함하지않으므로 버퍼에서 `\\n` 을 제거하기 위해 `cin.ignore()` 을 해야한다.\n\n## 10809 알파벳 찾기\n\n알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \tcin >> str;\n    \tint ans[26];\n    \tfill(&ans[0], &ans[26], -1);\n    \t\n    \tfor (int i=str.size()-1; i>=0; i--) {\n    \t\tint c = (int) str[i];\n    \t\tans[c - 97] = i;\n    \t}\n    \t\n    \tfor (int i=0; i<26; i++) {\n    \t\tcout << ans[i] << ' ';\n    \t}\n    \t\n    \treturn 0;\n    }\n\n## 1157 단어공부\n\n알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tchar str[1000000];\n    \tint cnt[26] = {0};\n    \tint idx = 0, max = 0, maxi = 0;\n    \t\n    \tscanf(\"%s\", str);\n    \t\n    \tfor (int i=0; str[i]; i++) {\n    \t\tif (str[i] < 97) idx = str[i] - 65;\n    \t\telse idx = str[i] - 97;\n    \t\t\n    \t\tcnt[idx]++;\n    \t\tif (cnt[idx] > max) {\n    \t\t\tmax = cnt[idx];\n    \t\t\tmaxi = idx;\n    \t\t} else if (cnt[idx] == max) {\n    \t\t\tmaxi = -1;\n    \t\t}\n    \t}\n    \t\n    \tprintf(\"%c\", maxi == -1 ? '?' : maxi + 65);\n    \t\n    \treturn 0;\n    }\n\n## 2908 상수\n\n상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다. 두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오.\n\n### strcmp로 문자열 비교\n\n    #include <iostream>\n    #include <string.h>\n    using namespace std;\n    \n    int main() {\n    \tchar a[4], b[4];\n    \tscanf(\"%s %s\", a, b);\n    \t\n    \tswap(a[2], a[0]);\n    \tswap(b[2], b[0]);\n    \t\n    \tif (strcmp(a, b) < 0) printf(\"%s\", b);\n    \telse printf(\"%s\", a);\n    \t\n    \treturn 0;\n    }\n\n### atoi로 char * → int로 변경 후 비교\n\n    #include <iostream>\n    #include <string>\n    using namespace std;\n    \n    int main() {\n    \tchar a[4], b[4];\n    \tscanf(\"%s %s\", a, b);\n    \t\n    \tswap(a[2], a[0]);\n    \tswap(b[2], b[0]);\n    \t\n    \tint na = atoi(a);\n    \tint nb = atoi(b);\n    \t\n    \tif (na > nb) printf(\"%d\", na);\n    \telse printf(\"%d\", nb);\n    \t\n    \treturn 0;\n    }\n\n- a, b 값을.. 3으로 했을 때 입력을 제대로 못 받는 문제 생김 ㅜ_ㅜ\n    - c의 문자열은 `\\0` 을 기준으로 구분한다. 문자열의 끝에 있는 `\\0` 이 어떤 식으로든 없어지게 된다면 그 뒤에 `\\0` 이 나타날 때까지 진행하게 된다\n    - 123 456 일 때, a, b 크기를 3으로 하면 a에는 \"123\"이 들어간다. 그럼 `\\0` 은 b[0]에 들어갔을 거다. 이 상태로 456을 입력받으면 b[0]에 4가 쓰여진다. 마찬가지로 b의  `\\0` 도 메모리 어딘가에 들어가게된다.\n    - 즉, a 출력시 123456이 나오는 이유는 123을 입력받을 때 `\\0` 을 받지 못해 456까지 입력받게 되서다."}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"94ca86fd0ce6c18a378cb92e9a8e202b4974c91f","text":"# GraphQL 알아보기\n\n- Title : GraphQL 알아보기\n- Date : 2020-03-17\n- Category : 프론트\n\n# Why?\n\nTIL 레파지토리의 문서들을 얻기 위해 Github Content API를 이용했다. 루트 폴더들, 각 폴더의 문서들, 문서의 내용 등을 REST API를 사용하여 얻었는 데 아무래도 엔드 포인트가 많다 보니 코드가 복잡해졌다. 또 내가 원하는 데이터만 받고 싶은 데 응답 구조가 정해져있다보니 응답 데이터를 직접 가공하는 수 밖에 없었다. 휴 불편하네~ 😥 불편하다. 생각하던 중 Github이 GraphQL API를 제공한다는 것을 발견했다. 예전에 잠깐 공부했을 때는 REST API보다 왜 편한지 이해를 못했는 데 역시 사람은 몸소 겪어봐야 아나보다. 직접 사용해보니 너무 너무 편했다. 그래서 오늘의 TIL은 GraphQL에 대해 정리해보려한다. \n\n# ✨ GraphQL 이란?\n\nGraphQL(gql)는 API를 위한 쿼리 언어로 API 서버에서 원하는 데이터를 효율적으로 가져올 수 있다. GraphQL을 사용하는 앱은 느린 모바일 네트워크 연결에서도 빠르게 수행할 수 있다고 한다. \n\nGraphQL API 서버는 gql로 작성된 쿼리를 입력으로 받고 쿼리를 처리한 결과를 클라이언트에게 돌려준다. HTTP API 처럼 gql도 특정 데이터베이스나 플랫폼에 종속적이지않다.\n\n네트워크 방식에도 종속적이지 않다. 일반적으로 gql의 인터페이스간 송수신은 네트워크 레이어 L7의 HTTP POST 메서드와 웹 소켓 프로토콜을 활용한다. 필요에 따라서는 L4의 TCP/UDP나 L2의 이더넷 프레임을 활용할 수 있다.\n\n## REST API와 차이점?\n\n- REST API가 여러 URL에서 데이터를 얻는 것과 달리 GraphQL은 모든 데이터를 하나의 엔드 포인트를 통해 가져올 수 있다.\n- REST API는 각 엔드포인트마다 데이터베이스 SQL 쿼리가 달라지고 gql API는 gql 스키마 타입마다 데이터베이스 SQL 쿼리가 달라진다.\n- REST API는 리소스를 URL로 표현하고 GraphQL은 Query로 표현한다고 할 수 있다.\n\n# GraphQL 구조\n\n## 📌 Query\n\nHTTP Method의 `GET` 과 비슷\n\n### **Fields**\n\n    {\n    \tplayers {\n    \t\tname\n    \t}\n    }\n\n    {\n    \t\"data\": {\n    \t\t\"players\": [\n    \t\t\t{\n    \t\t\t   \"name\": \"Pogba\"\n    \t\t\t },\n    \t\t\t {\n    \t\t\t   \"name\": \"Lukaku\"\n    \t\t\t },\n    \t\t\t {\n    \t\t\t   \"name\": \"Rashford\"\n    \t\t\t },\n    \t\t\t {\n    \t\t\t   \"name\": \"Marshal\"\n    \t\t\t }\n    \t\t]\n    \t}\n    }\n\n- 객체에서 원하는 필드만 리턴 받을 수 있다.\n- 쿼리는 한번의 요청으로 객체나 필드를 순회하여 관련된 데이터들도 가져올 수 있다. 이런 작업을 REST API에서 하려면 API 호출을 여러 번 해야한다.\n\n### **Arguments**\n\n    {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \t\"data\": {\n    \t\t\"players\": {\n    \t\t\t\"name\": \"Pogba\",\n    \t\t\t\"kit\": [\n    \t\t\t\t{\n    \t\t\t\t\t\"shirtSize\": \"large\",\n               \"shoeSize\": \"medium\"\n    \t\t\t\t}\t\t\t\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n\n- arguments를 쿼리의 필드 및 중첩된 객체들에 전달하여 원하는 데이터만 얻을 수 있다\n- REST API에서 ?name=Pogba 또는 /Pogba (/:name 형식일 때) 와 같은 목적으로 사용한다.\n\n### Aliases\n\n    {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    \tplayer(id: \"Lukaku\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \tplayer1: player(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    \tplayer2: player(id: \"Lukaku\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \t\"data\": {\n    \t\t\"player1\": {\n    \t\t\t\"name\": \"Pogba\",\n    \t\t\t\"kit\": [\n    \t\t\t\t{\n    \t\t\t\t\t\"shirtSize\": \"large\",\n               \"shoeSize\": \"medium\"\n    \t\t\t\t}\t\t\t\n    \t\t\t]\n    \t\t}\n    \t\t\"player2\": {\n    \t\t\t\"name\": \"Lukaku\",\n    \t\t\t\"kit\": [\n    \t\t\t\t{\n    \t\t\t\t\t\"shirtSize\": \"extralarge\",\n               \"shoeSize\": \"large\"\n    \t\t\t\t}\t\t\t\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n\n- 필드 이름을 겹쳐서 사용할 수는 없기에 왼쪽처럼 할 수 없다. 오른쪽 처럼 별칭을 써서 사용하면 된다.\n\n### Operation name\n\n    query PlayerDetails {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n- Operation Type: query, mutation과 같은 키워드\n- Operation Name: 이 작업이 무슨 일을 하는 지(메소드 명처럼..?)\n\n### Variables\n\n    query PlayerDetails($id: String) {\n    \tplayer(id: $id) {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n- arguments를 동적으로 받고 싶을 때 사용한다.\n- Operation Name 옆에 변수를 $변수이름: 타입 형태로 정의한다. 만약  `String!` 형태로 정의했다면 id는 **반드시** String이어야 한다.\n- 실제 argument로 사용하려면 필드명: $변수이름 형태로 사용하면 된다.\n- 전달된 변수가 없으면 디폴트로 사용할 값을 정의할 수도 있다. `$id: String = \"Pogba\"` 형태로 쓰면 된다.\n\n### Fragments\n\n    {\n    \tplayer(id: \"Pogba\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    \tplayer(id: \"Lukaku\") {\n    \t\tname\n    \t\tkit {\n    \t    shirtSize,\n          bootSize\n        }\n    \t}\n    }\n\n    {\n    \tplayer1: player(id: \"Pogba\") {\n    \t\t...playerKit\n    \t}\n    \tplayer2: player(id: \"Lukaku\") {\n    \t\t...playerKit\n    \t}\n    }\n    \n    fragment playerKit on player {\n    \tname,\n    \tkit {\n    \t\tshirtSize,\n    \t\tshoeSize\n    \t}\n    }\n\n- 왼쪽을 보면 name과 kit이 반복된다. 이처럼 동일한 구조의 필드를 가져올 때 fragment 를 이용하면 오른쪽처럼 간편하게 쓸 수 있다.\n\n### Inline Fragments\n\n    query HeroForEpisode($ep: Episode!) {\n      hero(episode: $ep) {\n        name\n        ... on Droid {\n          primaryFunction\n        }\n        ... on Human {\n          height\n        }\n      }\n    }\n\n    {\n      \"data\": {\n        \"hero\": {\n          \"name\": \"R2-D2\",\n          \"primaryFunction\": \"Astromech\"\n        }\n      }\n    }\n\n- 위 쿼리에서 hero 필드는 $ep 인수에 따라 Human 또는 Droid 타입인 Character 인터페이스를 리턴한다.\n- 위 쿼리의 name 필드는 Character 인터페이스에 있는 값이다.\n- Fragment의 타입 질의 기능을 이용하면 Human 타입일 때, Droid 타입일 때 가져올 데이터를 정의할 수 있다.\n- 어떤 필드가 Interface나 union 타입으로 리턴된다면 inline fragment로 원하는 데이터만 받을 수 있다.\n\n    interface Character {\n      id: ID!\n      name: String!\n      friends: [Character]\n      appearsIn: [Episode]!\n    }\n    \n    type Human implements Character {\n      id: ID!\n      name: String!\n      friends: [Character]\n      appearsIn: [Episode]!\n      starships: [Starship]\n      totalCredits: Int\n    }\n    \n    type Droid implements Character {\n      id: ID!\n      name: String!\n      friends: [Character]\n      appearsIn: [Episode]!\n      primaryFunction: String\n    }\n\n### Directives\n\n    query PlayerDetails ($playerShirtDirective: Boolean!){\n        player(id: \"Pogba\") {\n            name,\n            kit {\n                shirtSize @skip(if: $playerShirtDirective)\n                bootSize\n            }\n        }\n    }\n\n- 특정 필드를 포함할 지, 스킵할 지를 정할 수 있다.\n- @skip : true면 스킵\n- @include : true면 포함\n\n## 📌 Mutation\n\nHTTP Method의 `POST` `PATCH` `DELETE` 와 비슷\n\n    mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n      createReview(episode: $ep, review: $review) {\n        stars\n        commentary\n      }\n    }\n\n    {\n      \"ep\": \"JEDI\",\n      \"review\": {\n        \"stars\": 5,\n        \"commentary\": \"This is a great movie!\"\n      }\n    }\n\n    {\n      \"data\": {\n        \"createReview\": {\n          \"stars\": 5,\n          \"commentary\": \"This is a great movie!\"\n        }\n      }\n    }\n\n**참고**\n\n[GraphQL 개념잡기](https://tech.kakao.com/2019/08/01/graphql-basic/)\n\n[Understanding Queries in GraphQL | DigitalOcean](https://www.digitalocean.com/community/tutorials/understanding-queries-in-graphql)"}}}},"pageContext":{"id":"aca141df670b8b9c9474fa873d833730c6d80a8f","previousPostId":"cc4c2ba350ff2dcd7d43ee1ce312d69f9c1991b8","nextPostId":"94ca86fd0ce6c18a378cb92e9a8e202b4974c91f"}},"staticQueryHashes":["2685952063","2841359383"]}