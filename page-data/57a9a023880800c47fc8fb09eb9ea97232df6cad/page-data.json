{"componentChunkName":"component---src-templates-blog-post-js","path":"/57a9a023880800c47fc8fb09eb9ea97232df6cad","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"57a9a023880800c47fc8fb09eb9ea97232df6cad","text":"# [Drawable 리소스] LayerDrawable과 ShapeDrawable을 이용해 둥근모서리와 그림자 있는 배경 만들기.\n\n- Title : [Drawable 리소스] LayerDrawable과 ShapeDrawable을 이용해 둥근모서리와 그림자 있는 배경 만들기.\n- Date : 2019-01-16\n- Category: Android\n\nLayerDrawable과 ShapeDrawable을 이용해 둥근모서리+그림자+투명배경이 있는 디자인을 다른 XML 리소스의 background로 적용하는 방법입니다.\n\n[안드로이드 개발문서-Drawable 바로가기](https://developer.android.com/guide/topics/resources/drawable-resource?hl=ko)\n\n## 드로어블(Drawable) 리소스\n\n앱 화면에 그리고 싶은 것을 XML 파일로 미리 정의할 수 있으며, <code class=\"codetainer\">getDrawable(int)</code>와 같은 API를 사용하여 가져오거나\n<code class=\"codetainer\">android:drawable</code> 및 <code class=\"codetainer\">android:icon</code>과 같은 속성을 사용하여 다른 XML 리소스에 적용할 수 있다.  \n<span class=\"clr-grey\">**Example)** android:background=\"@drawable/custom_layer_resource\"</span>\n\n# LayerDrawable\n\n각 `<item>` 요소는 순서대로 그려지므로, 맨 마지막 `<item>`이 맨 위에 보이게 된다.\n\n<span class=\"li-nonicon\">위치 : res/drawable/filename.xml</span>\n<span class=\"li-nonicon\">Java 리소스 참조 : R.drawable.filename</span>\n<span class=\"li-nonicon\">XML 리소스 참조 : @[package:]drawable/filename</span>\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list\n    xmlns:android=\"http://schemas.android.com/apk/res/android\" ><!-- XML 네임스페이스 정의 필수 -->\n    <item\n        android:drawable=\"@[package:]drawable/drawable_resource\"\n        android:id=\"@[+][package:]id/resource_name\"\n        android:top=\"dimension\"\n        android:right=\"dimension\"\n        android:bottom=\"dimension\"\n        android:left=\"dimension\" />\n</layer-list>\n```\n\n<span class=\"li-icon\"><code class=\"codetainer\">android:top=\"dimension\"</code> top에서 dimension 값만큼 padding</span>\n\n# ShapeDrawable\n\n<span class=\"li-nonicon\">위치 : res/drawable/filename.xml</span>\n<span class=\"li-nonicon\">Java 리소스 참조 : R.drawable.filename</span>\n<span class=\"li-nonicon\">XML 리소스 참조 : @[package:]drawable/filename</span>\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<shape\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:shape=[\"rectangle\" | \"oval\" | \"line\" | \"ring\"] >\n    <corners\n        android:radius=\"integer\"\n        android:topLeftRadius=\"integer\"\n        android:topRightRadius=\"integer\"\n        android:bottomLeftRadius=\"integer\"\n        android:bottomRightRadius=\"integer\" />\n    <gradient\n        android:angle=\"integer\"\n        android:centerX=\"float\"\n        android:centerY=\"float\"\n        android:centerColor=\"integer\"\n        android:endColor=\"color\"\n        android:gradientRadius=\"integer\"\n        android:startColor=\"color\"\n        android:type=[\"linear\" | \"radial\" | \"sweep\"]\n        android:useLevel=[\"true\" | \"false\"] />\n    <padding\n        android:left=\"integer\"\n        android:top=\"integer\"\n        android:right=\"integer\"\n        android:bottom=\"integer\" />\n    <size\n        android:width=\"integer\"\n        android:height=\"integer\" />\n    <solid\n        android:color=\"color\" />\n    <stroke\n        android:width=\"integer\"\n        android:color=\"color\"\n        android:dashWidth=\"integer\"\n        android:dashGap=\"integer\" />\n</shape>\n```\n\n<span class=\"li-icon\"><code class=\"codetainer\">corners : </code>둥근모서리</span>\n<span class=\"li-icon\"><code class=\"codetainer\">gradient : </code>그라데이션 색상</span>\n<span class=\"li-icon\"><code class=\"codetainer\">padding : </code>shape가 아닌 view 요소에 적용할 패딩</span>\n<span class=\"li-icon\"><code class=\"codetainer\">size : </code>shape 크기</span>\n<span class=\"li-icon\"><code class=\"codetainer\">solid : </code>채우기 색상</span>\n<span class=\"li-icon\"><code class=\"codetainer\">stroke : </code>선 속성</span>\n\n# 실전예제\n\n1. 둥근모서리+그림자+투명배경 드로어블 생성하기\n\nres/drawable/round_border.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\" >\n    <item>\n        <shape android:shape=\"rectangle\" >\n            <solid android:color=\"@android:color/darker_gray\" />\n        </shape>\n    </item>\n    <item\n        android:bottom=\"-2dp\"\n        android:left=\"2dp\"\n        android:right=\"2dp\"\n        android:top=\"2dp\">\n        <shape android:shape=\"rectangle\" >\n            <stroke\n                android:width=\"0.75dp\"\n                android:color=\"#f5f5f5\" />\n            <corners\n                android:topLeftRadius=\"10dp\"\n                android:topRightRadius=\"10dp\"/>\n            <solid android:color=\"#3cffffff\" />\n        </shape>\n    </item>\n</layer-list>\n```\n\n2. round_border를 LinearLayout의 배경으로 적용하기\n\n```xml\n<LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"10dp\"\n        android:background=\"@drawable/round_border\">\n</LinearLayout>\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"5e41146edb49643835d7c14219615e273c6680a1","text":"# 안드로이드에서 이미지 애니메이션 구현 방법\n\n- Title : 안드로이드에서 이미지 애니메이션 구현 방법\n- Date : 2019-01-21\n- Category: Android\n\n이미지 애니메이션 구현 방법에는 다음과 같이 1)Animation Drawable과 2)Animated vector Drawable 두가지 옵션이 있다.\n\n[안드로이드 개발문서-Animate drwable graphics 바로가기](https://developer.android.com/guide/topics/graphics/drawable-animation?hl=ko)\n[Icon Animation 참고 문서](https://www.androiddesignpatterns.com/2016/11/introduction-to-icon-animation-techniques.html)\n\n**Animation Drawable** : 몇 개의 정적 drawable 파일들을 순차적으로 보여주는 방식으로 애니메이션을 구현하고 싶을 때(프레임 애니메이션)  \n**AnimatedVectorDrawable** : 하나의 아이콘이 다른 이미지로 서서히 변화되는(morph) 애니메이션을 구현하고 싶을 때\n\n# AnimationDrawable 사용하기\n\n프레임 애니메이션 구현 [예제](https://github.com/devgaram/AndroidBudgeter/blob/master/app/src/main/res/drawable/ani_emotion.xml)\n\nres/drawable/ani_emotion.xml\n\n```xml\n<animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:oneshot=\"false\">\n    <item android:drawable=\"@drawable/emotion_mouth_1\" android:duration=\"5000\" />\n    <item android:drawable=\"@drawable/emotion_mouth_2\" android:duration=\"5000\" />\n    <item android:drawable=\"@drawable/emotion_mouth_3\" android:duration=\"5000\" />\n    <item android:drawable=\"@drawable/emotion_mouth_4\" android:duration=\"5000\" />\n    <item android:drawable=\"@drawable/emotion_mouth_5\" android:duration=\"5000\" />\n</animation-list>\n```\n\n<span class=\"li-icon\"><code class=\"codetainer\">android:oneshot</code> : true 한번만, false 반복</span>\n\nres/drawable/emotion_mouth_1.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item\n        android:top=\"@dimen/mb_l\">\n        <shape\n            xmlns:android=\"http://schemas.android.com/apk/res/android\"\n            android:shape=\"rectangle\">\n            <size\n                android:width=\"120dp\"\n                android:height=\"60dp\"></size>\n            <solid android:color=\"@color/colorDefaultFont\"/>\n            <corners\n                android:topRightRadius=\"60dp\"\n                android:topLeftRadius=\"60dp\"></corners>\n        </shape>\n    </item>\n</layer-list>\n```\n\n<span class=\"li-icon\">ShapeDrawable로 입모양 그린 XML 파일</span>\n\nres/drawable/activity_main.xml\n\n```xml\n<ImageView\n            android:id=\"@+id/emotion_mouth\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_gravity=\"center\"\n            android:src=\"@drawable/ani_emotion\" />\n```\n\nMainActivity.java\n\n```java\nAnimationDrawable emotionAnimation;\n\npublic void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.main);\n\n  ImageView emotionImage  = (ImageView) findViewById(R.id.emotion_mouth);\n  emotionImage.setImageResource(R.drawable.ani_emotion);\n  emotionAnimation = (AnimationDrawable) emotionImage.getDrawable();\n\n  emotionImage.setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View view) {\n        emotionAnimation.start();\n      }\n  });\n}\n```\n\n<span class=\"clr-note\">**Note:** </span><span class=\"clr-grey\"><code class=\"codetainer\">onCreate()</code> 메서드에선 <code class=\"codetainer\">AnimationDrawable</code>가 완전히 로드되지 않으므로 <code class=\"codetainer\">start()</code> 메서드를 사용할 수 없고,\n만약 애니메이션 즉시 실행을 원한다면 액티비티의 <code class=\"codetainer\">onStart()</code> 메서드에서 <code class=\"codetainer\">start()</code> 메서드를 호출해야한다.</span>\n\n# AnimatedVectorDrawable 사용하기\n\n[안드로이드 개발문서-AnimatedVectorDrawable 바로가기](https://developer.android.com/reference/android/graphics/drawable/AnimatedVectorDrawable?hl=ko)\n\nvectorDrawable은 흐려지거나 픽셀화되는 현상 없이 확장가능한 드로어블 타입이다.  \nvectorDrawable 애니메이션을 구현하기 위해서는 3개의 xml 파일이 필요하다.\n\n## 1) vectorDrawable\n\n| Element Name  | Animatable attribute name                                                                                                      |\n| ------------- | ------------------------------------------------------------------------------------------------------------------------------ |\n| `<vector>`    | alpha                                                                                                                          |\n| `<group>`     | rotation, pivotX, pivotY, scaleX, scaleY, translateX, translateY                                                               |\n| `<path>`      | pathData, fillColor, strokeColor, strokeColor, strokeWidth, strokeAlpha, fillAlpha, trimPathStart, trimPathEnd, trimPathOffset |\n| `<clip-path>` | pathData                                                                                                                       |\n\n```xml\n <!--res/drawable/vectordrawable.xml-->\n <vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n     android:height=\"64dp\"\n     android:width=\"64dp\"\n     android:viewportHeight=\"600\"\n     android:viewportWidth=\"600\" >\n     <group\n         android:name=\"rotationGroup\"\n         android:pivotX=\"300.0\"\n         android:pivotY=\"300.0\"\n         android:rotation=\"45.0\" >\n         <path\n             android:name=\"v\"\n             android:fillColor=\"#000000\"\n             android:pathData=\"M300,70 l 0,-70 70,70 0,0 -70,70z\" />\n     </group>\n </vector>\n```\n\n## 2) AnimatedVectorDrawable\n\n<span class=\"li-nonicon\">한 개의 `android:drawable` 속성과 하나 이상의 `<target>`을 가진다.</span>\n<span class=\"li-nonicon\">`<target>` 은 `android:name` 속성으로 `ObjectAnimator` 또는 `AnimatorSet`의 타겟이 되는 `vectorDrawable`을 명시한다.\n<span class=\"clr-grey\">**Note:** 타겟은 vectorDrawable의 group element 또는 path element가 될 수 있다.</span></span>\n\n```xml\n<!--res/drawable/animatedVector.xml-->\n<animated-vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n     android:drawable=\"@drawable/vectordrawable\" >\n     <target\n         android:name=\"rotationGroup\"\n         android:animation=\"@animator/rotation\" />\n     <target\n         android:name=\"v\"\n         android:animation=\"@animator/path_morph\" />\n </animated-vector>\n```\n\n<span class=\"li-icon\">vectorDrawable에서 rotationGroup 이름 속성을 가진 `<group>` 엘리먼트에 rotation 애니메이션을 적용</span>\n<span class=\"li-icon\">vectorDrawable에서 v 이름 속성을 가진 `<path>` 엘리먼트에 path_morph 애니메이션을 적용</span>\n\n## 3) ObjectAnimator or AnimatorSet 애니메이션 정의\n\n애니메이션은 `ObjectAnimator` 와 `AnimatorSet`으로 정의할 수 있다.\n\n```xml\n<!-- res/animator/rotation.xml -->\n<objectAnimator\n    android:duration=\"6000\"\n    android:propertyName=\"rotation\"\n    android:valueFrom=\"0\"\n    android:valueTo=\"360\" />\n```\n\n6초동안 360도 회전하는 애니메이션\n\n```xml\n<!-- res/animator/path_morph.xml -->\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <objectAnimator\n        android:duration=\"3000\"\n        android:propertyName=\"pathData\"\n        android:valueFrom=\"M300,70 l 0,-70 70,70 0,0   -70,70z\"\n        android:valueTo=\"M300,70 l 0,-70 70,0  0,140 -70,0 z\"\n        android:valueType=\"pathType\" />\n</set>\n```\n\n3초동안 모양 바뀌는 애니메이션(morph)  \n<span class=\"clr-note\">**Note:** `android:valueFrom` 과 `android:valueTo`의 명령 순서와 파라미터 값은 동일해야한다.</span>  \n<span class=\"clr-grey\">**Note:** path 값은 string 리소스에 저장하는 것을 추천한다.</span>\n\n## 4) 3개의 xml을 AAPT 툴의 지원으로 하나의 xml에 정의할 수 있다.\n\n```xml\n <animated-vector xmlns:android=\"http://schemas.android.com/apk/res/android\"\n                  xmlns:aapt=\"http://schemas.android.com/aapt\" >\n     <aapt:attr name=\"android:drawable\">\n         <vector\n             android:height=\"64dp\"\n             android:width=\"64dp\"\n             android:viewportHeight=\"600\"\n             android:viewportWidth=\"600\" >\n             <group\n                 android:name=\"rotationGroup\"\n                 android:pivotX=\"300.0\"\n                 android:pivotY=\"300.0\"\n                 android:rotation=\"45.0\" >\n                 <path\n                     android:name=\"v\"\n                     android:fillColor=\"#000000\"\n                     android:pathData=\"M300,70 l 0,-70 70,70 0,0 -70,70z\" />\n             </group>\n         </vector>\n     </aapt:attr>\n\n     <target android:name=\"rotationGroup\"> *\n         <aapt:attr name=\"android:animation\">\n             <objectAnimator\n             android:duration=\"6000\"\n             android:propertyName=\"rotation\"\n             android:valueFrom=\"0\"\n             android:valueTo=\"360\" />\n         </aapt:attr>\n     </target>\n\n     <target android:name=\"v\" >\n         <aapt:attr name=\"android:animation\">\n             <set>\n                 <objectAnimator\n                     android:duration=\"3000\"\n                     android:propertyName=\"pathData\"\n                     android:valueFrom=\"M300,70 l 0,-70 70,70 0,0 -70,70z\"\n                     android:valueTo=\"M300,70 l 0,-70 70,0  0,140 -70,0 z\"\n                     android:valueType=\"pathType\"/>\n             </set>\n         </aapt:attr>\n      </target>\n </animated-vector>\n```\n\n## 5) 정의한 애니메이션 적용하기\n\nres/drawable/activity_main.xml\n\n```xml\n<ImageView\n            android:id=\"@+id/emotion_mouth\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_gravity=\"center\"\n            android:src=\"@drawable/animatedVector\" />\n```\n\nMainActivity.java\n\n```java\n ImageView emotionImage;\n\npublic void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.main);\n\n  emotionImage  = (ImageView) findViewById(R.id.emotion_mouth);\n\n  emotionImage.setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View view) {\n        Drawable drawable = emotionImage.getDrawable();\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n                if (drawable instanceof AnimatedVectorDrawable) {\n                    AnimatedVectorDrawable animatedVectorDrawable = (AnimatedVectorDrawable) drawable;\n                    animatedVectorDrawable.start();\n                }\n            } else {\n                if (drawable instanceof AnimatedVectorDrawableCompat) {\n                    AnimatedVectorDrawableCompat animatedVectorDrawableCompat = (AnimatedVectorDrawableCompat) drawable;\n                    animatedVectorDrawableCompat.start();\n                }\n            }\n      }\n  });\n\n}\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"92b42dd986f3a755361f0a2640d33d0bb9c70fd3","text":"# [안드로이드] 안드로이드 LiveData 대해 알아보자\n\n- Title : [안드로이드] 안드로이드 LiveData 대해 알아보자\n- Date : 2019-01-09\n- Category: Android\n\nLiveData 클래스를 통해 데이터 변경을 감지해보자.\n\n[안드로이드 개발문서-LiveData](https://developer.android.com/topic/libraries/architecture/livedata#java).\n\n# LiveData는 LifecycleOwner의 라이프사이클을 알고있다.\n\nLiveData 객체는 <code class=\"codetainer\">observe()</code> 메서드를 통해 <code class=\"codetainer\">LifecycleOwner</code>와 <code class=\"codetainer\">Observer</code>객체를 페어로 등록한다.  \nObserver 객체는 페어인 LifecycleOwner가 활성상태(<code class=\"codetainer\">STARTED</code> 또는 <code class=\"codetainer\">RESUMED</code>)일 때, 데이터 변화을 관측할 수 있다.\n반대로, LiveData 객체는 LifecycleOwner가 비활성 상태면 LiveData의 변화를 Observer에게 전달하지 않으며, LifecycleOwner가 <code class=\"codetainer\">DESTROYED</code> 상태라면 자동으로 제거된다.\n이러한 LiveData의 라이프사이클의 인지는 메모리 누수에 대한 걱정을 덜어주며, UI 컴포넌트(액티비티, 프래그먼트)를 사용할 때 유용하다.  \n<span class=\"clr-grey\">**Note:** LifecycleOwner의 비활성 상태 예시) 액티비티가 백 스택에 올라가있을 때 </span>\n\n# LiveData 사용시 이점\n\n<span class=\"li-icon\">일반적인 Observable과 달리, LifecycleOwner가 활성 상태일 때, LiveData의 변화를 Observer 객체에 전달함</span>\n<span class=\"li-icon\">충돌방지 : 액티비티가 백스택(비활성)에 있을 때, LiveData의 변화 이벤트를 Observer에게 전달하지 않음</span>\n<span class=\"li-icon\">메모리누수방지 : <code class=\"codetainer\">DESTROYED</code> 시, LiveData 제거</span>\n<span class=\"li-icon\">생명주기 수동으로 관리할 필요 없음</span>\n<span class=\"li-icon\">항상 최신 데이터 유지 가능 : 액티비티가 다시 활성상태로 돌아온 즉시 최신 데이터를 받는다.</span>\n<span class=\"li-icon\">환경변화(예,화면회전)로 UI 컴포넌트 재생성 시, 즉시 최신 데이터를 받는다.</span>\n<span class=\"li-icon\">LiveData를 상속받아 앱에서 자원 공유 가능</span>\n\n# LiveData 사용하기\n\n[예제로 바로가기](/android/android-mvvm/#LiveData).\n\n## 1. LiveData 객체 생성하기\n\nLiveData는 보통 <code class=\"codetainer\">Collections</code> 인터페이스를 구현한 클래스(List, Map, Set)를 사용하며, <code class=\"codetainer\">ViewMoodel</code> 객체 안에 저장된다.\n\n```java\npublic class NameViewModel extends ViewModel {\n  // String 타입의 LiveData 생성\n  private MutableLiveData<String> mCurrentName;\n\n    public MutableLiveData<String> getCurrentName() {\n        if (mCurrentName == null) {\n            mCurrentName = new MutableLiveData<String>();\n        }\n        return mCurrentName;\n    }\n\n// ..생략\n}\n```\n\n## 2. LiveData 객체 관찰하기\n\n<code class=\"codetainer\">onCreate()</code> 메서드에서 LiveData 관찰을 시작하는 것이 좋다.\n<span class=\"li-icon\"><code class=\"codetainer\">onResume()</code> 메서드에서 사용 시 중복 호출이 발생된다.</span>\n<span class=\"li-icon\"><code class=\"codetainer\">STARTED</code> 상태가 되자마자 LiveData 객체의 최신 데이터를 받을 수 있다.</span>\n\n```java\npublic class NameActivity extends AppCompatActivity {\n\n    private NameViewModel mModel;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        // ..생략\n\n        // ViewModel 얻기\n        mModel = ViewModelProviders.of(this).get(NameViewModel.class);\n\n\n        // 옵저버 생성\n        final Observer<String> nameObserver = new Observer<String>() {\n            @Override\n            public void onChanged(@Nullable final String newName) {\n                // Update the UI, in this case, a TextView.\n                mNameTextView.setText(newName);\n            }\n        };\n\n        // LiveData 관찰 시작\n        mModel.getCurrentName().observe(this, nameObserver);\n    }\n}\n```\n\n## 3. LiveData 객체 업데이트하기\n\nLiveData는 데이터를 업데이트 하는 publid 메서드를 가지고 있지 않으므로, LiveData를 상속받은 <code class=\"codetainer\">MutableLiveData</code>를 사용해야한다.\n<code class=\"codetainer\">MutableLiveData</code>는 <code class=\"codetainer\">public setValue(T)</code>와 <code class=\"codetainer\">public postValue(T)</code> 메서드를 가지고 있어서 이를 통해 데이터를 변경할 수 있다.\n\n```java\nmButton.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        String anotherName = \"John Doe\";\n        mModel.getCurrentName().setValue(anotherName);\n    }\n});\n```\n\n<code class=\"codetainer\">setValue(T)</code>와 <code class=\"codetainer\">postValue(T)</code>는 호출 시 Observer의 <code class=\"codetainer\">onChanged()</code> 메서드가 호출되어 UI가 업데이트 된다.\n"}}}},"pageContext":{"id":"57a9a023880800c47fc8fb09eb9ea97232df6cad","previousPostId":"5e41146edb49643835d7c14219615e273c6680a1","nextPostId":"92b42dd986f3a755361f0a2640d33d0bb9c70fd3"}},"staticQueryHashes":["2685952063","2841359383"]}