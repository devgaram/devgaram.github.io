{"componentChunkName":"component---src-templates-blog-post-js","path":"/5219daaeb39e005c6bc68059ba819110107f2daf","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"5219daaeb39e005c6bc68059ba819110107f2daf","text":"# 최단 경로 알고리즘 - Dijkstra\n\n- Title : 최단 경로 알고리즘 - Dijkstra\n- Date : 2020-03-01\n- Category: Algorithm\n\n## Why?\n\n[1753번: 최단경로](https://www.acmicpc.net/problem/1753)\n\n> 최단 경로 문제는 네트워크에서 정점 u와 정점 v를 연결하는 경로 중에서 간선들의 가중치 합이 최소가 되는 경로를 찾는 문제다.\n\n## Dijkstra의 최단 경로 알고리즘\n\n네트워크에서 **하나의** 시작 정점으로부터 **모든** 다른 정점까지의 최단 경로를 찾는 알고리즘이다. 최단 경로는 경로의 길이순으로 구해진다.\n\n- 집합 S는 정점 v로부터의 최단 경로가 이미 발견된 정점들의 집합이다.\n- distance[]는 시작 정점에서 집합 S에 있는 정점을 거쳐서 다른 정점으로 가는 최단 거리를 기록한 배열이다.\n- distance 배열의 초깃값은 시작 정점이 v라면 distance[v] = 0 이고 다른 정점에 대한 distance 값은 v와 해당 정점 간의 가중치가 된다. 정점 v와 w와 직접 간선이 없다면 무한대 값을 저장한다.\n- 알고리즘 매 단계에서 집합 S에 없는 정점 중 가장 distance 값이 작은 정점을 S에 추가한다. 왜냐하면 현재 정점 u에서 x, y, z 중 y의 가중치가 최소라면 u → y가 u → x → y 또는 u → y → x 등 어떤 정점을 거쳐서 y로 가든 u → y 가 최단 경로이기 때문이다.\n- 새로운 정점 x가 S에 추가되면 S에 있지 않은 다른 정점들의 distance 값을 수정한다. 새로 추가된 정점 x를 거쳐 다른 정점까지 가는 거리와 기존의 거리를 비교하여 더 작은 거리로 distance 값을 수정한다. **distance[w] = min(distance[w], distance[x] + weight[x][w])** 식과 같다.\n\n![Dijkstra/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-01-img/Untitled.png)\n\n네트워크에 n개의 정점이 있다면, 다익스트라 최단 경로 알고리즘은 주 반복문을 n번 반복하고 내부 반복문을 2n번 반복하므로 **O(n²)** 의 복잡도를 가진다. distance를 배열이 아닌 **우선순위 큐**를 사용하면 더 빠르게 수행할 수 있다.\n\n### 백준 문제 풀이\n\n**1753번 최단경로**\n\n[1753번: 최단경로](https://www.acmicpc.net/problem/1753)\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #include <queue>\n    #define MAX_W 98765432\n    using namespace std;\n\n    vector<pair<int, int> > graph[20001];\n\n    vector<int> dijkstra (int s, int cv) {\n    \tvector<int> dis(cv, MAX_W);\n    \tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n    \tpq.push(make_pair(0, s));\n    \tdis[s] = 0;\n\n    \twhile (!pq.empty()) {\n    \t\tint cost = pq.top().first;\n    \t\tint v = pq.top().second;\n    \t\tpq.pop();\n    \t\tif (dis[v] < cost) continue;\n\n    \t\tfor (int i=0; i<graph[v].size(); i++) {\n    \t\t\tif (dis[graph[v][i].second] >= cost + graph[v][i].first) {\n    \t\t\t\tpq.push(make_pair(cost + graph[v][i].first, graph[v][i].second));\n    \t\t\t\tdis[graph[v][i].second] = cost + graph[v][i].first;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn dis;\n    }\n    int main() {\n    \tint v, e, s;\n    \tint a, b, c;\n\n    \tscanf(\"%d %d\", &v, &e);\n    \tscanf(\"%d\", &s);\n\n    \twhile (e--) {\n    \t\tscanf(\"%d %d %d\", &a, &b, &c);\n    \t\tgraph[a].push_back(make_pair(c, b));\n    \t}\n\n    \tvector<int> dis = dijkstra(s, v + 1);\n\n    \tfor (int i=1; i<v+1; i++) {\n    \t\tif (dis[i] == MAX_W)\n    \t\t\tprintf(\"INF\\n\");\n    \t\telse\n    \t\t\tprintf(\"%d\\n\", dis[i]);\n    \t}\n\n    \treturn 0;\n    }\n```\n\n**참고**\n\n[C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539)\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"90b6ccb77c8749885afcac589cc7c853f9e17a48","text":"# Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 2탄\n\n- Title : Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 2탄\n- Date : 2020-03-03\n- Category: Vue\n\n## Why?\n\n에 이어 오늘은 Typescript와 Vue를 설정할거다.\n\n## 5. Vue 설치 및 설정\n\n    npm install --save-dev vue vue-loader vue-template-compiler\n\n> vue 가 릴리즈 될 때 vue-template-compiler도 릴리즈된다. vue-template-compiler 버전이 vue 패키지와 동기되어야 vue-loader가 vue를 웹팩이 이해할 수 있는 코드로 생산할 수 있다. 즉 프로젝트에서 vue를 업그레이드 했으면 반드시 vue-template-compiler 버전도 맞춰줘야한다.\n\n- vue-loader : vue-loader는 rule 설정 외에 추가적으로 vue loader 플러그인을 설정해야한다. 예를 들어 **new VueLoaderPlugin()** 을 해야 .vue 파일의 `<script>` 블록이 웹팩의 /\\.js\\$/ 의 바벨 로더에도 적용될 수 있다.\n\nwebpack.config.js에 아래를 추가해주자.\n\n```js\nconst VueLoaderPlugin = require(\"vue-loader/lib/plugin\");\n\nmodule.exports = {\n  mode: \"development\",\n  plugins: [new VueLoaderPlugin()],\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: \"babel-loader\"\n      },\n      {\n        test: /\\.vue$/,\n        loader: \"vue-loader\"\n      }\n    ]\n  }\n};\n```\n\n.vue 파일의 `<style>` 블록과 .css 파일을 처리하기 위해 vue-style-loader와 css-loader 를 설치하자\n\n    npm install --save-dev vue-style-loader css-loader\n\nwebpack.config.js 파일에도 추가하자.\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\"vue-style-loader\", \"css-loader\"]\n      }\n    ]\n  }\n};\n```\n\nVue 루트 인스턴스를 `<div id=\"app\"></div>`에 마운트 시키려면 dist/index.html 에 위 DOM이 있어야 한다. 이 작업을 위해 public/index.html 파일을 만들고 아래와 같이 작성한다.\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Webpack App</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n  </body>\n</html>\n```\n\nwebpack.config.js의 HtmlWebpackPlugin에 template 옵션을 추가하여 위 html을 기반으로 index.html이 만들어지게 설정한다. npm run build를 해보면 dist/index.html 파일에 `<div id=\"app\"></div>`이 보일 것이다.\n\n```js\nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: \"public/index.html\"\n    })\n  ]\n};\n```\n\n테스트를 위해 간단히 vue-router가 적용된 vue앱을 만들어보자. 우선 vue-router을 설치한다.\n\n    npm install --save-dev vue-router\n\nsrc에 router/index.js 파일을 만들고 아래와 같이 입력한다.\n\n```js\n    // router/index.js\n    import Vue from \"vue\"\n    import VueRouter from \"vue-router\"\n    import Hello from \"../components/Hello.vue\"\n\n    Vue.use(VueRouter)\n\n    export default new VueRouter({\n      mode: \"history\",\n      base: process.env.BASE_URL,\n      routes: [\n        {\n          path: \"/\",\n          name: \"Hello\",\n          component: Hello\n        }\n      ]\n    })\n\n    // index.js\n    import Vue from \"vue\";\n    import App from \"./App.vue\";\n    import router from \"./router\";\n\n    new Vue({\n      render: h => h(App),\n      router\n    }).$mount(\"#app\");\n\n    // App.vue\n    <template>\n      <div id=\"app\">\n        <router-view></router-view>\n      </div>\n    </template>\n\n    // Hello.vue\n    <template>\n      <p>{{ greeting }} world!</p>\n    </template>\n    <script>\n    module.exports = {\n      data: function () {\n        return {\n          greeting: 'Hello'\n        }\n      }\n    }\n    </script>\n    <style scoped>\n    p {\n      font-size: 2em;\n      text-align: center;\n    }\n    </style>\n```\n\nnpm run start:dev 를 했을 때 아래 화면이 보이면 제대로 설정된 것이다.\n\n![Vue%20CLI%20Vue%20Typescript%20Babel%20Webpack%202/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Vue/images/2020-03-03-img/Untitled.png)\n\n**추가 설정**\n\nrouter/index.js 에서 import Hello from \"../components/Hello.vue\" 를 매번 ../ 식으로 쓰는 게 귀찮을 때! webpack resolve 설정을 통해 src를 기준으로 모듈을 찾을 수 있다. webpack.config.js 에 아래와 같이 추가하면 **import Hello from \"@/components/Hello.vue\"** 를 사용할 수 있다. 또 .vue 확장자를 빼고 입력하고 싶다면 extensions를 추가하면 된다. 웹팩이 알아서 파일 확장자를 처리해준다.\n\n```js\nmodule.exports = {\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"src\")\n    },\n    extensions: [\".js\", \".vue\"]\n  }\n};\n```\n\n- **resolve** : 모듈을 어떻게 처리할지 정의 만약 ES2015에서 import 'lodash' 를 사용한다면 웹팩에서 lodash를 어떻게 볼 것인지 lodash.js로 볼지 lodash.ts 로 볼 지 등을 정의한다.\n\n> 물론 이 외에도 설정할 게 많겠지만...... 일단은 여기까지 하고 Vue에서 Typescript 사용하는 방법을 이어가려고 한다. 나중에 이 설정을 기반으로 실제로 프로젝트를 진행하게 된다면 문제가 쏟아질 듯 싶다....\n\n## 6. Vue에서 Typescript 설치 및 설정\n\ntypescript와 ts-loader 패키지를 설치한다.\n\n    npm install --save-dev typescript ts-loader\n\n- typescript : 타입스크립트\n- ts-loader : 웹팩 로더 패키지\n\nwebpack.config.js 에 아래 내용을 추가한다. 이제 .vue 파일 안의 ts도 .ts 파일도 ts-loader에 의해 처리된다.\n\n```js\n    module.exports = {\n    \tentry: './src/index.ts',\n      module: {\n          {\n            test: /\\.ts$/,\n    \t\t\t\texclude: /node_modules/,\n            loader: 'ts-loader',\n            options: { appendTsSuffixTo: [/\\.vue$/] }\n          }\n        ]\n      },\n      resolve: {\n        extensions: ['.ts', 'tsx', '.js', '.vue']\n      }\n    };\n```\n\ntypescript 설정을 위해 프로젝트 루트 폴더에 tsconfig.json 파일을 생성하고 아래 내용을 입력한다.\n\n    {\n      \"compilerOptions\": {\n        \"outDir\": \"./dist/\",\n        \"strict\": true,\n        \"module\": \"es2015\",\n        \"target\": \"es5\",\n    \t\t\"moduleResolution\": \"node\",\n        \"sourceMap\": true,\n        \"allowSyntheticDefaultImports\": true\n      },\n      \"include\": [\n        \"src/**/*\"\n      ],\n      \"exclude\": [\n        \"node_modules\",\n        \"**/*.spec.ts\"\n      ]\n    }\n\n- allowSyntheticDefaultImports : export default 를 export 한 값들을 가지는 객체로 설정\n\n테스트를 위해 프로젝트 코드 수정하자. 우선 src/index.js, src/router/index.js → src/index.ts, src/router/index.ts 로 바꾼다. Hello.vue의 내용을 아래처럼 바꾼다. Vue 컴포넌트 안에서 Typescript를 사용하려면 Vue.component 또는 Vue.extend로 컴포넌트를 정의해야한다. 타입스크립트가 Vue 컴포넌트 타입 유추를 할 수 있게 하기 위해서다.\n\n```js\n    <template>\n      <p>{{ greeting }} world!</p>\n    </template>\n    <script lang=\"ts\">\n    import Vue from 'vue'\n    export default Vue.extend({\n      data: function () {\n        return {\n          greeting: 'Hello'\n        }\n      }\n    })\n    </script>\n    <style scoped>\n    p {\n      font-size: 2em;\n      text-align: center;\n    }\n    </style>\n```\n\n실행하려고 하면 .vue 파일이 import 되지 않는 오류를 발견할 것이다. ts 파일에 .vue 파일을 임포트하려면 추가적인 설정이 필요하다. src/shims-vue.d.ts 파일을 생성하여 이렇게 적자.\n\n```js\n    declare module \"*.vue\" {\n      import Vue from \"vue\";\n      export default Vue;\n    }\n```\n\n저장 후 실행해보면 잘된다.\n\n다음 TIL에서는 vue-class-component 데코레이터를 사용하여 컴포넌트를 선언할 때 클래스 기반 API를 이용하는 방식을 적용해봐야지!\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"5d8f5742317fc2443a1810a411eb106b455e189d","text":"# Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 1탄\n\n- Title : Vue CLI 없이 Vue, Typescript, Babel, Webpack 설정하기 1탄\n- Date : 2020-02-29\n- Category: Vue\n\n## Why?\n\nVue CLI로 프로젝트를 생성해왔는데 문뜩 웹팩과 바벨에 대한 이해가 부족한듯 싶었다. 그래서😎 오늘은 Vue, Typescript, Babel, Webpack을 사용해서 Vue CLI 없이 프로젝트를 설정해보면서 공부한 내용을 정리해보기로 했다. 1탄은 웹팩과 바벨에 대한 설정과 개념을 잡아보고 2탄에서 Vue와 Typescript 설정을 진행할 거다.\n\n## 1. 프로젝트 생성\n\n```\n    $ mkdir vue-typescript\n    $ cd vue-typescript\n    $ mkdir src\n    $ cd src\n    $ mkdir components\n    $ cd ..\n```\n\n## 2. package.json 파일 생성\n\n> **npm(node package manager)** 은 자바스크립트 패키지 매니저다. Node.js에서 사용할 수 있는 모듈들을 패키지화하여 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI(Common line interface)를 제공한다. 비슷한 패키지 매니저인 페이스북이 만든 **yarn**은 npm보다 더 빠르고 안전하다. 둘 다 package.json 파일에 선언된 semver rule을 만족하는 최신 버전을 설치한다.\n\n```\n    $ npm init\n```\n\n**package.json란?**\n\n- 프로젝트가 의존하고 있는 패키지들의 리스트를 보여준다.\n- semantic versioning rule에 따라 프로젝트에 의존한 패키지들의 버전을 설정할 수 있다.\n- 빌드를 재현할 수 있어 좀 더 쉽게 다른 개발자와 공유할 수 있다.\n\n> **—save-dev** 란? —production 빌드 시 포함될 필요가 없는 패키지는 —save-dev 옵션을 사용하여 package.json의 devDependencies에 패키지 정보를 저장한다.\n\n## 3. Webpack 설치 및 초기 설정\n\n> 웹팩은 자바스크립트 애플리케이션을 위한 **정적 모듈 번들러**다. 자바스크립트 코드를 하나의 파일로 관리하는 것과 여러개의 파일로 관리하는 것은 각각 단점이 있다. 우선 각 파일을 브라우저에 로딩하면 그만큼 네트워크 비용이 커진다. 또한 각 파일이 서로의 스코프를 침범하여 변수 충돌의 위험이 생길 수도 있다. 물론 해결 방법이 있다. 자바스크립트는 함수 스코프를 사용하니 즉시호출함수를 사용해 모듈을 만들면 된다. 그러나 모듈을 모두 즉시호출함수로 변경하여 하나의 파일로 묶는 것을 일일이 작업하면 귀찮지않을까? 웹팩이 등장한 배경이 바로 여기에 있다.\n\n    npm install --save-dev webpack webpack-cli webpack-dev-server html-webpack-plugin\n\n- webpack : 웹팩\n- webpack-cli : 커맨드 라인에서 웹팩을 구동시키기위한 패키지\n- webpack-dev-server : 실시간 리로드를 제공하는 개발 서버로 localhost에서 테스트하고 싶을 때 사용\n- html-webpack-plugin : 웹팩 번들을 서비스하기 위한 HTML 파일을 만들어주는 패키지로 컴파일할 때마다 이름이 변하는 번들파일을 HTML 파일에 넣어줄 때 유용하다.\n\n설치가 완료되면 src 폴더에 index.js 파일을 만들고 package.json 파일의 scripts에 **\"build\": \"webpack\"** 와 **\"start:dev\": \"webpack-dev-server\"** 를 추가한다.\n\n```\n    {\n      \"name\": \"vue-typescript\",\n      \"version\": \"1.0.0\",\n      \"description\": \"\",\n      \"main\": \"index.js\",\n      \"scripts\": {\n    \t\t\"start:dev\": \"webpack-dev-server\",\n    \t\t\"build\": \"webpack\",\n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n      },\n      \"author\": \"\",\n      \"license\": \"ISC\",\n      \"devDependencies\": {\n        \"html-webpack-plugin\": \"^3.2.0\",\n        \"webpack\": \"^4.42.0\",\n        \"webpack-cli\": \"^3.3.11\",\n        \"webpack-dev-server\": \"^3.10.3\"\n      }\n    }\n```\n\n웹팩4는 webpack.config.js 파일이 없어도 파일을 번들할 수 있다. 커맨드 라인에서 **npm run build** 를 치면 dist 폴더에 번들된 파일인 main.js를 볼 수 있다. 또한 **npm run start:dev** 로 치면 8080포트로 개발서버가 동작한다. 하지만 index.html 파일이 없어서 localhost:8080에서 제대로 된 화면을 볼 수 없다. index.html 파일을 직접 dist 폴더에 만들어서 main.js 파일을 **<script src=\"main.js\"></script>** 로 로딩시켜서 동작시킬 수는 있다. 하지만 번들 파일의 이름이 매번 바뀐다면? 또 번들 파일이 많다면? 매우 귀찮을 거다. 그래서 **html-webpack-plugin** 을 이용하여 자동으로 index.html 파일을 생성시키고 번들 파일들을 주입시킬 거다. 설정을 위해 프로젝트 루트에 프로젝트 루트에 webpack.config.js 파일을 생성한 후 아래와 같이 작성한다.\n\n```js\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  entry: \"./src/index.js\",\n  plugins: [new HtmlWebpackPlugin()],\n  output: {\n    filename: \"main.js\",\n    path: path.resolve(__dirname, \"dist\")\n  }\n};\n```\n\n- **entry** : 자바스크립트가 로딩하는 모듈이 많아질수록 모듈간의 의존성은 증가한다. 웹팩에서 의존성 그래프의 시작점을 엔트리(entry)라고 한다.\n- **output** : entry에 설정한 main.ts을 시작으로 의존되어있는 모든 모듈을 하나로 묶은(번들된) 결과의 위치를 output에 정의한다. webpack을 실행하면 /dist 폴더에 main.bundle.js란 이름으로 파일이 생성될 것이다.\n\n**npm run build** 를 실행시키면 dist 폴더에 index.html 파일이 생성되고 `<script type=\"text/javascript\" src=\"main.js\">`로 번들 파일이 주입된다.\n\nwebpack-dev-server 에 대한 추가적인 설정을 하려면 devServer 옵션을 이용하면 된다.\n\n```js\nmodule.exports = {\n  devServer: {\n    hot: true,\n    contentBase: path.join(__dirname, \"dist\"),\n    compress: true,\n    port: 9000\n  }\n};\n```\n\nhot: true 는 핫로더, contentBase는 대상 위치, compress는 파일 gzip 압축, port는서버 포트 설정이다.\n\n[DevServer | webpack](https://webpack.js.org/configuration/dev-server/)\n\n    DevTools failed to parse SourceMap: webpack:///node_modules/sockjs-client/dist/sockjs.js.map\n\n[localhost:9000](http://localhost:9000) 에서 콘솔 창을 확인하면 devtools을 설정하지 않아 위와 같은 경고 문구가 뜬다. devtools 옵션으로 소스맵 생성을 정의할 수 있다. 소스맵은 번들링된 파일과 원래 파일을 맵핑하여 에러 추적할 때 용이하다. 예를 들어 세개의 js 파일을 번들링한 main.js 파일이 있다고 하자. 콘솔 창을 확인해보니 main.js 파일에서 에러가 났다. 만약 소스맵을 사용하지않는다면 세 개의 파일 중 어디서 에러가 났는 지 알 수가 없다. _여러가지 종류가 있지만 inline-source-map 을 추천한다길래 얘를 사용했다. 나중에 각 옵션의 차이점도 알아봐야겠다._\n\n```js\nmodule.exports = {\n  devtool: \"inline-source-map\"\n};\n```\n\n## 4. Babel로 ES6를 ES5로 변환하기\n\n> 구형 브라우저(IE)에서는 ES6 코드가 호환되지 않는다. 그렇다고 ES5로 코드를 짤 수도 없는 노릇. ES2015+ 문법을 ES5로 바꿔주는 녀석이 없을까? 바로 바벨이 그 역할을 한다.\n\n먼저 바벨 패키지를 설치한다.\n\n```\n    npm install --save-dev babel-loader @babel/core @babel/preset-env\n```\n\n- babel-loader : 웹팩에서 ES6로 된 파일을 ES5로 변환할 때 사용\n- @babel/core\n\n웹팩에게 빌드하기전 자바스크립트 파일을 ES5로 트랜스파일링하라고 말해야한다. 웹팩의 Loaders를 이용하여 이를 설정할 수 있다.\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: \"babel-loader\"\n      }\n    ]\n  }\n};\n```\n\n- **loader** : 웹팩은 자바스크립트, 이미지, 폰트, 스타일시트도 전부 모듈로 관리한다. 하지만 웹팩은 자바스크립트만 아는 녀석이라서 웹팩이 자바스크립트 파일이 아닌 파일들을 이해할 수 있게끔 변경해야하는데 로더(loader)가 그런 역할을 한다. 위 코드를 보면 test에 로딩할 파일, use에 적용할 로더, exclude는 제외할 파일를정의한 것을 알 수 있다.\n\n바벨 설정을 완료했지만 사실 바벨은 아무 것도 하지않는다. 프로젝트 루트에 .babelrc 파일을 만들어 설정을 해야한다. 그 전에 ES2015+를 트랜스파일링하기위해 필요한 프리셋과 플러그인을 모은 모듈을 다운받는다. @babel/preset-env는 자동으로 브라우저 polyfill 을 맞춘다.\n\n    npm install @babel/preset-env --save-dev\n\n.babelrc에 아래와 같이 입력한다.\n\n    {\n      \"presets\": [\"@babel/preset-env\"]\n    }\n\n따로 .babelrc 파일을 만들지않고 웹팩에서도 설정 가능하다.\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: \"babel-loader\",\n          options: {\n            presets: [\"@babel/preset-env\"]\n          }\n        }\n      }\n    ]\n  }\n};\n```\n\n실제로 트랜스파일링되는지 테스트하기위해 index.js에 아래와 같이 작성하고 npm run build하면 es5 문법으로 바뀐 것을 알 수 있다.\n\n```js\nconst myconst = 123;\nlet mylet = 456;\n```\n\n![Vue%20CLI%20Vue%20Typescript%20Babel%20Webpack%201/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Vue/images/2020-02-29-img/Untitled.png)\n\n추가로 @babel/preset-env에서 타켓에 옵션으로 브라우저 버전을 직접 설정할 수도 있다. options을 쓰거나 package.json에 작성하는 방법도 있지만 공식문서는 **.browserslistrc** 파일을 만들어서 설정하는 것을 추천하고 있다. 프로젝트 루트 폴더에 .browserslistrc를 만든 후 아래의 내용을 작성하자. 각 브라우저에서 최근 2개의 버전까지, 1% 이상 사용되는 브라우저를 타켓으로 한다. 디폴트는 _> 0.5%, last 2 versions, Firefox ESR, not dead_ 다.\n\n    > 1%\n    last 2 versions\n\n### ES6 메서드나 생성자 지원하려면?\n\nindex.js 에 console.log(Array.from('foo')); 을 입력한 후 IE11에서 확인해보자.\n\n```js\nconsole.log(Array.from(\"foo\"));\n```\n\n콘솔 창을 보면 개체가 'from' 속성이나 메서드를 지원하지 않습니다. 라는 에러 문구를 보게될 것이다. 바벨로 ES5로 바꿨는 데 왜 그러지??? 라는 혼란이 생길 것이다.😨😨\n\n방금까지는 바벨을 이용하여 ES6 문법을 ES5로 문법 트랜스파일링만 한 거다. 그래서 Array.from()과 같이 ES6에만 있는 메서드나 생성자들은 구형 브라우저에서 동작하지 않는다. 이 문제를 해결하기 위해polyfill을 사용한다. **polyfill**은 code 조각으로 런타임에 존재하지 않는 nativeAPI의 복사본을 말한다. @babel/polyfill이나 @babel/plugin-transform-runtime를 사용하면 되지만 **@babel/polyfill** 은 7.4.0부터 deprecated 되서 **core-js@3**를 사용하는 것을 추천한다.\n\n**Babel-Polyfill vs Babel-Transform-Runtime**\n\n- Babel-Polyfill은 전역적으로 polyfill을 사용하여 전역 스코프를 오염시킬 수 있다. 또한 번들 파일에 포함되고 코드 상단에 **import 'babel-polyfill';** 을 추가해야 사용할 수 있다. 프로젝트에서 전역적으로 polyfill을 사용하거나 라이브러리 규모가 클 경우에 사용하는 게 유리하다.\n- Babel-Transform-Runtime는 플러그인으로 추가하면 되고 기능은babel-polyfill과 거의 비슷하나 array.includes()와 array.values() 같은 특정 함수를 제공하지않는다. core-js@3과 함께 사용하면 이 문제를 해결할 수 있다. 간단하게 라이브러리에서 사용하는 API를 래핑시킬 때 좋다.\n\n여기서는 core-js@3를 사용하며 @babel/preset-env의 옵션으로 폴리필을 설정한다. 우선 core-js를 설치해주자.\n\n    npm install core-js@3 --save\n\n.babelrc에 아래와 같이 추가한다. \"useBuiltIns\": \"usage\"는 트랜스파일 시 소스에서 쓰는 폴리필을 자동으로 넣어준다.\n\n    {\n      \"presets\": [\n        [\n          \"@babel/preset-env\",\n          {\n            \"useBuiltIns\": \"usage\",\n            \"corejs\": {\n              \"version\": 3,\n              \"proposals\": true\n            }\n          }\n        ]\n      ]\n    }\n\n구글 크롬 브라우저에 들어가보면 아래와 같이 트랜스 파일링 된 것을 알 수 있다.\n\n```js\n    /***/ \"./src/index.js\":\n    /*!**********************!*\\\n      !*** ./src/index.js ***!\n      \\**********************/\n    /*! no exports provided */\n    /***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n    \"use strict\";\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony import */ var core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.from */ \"./node_modules/core-js/modules/es.array.from.js\");\n    /* harmony import */ var core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_0__);\n    /* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.string.iterator */ \"./node_modules/core-js/modules/es.string.iterator.js\");\n    /* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_1__);\n\n\n    console.log(Array.from('foo'));\n\n    /***/ }),\n```\n\nIE 11에서도 폴리필하려면 브라우저 타켓에 IE 11을 추가해야한다. .browserslistrc에 아래와 같이 추가하고 IE 브라우저를 확인하면 잘 동작하는 것을 볼 수 있다.\n\n    > 1%\n    last 2 versions\n    IE 11\n\n**참고**\n\n[웹팩의 기본 개념](http://jeonghwan-kim.github.io/js/2017/05/15/webpack.html)\n\n[[Tool] (번역)Babel에 대한 모든 것](https://jbee.io/etc/Everything-about-babel/)\n"}}}},"pageContext":{"id":"5219daaeb39e005c6bc68059ba819110107f2daf","previousPostId":"90b6ccb77c8749885afcac589cc7c853f9e17a48","nextPostId":"5d8f5742317fc2443a1810a411eb106b455e189d"}},"staticQueryHashes":["2685952063","2841359383"]}