{"componentChunkName":"component---src-templates-blog-post-js","path":"/5219daaeb39e005c6bc68059ba819110107f2daf","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"5219daaeb39e005c6bc68059ba819110107f2daf","text":"# 최단 경로 알고리즘 - Dijkstra\n\n- Title : 최단 경로 알고리즘 - Dijkstra\n- Date : 2020-03-01\n- Category: Algorithm\n\n## Why?\n\n[1753번: 최단경로](https://www.acmicpc.net/problem/1753)\n\n> 최단 경로 문제는 네트워크에서 정점 u와 정점 v를 연결하는 경로 중에서 간선들의 가중치 합이 최소가 되는 경로를 찾는 문제다.\n\n## Dijkstra의 최단 경로 알고리즘\n\n네트워크에서 **하나의** 시작 정점으로부터 **모든** 다른 정점까지의 최단 경로를 찾는 알고리즘이다. 최단 경로는 경로의 길이순으로 구해진다.\n\n- 집합 S는 정점 v로부터의 최단 경로가 이미 발견된 정점들의 집합이다.\n- distance[]는 시작 정점에서 집합 S에 있는 정점을 거쳐서 다른 정점으로 가는 최단 거리를 기록한 배열이다.\n- distance 배열의 초깃값은 시작 정점이 v라면 distance[v] = 0 이고 다른 정점에 대한 distance 값은 v와 해당 정점 간의 가중치가 된다. 정점 v와 w와 직접 간선이 없다면 무한대 값을 저장한다.\n- 알고리즘 매 단계에서 집합 S에 없는 정점 중 가장 distance 값이 작은 정점을 S에 추가한다. 왜냐하면 현재 정점 u에서 x, y, z 중 y의 가중치가 최소라면 u → y가 u → x → y 또는 u → y → x 등 어떤 정점을 거쳐서 y로 가든 u → y 가 최단 경로이기 때문이다.\n- 새로운 정점 x가 S에 추가되면 S에 있지 않은 다른 정점들의 distance 값을 수정한다. 새로 추가된 정점 x를 거쳐 다른 정점까지 가는 거리와 기존의 거리를 비교하여 더 작은 거리로 distance 값을 수정한다. **distance[w] = min(distance[w], distance[x] + weight[x][w])** 식과 같다.\n\n![Dijkstra/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-01-img/Untitled.png)\n\n네트워크에 n개의 정점이 있다면, 다익스트라 최단 경로 알고리즘은 주 반복문을 n번 반복하고 내부 반복문을 2n번 반복하므로 **O(n²)** 의 복잡도를 가진다. distance를 배열이 아닌 **우선순위 큐**를 사용하면 더 빠르게 수행할 수 있다.\n\n### 백준 문제 풀이\n\n**1753번 최단경로**\n\n[1753번: 최단경로](https://www.acmicpc.net/problem/1753)\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #include <queue>\n    #define MAX_W 98765432\n    using namespace std;\n\n    vector<pair<int, int> > graph[20001];\n\n    vector<int> dijkstra (int s, int cv) {\n    \tvector<int> dis(cv, MAX_W);\n    \tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n    \tpq.push(make_pair(0, s));\n    \tdis[s] = 0;\n\n    \twhile (!pq.empty()) {\n    \t\tint cost = pq.top().first;\n    \t\tint v = pq.top().second;\n    \t\tpq.pop();\n    \t\tif (dis[v] < cost) continue;\n\n    \t\tfor (int i=0; i<graph[v].size(); i++) {\n    \t\t\tif (dis[graph[v][i].second] >= cost + graph[v][i].first) {\n    \t\t\t\tpq.push(make_pair(cost + graph[v][i].first, graph[v][i].second));\n    \t\t\t\tdis[graph[v][i].second] = cost + graph[v][i].first;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn dis;\n    }\n    int main() {\n    \tint v, e, s;\n    \tint a, b, c;\n\n    \tscanf(\"%d %d\", &v, &e);\n    \tscanf(\"%d\", &s);\n\n    \twhile (e--) {\n    \t\tscanf(\"%d %d %d\", &a, &b, &c);\n    \t\tgraph[a].push_back(make_pair(c, b));\n    \t}\n\n    \tvector<int> dis = dijkstra(s, v + 1);\n\n    \tfor (int i=1; i<v+1; i++) {\n    \t\tif (dis[i] == MAX_W)\n    \t\t\tprintf(\"INF\\n\");\n    \t\telse\n    \t\t\tprintf(\"%d\\n\", dis[i]);\n    \t}\n\n    \treturn 0;\n    }\n```\n\n**참고**\n\n[C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539)\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f9911ac03613c935962bb92b556860145926df9d","text":"# 최단 경로 알고리즘 - Floyd\n\n- Title : 최단 경로 알고리즘 - Floyd\n- Date : 2020-03-04\n- Category: Algorithm\n\n## Why?\n\n## Floyd 알고리즘\n\n그래프에 존재하는 **모든** 정점 사이의 최단 경로를 한 번에 **모두** 찾아주는 알고리즘이다. 다익스트라는 모든 정점 사이의 최단 경로를 구하려면 정점의 수만큼 다익스트라 알고리즘을 반복 실행한다.\n\n- 2차원 배열 weight를 이용하여 3중 반복으로 구성되어 있다.\n- 초기 배열 weight에서 i==j 면 weight[i][j] = 0, i j 사이의 직접 간선 없으면 weight[i][j]=INF, i j 사이 간선 있으면 weight[i][j] = 가중치값\n- 정점 0부터 n까지 반복을 돌린다. 정점 0을 거치는 경우..1을 거치는 경우..\n- weight[i][j] = min(weight[i][j], weight[i][k] + weight[k][j])\n\n![Floyd/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-03-04-img/Untitled.png)\n\n## 백준 문제 풀이\n\n11404번 플로이드\n\n[11404번: 플로이드](https://www.acmicpc.net/problem/11404)\n\n```cpp\n    #include <iostream>\n    #include <algorithm>\n    using namespace std;\n\n    int main() {\n    \tint n, m;\n    \tcin >> n >> m;\n\n    \tint graph[n+1][n+1];\n    \tfill(&graph[1][1], &graph[n][n], 10000001);\n    \tfor (int i=1; i<n+1; i++)\n    \t\tgraph[i][i] = 0;\n\n    \tint a, b, c;\n    \twhile (m--) {\n    \t\tcin >> a >> b >> c;\n    \t\tgraph[a][b] = min(graph[a][b], c);\n    \t}\n\n    \tfor (int k=1; k<n+1; k++) {\n    \t\tfor (int i=1; i<n+1; i++) {\n    \t\t\tif (k == i) continue;\n    \t\t\tfor (int j=1; j<n+1; j++) {\n    \t\t\t\tif (k == j) continue;\n    \t\t\t\tgraph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \tfor (int i=1; i<n+1; i++) {\n    \t\tfor (int j=1; j<n+1; j++) {\n    \t\t\tif (graph[i][j] == 10000001) cout << 0 << \" \";\n    \t\t\telse cout << graph[i][j] << \" \";\n    \t\t}\n\n    \t\tcout << \"\\n\";\n    \t}\n\n    \treturn 0;\n    }\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e027d4b137d5f1bb918e6d826d69a9f8803d0228","text":"# MST(최소신장트리)\n\n- Title : MST(최소신장트리)\n- Date : 2020-02-28\n- Category: Algorithm\n\n## Why?\n\n[1922번: 네트워크 연결](https://www.acmicpc.net/problem/1922)\n\n이 문제를 풀면서 MST 이론을 정리해놔야 겠다는 생각이 들었다.\n\n## MST(Minimun spanning tree)란?\n\n신장 트리는 그래프 내의 모든 정점을 포함하는 트리다. 트리의 특수한 형태로 **모든 정점들이 연결**되어 있어야 하고 사이클을 포함해서는 안된다. 따라서 신장 트리는 그래프에 있는 n개의 정점을 정확히 n-1개의 간선으로 연결하게 된다.\n\n하나의 그래프에는 많은 신장 트리가 존재할 수 있는 데 이 중 사용된 간선들의 **가중치 합이 가장 최소인 신장 트리**가 최소 신장 트리가 된다.\n\n## 신장 트리 찾기\n\nDFS나 BFS를 사용하여 탐색 도중에 사용된 간선을 모으면 신장 트리를 만들 수 있다.\n\n**DFS와 큐로 신장트리 찾기**\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #include <queue>\n    #define MAX_NODE 20\n    using namespace std;\n\n    vector<int> graph[MAX_NODE]; // 인접 리스트로 구현한 그래프\n    bool visited[MAX_NODE] = {false}; // 방문 표시\n    queue<int> st; // 신장 트리\n\n    void dfs(int v) { // 시작 노드\n    \tvisited[v] = true;\n    \tst.push(v);\n    \tfor (int i=0; i<graph[v].size(); i++) {\n    \t\tif (!visited[graph[v][i]]) {\n    \t\t\tdfs(graph[v][i]);\n    \t\t}\n    \t}\n    }\n```\n\n## 최소 신장 트리 찾기\n\n> 구하는 방법으로는 Kruskal과 Prime이 제안한 알고리즘이 대표적이다. 이 알고리즘들은 최소 신장 트리가 간선의 가중치의 합이 최소이어야 하고, 반드시 n-1개의 간선만 사용해야 하며, 사이클이 포함되어서는 안 된다는 조건들을 적절히 이용한다.\n\n### Kruskal의 MST 알고리즘\n\n이 알고리즘은 **탐욕적인 방법**을 이용한다. 탐욕적인 방법은 결정을 해야 할때마다 그 순간에 가장 최적이라고 생각되는 것을 선택함으로써 최종적인 해답을 구한다. 최적을 선택했다고 항상 최적의 해답을 주는 건 아니지만 다행히 Kruskal 알고리즘은 최적의 해답을 주는 것으로 증명되어 있다.\n\n- 그래프 e개의 간선들을 가중치의 오름차순으로 정렬한다.\n- 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택하여 현재의 최소 비용 신장 트리의 집합에 추가한다. 만약 사이클을 형성하면 그 간선은 제외된다.\n- 선택된 간선의 개수가 정점의 개수보다 하나 적으면 알고리즘을 종료한다.\n\n**사이클 체크**\n\n간선을 집합에 추가할 때 사이클을 생성하는지를 체크해야 한다. 양 끝 정점이 서로 다른 집합에 속하는 경우 두 정점을 연결하여도 사이클이 형성되지 않는다. Union-Find 알고리즘을 이용하여 간선의 양끝 정점이 같은 집합에 속해 있는지를 검사할 수 있다.\n\n**시간복잡도**\n\nUnion-Find 알고리즘을 이용하면 Kruskal 알고리즘의 시간 복잡도는 간선들을 정렬하는 시간에 좌우된다. 따라서 간선 e개를 퀵 정렬과 같은 효율적인 알고리즘으로 정렬한다면 시간복잡도는 **O(elog₂e)** 다.\n\n✔**백준 문제 풀이**\n\n1922번 문제를 Kruskal 알고리즘을 사용한 풀이\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #include <algorithm>\n\n    using namespace std;\n\n    struct Info {\n    \tint a;\n    \tint b;\n    \tint c;\n    };\n\n    int n;\n    int parent[1001]; // 부모 노드\n    int num[1001]; // 집합의 크기\n\n    void set_init(int n) {\n    \tfor (int i=1; i<n+1; i++) {\n    \t\tparent[i] = i;\n    \t\tnum[i] = 1;\n    \t}\n    }\n    int set_find(int v) {\n    \tif (parent[v] == v) return v;\n    \treturn parent[v] = set_find(parent[v]);\n    }\n\n    bool set_union(int a, int b) {\n    \ta = set_find(a);\n    \tb = set_find(b);\n\n    \tif (a == b) return false;\n\n    \tif (num[a] > num[b]) swap(a, b);\n    \tparent[a] = b;\n    \tif (num[a] == num[b]) num[b]++;\n    \treturn true;\n    }\n\n    bool compare(Info t1, Info t2) {\n    \treturn t1.c < t2.c;\n    }\n    int main() {\n    \tint m, a, b, c;\n    \tscanf(\"%d\", &n);\n    \tscanf(\"%d\", &m);\n    \tvector<Info> edge;\n\n    \twhile (m--) {\n    \t\tscanf(\"%d %d %d\", &a, &b, &c);\n    \t\tedge.push_back({a, b, c});\n    \t}\n\n    \tsort(edge.begin(), edge.end(), compare);\n\n    \tset_init(n);\n\n    \tint count = 0, cost = 0;\n    \tint ra, rb;\n    \tfor (int i=0; i<edge.size(); i++) {\n    \t\tif (set_union(edge[i].a, edge[i].b)) {\n    \t\t\tcost += edge[i].c;\n    \t\t\tif(++count == n-1) break;\n    \t\t}\n    \t}\n\n    \tprintf(\"%d\", cost);\n\n    \treturn 0;\n    }\n```\n\n✔**응용 문제**\n\n백준 4195번\n\n[4195번: 친구 네트워크](https://www.acmicpc.net/problem/4195)\n\n```cpp\n    #include <iostream>\n    #include <string>\n    #include <map>\n    using namespace std;\n\n    map<string, string> parent;\n    map<string, int> num;\n\n    void check_init(string v) {\n    \tif (parent.find(v) == parent.end()) {\n    \t\tparent.insert(make_pair(v, v));\n    \t\tnum.insert(make_pair(v, 1));\n    \t}\n    }\n    string set_find(string v) {\n    \tif(parent[v] == v) return v;\n    \treturn parent[v] = set_find(parent[v]);\n    }\n\n    int set_union(string a, string b) {\n    \ta = set_find(a);\n    \tb = set_find(b);\n    \tif (a == b) return num[a];\n    \tif (num[a] > num[b]) swap(a, b);\n    \tparent[a] = b;\n    \tnum[b] += num[a];\n    \treturn num[b];\n    }\n    int main() {\n    \tios::sync_with_stdio(false);\n    \tcin.tie(0);\n    \tint t, f;\n    \tcin >> t;\n\n    \twhile(t--) {\n    \t\tcin >> f;\n    \t\twhile (f--) {\n    \t\t\tstring a, b;\n    \t\t\tcin >> a;\n    \t\t\tcin >> b;\n\n    \t\t\tcheck_init(a);\n    \t\t\tcheck_init(b);\n\n    \t\t\tcout << set_union(a, b) << \"\\n\";\n    \t\t}\n    \t\tparent.clear();\n    \t\tnum.clear();\n    \t}\n\n    \treturn 0;\n    }\n```\n\n> 다른 사람 풀이보다 시간이 더 걸려서 비교해보니 map<string, int>로 기존 Union-Find 알고리즘을 그대로 사용할 수 있게 이름에 index를 강제 할당시키는 방식이었다. 왜 이런 생각을 못했지.....😢😢 아! 그리고 **ios::sync_with_stdio(false); cin.tie(0);** 를 안했더니 시간 초과가 났었다.\n\n### Prim의 MST 알고리즘\n\nKruskal은 간선 선택을 기반으로 하는 알고리즘인 반면에, Prim의 알고리즘은 **정점 선택**을 기반으로 하는 알고리즘이다. 또한 Kruskal의 알고리즘은 이전 단계에서 만들어진 신장 트리와는 상관없이 무조건 최소 간선만을 선택하는 방법인 데 반하여 Prime의 알고리즘은 이전 단계에서 만들어진 신장 트리를 확장하는 방식이다.\n\n- 시작 단계에는 시작 정점만이 신장 트리 집합에 포함된다.\n- 앞 단계에서 만들어진 신장 트리 집합에 속한 정점들의 인접 정점들 중에서 최소 비용 간선으로 연결된 정점을 선택하여 신장 트리 집합에 포함한다.\n- 트리 집합의 정점 개수가 n개가 될 때까지 이 과정을 반복한다.\n\n아래 그림으로 예를 들어보자.\n\n- 우선 A 정점을 신장 트리 집합에 포함시킨다.\n- A 정점의 인접 정점인 D, B와 연결된 간선 중 가중치가 최소인 D를 선택하여 집합에 포함시킨다.\n- 신장 트리 집합의 정점 개수가 2개{A, D}로 아직 7개가 아니므로 다시 A, D의 인접 정점을 확인한다.\n- A-B, D-B, D-E, D-F 간선 중 가중치가 최소인 정점인 F를 선택하여 집합에 포함시킨다.\n- 반복..\n\n![MST/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-28-img/Untitled.png)\n\n**구현 방법**\n\n- dist[정점개수] 배열이 필요하다. dist는 현재 신장 트리의 정점 집합에서 각 정점까지의 거리를 가지고 있다. A(0)가 시작 정점이면 dist[0]만 값이 0이고 나머지 배열의 값은 무한대를 가진다. 명백하게 처음에는 트리 집합에 아무것도 없으므로 당연하다. 정점들이 트리 집합에 추가되면서 dist 값은 변경된다.\n- 우선순위 큐가 필요하다. 큐에 모든 정점을 삽입하는 데 이 때 우선순위는 dist 배열 값이 된다.\n- while 루프로 큐에서 가장 작은 dist 값을 가지는 정점을 추출한다. 추출된 정점이 트리 집합에 추가된다.\n- 트리 집합에 새로운 정점 u가 추가되었으므로 u에 인접한 정점 v들의 dist 값을 변경시켜준다. 즉, 기존의 dist[v] 값보다 간선(u, v)의 가중치가 적으면 간선 (u, v)의 가중치로 dist[v]를 변경시킨다.\n- 큐가 빌 때까지 반복한다.\n\n**시간복잡도**\n\nPrim의 알고리즘은 배열을 사용하면 주 반복문이 정점의 수 n만큼 반복하고, 내부 반복문이 n번 반복하므로 Prim의 알고리즘의 시간 복잡도는 O(n²)다. 하지만 우선 순위 큐를 사용하면 **O(elongv)** 의 시간복잡도를 가진다.\n\n✔**백준 문제 풀이**\n\n1197번 문제를 Prim의 알고리즘을 사용한 풀이\n\n[1197번: 최소 스패닝 트리](https://www.acmicpc.net/problem/1197)\n\n```cpp\n    #include <iostream>\n    #include <vector>\n    #include <queue>\n    using namespace std;\n\n    bool selected[10001] = {false}; // selected[i]: true면 mst 집합의 원소, false면 선택 가능\n    vector<pair<int, int> > edge[100001]; // 인접 리스트로 그래프 자료구조 구현\n\n    int prim() {\n    \tint cost = 0;\n    \t// 우선 순위 큐: 가중치가 적은 정점이 우선 순위로 나오게\n    \tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n    \tpq.push(make_pair(0, 1)); // 가중치:0, 정점: 1\n\n    \twhile (!pq.empty()) {\n    \t\tpair<int, int> p = pq.top();\n    \t\tpq.pop();\n    \t\tif (selected[p.second]) continue; // 이미 선택된 정점이면 작업할 필요가 없다.\n    \t\tselected[p.second] = true;\n    \t\tcost += p.first;\n    \t\tfor (int i=0; i<edge[p.second].size(); i++) {\n    \t\t\tif (!selected[edge[p.second][i].second]) {\n    \t\t\t\tpq.push(edge[p.second][i]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn cost;\n\n    }\n    int main() {\n    \tios::sync_with_stdio(false);\n    \tcin.tie(0);\n\n    \tint v, e;\n    \tcin >> v >> e;\n    \tint t = e;\n    \twhile (t--) {\n    \t\tint a, b, c;\n    \t\tcin >> a >> b >> c;\n    \t\tedge[a].push_back(make_pair(c, b));\n    \t\tedge[b].push_back(make_pair(c, a));\n    \t}\n\n    \tprintf(\"%d\", prim());\n\n    \treturn 0;\n    }\n```\n\n> 우선 순위 큐에 전달할 데이터가 2개 이상일 때, pair로 묶으면 first 값을 1순위, second 값을 2순위로 우선 순위를 정할 수 있다.\n\n**정리**\n\nKruskal 알고리즘은 희박한 그래프를 대상으로 할 경우에 유리하고 밀집한 그래프의 경우에는 Prim의 알고리즘이 적합하다라고 할 수 있다. 밀집 그래프는 간선이 많이 존재하는 그래프, 희소 그래프는 적은 숫자의 간선을 가지는 그래프다.\n\n**참고**\n\n[C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539)\n"}}}},"pageContext":{"id":"5219daaeb39e005c6bc68059ba819110107f2daf","previousPostId":"f9911ac03613c935962bb92b556860145926df9d","nextPostId":"e027d4b137d5f1bb918e6d826d69a9f8803d0228"}},"staticQueryHashes":["2685952063","2841359383"]}