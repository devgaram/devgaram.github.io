{"componentChunkName":"component---src-templates-blog-post-js","path":"/21592a4a75d3f4c8d56813075597b1287f9822f2","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"21592a4a75d3f4c8d56813075597b1287f9822f2","text":"# [안드로이드] fragment를 사용하자\n\n- Title : [안드로이드] fragment를 사용하자\n- Date : 2018-12-07\n- Category: Android\n\n[될 때까지 안드로이드]의 fragment 파트를 정리한 내용입니다.\n\n[기본 프래그먼트 구현 예제](https://github.com/devgaram/androidExample/tree/master/fragmentexam).  \n[다이얼로그 프래그먼트 구현 예제](https://github.com/devgaram/androidExample/tree/master/exitdialogfragment).  \n[콜백 구현 예제](https://github.com/devgaram/androidExample/tree/master/callbackexam).\n\n여러 개의 프래그먼트를 하나의 액티비티에 조합하여 창이 여러 개인 UI를 구축할 때 사용할 수 있다.\n\n- 하나의 프래그먼트를 여러 액티비티에서 재사용할 수 있으며,동적으로 추가, 삭제, 교체가 쉽다.\n- 프래그먼트는 자체 수명 주기를 가진다.\n- 프래그먼트는 부모-자식 관계를 가질 수 있다.\n\n---\n\n# 생명주기 (소속 액티비티가 실행 중일 때)\n\n최소한 다음과 같은 수명 주기 메서드를 구현해야한다.\n\n**onCreate()**  \n프래그먼트를 생성할 때 호출되는 콜백 메서드  \n프래그먼트가 일시정지되거나 중지되었다가 재개되었을 때 유지하고자 하는 것을 초기화하는 부분\n\n**onCreateView()**  \n액티비티는 <code class=\"codetainer\">onCreate()</code> 콜백 메서드에서 <code class=\"codetainer\">setContentView()</code> 메서드를 호출하여 View 객체(레이아웃)을 가져온다.  \n프래그먼트는 <code class=\"codetainer\">onCreateView()</code> 콜백 메서드에서 LayoutInflater를 통해 레이아웃을 가져온다.\n\n**onPause()**  \n시스템이 이 메서드를 호출하는 것은 사용자가 프래그먼트를 떠난다는 첫 번째 신호.  \n현재 사용자 세션을 넘어서 지속되어야 하는 변경 사항을 저장하는 부분\n\n프래그먼트 추가  \nonAttach() -> onCreate() -> onCreateView() -> onActivityCreated() -> onStart() -> onResume()\n\n프래그먼트 소멸  \nonPause() -> onStop() -> onDestroyView() -> onDestroy() -> onDetach()\n\n# 실습\n\n## 프래그먼트의 생성자\n\n생성자를 오버로드할 수 없으며, 생성자를 통해 파라미터 전달을 금지하고 있다.  \n재생성 시에 정보를 자동으로 저장 및 복원하기 위한 설계가 이미 되어 있고 그것을 따르기 위한 제약이다.\n프래그먼트의 생성과 동시에 파라미터를 전달하는 방법은 **Bundle 객체**를 활용한다.\n\n```java\npublic class ColorFragment extends Fragment {\n\n    public ColorFragment() {\n        // Required empty public constructor\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.fragment_color, container, false);\n    }\n}\n```\n\n## 프래그먼트 매니저\n\n프래그먼트 조작을 위해 프래그먼트 매니저가 필요하다.  \n프래그먼트 매니저는 액티비티 처럼 백스택을 가지고 있음.\n\n- 액티비티 내 XML에 포함된 프래그먼트를 <code class=\"codetainer\">findFragmentById()</code> 메서드로 가져오기 또는 <code class=\"codetainer\">findFragmentByTag()</code>로 가져오기\n- 액티비티 백스택에서 프래그먼트를 <code class=\"codetainer\">popBackStack()</code>메서드로 빠져나오게 하여 액티비티의 뒤로 가기와 같은 효과를 냄 ( <code class=\"codetainer\">addToBackStack()</code> : 프래그먼트 매니저의 백스택에 프래그먼트 추가하는 메서드 )\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n      ...생략...\n        FragmentManager fragmentManager = getSupportFragmentManager();\n        ColorFragment colorFragment = (ColorFragment) fragmentManager.findFragmentById(R.id.color_fragment);\n        colorFragment.setColor(Color.BLUE);\n    }\n}\n```\n\n## 프래그먼트에서 액티비티에 접근하는 방법\n\n```java\nView listView = getActivity().findViewById(R.id.list);\n```\n\n## 프래그먼트 교체, 삭제, 추가\n\n프래그먼트를 교체하기 위해서는 <fragment<fragment>>를 <FrameLayout<FrameLayout>>과 같은 레이아웃으로 감싸줘야한다.  \n**프래그먼트 트랜지션 수행** add(), remove(), replace() 같은 메서드를 사용하고 commit()을 수행하면 트랜지션이 적용된다.\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n  ...생략....\n\n    public void change(View view) {\n        ColorFragment fragment = new ColorFragment();\n        int red = new Random().nextInt(256);\n        int green = new Random().nextInt(256);\n        int blue = new Random().nextInt(256);\n        fragment.setColor(Color.rgb(red, green, blue));\n        getSupportFragmentManager()\n                .beginTransaction()\n                .replace(R.id.container, fragment)\n                .commit();\n    }\n}\n```\n\n## 프래그먼트와 액티비티 간의 통신\n\n일반적으로 액티비티에서 프래그먼트나 다른 뷰들의 인스턴스를 가지고 있어서 이들의 메서드를 호출하는 식이다. 따라서 프래그먼트의 상태가 변했을 때 액티비티에서 이것을 알아차리려면 계속해서 프래그먼트의 상태 값을 알아내는 메서드를 호출해야한다.\n\n그러나 콜백 인터페이스를 사용하여 프래그먼트의 상태가 변할 때마다 자동으로 액티비티에게 알려줄 수 있다.\nButton의 <code class=\"codetainer\">onClick()</code> 이벤트나 액티비티의 <code class=\"codetainer\">onCreate()</code>가 대표적인 콜백 메서드이며, 호출자 입장에서는 피호출자의 변화를 감시하다가 알아채기 때문에 리스너(Listener) 라고도 불른다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f3c739a9f9af2d42a8f59bed45bd78959efdcd6e","text":"# jekyll의 minimal-mistakes에서 자바스크립트 커스텀하는 방법\n\n- Title : jekyll의 minimal-mistakes에서 자바스크립트 커스텀하는 방법\n- Date : 2019-01-05\n- Category: Jekyll\n\nminimal-mistakes 테마를 적용한 jekyll 블로그를 커스텀하는 과정에서 자바스크립트 코드를 추가하는 방법입니다.  \nminimal-mistakes 문서에 자바스크립트 커스텀 방법이 잘 정리되어있습니다.\n[공식문서 바로가기](https://mmistakes.github.io/minimal-mistakes/docs/javascript/).\n\n---\n\n우리가 수정해야 할 파일은 /assets/js/ 에 위치한 \\_main.js 파일입니다.  \n하지만, jekyll은 \\_main.js 파일이 아닌 main.min.js 파일을 컴파일하여 화면에 반영합니다.  \nmain.min.js 는 \\_main.js 자바스크립트 코드를 압축화하고 난독화한 파일로 npm 패키지 중 하나인 uglify를 이용하여 만들 수 있습니다.\n\n## 1. npm 셋팅\n\n```\n> npm init\n```\n\n블로그 프로젝트 디렉토리 위치에서 위 코드를 실행시키면 package.json 파일이 생성됩니다.\n\n## 2. package.json 파일 수정\n\nhttps://github.com/mmistakes/minimal-mistakes/blob/master/package.json\npackage.json 파일을 아래와 같이 수정합니다.\n\n```json\n{\n  \"name\": \"minimal-mistakes\",\n  \"version\": \"4.14.2\",\n  \"description\": \"Minimal Mistakes 2 column Jekyll theme.\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/mmistakes/minimal-mistakes.git\"\n  },\n  \"keywords\": [\"jekyll\", \"theme\", \"minimal\"],\n  \"author\": \"Michael Rose\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mmistakes/minimal-mistakes/issues\"\n  },\n  \"homepage\": \"https://mmistakes.github.io/minimal-mistakes/\",\n  \"engines\": {\n    \"node\": \">= 0.10.0\"\n  },\n  \"devDependencies\": {\n    \"npm-run-all\": \"^4.1.5\",\n    \"onchange\": \"^5.1.3\",\n    \"uglify-js\": \"^3.4.9\"\n  },\n  \"scripts\": {\n    \"uglify\": \"uglifyjs assets/js/vendor/jquery/jquery-3.3.1.min.js assets/js/plugins/jquery.fitvids.js assets/js/plugins/jquery.greedy-navigation.js assets/js/plugins/jquery.magnific-popup.js assets/js/plugins/jquery.smooth-scroll.min.js assets/js/_main.js -c -m -o assets/js/main.min.js\",\n    \"add-banner\": \"node banner.js\",\n    \"watch:js\": \"onchange \\\"assets/js/**/*.js\\\" -e \\\"assets/js/main.min.js\\\" -- npm run build:js\",\n    \"build:js\": \"npm run uglify && npm run add-banner\"\n  }\n}\n```\n\n## 3. uglify 설치 및 실행\n\nuglify-js 패키지 설치\n\n```\n> npm install uglify-js\n```\n\npackage.json의 scripts 부분을 보면 build:js 스크립트 실행시 **npm run uglify && npm run add-banner** 를 실행하도로 되어있습니다.\n이를 참고하여 cmd에서 <code class=\"codetainer\">npm run build:js</code>를 실행해봅시다. 정상적으로 \\_main.js 파일이 main.min.js로 압축된 것을 확인할 수 있을 것입니다.\n\n## 4. jekyll serve 실행\n\n이미 서버가 실행되어있다면 자동으로 반영됩니다.  \n그렇지 않다면 다시 **jekyll serve** 를 통해 서버를 실행해주면 커스텀한 자바스크립트 코드가 반영된 것을 확인할 수 있습니다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d3243c845434711276363da6e3b2e4b8a276c730","text":"# [안드로이드] RecyclerView를 사용하자\n\n- Title : [안드로이드] RecyclerView를 사용하자\n- Date : 2018-12-05\n- Category: Android\n\n[될 때까지 안드로이드]의 RecyclerView 파트를 정리한 내용입니다.\n\n어댑터 뷰의 성능을 개선한 컴포넌트로 애니메이션을 지원하고 뷰홀더 패턴을 강제한다.  \n대신 이벤트 리스너와 커서를 지원하지 않는 단점이 있다.\n\n## 어댑터 뷰의 단점\n\n1. 빠르게 스크롤 할 때 성능문제와 불필요한 지연 문제가 있다.\n2. 데이터 목록이 변경되었을 때, <code class=\"codetainer\">notifyDataSetChanged()</code> 메서드를 빈번하게 호출하여 전체 아이템을 갱신하는 데 비용이 많이 든다. 이 메서드는 항상 전체 항목을 새로 로드한다.\n\n## 리사이클러 뷰 vs 어댑터 뷰\n\n- 상속 받는 클래스 : RecyclerView.Adapter vs BaseAdapter\n- 리사이클러 뷰는 레이아웃 매니저를 지정해줘야 한다.\n- 리사이클러 뷰는 뷰홀더 패턴을 반드시 구현해야한다.\n\n## 리사이클러 뷰 관련 클래스\n\n1. RecyclerView.Adapter : 어댑터 역할\n2. RecyclerView.ViewHolder : 뷰홀더 클래스가 상속받아야 할 클래스\n3. LayoutManager : 아이템을 어떻게 배치할 것 인가\n\n   - LinearLayoutManager\n   - GridLayoutManager\n   - StaggeredGridLayoutManager\n\n4. RecyclerView.ItemAnimator : 아이템이 추가, 삭제, 재정렬 시 애니메이션 어떻게 할 것인가\n5. RecyclerView.ItemDecoration : 아이템을 세부적으로 어떻게 꾸밀 것인가\n\n## 리사이클러 통지 메서드\n\n- <code class=\"codetainer\">notifyItemInserted(int position)</code> : position 위치의 아이템이 삽입된 것을 통지\n- <code class=\"codetainer\">notifyItemRemoved(int position)</code> : position 위치의 아이템이 삭제된 것을 통지\n\n## 관련 메서드\n\n- <code class=\"codetainer\">void setHasFixedSize (boolean hasFixedSize)</code> : 각 아이템의 변화가 리사이클러 뷰의 전체 크기에 영향을 끼치지 않는다면 true를 사용한다.\n"}}}},"pageContext":{"id":"21592a4a75d3f4c8d56813075597b1287f9822f2","previousPostId":"f3c739a9f9af2d42a8f59bed45bd78959efdcd6e","nextPostId":"d3243c845434711276363da6e3b2e4b8a276c730"}},"staticQueryHashes":["2685952063","2841359383"]}