{"componentChunkName":"component---src-templates-blog-post-js","path":"/7597906a0b776c9b2fe7ef84398e8890c40f630f","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"7597906a0b776c9b2fe7ef84398e8890c40f630f","text":"# 운영체제 서론 - 운영체제의 정의와 역할\n\n- Title : 운영체제 서론 - 운영체제의 정의와 역할\n- Date : 2019-12-23\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # 운영체제가 없는 컴퓨터의 전원을 키면 어떤 일이 일어날까??\n\n운영체제가 하는 일을 알면 운영체제가 없는 PC에서 어떤 일이 일어나는 지 알 수 있다. 결론부터 말하자면, 컴퓨터는 **한 마디로 야.생.마.** 가 되어 제어할 수 없게 된다. 아래에서 운영체제의 역할을 살펴보며 왜 야생마가 되는 지 알아보자.\n\n## 알아보기 전, 간단히 컴퓨터 구조를 살펴보자!\n\n컴퓨터에는 <code class=\"codetainer\">프로세스(처리기)</code>와 <code class=\"codetainer\">메인 메모리</code>가 있다. 우리는 어떤 프로그램을 실행하기 전에 메모리에 명령들(Instructions)을 기록하는 데 이 명령어의 집합을 <code class=\"codetainer\">프로그램</code>이라고 한다. 이렇게 프로그램을 미리 내장해놓고 실행하며 이런 구조의 컴퓨터를 프로그램 내장형 컴퓨터라고 한다. 정리하자면, 전원을 키면 프로세스는 메인 메모리에서 명령어를 가져와서 실행하고 또 그 다음 명령어를 가져와서 실행한다.\n\n## 운영체제가 없는 PC의 전원을 켰을 때, 메인 메모리의 상태는??\n\n멋대로의, 임의의 값이 들어있기에 프로세스가 하는 일이 의미가 없다. 마치 전혀 제어가 안되는 야생마와 같다.\n\n## 운영체제는 프로그램을 어떻게 실행시킬까??\n\n<span class=\"clr-note\">프로그램은 컴퓨터의 하드디스크 안에 실행 파일 형태로 모여있으며 이 파일이 메모리에 올라가야 실제로 실행될 수 있다.</span> 하드디스크의 실행 파일을 메모리에 올리는 것은 운영체제가 담당하기 때문에 운영체제가 없으면 실행 파일을 메모리에 올릴 수가 없다. 메인 메모리에 여러 개의 프로그램이 동시에 올라가있고 프로세스는 한 개 라면 동시에 어떻게 실행시킬까? 사실 이 것도 운영체제가 처리해준다.\n\n## 그 외에\n\n<span class=\"clr-note\">프린터에 인쇄 명령, 하드 디스크에 저장</span> 등 <span class=\"clr-grey\">(즉, 하드웨어 관리)</span>도 운영체제가 처리해준다. 따라서 운영체제가 없으면 위에 언급한 내용들을 처리할 수 없어서 컴퓨터를 제대로 사용할 수가 없다.\n\n## 정리하자면!\n\n운영체제는 컴퓨터의 하드웨어(프로세스, 메모리, 디스크, 키보드, 마우스, 모니터, 네트워크, 스피커, 마이크, GPS..) 등을 잘 관리하여 성능을 높이고 사용자에게 편의성을 제공하는 역할을 담당한다.\n\n# # 부팅(Booting)\n\n## 알아보기 전, 메모리에 대해 간단히 살펴보자!\n\n메인 메모리는 일반적으로 <code class=\"codetainer\">RAM</code>과 <code class=\"codetainer\">ROM</code>으로 나눠지는 데 ROM은 극히 일부분을 차지하고 대부분은 RAM이다. RAM은 휘발성 메모리라서 전원을 껐다 키면 내용이 사라지지만 ROM과 하드디스크는 전원 상관 없이 내용이 유지된다.\n\n## 극히 일부분인 ROM이 하는 일은 무엇일까??\n\n전원을 키면 프로세스는 제일 먼저 <code class=\"codetainer\">ROM</code>의 명령어를 읽어와서 실행한다. <span class=\"clr-grey\">ROM은 전원을 처음 켰을 때 한번만 필요.</span> ROM의 프로그램 중, <code class=\"codetainer\">POST(Power-On Self-Test: 컴퓨터가 환경 설정이 제대로 되어 있는지, 프린터 키보드 연결 여부 및 메인 메모리 크기 등을 테스트)</code>를 제일 먼저 실행하고 그 다음 <code class=\"codetainer\">부트로더(Boot loader)</code>를 실행한다.\n\n## ROM의 부트로더가 하는 일은??\n\n부트로더는 하드디스크에 있는 OS를 메인 메모리에 올리는 역할을 한다. OS가 메인 메모리에 올라가면 ROM은 필요가 없다.\n\n## 그 후의 이야기..\n\nOS가 메인 메모리에 올라오면 윈도우즈라면 윈도우즈 초기화면이 나타나고 리눅스는 로그인 프롬트가 나타난다. 즉 <span class=\"clr-note\">OS가 메인 메모리에 상주되어 모든 명령어를 받아드릴 준비가 된다.</span> OS는 다른 프로그램과 달리 전원을 끌 때까지 메모리에 상주한다.\n\n# # 커널(kernel) vs 명령 해석기(shell, command interpreter)\n\n운영체제는 여러가지 하드웨어 장치를 관리하는 프로그램으로 OS 중 핵심 부분을 <code class=\"codetainer\">커널(kernel)</code>이라고 한다. 반대로 <code class=\"codetainer\">명령 해석기(shell, command interpreter)</code>는 os의 껍질로 사용자로부터 명령을 받고 그 명령을 해석하여 결과를 보여주는 역할을 한다. 예를 들어, 리눅스에서 <code class=\"codetainer\">\\$who</code>라는 명령을 내려 사용자 목록을 보여주는 데, 이 것을 쉘이 담당한다.\n\n## 하드웨어 > 운영체제 > 애플리케이션\n\n하드웨어 위에 운영체제, 운영체제 위에서 애플리케이션이 실행된다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f6cb269db79cf2dc5897ed2c1c5e4e7e9526daf8","text":"# 운영체제 - 프로세스 관리\n\n- Title : 운영체제 - 프로세스 관리\n- Date : 2019-12-25\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # 프로세스\n\n## 프로그램 vs 프로세스\n\n<code class=\"codetainer\">Process = task = job</code>  \n게임 프로그램이 하드디스크에 있으면 아무 것도 할 수 없다. 게임을 하기 위해 더블 클릭하면 게임 프로그램이 메인 메모리에 올라와서 실행 된다. 이렇게 실행 중인 프로그램을 <code class=\"codetainer\">프로세스</code>라고 한다\n\n## 프로세스 상태\n\n하나의 컴퓨터는 여러 개의 프로세스를 돌리고 CPU는 일정 시간을 나눠주어 이 프로세스들을 관리한다. 이 때, 프로세스는 <code class=\"codetainer\">new, ready, running, waiting, terminated</code> 상태를 겪게 된다.\n\n![프로세스 상태](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-25-img/process.png)<br/>\n\n- new : 하드디스크의 프로그램이 메인 메모리에 올라왔을 때\n- ready : 모든 초기화를 끝내고 실행 준비가 되었을 때\n- running : 실제로 CPU에서 실행하고 있을 때\n- waiting : 다시 CPU 할당 받을 때까지 기다릴 때\n- terminated : 프로세스가 종료된 상태\n\n- (1) : 프린트 출력 같은 I/O 발생 시 Waiting으로 감\n- (2) : I/O 완료되면 다시 Ready로 감\n- (3) : Time sharing system 에서는 일정 주기마다 프로세스 전환 인터럽트가 발생하는 데, 프로세스에게 주어진 CPU 사용 시간이 지나면 자동으로 이 프로세스는 Ready 상태로 가고 다른 프로세스가 running 상태가 된다.\n\n# # PCB(Process Control Block)\n\n사람으로 비유하면 주민등록증과 같고 프로세스를 잘 관리하기 위해서 PCB가 필요하다.\n\n- 하나의 프로세스에 하나의 PCB가 있다.(PCB는 운영체제의 프로세스 관리 부서에 있음)\n- <span class=\"clr-note\">Task Control Block(TCB)</span> 라고도 한다.\n- 프로세스에 대한 모든 정보가 들어있다.\n- <span class=\"clr-note\">process state(running, ready, waiting, …)</span>\n- <span class=\"clr-note\">PC</span> : 다시 CPU 돌아왔을 때, 그 당시의 PC 값이 필요하다.\n- <span class=\"clr-note\">registers</span> : CPU가 다른 프로그램 실행하다가 다시 돌아왔을 때, 어디서부터 다시 실행할 건지 알아야 한다.\n- <span class=\"clr-note\">MMU info (base, limit)</span> : 프로세스 스위칭 할 때마다 값을 바꿔줘야 한다\n- <span class=\"clr-note\">CPU time</span> : 현재까지 이 프로세스가 CPU 얼마나 사용했는 지\n- <span class=\"clr-note\">process id</span> : PID 프로세스마다 번호를 붙임\n- <span class=\"clr-note\">list of open files</span> : 프로세스가 지금 어떤 파일들을 사용하고 있는 지\n- 등...\n\n# # Queues\n\n## Job Queue\n\n하드디스크에 비해 메인 메모리 크기는 너무나 작아서 바로 메인 메모리에 못 올라가는 경우가 생긴다. 이 때 잡들은 큐에 줄 서게 되는 데, 이 것은 <code class=\"codetainer\">Job Queue</code> 라고 한다. 큐에 있는 작업들을 어떤 순서대로 실행할 지를 정하는 것을 <code class=\"codetainer\">Job scheduler(Long-term scheduler)</code> 라고 한다.\n\n## Ready Queue\n\n메인 메모리에 올라왔다고 바로 CPU 서비스 받는 것은 아니다. 또 <code class=\"codetainer\">Ready Queue</code>에 줄 서야 한다. 여기의 잡들도 <code class=\"codetainer\">CPU scheduler(short-term scheduler)</code>에 의해 순서가 정해진다.\n\n## Device Queue\n\nI/O, 하드 디스크 사용을 위해서도 <code class=\"codetainer\">Device Queue</code>에 줄 선다. 여기 잡을 관리하는 것은 <code class=\"codetainer\">Device scheduler</code>다.\n\n# # Multiprogramming\n\n## Degree of multiprogramming\n\n메인 메모리에 몇 개의 프로세스가 올라가 있는 지.\n\n## I/O-bound vs CPU-bound process\n\n프로세스는 크게 <code class=\"codetainer\">I/O-bound process</code>와 <code class=\"codetainer\">CPU-bound process</code>로 나눌 수 있다. I/O-bound는 주로 입출력 작업을 하는 프로세스로 문서편집 프로그램이 대표적이다. CPU-bound는 연산 작업이 많아 주로 CPU를 사용하는 경우며 예시로 슈퍼 컴퓨터 쓰는 일기 예보 프로그램을 들 수 있다.\n\n## Medium-term scheduler\n\nshort-term 보다는 적게 long-term 보다는 많게 일어난다. 운영체제는 메인 메모리를 감시하여 메모리에는 올라와있지만 아무 활동을 안하는 프로세스를 디스크에 쫒아낸다. 빈 메모리에는 새로운 프로그램을 올리거나 다른 프로세스에게 할당해준다. 이렇게 프로세스 이미지를 디스크로 쫒아내는 것을 <code class=\"codetainer\">Swapping Out</code> 이라고 하며 반대로 다시 프로세스를 사용하기 위해 메인 메모리에 올리면 <code class=\"codetainer\">Swapping In</code> 이라고 한다. 디스크를 프로세스 이미지를 쫒아내는 목적으로 사용하면 이를 <code class=\"codetainer\">Swap</code> 이라고 한다.\n\n## Context switching(문맥전환)\n\nCPU는 메인 메모리의 여러 프로세스를 동시에 서비스할 수 없어서 Process1을 사용하다가 Process2로 넘어가야한다. 이처럼 프로세스를 전환하는 것을 문맥전환이라고 한다.\n\n- <span class=\"clr-note\">Scheduler</span> : 큐에서 기다리는 잡 중에 무엇을 선택해서 작업할 지\n- <span class=\"clr-note\">Dispatcher</span> : CPU가 프로세스1을 서비스하다가 스케줄러에 의해 프로세스2로 문맥전환을 하려는 상황을 생각해보자. 운영체제는 안전한 문맥전환을 위해 Dispatcher 프로그램을 통해 다음의 2가지 일을 한다. 첫째로, 프로세스1의 현재 상태와 MMU(BASE, LIMIT) 정보를 프로세스1을 위한 PCB에 저장한다. 그 다음, 프로세스2의 정보를 복원하여 이전에 중지된 위치에서 재개할 수 있게 한다.\n- <span class=\"clr-note\">Context switching overhead</span> : 정보를 저장하고 복원하는 과정에서 오버헤드(부담)가 생기기 마련이다. 컴퓨터는 이를 Context switching overhead라고 부른다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"57230c4640ec299d7d03355c2e48f3f78fad5edf","text":"# 운영체제의 역사 - 일괄처리부터 시분할시스템까지 운영체제 변천의 역사\n\n- Title : 운영체제의 역사 - 일괄처리부터 시분할시스템까지 운영체제 변천의 역사\n- Date : 2019-12-23\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # Batch processing system(일괄처리)\n\n최초의 운영체제로 과거 오퍼레이터가 했던 일련의 작업들을 <span class=\"clr-note\">메모리에 상주시켜 일괄처리</span>한다. 메모리에 상주시킨 작은 프로그램을 <code class=\"codetainer\">레지던트 모니터(resident monitor)</code>라고 한다.\n\n# # Multiprogramming system(다중프로그래밍)\n\n## 멀티프로그래밍 시스템 등장 배경은??\n\n배치 프로세싱 시스템은 메모리에 운영체제와 **하나의** 사용자 프로그램(컴파일러, 게임 등..)만 올릴 수 있다. 하나만 올린다는 건 비싼 컴퓨터를 낭비하는 일이다. 예를 들어 +, \\*와 같은 연산 작업(CPU)과 화면에 입/출력하는 작업(I/O)을 하는 간단한 C 프로그램을 생각해보자. 프로그램을 실행하면 연산 작업에서는 빠른 CPU를 사용하고 입/출력 작업에서 느린 I/O를 사용한다. 즉, I/O 작업 중에는 CPU가 놀게 되는 것이다. 비싼 CPU를 쉬게 만든다니 너무나 아까운 일이다. 그래서 메모리에 여러 프로그램을 올리는 다중 프로그래밍 시스템이 등장하게 된 것이다.\n\n## 동작 방식은??\n\n이제 메모리에 여러 개의 사용자 프로그램이 올라갈 수 있게 된다. user1, user2, user3 프로그램이 메모리에 올라가있고 user1을 실행 중이라고 가정해보자. user1이 연산작업을 위해 CPU를 사용하다가 I/O를 사용하게 되면 바로 user2 프로그램을 실행한다. user2에서도 CPU를 사용하다가 I/O를 사용하게 되면 user3를 실행한다. 이렇게 프로그램이 I/O 작업을 하는 동안 또 다른 프로그램을 실행시켜 CPU를 사용하게 만들어 CPU 낭비를 줄인다.\n\n## 다중 프로그래밍에서 생각해야할 점이 있는데??\n\n바로 <span class=\"clr-note\">CPU scheduling, 메모리 관리, 보호</span>이다. 성능을 위해 각 사용자 프로그램을 최적의 순서로 실행해야하는 데 이를 <code class=\"codetainer\">CPU 스케줄링</code>이라고 한다. 이는 나중에 배운다. 또한, 각 사용자 프로그램을 메모리에 어떻게 배치하고 관리<code class=\"codetainer\">(메모리 관리)</code>할지도 고민해야하며 다른 프로그램 영역을 침범하는 경우를 막아야 한다.<code class=\"codetainer\">(보호)</code>\n\n# # Time-sharing system(시공유 시스템)\n\n## 시공유 시스템 등장 배경은??\n\n모니터와 키보드가 나오면서 대화형(Interactive system) 컴퓨터가 등장했고 컴퓨터 하나에 여러 개의 단말기(terminal)를 연결하여 여러 사람이 동시에 컴퓨터를 사용할 수 있게 되었다. 그런데 다중 프로그래밍 운영체제로는 동시에 컴퓨터를 사용할 수가 없다. user1 프로그램이 실행되는 동안 user2 프로그램을 실행할 수 없다는 것을 생각해보면 이해가 될 것이다. 시공유 시스템이 등장하게 된 배경이 바로 여기에 있다.\n\n## 동작 방식은??\n\n간단하게 1/100(초)마다 user1, user2, user3 프로그램을 스위칭한다고 생각하면 된다. 1/100(초) 동안 user1을 실행하고 그 다음 1/100(초) 동안 user2를 실행한다. 다중 프로그래밍이 I/O에 스위칭하는 것과 달리 시공유 시스템은 특정 시간마다 강제 전환한다. 더 나아가 1초를 기준으로 생각해보자. 1초동안 스위칭이 100번 일어나고 세 개의 프로그램이 메모리에 올라가있으므로 각 프로그램은 1초동안 33번 CPU에 할당된다. 워낙 빠르게 스위칭되어 여러 사용자가 하나의 컴퓨터를 사용하고 있음에도 혼자서 컴퓨터를 사용하는 것처럼 느껴진다.\n\n## 생각해봐야할 점은??\n\n바로 <span class=\"clr-note\">프로세스간 통신, 동기화, 가상 메모리</span>다. 하나의 컴퓨터를 여러명이 사용하다보면 서로 간에 데이터를 주고 받고 싶어진다. <code class=\"codetainer\">프로세스간 통신</code>의 등장 이유다. 또, user1, user2, user3가 거의 동시에 실행되므로 누가 앞서서 실행되는 지를 정해야하는 데 이를 <code class=\"codetainer\">동기화</code>라고 한다. 마지막으로 유저가 많아지면 메모리에 올린 프로그램이 많아져 메인 메모리가 부족해지는 경우가 생긴다. 이러한 문제를 해결하기 위해 하드디스크의 일부를 메인 메모리처럼 사용하는 <code class=\"codetainer\">가상 메모리 기술</code>이 등장했다.\n\n위에서 언급된 cpu 스케줄링, 프로세스간 통신 등은 뒤에서 상세히 공부할 예정이다.\n"}}}},"pageContext":{"id":"7597906a0b776c9b2fe7ef84398e8890c40f630f","previousPostId":"f6cb269db79cf2dc5897ed2c1c5e4e7e9526daf8","nextPostId":"57230c4640ec299d7d03355c2e48f3f78fad5edf"}},"staticQueryHashes":["2841359383"]}