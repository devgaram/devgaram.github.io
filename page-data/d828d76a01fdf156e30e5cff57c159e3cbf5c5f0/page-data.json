{"componentChunkName":"component---src-templates-blog-post-js","path":"/d828d76a01fdf156e30e5cff57c159e3cbf5c5f0","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d828d76a01fdf156e30e5cff57c159e3cbf5c5f0","text":"# git rebase\n\nDate: Apr 27, 2020\n\n- Title : git rebase\n- Date : 2020-04-27\n- Category : Git\n\n## git rebase 하기\n\n```bash\ngit checkout develop\n\ngit fetch origin develop\n\ngit checkout feature\n\ngit rebase origin/develop\n\n// conflict 발생 시 충돌 해결 후\ngit add <수정된 파일 이름>\n\ngit rebase --continue\n```\n\n- git fetch origin develop을 하면 로컬의 origin/develop 에 원격저장소 develop의 최신 커밋들이 싱크된다. 그래서 rebase 대상이 develop이 아니라 origin/develop 이다.\n- 충돌 해결 후 파일을 commit 이 아니라 **꼭 add만 해야 한다.**\n\n## git rebase 취소\n\n이미 remote 까지 push 했을 때 rebase 취소하는 방법\n\n```bash\ngit reflog <브랜치명>\n\n// 돌아가고 싶은 커밋 확인\ngit reset --hard <128e6d4>\n\ngit push -f origin <브랜치명>\n```\n\n## 생각하기\n\n### `git rebase origin/develop` 과 `git rebase develop` 의 차이점\n\n### `git fetch origin develop` 과 `git pull origin develop` 의 차이점\n\npull 은 내부적으로 `fetch + merge` 를 실행한 것과 같다. 즉 pull 을 실행하면 원격 저장소의 내용을 가져오고(fetch) 병합작업(merge)를 수행하게 된다. 만약 단순히 원격 저장소의 내용을 확인만 하고 로컬 데이터와 병합은 하고 싶지 않다면 fetch를 수행하면 된다. fetch를 하게되면 최신 커밋들은 로컬에 `FETCH_HEAD` 라는 이름으로 가져오게 된다. 이 상태에서 원격 저장소의 내용을 로컬 저장소에 통합하고 싶다면 `FETCH_HEAD` 브랜치를 merge 하거나 pull 하면 된다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"03e73fed3a9d0eacb1704fefb89e8300da18fa23","text":"# 부트스트랩의 sr-only 클래스가 하는 일\n\n- Title : 부트스트랩의 sr-only 클래스가 하는 일\n- Date : 2020-05-18\n- Category : 프론트\n\n이 글은 그저 기억하기 위한 용도로 작성했으니 참고바랍니다.\n\n부트스트랩은 `sr-only` 클래스를 사용하여 원하는 요소를 화면상에서는 사라지게 하는 동시에 웹 접근성을 높인다. 장애를 가진 사람은 스크린 리더기나 점자 타자기와 같은 보조 기구를 통해 웹을 인식하기 때문에 웹 접근성은 신경써야 할 요소 중 하나다. 간단하게 `<img>` 태그의 alt 요소에 이미지를 파악할 수 있는 텍스트를 작성하는 것만으로도 웹 접근성을 높일 수 있다. \n\n나는 체크박스(`<input type=\"checkbox>`)를 커스텀하면서 `sr-only` 를 접하게 되었다. *아마 사수가 아니었으면 웹 접근성을 신경쓰지도 않았을 텐데 덕분에 팁을 얻었다.*  작업에 대해 자세히 말하자면 체크박스를 슬라이드 토글 형태로 커스텀하는 것이었다. 작업 순서는 아래와 같다. 체크 박스에 `sr-only` 클래스를 적용하여 체크 박스를 사라지게 만들기 → `<label><div class=\"circle\"></label>` 로 style 만들기 → 체크박스 `:checked` 일 때 토글 효과 주기\n\n부트스트랩의 `sr-only` 는 다음과 같이 작성되어있다. 이를 이용하여 체크박스를 화면에서 지우면 된다.\n\n```css\n.sr-only {\n\tposition: absolute;\n\toverflow: hidden;\n\twidth: 1px;\n\theight: 1px;\n\tpadding: 0;\n\tmargin: -1px;\n\tborder: 0;\n\tclip: rect(0,0,0,0);\n}\n```\n\n `clip` 속성은 요소의 일부분만 보이게 하고 싶을 때 사용한다. 단, 요소의 `position`이 `absolute` 또는 `fixed`로 적용되어 있어야 작동된다. `sr-only` 에서 `clip` 요소는 `rect(0,0,0,0)` 으로 선언되어있는 데 이는 요소를 노출 시키지 않겠다는 의미다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d40dfa460c3404882d4c862ecddb0374d3a40df0","text":"# 자바스크립트 동작 방식 - 스레드 큐와 setTimeout()\n\nDate: Mar 31, 2020\n\n- Title : 자바스크립트 동작 방식 - 스레드 큐와 setTimeout()\n- Date : 2020-03-31\n- Category : Javascript\n\n# WHY?\n\n자바스크립트가 단일 스레드 환경에서 돌아간다는 것은 대부분의 사람들이 알고 있을 것이다. 하지만 어떻게 동작하는 지는 모르는 사람이 있다.. ~~바로..나처럼..?~~ 그런 이유로 자바스크립트가 어떻게 돌아가는 지 낱낱이 파헤쳐 봐야지!\n\n# 스레드 큐(태스크 큐)\n\n스레드 큐는 단일 스레드 환경에서 어떠한 순서로 함수나 기능을 수행할지 결정하는 목록으로 FIFO(First-In First-Out)의 정책을 가진다. 스레드 큐 덕분에 지연이 발생하더라도 들어온 순서대로 요청을 처리할 수 있다. \n\n> ✨ 여기서 말하는 지연이란? 자바스크립트는 사용자와 상호작용하는 이벤트 기반 언어라, 비동기로 동작하거나 현재 소스가 실행 중에 사용자의 입력이 들어오면 지연이 발생할 수 있다.\n\n# setTimeOut() 파헤치기\n\n🎉아래 코드에서 `buttonAddItem.onclick`, `divItems.appendChild()`, `inputCloneItem.focus()` 가 스레드 큐에 어떤 순서로 들어갈지 생각해보자.\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n      </head>\n      <body>\n        <button id=\"addItem\">Add New Input</button>\n        <div id=\"items\"></div>\n        <script>\n          (function() {\n            const divItems = document.getElementById(\"items\"),\n              buttonAddItem = document.getElementById(\"addItem\"),\n              inputItem = document.createElement(\"input\");\n            buttonAddItem.onclick = () => {\n              const inputCloneItem = inputItem.cloneNode(true);\n              inputCloneItem.value = \"Give me focus\";\n    \n              divItems.appendChild(inputCloneItem);\n              setTimeout(() => {\n                inputCloneItem.focus();\n              }, 0);\n            };\n          }());\n        </script>\n      </body>\n    </html>\n\n`setTimeout()` 함수의 두번째 파라미타를 0으로 했으니깐 버튼을 클릭하면 `divItems.appendChild(inputCloneItem)` 보다 `inputCloneItem.focus()` 가 먼저 들어가있을거라고 생각했다면...? 땡땡!!😂😂 정답은 아래와 같다. `setTimeout()` 함수를 0초 후에 호출되도록 설정하면 호출하자마자 실행되는 것이 아니라 UI 업데이트가 이루어지고 나서 호출된다. 즉, setTimeout() 함수는 특정 시간이 되면 콜백 함수를 호출하도록 실행 큐 뒤에 해당 함수를 넣는 거지 함수 자체를 호출한다는 의미가 아니다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled.png)\n\n🎉 다음 예제를 통해 `setTimeout()` 함수와 단일 스레드 환경을 명확하게 이해해보자. 방금 예제와 비슷하지만 `setTimeout()`은 버튼이 클릭되고 2초 뒤에 콜백함수로 호출하도록 했고 `sleep()` 함수를 추가해서 10초동안 while 문이 돌아가게 했다. 자, 그럼 `setTimeout()`의 콜백함수는 언제 실행될까?\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n      </head>\n      <body>\n        <button id=\"addItem\">Add New Input</button>\n        <div id=\"items\"></div>\n        <script>\n          (function() {\n            const divItems = document.getElementById(\"items\"),\n              buttonAddItem = document.getElementById(\"addItem\"),\n              inputItem = document.createElement(\"input\"),\n              divLog = document.getElementById(\"log\");\n            buttonAddItem.onclick = () => {\n              const inputCloneItem = inputItem.cloneNode(true),\n                    waitSeconds = 10;\n              \n              inputCloneItem.value = \"Give me focus\";\n    \n              divItems.appendChild(inputCloneItem);\n    \n              console.log(\"Execute setTimeout at: \\t\" + Date.now());\n              setTimeout(() => {\n                inputCloneItem.focus();\n                console.log(\"Execute setTimeout at: \\t\" + Date.now());\n              }, 2000);\n    \n              sleep(waitSeconds * 1000);\n            };\n    \n            function sleep(waitSeconds) {\n              const waitUntil = Date.now() + waitSeconds;\n              while (Date.now() < waitUntil);\n            }\n          }());\n        </script>\n      </body>\n    </html>\n\n아래의 실행결과를 보면 setTimeout() 안의 콜백함수는 2초 뒤에 실행되지않고 10초 뒤에 실행된다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%201.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%201.png)\n\nsetTimeout()의 콜백함수는 버튼 클릭 2초 후 스레드 큐에 등록되지만 버튼 클릭 핸들러 내 sleep() 함수가 다 실행되어야 순서대로 처리되기 때문에 10초보다 뒤에 실행된다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%202.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%202.png)\n\n🎉 위 예제에서 버튼 클릭 시 setTimeout() 함수를 두번 호출하도록 코드를 수정해보고 실행이 어떤식으로 되는 지 알아보자.\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n      </head>\n      <body>\n        <button id=\"addItem\">Add New Input</button>\n        <div id=\"items\"></div>\n        <script>\n          (function() {\n            const divItems = document.getElementById(\"items\"),\n              buttonAddItem = document.getElementById(\"addItem\"),\n              inputItem = document.createElement(\"input\"),\n              divLog = document.getElementById(\"log\");\n            buttonAddItem.onclick = () => {\n              const inputCloneItem = inputItem.cloneNode(true),\n                    waitSeconds = 10;\n              \n              inputCloneItem.value = \"Give me focus\";\n    \n              divItems.appendChild(inputCloneItem);\n    \n              console.log(\"onclick function invoked at: \\t\" + Date.now());\n              setTimeout(() => {\n                console.log(\"1st Execute setTimeout at: \\t\" + Date.now());\n                sleep(waitSeconds * 1000);\n              }, 2000);\n              setTimeout(() => {\n                inputCloneItem.focus();\n                console.log(\"2 Execute setTimeout at: \\t\" + Date.now());\n              }, 2000);\n    \n              sleep(waitSeconds * 1000);\n            };\n    \n            function sleep(waitSeconds) {\n              const waitUntil = Date.now() + waitSeconds;\n              while (Date.now() < waitUntil);\n            }\n          }());\n        </script>\n      </body>\n    </html>\n\n클릭 이벤트가 발생하면 setTimeout() 함수의 콜백 이벤트를 등록하고 2초 뒤에는 등록한 2개의 setTimeout() 함수가 호출된다(스레드 큐에 콜백함수가 들어간다) 이때 스레드 큐에서는 10초간 sleep()을 수행하기때문이 sleep()이 끝나고 UI 업데이트가 이루어진 후 첫번째 콜백이 실행된다. 콜백 안에 또 sleep()이 있어서 10초 뒤에 두번째 콜백이 수행된다. 즉, 두번째 setTimeout 콜백은 20초 뒤에나 실행된다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%203.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%203.png)\n\n스레드 큐는 아래와 같다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%204.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%204.png)\n\n# 결론\n\nsetTimeout() 뿐만 아니라 모든 XMLHttpRequest나 다른 콜백 이벤트가 발생했다고 해서 바로바로 현재의 스레드에 인터럽트를 걸고 실행하는 것이 아니라, **현재 실행하고 있는 스레드 큐가 끝나고 자신의 차리가 와야 실행된다**. 즉, 처리가 오래 걸리는 자바스크립트 함수가 있을 때는 호출이 이루어져야 하는 시간이 되어도 그 함수의 처리가 끝날 때까지 스레드 큐에서 대기한다."}}}},"pageContext":{"id":"d828d76a01fdf156e30e5cff57c159e3cbf5c5f0","previousPostId":"03e73fed3a9d0eacb1704fefb89e8300da18fa23","nextPostId":"d40dfa460c3404882d4c862ecddb0374d3a40df0"}},"staticQueryHashes":["2685952063","2841359383"]}