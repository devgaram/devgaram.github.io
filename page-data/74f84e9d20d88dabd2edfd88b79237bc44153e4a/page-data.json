{"componentChunkName":"component---src-templates-blog-post-js","path":"/74f84e9d20d88dabd2edfd88b79237bc44153e4a","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"74f84e9d20d88dabd2edfd88b79237bc44153e4a","text":"# 백준 - 17142 연구소3(C++)\n\n- Title : 백준 - 17142 연구소3(C++)\n- Date : 2020-01-29\n- Category: 알고리즘 풀이\n\n## 입력 받기\n\n- 연구소 상태는 N x N 이니깐 int A[N][n] 형태로 입력을 저장해야겠다.\n- 입력을 받을 때, 선택 가능한 바이러스들(값이 2인)의 row, col 값을 따로 저장할 필요가 있겠네. pair<int, int> V[10] 형태로 저장해야겠다. 바이러스 개수는 최대 10이니깐 배열의 크기는 10으로 하자.\n- 퍼트릴 수 있는 빈 칸의 개수도 카운트 해놓자. 그래야 모든 빈칸에 바이러스를 퍼트렸는 지 알 수 있으니깐.\n- 아! 퍼트린 후 연구소 상태를 원상 복귀해야하니깐 int TMP[N][n] 형태의 2차원 배열을 만들어놔야지.\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nint main() {\n  int A[50][50]; // 연구소\n  int TMP[50][50]; // 연구소 결과 처리용\n  int N, M; // N: 연구소 크기, M: 활성화할 바이러스 수\n  int tcnt = 0; // 연구소 빈칸(0)의 개수\n  pair<int, int> V[10]; // 연구소 선택 가능한 바이러스(2)의 위치\n  int vcnt = 0; // V 배열을 위한 인덱스\n  int prow[4] = {-1, 1, 0, 0}; // 상하좌우 확산 시 사용 row\n  int pcol[4] = {0, 0, -1, 1}; // 상하좌우 확산 시 사용 col\n\n  // 입력받기\n  scanf(\"%d %d\", &N, &M);\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n      TMP[i][j] = A[i][j];\n      if (A[i][j] == 2) V[vcnt++] = make_pair(i, j);\n      if (A[i][j] == 0) tcnt++;\n    }\n  }\n}\n```\n\n## 활성화할 바이러스 선택하기\n\n- DFS로 할 수도 있지만 비트 마스크로 풀어봐야지\n- 만약 5개의 바이러스 중 3개를 선택해야한다면 범위는 00111 ~ 11100 이다.\n- 근데 사실, DFS로 하는 게 코드가 간단해서... DFS가 나을 듯,, 비트 마스크로 풀다가 실수를 너무 많이 했다.\n\n```cpp\n  unsigned int flag = (1 << M) - 1; // 시작 플래그, unsigned int는 양수 범위를 가짐\n  int tcc = M;\n  unsigned int fin = 0; // 종료 플래그\n  // 종료 플래그 만들기.\n  while (tcc-- > 0) {\n    fin |= (1 <<  (vcnt - 1 - tcc));\n  }\n  unsigned int curflag = 0; // 조작용\n  int fcnt = 0;\n  int pos = 0;\n  queue<pair<int, int> > q;\n  // 시작플래그 ~ 종료플래그\n  for (flag; flag<=fin; flag++) {\n    curflag = flag;\n    fcnt = 0;\n    // 1비트 개수 세기, M개 일때만 코드 진행\n    while (curflag > 0) {\n      if (curflag & 1 == 1) fcnt++;\n      if (fcnt > M) break;\n      curflag = curflag >> 1;\n    }\n    if (fcnt != M) continue;\n\t\t// 이제 고른 바이러스 표시하기\n    curflag = flag;\n    pos = 0;\n    while (curflag > 0) {\n      if (curflag & 1 == 1) {\n        TMP[V[pos].first][V[pos].second] = -1; // 바이러스 복제\n        // 큐에 선택한 바이러스 넣기 -> 퍼트리기에서 BFS로 사용할 예정\n        q.push(make_pair(V[pos].first, V[pos].second));\n      }\n      pos++;\n      curflag = curflag >> 1;\n    }\n    // ...바이러스 퍼트리기가 이어진다.\n  }\n```\n\n## 바이러스 퍼트리기\n\n- 만약 백준에서 제출 시 100%에서 틀린다면 비활성화 바이러스도 시간 체크했는 지 살펴봐야한다.\n  여기서 엄청 헤매서 시간 다 잡아먹었다ㅠㅠ\n- 쉽게 설명하자면 대부분 BFS로 q가 빌 때까지 반복을 돌릴텐데 만약 이미 빈칸(0)에는 다 전파했는 데 q에 비활성화(선택 못 받은 바이러스)가 있다면? 이 상황을 이해한다면 오류를 잡을 수 있을 거다.\n  > 반례가 있어야 이해가 되겠죠?  \n  > 5 1  \n  > 1 1 1 1 1  \n  > 1 1 1 1 1  \n  > 1 1 1 1 1  \n  > 2 0 0 2 0  \n  > 1 1 1 1 1  \n  > answer : 2\n- 사실 q에 시간 체크용 값도 넣어버려서.. 복잡하게 풀어버린 것 같다..\n- 더 간단히 풀 수 있을 듯..\n\n```cpp\n  // ..위에는 바이러스 선택하기\n  // 시간 체크용, 현재 q에는 선택된 바이러스가 있고 얘는 0초이므로 0을 넣어준다. -1은 구분 용\n  q.push(make_pair(-1, 0));\n  spread = 0; // 퍼진 바이러스\n  time = 0; // 시간\n  stopflag = false; // 빈칸에 다 퍼트렸으면 true로 바꿀거다.\n  while (!q.empty()) {\n    // c++에서 q.pop()은 void 메소드라서 q.front()로 값 가져온다.\n    pair<int, int> po = q.front();\n    q.pop();\n    if (po.first >= 0) { // 퍼트린 칸이면\n      if (A[po.first][po.second] == 0) spread++; // 해당 칸이 원래 빈칸(0)이면 값 증가\n      if (spread == tcnt) stopflag = true; // 빈칸에 다 퍼트리면 시간체크용 값 나올 때 스탑하려고\n      for (int i=0; i<4; i++) { // 상하좌우 처리\n        nextrow = po.first + prow[i];\n        nextcol = po.second + pcol[i];\n        if (nextrow < 0 || nextrow >= N || nextcol < 0 || nextcol >= N) continue; // 범위 밖\n        if (TMP[nextrow][nextcol] == -1 || TMP[nextrow][nextcol] == 1) continue;\n        q.push(make_pair(nextrow, nextcol)); // 큐에 넣자넣자!\n        TMP[nextrow][nextcol] = -1; // 퍼트렸다는(방문했다는) 표시!\n      }\n    } else { // 시간체크용\n      time = po.second;\n      if (!q.empty()) q.push(make_pair(-1, po.second + 1));\n      if (stopflag) break; // 이미 모든 빈칸에 퍼트렸으면 나오자!\n    }\n  }\n  while (!q.empty()) // 위 반복에서 stopflag에 의해 중간에 빠져나왔을 경우를 대비해서\n  {\n    q.pop();\n  }\n  // 시간 넣자!!\n  if (spread == tcnt && ans > time) ans = time;\n```\n\n## 원상복귀\n\n- TMP는 또 써야하니깐!\n\n```cpp\nfor (int i=0; i<N; i++) {\n  for (int j=0; j<N; j++) {\n    TMP[i][j] = A[i][j];\n  }\n}\n```\n\n## 전체 코드\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <limits>\nusing namespace std;\n\n\nint A[50][50];\nint TMP[50][50];\nint N, M;\nint vcnt = 0;\nint tcnt = 0;\npair<int, int> V[10];\nint prow[4] = {-1, 1, 0, 0};\nint pcol[4] = {0, 0, -1, 1};\n\nint main() {\n  // 입력받기\n  scanf(\"%d %d\", &N, &M);\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n      TMP[i][j] = A[i][j];\n      if (A[i][j] == 2) V[vcnt++] = make_pair(i, j);\n      if (A[i][j] == 0) tcnt++;\n    }\n  }\n  unsigned int flag = (1 << M) - 1; // 시작 플래그, unsigned int는 양수 범위를 가짐\n  int tcc = M;\n  unsigned int fin = 0; // 종료 플래그\n  // 종료 플래그 만들기.\n  while (tcc-- > 0) {\n    fin |= (1 <<  (vcnt - 1 - tcc));\n  }\n  unsigned int curflag = 0; // 조작용\n  int fcnt = 0;\n  int pos = 0;\n  int nextrow = 0, nextcol = 0;\n  queue<pair<int, int> > q;\n  int spread = 0, time = 0;\n  int ans = numeric_limits<int>::max();\n  bool stopflag = false;\n  // 시작플래그 ~ 종료플래그\n  for (flag; flag<=fin; flag++) {\n    curflag = flag;\n    fcnt = 0;\n    // 1비트 개수 세기, M개 일때만 코드 진행\n    while (curflag > 0) {\n      if (curflag & 1 == 1) fcnt++;\n      if (fcnt > M) break;\n      curflag = curflag >> 1;\n    }\n    if (fcnt != M) continue;\n\t\t// 이제 고른 바이러스 표시하기\n    curflag = flag;\n    pos = 0;\n    while (curflag > 0) {\n      if (curflag & 1 == 1) {\n        TMP[V[pos].first][V[pos].second] = -1; // 바이러스 복제\n        // 큐에 선택한 바이러스 넣기 -> 퍼트리기에서 BFS로 사용할 예정\n        q.push(make_pair(V[pos].first, V[pos].second));\n      }\n      pos++;\n      curflag = curflag >> 1;\n    }\n    q.push(make_pair(-1, 0));\n    spread = 0; // 퍼진 바이러스\n    time = 0; // 시간\n    stopflag = false; // 빈칸에 다 퍼트렸으면 true로 바꿀거다.\n    while (!q.empty()) {\n      // c++에서 q.pop()은 void 메소드라서 q.front()로 값 가져온다.\n      pair<int, int> po = q.front();\n      q.pop();\n      if (po.first >= 0) { // 퍼트린 칸이면\n        if (A[po.first][po.second] == 0) spread++; // 해당 칸이 원래 빈칸(0)이면 값 증가\n        if (spread == tcnt) stopflag = true; // 빈칸에 다 퍼트리면 시간체크용 값 나올 때 스탑하려고\n        for (int i=0; i<4; i++) { // 상하좌우 처리\n          nextrow = po.first + prow[i];\n          nextcol = po.second + pcol[i];\n          if (nextrow < 0 || nextrow >= N || nextcol < 0 || nextcol >= N) continue; // 범위 밖\n          if (TMP[nextrow][nextcol] == -1 || TMP[nextrow][nextcol] == 1) continue;\n          q.push(make_pair(nextrow, nextcol)); // 큐에 넣자넣자!\n          TMP[nextrow][nextcol] = -1; // 퍼트렸다는(방문했다는) 표시!\n        }\n      } else { // 시간체크용\n        time = po.second;\n        if (!q.empty()) q.push(make_pair(-1, po.second + 1));\n        if (stopflag) break; // 이미 모든 빈칸에 퍼트렸으면 나오자!\n      }\n    }\n    while (!q.empty()) // 위 반복에서 stopflag에 의해 중간에 빠져나왔을 경우를 대비해서\n    {\n      q.pop();\n    }\n    // 시간 넣자!!\n    if (spread == tcnt && ans > time) ans = time;\n    for (int i=0; i<N; i++) {\n      for (int j=0; j<N; j++) {\n        TMP[i][j] = A[i][j];\n      }\n    }\n  }\n  if (ans == numeric_limits<int>::max()) ans = -1;\n  printf(\"%d\", ans);\n  return 0;\n}\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"16dcace2ef64f8366920a452156651609248244b","text":"# 백준 - 17837 새로운 게임2(C++)\n\n- Title : 백준 - 17837 새로운 게임2(C++)\n- Date : 2020-01-30\n- Category: 알고리즘 풀이\n\n## 생각의 흐름\n\n- 자료구조는 뭘 사용해야하지?\n- 체스는 구조체로 정의해서 배열로 저장해야겠고.. 보드판 각 칸마다 어떤 체스가 순서대로 있는 지를 표현해야하는 데.. 어떤 걸 사용할까?\n- 앞, 뒤로 pop, push 하고 싶으니깐 deque를 사용해보자..!\n  > 다 푼 후,.. <br/>\n  > 근데.. 다른 사람들 코드를 보니깐 vector를 사용했던 데 나중에 살펴봐야겠다..\n- 구조체 배열을 받을 때는 &를 사용한 참조변수를 사용하자! 그래야 수정도 가능하니깐!\n- A말이 위치한 체스칸의 큐에서 뒤부터 하나씩 빼야겠다. 단, A가 나올 때까지만!\n- 그 다음 뺀 거를 가지고 A말이 이동할 체스칸에 push_back을 해줘야겠지..?\n- 빨간색은 반대로 넣어줘야하니깐 pop_front, pop_back을 적절히 활용해봐야겠다..\n\n```cpp\n#include <iostream>\n#include <deque>\nusing namespace std;\n\nstruct Horse {\n int row, col, dir;\n};\n\nint N, K;\nint prow[4] = {0, 0, -1, 1}; //우,좌,상,하\nint pcol[4] = {1, -1, 0, 0};\n\nHorse horse[10];\nint color[12][12];\ndeque<int> board[12][12];\n\nvoid input() {\n scanf(\"%d %d\", &N, &K);\n\n for (int i=0; i<N; i++) {\n  for (int j=0; j<N; j++) {\n   scanf(\"%d\", &color[i][j]);\n  }\n }\n\n for (int i=0; i<K; i++) {\n  scanf(\"%d %d %d\", &horse[i].row, &horse[i].col, &horse[i].dir);\n  horse[i].row--, horse[i].col--, horse[i].dir--;\n  board[horse[i].row][horse[i].col].push_back(i);\n }\n}\n\nbool move(int k) {\n Horse &h = horse[k];\n int nextrow = h.row + prow[h.dir];\n int nextcol = h.col + pcol[h.dir];\n\n // 범위 밖 or 파란색\n if ((nextrow < 0 || nextcol < 0 || nextrow >= N || nextcol >= N) || color[nextrow][nextcol] == 2) {\n  // 방향 반대로\n  switch(h.dir) {\n   case 0:\n    h.dir = 1;\n    break;\n   case 1:\n    h.dir = 0;\n    break;\n   case 2:\n    h.dir = 3;\n    break;\n   case 3:\n    h.dir = 2;\n    break;\n   default: break;\n  }\n  nextrow = h.row + prow[h.dir];\n  nextcol = h.col + pcol[h.dir];\n\n  if ((nextrow < 0 || nextcol < 0 || nextrow >= N || nextcol >= N) || color[nextrow][nextcol] == 2)\n   return false;\n }\n\n deque<int> &q = board[h.row][h.col];\n deque<int> tmpq;\n int tmpk;\n while (!q.empty()) {\n  tmpk = q.back();\n  // k말 좌표 이동\n  horse[tmpk].row = nextrow;\n  horse[tmpk].col = nextcol;\n\n  // 원래 큐에서 이동할 말들 빼기\n  tmpq.push_front(tmpk);\n  q.pop_back();\n\n  if (tmpk == k) break;\n }\n deque<int> &nextq = board[nextrow][nextcol];\n // 다음 이동칸이 흰색\n if (color[nextrow][nextcol] == 0) {\n  while (!tmpq.empty()) {\n   nextq.push_back(tmpq.front());\n   tmpq.pop_front();\n  }\n } else if (color[nextrow][nextcol] == 1) { // 빨간(순서 반대로)\n  while (!tmpq.empty()) {\n   nextq.push_back(tmpq.back());\n   tmpq.pop_back();\n  }\n }\n if (nextq.size() >= 4) return true;\n else return false;\n}\n\nint main() {\n int ans = 0;\n int i;\n input();\n while (ans++ < 1000) {\n  for (i=0; i<K; i++) {\n   if (move(i)) break;\n  }\n  if (i < K) break;\n }\n\n if (ans > 1000) ans = -1;\n printf(\"%d\", ans);\n return 0;\n}\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"71b6232e760cb058f53c92719edc32233daa262c","text":"# c++로 알고리즘 풀 때 팁들\n\n- Title : c++로 알고리즘 풀 때 팁들\n- Date : 2020-01-28\n- Category: Algorithm\n\n# # 입출력\n\ncin, cout은 느려서 scanf, printf를 사용하는 걸 추천한다.\n\n```cpp\nint N, M, K;\nscanf(\"%d %d %d\", &N, &M, &K);\n```\n\n# # 2차원 배열\n\n1 2 3 4 5 <br/>\n2 3 4 5 6 <br/>\n... 방식의 입력을 받고 싶다면?\n\n```cpp\n#define MAX 10\nint A[MAX][MAX];\n\nint main() {\n\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n    }\n  }\n  return 0;\n}\n```\n\n## 2차원 deque 입력, 정렬\n\n```cpp\n#define MAX 10\ndeque<int> T[MAX][MAX];\n// ...\nint main() {\n  int x, y, age;\n\n  // 입력\n  for (int i=0; i<M; i++) {\n    scanf(\"%d %d %d\", &x, &y, &age);\n    T[--x][--y].push_back(age);\n  }\n\n  // 정렬 오름차순\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      if (T[i][j].size() > 1)\n        sort(T[i][j].begin(), T[i][j].end());\n\n    }\n  }\n\n  // 순회\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      deque<int> &tmp = T[i][j]; // 참조로 받기(수정하려면)\n      for(auto iter=tmp.begin(); iter != tmp.end();) {\n        int &t = *iter;\n        if () //삭제X\n          iter++;\n        else //삭제 O\n          iter = tmp.erase(iter); //다음 iter 받음\n\n      }\n    }\n  }\n  return 0;\n}\n```\n\n# 포인터와 참조\n\n```cpp\n// 새로운게임2 에서..\nstruct Horse {\n  int row, col, dir;\n};\n\n// 참조 변수 : 대상을 직접 할당\n// 선언과 동시에 초기화해야한다!\n// NULL 불가\nHorse &h = horse[0];\nh = horse[1]; // 에러!! (대상 변경 불가)\nprintf(\"%d\", h.row);\n\n// 포인터 변수 : 주소값 할당\nHorse *h = &horse[0];\nh = &horse[1];  // 대상 변경 가능!\nHorse *h = NULL; // NULL 가능\n\nif (h) printf(\"%d\", h->row);\n// 또는\nif (h) printf(\"%d\", (*h).row);\n```\n\n# 배열 초기화할 때, memset 함수 쓰자!\n\n- for문보다 더 빠른 속도가 나올 수 있다.\n- 특정 범위에 있는 **연속된 메모리**에 값을 지정하고 싶을 때 쓰자!\n- cstring 헤더\n\n```cpp\nvoid* memset(void *ptr, int value, size_t num);\n/*\nptr : 메모리 시작 포인터(주소) => 배열 이름\nvalue: 채울 값 => 값\nnum: 채우고자 하는 바이트 수(메모리 크기) => sizeof(배열이름)\n*/\n```\n\n```cpp\n#include <cstring>\nusing namespace std;\nint main() {\n  int C[21][21];\n  memset(C, 0, sizeof(C));\n  return 0;\n}\n```\n\n# 구조체 멤버 내용 복사하고 싶으면? memcpy를 쓰자\n\n```cpp\n#include <cstring>\nusing namespace std;\n\nstruct Horse {\n  int row, col, dir;\n};\n\nint main() {\n  Horse h1, h2;\n  h1.row = 1;\n  h1.col = 2;\n  h1.dir = 3\n\n  memcpy(&h2, &h1, sizeof(Horse)); // Horse 구조체 크기만큼 h1 내용을 h2에 복사\n  return 0;\n}\n```\n\n## 동적 할당된 경우는?\n\n```cpp\n#include <cstring>\nusing namespace std;\n\nstruct Horse {\n  int row, col, dir;\n};\n\nint main() {\n  Horse *h1 = malloc(sizeof(Horse));\n  Horse *h2= malloc(sizeof(Horse));\n  h1->row = 1;\n  h1->col = 2;\n  h1->dir = 3\n\n  memcpy(h2, h1, sizeof(Horse)); // Horse 구조체 크기만큼 h1 내용을 h2에 복사\n  return 0;\n}\n```\n\n## 또 다른 예\n\n```cpp\nHorse h1;\nHorse *h2= malloc(sizeof(Horse));\n\nmemcpy(h2, &h1, sizeof(Horse));    // 구조체 변수에서 동적 메모리로 복사\n```\n\n# 자료형\n\n정수 자료형 int는 4바이트 정보를 기록할 수 있는 자료형으로, signed int(부호가 있는 정수)를 기준으로 기록할 수 있는 양의 정수 범위는 0 ~ 2,147,483,647 (16진수로 7FFFFFFF)이다.\n\n## int 범위를 벗어나는 경우 자료형은 무엇을 쓸까?\n\n8바이트 크기를 가지는 정수 자료형 long long을 쓰는 게 좋다. signed long long을 기준으로 하면 최대 계산할 수 있는 양의 정수 범위는 0 ~ 9,223,372,036,854,775,807(16진수로 7FFFFFFFFFFFFFFF)다.\n\nlong long으로도 불가능하다면 BigInteger를 사용하면 된다.\n\n```cpp\ntypedef long long ll;\nll large, small;\n\n```\n\n# 순열관련 함수\n\nprev_permutation\n"}}}},"pageContext":{"id":"74f84e9d20d88dabd2edfd88b79237bc44153e4a","previousPostId":"16dcace2ef64f8366920a452156651609248244b","nextPostId":"71b6232e760cb058f53c92719edc32233daa262c"}},"staticQueryHashes":["2685952063","2841359383"]}