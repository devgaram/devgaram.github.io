{"componentChunkName":"component---src-templates-blog-post-js","path":"/74f84e9d20d88dabd2edfd88b79237bc44153e4a","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"74f84e9d20d88dabd2edfd88b79237bc44153e4a","text":"# 백준 - 17142 연구소3(C++)\n\n- Title : 백준 - 17142 연구소3(C++)\n- Date : 2020-01-29\n- Category: 알고리즘 풀이\n\n## 입력 받기\n\n- 연구소 상태는 N x N 이니깐 int A[N][n] 형태로 입력을 저장해야겠다.\n- 입력을 받을 때, 선택 가능한 바이러스들(값이 2인)의 row, col 값을 따로 저장할 필요가 있겠네. pair<int, int> V[10] 형태로 저장해야겠다. 바이러스 개수는 최대 10이니깐 배열의 크기는 10으로 하자.\n- 퍼트릴 수 있는 빈 칸의 개수도 카운트 해놓자. 그래야 모든 빈칸에 바이러스를 퍼트렸는 지 알 수 있으니깐.\n- 아! 퍼트린 후 연구소 상태를 원상 복귀해야하니깐 int TMP[N][n] 형태의 2차원 배열을 만들어놔야지.\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nint main() {\n  int A[50][50]; // 연구소\n  int TMP[50][50]; // 연구소 결과 처리용\n  int N, M; // N: 연구소 크기, M: 활성화할 바이러스 수\n  int tcnt = 0; // 연구소 빈칸(0)의 개수\n  pair<int, int> V[10]; // 연구소 선택 가능한 바이러스(2)의 위치\n  int vcnt = 0; // V 배열을 위한 인덱스\n  int prow[4] = {-1, 1, 0, 0}; // 상하좌우 확산 시 사용 row\n  int pcol[4] = {0, 0, -1, 1}; // 상하좌우 확산 시 사용 col\n\n  // 입력받기\n  scanf(\"%d %d\", &N, &M);\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n      TMP[i][j] = A[i][j];\n      if (A[i][j] == 2) V[vcnt++] = make_pair(i, j);\n      if (A[i][j] == 0) tcnt++;\n    }\n  }\n}\n```\n\n## 활성화할 바이러스 선택하기\n\n- DFS로 할 수도 있지만 비트 마스크로 풀어봐야지\n- 만약 5개의 바이러스 중 3개를 선택해야한다면 범위는 00111 ~ 11100 이다.\n- 근데 사실, DFS로 하는 게 코드가 간단해서... DFS가 나을 듯,, 비트 마스크로 풀다가 실수를 너무 많이 했다.\n\n```cpp\n  unsigned int flag = (1 << M) - 1; // 시작 플래그, unsigned int는 양수 범위를 가짐\n  int tcc = M;\n  unsigned int fin = 0; // 종료 플래그\n  // 종료 플래그 만들기.\n  while (tcc-- > 0) {\n    fin |= (1 <<  (vcnt - 1 - tcc));\n  }\n  unsigned int curflag = 0; // 조작용\n  int fcnt = 0;\n  int pos = 0;\n  queue<pair<int, int> > q;\n  // 시작플래그 ~ 종료플래그\n  for (flag; flag<=fin; flag++) {\n    curflag = flag;\n    fcnt = 0;\n    // 1비트 개수 세기, M개 일때만 코드 진행\n    while (curflag > 0) {\n      if (curflag & 1 == 1) fcnt++;\n      if (fcnt > M) break;\n      curflag = curflag >> 1;\n    }\n    if (fcnt != M) continue;\n\t\t// 이제 고른 바이러스 표시하기\n    curflag = flag;\n    pos = 0;\n    while (curflag > 0) {\n      if (curflag & 1 == 1) {\n        TMP[V[pos].first][V[pos].second] = -1; // 바이러스 복제\n        // 큐에 선택한 바이러스 넣기 -> 퍼트리기에서 BFS로 사용할 예정\n        q.push(make_pair(V[pos].first, V[pos].second));\n      }\n      pos++;\n      curflag = curflag >> 1;\n    }\n    // ...바이러스 퍼트리기가 이어진다.\n  }\n```\n\n## 바이러스 퍼트리기\n\n- 만약 백준에서 제출 시 100%에서 틀린다면 비활성화 바이러스도 시간 체크했는 지 살펴봐야한다.\n  여기서 엄청 헤매서 시간 다 잡아먹었다ㅠㅠ\n- 쉽게 설명하자면 대부분 BFS로 q가 빌 때까지 반복을 돌릴텐데 만약 이미 빈칸(0)에는 다 전파했는 데 q에 비활성화(선택 못 받은 바이러스)가 있다면? 이 상황을 이해한다면 오류를 잡을 수 있을 거다.\n  > 반례가 있어야 이해가 되겠죠?  \n  > 5 1  \n  > 1 1 1 1 1  \n  > 1 1 1 1 1  \n  > 1 1 1 1 1  \n  > 2 0 0 2 0  \n  > 1 1 1 1 1  \n  > answer : 2\n- 사실 q에 시간 체크용 값도 넣어버려서.. 복잡하게 풀어버린 것 같다..\n- 더 간단히 풀 수 있을 듯..\n\n```cpp\n  // ..위에는 바이러스 선택하기\n  // 시간 체크용, 현재 q에는 선택된 바이러스가 있고 얘는 0초이므로 0을 넣어준다. -1은 구분 용\n  q.push(make_pair(-1, 0));\n  spread = 0; // 퍼진 바이러스\n  time = 0; // 시간\n  stopflag = false; // 빈칸에 다 퍼트렸으면 true로 바꿀거다.\n  while (!q.empty()) {\n    // c++에서 q.pop()은 void 메소드라서 q.front()로 값 가져온다.\n    pair<int, int> po = q.front();\n    q.pop();\n    if (po.first >= 0) { // 퍼트린 칸이면\n      if (A[po.first][po.second] == 0) spread++; // 해당 칸이 원래 빈칸(0)이면 값 증가\n      if (spread == tcnt) stopflag = true; // 빈칸에 다 퍼트리면 시간체크용 값 나올 때 스탑하려고\n      for (int i=0; i<4; i++) { // 상하좌우 처리\n        nextrow = po.first + prow[i];\n        nextcol = po.second + pcol[i];\n        if (nextrow < 0 || nextrow >= N || nextcol < 0 || nextcol >= N) continue; // 범위 밖\n        if (TMP[nextrow][nextcol] == -1 || TMP[nextrow][nextcol] == 1) continue;\n        q.push(make_pair(nextrow, nextcol)); // 큐에 넣자넣자!\n        TMP[nextrow][nextcol] = -1; // 퍼트렸다는(방문했다는) 표시!\n      }\n    } else { // 시간체크용\n      time = po.second;\n      if (!q.empty()) q.push(make_pair(-1, po.second + 1));\n      if (stopflag) break; // 이미 모든 빈칸에 퍼트렸으면 나오자!\n    }\n  }\n  while (!q.empty()) // 위 반복에서 stopflag에 의해 중간에 빠져나왔을 경우를 대비해서\n  {\n    q.pop();\n  }\n  // 시간 넣자!!\n  if (spread == tcnt && ans > time) ans = time;\n```\n\n## 원상복귀\n\n- TMP는 또 써야하니깐!\n\n```cpp\nfor (int i=0; i<N; i++) {\n  for (int j=0; j<N; j++) {\n    TMP[i][j] = A[i][j];\n  }\n}\n```\n\n## 전체 코드\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <limits>\nusing namespace std;\n\n\nint A[50][50];\nint TMP[50][50];\nint N, M;\nint vcnt = 0;\nint tcnt = 0;\npair<int, int> V[10];\nint prow[4] = {-1, 1, 0, 0};\nint pcol[4] = {0, 0, -1, 1};\n\nint main() {\n  // 입력받기\n  scanf(\"%d %d\", &N, &M);\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      scanf(\"%d\", &A[i][j]);\n      TMP[i][j] = A[i][j];\n      if (A[i][j] == 2) V[vcnt++] = make_pair(i, j);\n      if (A[i][j] == 0) tcnt++;\n    }\n  }\n  unsigned int flag = (1 << M) - 1; // 시작 플래그, unsigned int는 양수 범위를 가짐\n  int tcc = M;\n  unsigned int fin = 0; // 종료 플래그\n  // 종료 플래그 만들기.\n  while (tcc-- > 0) {\n    fin |= (1 <<  (vcnt - 1 - tcc));\n  }\n  unsigned int curflag = 0; // 조작용\n  int fcnt = 0;\n  int pos = 0;\n  int nextrow = 0, nextcol = 0;\n  queue<pair<int, int> > q;\n  int spread = 0, time = 0;\n  int ans = numeric_limits<int>::max();\n  bool stopflag = false;\n  // 시작플래그 ~ 종료플래그\n  for (flag; flag<=fin; flag++) {\n    curflag = flag;\n    fcnt = 0;\n    // 1비트 개수 세기, M개 일때만 코드 진행\n    while (curflag > 0) {\n      if (curflag & 1 == 1) fcnt++;\n      if (fcnt > M) break;\n      curflag = curflag >> 1;\n    }\n    if (fcnt != M) continue;\n\t\t// 이제 고른 바이러스 표시하기\n    curflag = flag;\n    pos = 0;\n    while (curflag > 0) {\n      if (curflag & 1 == 1) {\n        TMP[V[pos].first][V[pos].second] = -1; // 바이러스 복제\n        // 큐에 선택한 바이러스 넣기 -> 퍼트리기에서 BFS로 사용할 예정\n        q.push(make_pair(V[pos].first, V[pos].second));\n      }\n      pos++;\n      curflag = curflag >> 1;\n    }\n    q.push(make_pair(-1, 0));\n    spread = 0; // 퍼진 바이러스\n    time = 0; // 시간\n    stopflag = false; // 빈칸에 다 퍼트렸으면 true로 바꿀거다.\n    while (!q.empty()) {\n      // c++에서 q.pop()은 void 메소드라서 q.front()로 값 가져온다.\n      pair<int, int> po = q.front();\n      q.pop();\n      if (po.first >= 0) { // 퍼트린 칸이면\n        if (A[po.first][po.second] == 0) spread++; // 해당 칸이 원래 빈칸(0)이면 값 증가\n        if (spread == tcnt) stopflag = true; // 빈칸에 다 퍼트리면 시간체크용 값 나올 때 스탑하려고\n        for (int i=0; i<4; i++) { // 상하좌우 처리\n          nextrow = po.first + prow[i];\n          nextcol = po.second + pcol[i];\n          if (nextrow < 0 || nextrow >= N || nextcol < 0 || nextcol >= N) continue; // 범위 밖\n          if (TMP[nextrow][nextcol] == -1 || TMP[nextrow][nextcol] == 1) continue;\n          q.push(make_pair(nextrow, nextcol)); // 큐에 넣자넣자!\n          TMP[nextrow][nextcol] = -1; // 퍼트렸다는(방문했다는) 표시!\n        }\n      } else { // 시간체크용\n        time = po.second;\n        if (!q.empty()) q.push(make_pair(-1, po.second + 1));\n        if (stopflag) break; // 이미 모든 빈칸에 퍼트렸으면 나오자!\n      }\n    }\n    while (!q.empty()) // 위 반복에서 stopflag에 의해 중간에 빠져나왔을 경우를 대비해서\n    {\n      q.pop();\n    }\n    // 시간 넣자!!\n    if (spread == tcnt && ans > time) ans = time;\n    for (int i=0; i<N; i++) {\n      for (int j=0; j<N; j++) {\n        TMP[i][j] = A[i][j];\n      }\n    }\n  }\n  if (ans == numeric_limits<int>::max()) ans = -1;\n  printf(\"%d\", ans);\n  return 0;\n}\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"16dcace2ef64f8366920a452156651609248244b","text":"# 백준 - 17837 새로운 게임2(C++)\n\n- Title : 백준 - 17837 새로운 게임2(C++)\n- Date : 2020-01-30\n- Category: 알고리즘 풀이\n\n## 생각의 흐름\n\n- 자료구조는 뭘 사용해야하지?\n- 체스는 구조체로 정의해서 배열로 저장해야겠고.. 보드판 각 칸마다 어떤 체스가 순서대로 있는 지를 표현해야하는 데.. 어떤 걸 사용할까?\n- 앞, 뒤로 pop, push 하고 싶으니깐 deque를 사용해보자..!\n  > 다 푼 후,.. <br/>\n  > 근데.. 다른 사람들 코드를 보니깐 vector를 사용했던 데 나중에 살펴봐야겠다..\n- 구조체 배열을 받을 때는 &를 사용한 참조변수를 사용하자! 그래야 수정도 가능하니깐!\n- A말이 위치한 체스칸의 큐에서 뒤부터 하나씩 빼야겠다. 단, A가 나올 때까지만!\n- 그 다음 뺀 거를 가지고 A말이 이동할 체스칸에 push_back을 해줘야겠지..?\n- 빨간색은 반대로 넣어줘야하니깐 pop_front, pop_back을 적절히 활용해봐야겠다..\n\n```cpp\n#include <iostream>\n#include <deque>\nusing namespace std;\n\nstruct Horse {\n int row, col, dir;\n};\n\nint N, K;\nint prow[4] = {0, 0, -1, 1}; //우,좌,상,하\nint pcol[4] = {1, -1, 0, 0};\n\nHorse horse[10];\nint color[12][12];\ndeque<int> board[12][12];\n\nvoid input() {\n scanf(\"%d %d\", &N, &K);\n\n for (int i=0; i<N; i++) {\n  for (int j=0; j<N; j++) {\n   scanf(\"%d\", &color[i][j]);\n  }\n }\n\n for (int i=0; i<K; i++) {\n  scanf(\"%d %d %d\", &horse[i].row, &horse[i].col, &horse[i].dir);\n  horse[i].row--, horse[i].col--, horse[i].dir--;\n  board[horse[i].row][horse[i].col].push_back(i);\n }\n}\n\nbool move(int k) {\n Horse &h = horse[k];\n int nextrow = h.row + prow[h.dir];\n int nextcol = h.col + pcol[h.dir];\n\n // 범위 밖 or 파란색\n if ((nextrow < 0 || nextcol < 0 || nextrow >= N || nextcol >= N) || color[nextrow][nextcol] == 2) {\n  // 방향 반대로\n  switch(h.dir) {\n   case 0:\n    h.dir = 1;\n    break;\n   case 1:\n    h.dir = 0;\n    break;\n   case 2:\n    h.dir = 3;\n    break;\n   case 3:\n    h.dir = 2;\n    break;\n   default: break;\n  }\n  nextrow = h.row + prow[h.dir];\n  nextcol = h.col + pcol[h.dir];\n\n  if ((nextrow < 0 || nextcol < 0 || nextrow >= N || nextcol >= N) || color[nextrow][nextcol] == 2)\n   return false;\n }\n\n deque<int> &q = board[h.row][h.col];\n deque<int> tmpq;\n int tmpk;\n while (!q.empty()) {\n  tmpk = q.back();\n  // k말 좌표 이동\n  horse[tmpk].row = nextrow;\n  horse[tmpk].col = nextcol;\n\n  // 원래 큐에서 이동할 말들 빼기\n  tmpq.push_front(tmpk);\n  q.pop_back();\n\n  if (tmpk == k) break;\n }\n deque<int> &nextq = board[nextrow][nextcol];\n // 다음 이동칸이 흰색\n if (color[nextrow][nextcol] == 0) {\n  while (!tmpq.empty()) {\n   nextq.push_back(tmpq.front());\n   tmpq.pop_front();\n  }\n } else if (color[nextrow][nextcol] == 1) { // 빨간(순서 반대로)\n  while (!tmpq.empty()) {\n   nextq.push_back(tmpq.back());\n   tmpq.pop_back();\n  }\n }\n if (nextq.size() >= 4) return true;\n else return false;\n}\n\nint main() {\n int ans = 0;\n int i;\n input();\n while (ans++ < 1000) {\n  for (i=0; i<K; i++) {\n   if (move(i)) break;\n  }\n  if (i < K) break;\n }\n\n if (ans > 1000) ans = -1;\n printf(\"%d\", ans);\n return 0;\n}\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"6c5737bcef4046d74738a7a56d218a7a8c80d728","text":"# 백준 - 16235 나무 재테크(C++)\n\n- Title : 백준 - 16235 나무 재테크(C++)\n- Date : 2020-01-28\n- Category: 알고리즘 풀이\n\n# 나무 재테크\n\n- 각 계절을 구현하는 데는 어려움이 없었으나 처음에 벡터 하나에 나무를 다 저장하고 매번 sort를 해서 시간 초과가 발생했었다.\n- 고민하다가 각 칸마다 deque에 나무 나이를 담는 식으로 바꿨다.\n- vector가 아닌 deque를 선택한 건 가을(번식)때 생성되는 나무는 나이가 1이므로 맨 앞에 추가되어야하기 때문이다.\n- vector는 배열이라 맨 앞 추가할 때 O(N)의 시간복잡도가 발생한다.\n- deque로 바꿨기에 처음 1번만 sort를 사용하여 효율성을 높였다.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <deque>\nusing namespace std;\n\n#define MAX 10\n\nint N, M, K;\nint A[MAX][MAX]; // 로봇 양분\nint L[MAX][MAX]; // 땅\ndeque<int> T[MAX][MAX]; // 각 땅의 나무 나이\n\nvoid addTree(int r, int c){\n\tif (r < 0 || c < 0 || r >= N || c >= N) return;\n\tT[r][c].push_front(1);\n}\n\nint main() {\n\tint x, y, age;\n\tscanf(\"%d %d %d\", &N, &M, &K);\n\n\tfor (int i=0; i<N; i++) {\n\t\tfor (int j=0; j<N; j++) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t\tL[i][j] = 5;\n\t\t}\n\t}\n\tfor (int i=0; i<M; i++) {\n\t\tscanf(\"%d %d %d\", &x, &y, &age);\n\t\tT[--x][--y].push_back(age);\n\t}\n\n\tfor (int i=0; i<N; i++) {\n\t\tfor (int j=0; j<N; j++) {\n\t\t\tif (T[i][j].size() > 1) {\n\t\t\t\tsort(T[i][j].begin(), T[i][j].end());\n\t\t\t}\n\t\t}\n\t}\n\n\tbool flag;\n\twhile(K-- > 0) {\n\n\t\t// 같은 칸이면 어린 순으로 나이만큼 양분먹고 나이 증가\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tdeque<int> &tmp = T[i][j];\n\t\t\t\tflag = true;\n\t\t\t\tfor(auto iter=tmp.begin(); iter != tmp.end();) {\n\t\t\t\t\tint &t = *iter;\n\t\t\t\t\tif (L[i][j] >= t && flag) {\n\t\t\t\t\t\tL[i][j] -= t;\n\t\t\t\t\t\tt += 1;\n\t\t\t\t\t\titer++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t// 여름 처리\n\t\t\t\t\t\tL[i][j] += t / 2;\n\t\t\t\t\t\titer = tmp.erase(iter);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\t// 나이 5의 배수 나무 번식\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tdeque<int> &tmp = T[i][j];\n\t\t\t\tfor(auto iter=tmp.begin(); iter != tmp.end(); iter++) {\n\t\t\t\t\tint t = *iter;\n\t\t\t\t\tif (t % 5 == 0) {\n\t\t\t\t\t\taddTree(i - 1, j - 1);\n\t\t\t\t\t\taddTree(i - 1, j);\n\t\t\t\t\t\taddTree(i - 1, j + 1);\n\t\t\t\t\t\taddTree(i, j - 1);\n\t\t\t\t\t\taddTree(i, j + 1);\n\t\t\t\t\t\taddTree(i + 1, j - 1);\n\t\t\t\t\t\taddTree(i + 1, j);\n\t\t\t\t\t\taddTree(i + 1, j + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 로봇이 양분 추가\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tfor (int j=0; j<N; j++) {\n\t\t\t\tL[i][j] += A[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i=0; i<N; i++) {\n\t\tfor (int j=0; j<N; j++) {\n\t\t\tans += T[i][j].size();\n\t\t}\n\t}\n\tprintf(\"%d\", ans);\n\n\treturn 0;\n}\n```\n"}}}},"pageContext":{"id":"74f84e9d20d88dabd2edfd88b79237bc44153e4a","previousPostId":"16dcace2ef64f8366920a452156651609248244b","nextPostId":"6c5737bcef4046d74738a7a56d218a7a8c80d728"}},"staticQueryHashes":["2685952063","2841359383"]}