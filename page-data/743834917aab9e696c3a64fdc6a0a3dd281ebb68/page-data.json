{"componentChunkName":"component---src-templates-blog-post-js","path":"/743834917aab9e696c3a64fdc6a0a3dd281ebb68","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"743834917aab9e696c3a64fdc6a0a3dd281ebb68","text":"# 백준 - 17779 게리멘더링2(C++)\n\n- Title : 백준 - 17779 게리멘더링2(C++)\n- Date : 2020-01-31\n- Category: 알고리즘 풀이\n\n## 생각의 흐름\n\n- x, y, d1, d2를 정해야되서 4중 포문을 써야지.. 시간 초과가 나려나.. 일단 해본 후에 최적화하자 --> 시간 초과 발생하지 않음\n\n```cpp\n#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint N;\nint total = 0;\nint A[21][21]; // 인풋용\nint C[21][21]; // 각 구역 표시 용도\nint S[6] ={0, 0, 0, 0, 0, 0}; // 1~5 구역 인구수 합 표시\nint prow[4] = {1, -1, 0, 0};\nint pcol[4]= {0, 0, -1, 1};\nint ans = 40001;\n\n// 구역 그리기\nvoid dfs(int sx, int sy, int ex, int ey, int area) {\n // 좌표가 범위 밖인 경우\n if (sx < 1 || sy < 1 || sx > ex || sy > ey) return;\n if (C[sx][sy] > 0) return; // 이미 다른 구역인 경우\n S[area] += A[sx][sy]; // 인구 수 더하기\n C[sx][sy] = area; // 구역 방문했다는 표시\n for (int i=0; i<4; i++) { // 상하좌우\n  dfs(sx + prow[i], sy + pcol[i], ex, ey, area);\n }\n}\nvoid dividearea(int x, int y, int d1, int d2) {\n int tx, ty;\n memset(C, 0, sizeof(C));\n memset(S, 0, sizeof(S));\n\n /* 경계선 그리기 */\n // 경계선 1, 4번 조건\n for (tx=x, ty=y; tx<=x+d1 && ty>=y-d1; tx++, ty--) {\n  C[tx][ty] = 5, C[tx+d2][ty+d2] = 5;\n  S[5] += A[tx][ty] + A[tx+d2][ty+d2];\n }\n // 경계선 2, 3번 조건\n for (tx=x, ty=y; tx<=x+d2 && ty<=y+d2; tx++, ty++) {\n  C[tx][ty] = 5, C[tx+d1][ty-d1] = 5;\n  S[5] += A[tx][ty] + A[tx+d1][ty-d1];\n }\n\n // 각 구역 인구수 세기\n // 문제에서 주어진 조건대로 시작 좌표와 종료 좌표 입력\n dfs(1, 1, x+d1-1, y, 1); // 1번 구역\n dfs(1, y+1, x+d2, N, 2); // 2번 구역\n dfs(N, 1, N, y-d1+d2-1, 3); // 3번 구역\n dfs(N, N, N, N, 4); // 4번 구역\n\n // 경계선 내부 인구수 계산\n // 위 dfs로 인해 S[]에 인구수 합이 있으므로 얘를 이용하면 경계선 내부 인구 수 알 수 있다.\n int inside= total;\n for (int i=1; i<=5; i++) {\n  inside -= S[i];\n }\n S[5] += inside;\n\n // 최댓값, 최솟값, 정답 구하기\n int largest = 0, smallest = 40001;\n for (int i=1; i<=5; i++) {\n  largest = max(largest, S[i]);\n   smallest = min(smallest, S[i]);\n }\n ans = min(ans, largest - smallest);\n\n}\n\n// x, y, d1, d2 구하기 == 경계썬 구하기\nvoid selectval() {\n int x, y, d1, d2;\n for (x=1; x<=N; x++) {\n  for (y=1; y<=N; y++) {\n   for (d1=1; d1<N; d1++) {\n    for (d2=1; d2<N; d2++) {\n     if (x + d1 + d2 <= N && 1 <= y - d1 && y + d2 <= N) {\n      dividearea(x, y, d1, d2);\n     } else break;\n    }\n   }\n  }\n }\n}\nint main() {\n scanf(\"%d\", &N);\n for (int i=1; i<=N; i++) {\n  for (int j=1; j<=N; j++) {\n   scanf(\"%d\", &A[i][j]);\n   total += A[i][j]; // 나중에 경계선 내부 인구 수 계산할 때 쓰려고 전체 인구수를 저장해놓음\n  }\n }\n selectval();\n printf(\"%d\", ans);\n return 0;\n}\n\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"77ee51be00a66cb386e84663fe372b319859e4f3","text":"# 알고리즘 개념 잡자 - 그래프\n\n- Title : 알고리즘 개념 잡자 - 그래프\n- Date : 2020-02-01\n- Category: Algorithm\n\n> 참고서적\n>\n> - [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539)\n\n<br/>\n\n# 1. 그래프(graph)란\n\n- 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조다.\n- 정점(vertex)과 간선(edge)들의 집합으로 구성된다 => G = (V, E)\n- 정점 == 객체 == 노드, 간선 == 관계 == 노드\n- 그래프로 표현할 수 있는 것들) 도로, 영역 간 인접 관계, 선수 과목\n- 간선의 종류에 따라 무방향 그래프와 방향 그래프로 구분된다.\n\n> **오일러 경로**\n>\n> - 모든 간선을 한번만 통과하면서 처음 정점으로 되돌아오는 경로다.\n> - 그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 오일러 경로가 존재한다.\n\n# 2. 그래프 용어정리\n\n- 가중치 그래프(네트워크) : 간선에 비용이나 가중치가 할당된 그래프\n- 차수(degree) : 정점이 가지고 있는 인접 링크의 수\n- 인접 정점(adjacent vertex) : 간선에 의해 직접 연결된 정점\n  - 무방향 그래프에서 정점의 차수(degree)는 인접 정점의 수다.\n  - 무방향 그래프에 존재하는 정점의 모든 차수를 합하면 그래프의 간선 수의 2배가 된다.\n- 방향 그래프 : 간선에 방향성이 존재하는 그래프\n  - 집입 차수(in-degree) : 외부에서 오는 간선 수\n  - 진출 차수(out-degree) : 외부로 향하는 간선 수\n  - 정점의 진입 차수와 진출 차수의 합은 방향 그래프의 간선의 수가 된다.\n- 경로 길이(path length) : 경로를 구성하는 데 사용된 간선의 수\n  - 단순 경로(simple path) : 경로 중에서 반복되는 간선이 없는 경우\n  - 사이클(cycle) : 단순 경로의 시작 정점과 종료 정점이 동일한 경우\n- 연결 그래프(connected graph) : 무방향 그래프에 있는 모든 정점에 대해 항상 경로가 존재하면 그래프는 연결되어 있다고 한다.\n  - 그래프의 어느 두 정점을 선택해도 그 사이에 경로가 존재하면 연결 그래프다.\n  - 트리는 그래프의 특수한 형태로 사이클을 가지지 않는 연결 그래프이다.\n- 완전 그래프(complete graph) : 그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프\n  - 무방향 완전 그래프의 정점 수가 n이면 하나의 정점은 n-1개의 다른 정점으로 연결되므로 간선의 수는 n x (n-1)/2가 된다.\n\n# 3. 그래프의 구현\n\n## 1) 인접 행렬(adjacency matrix)\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-23-img/1.png)<br/>\n\n- 2차원 배열로 표현\n- n개의 정점을 가지는 그래프를 표현하기 위해서는 n<sup>2</sup>의 메모리 공간이 필요해서 간선이 많이 존재하는 밀집 그래프를 표현하는 경우에 적합하다.\n- 간선 수가 적은 최소 그래프의 경우에는 메모리의 낭비가 크므로 부적합하다.\n- 두 정점을 연결하는 간선의 존재 여부를 O(1) 시간 안에 알 수 있다.\n- 정점의 차수는 인접 행렬의 행이나 열을 조사하면 알 수 있으므로 O(n)의 연산에 알 수 있다.\n- 정점 i에 대한 차수는 인접 행렬의 i번째 행에 있는 값을 모두 더하면 된다.\n- 그래프에 존재하는 모든 간선의 수를 알아내려면 인접 행렬 전체를 조사해야하므로 O(n<sup>2</sup>)의 시간이 요구된다.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n  int n, m; // n: 정점개수, m: 간선 개수\n  int v1, v2, d, c; // v1: 정점1, v2: 정점2, d: 0(무방향) 1(v1->v2), c: 간선 가중치 (1이상)\n  scanf(\"%d %d\", &n, &m);\n\n  int graph[n+1][n+1] = {0}; // 0으로 초기화\n\n  for (int i=0; i<m+1; i++) {\n    scanf(\"%d %d %d %d\", &v1, &v2, &d, &c);\n    if (d == 0) {\n      graph[v1][v2] = graph[v2][v1] = c;\n    } else {\n      graph[v1][v2] = c;\n    }\n  }\n\n  return 0;\n}\n```\n\n## 2) 인접 리스트(adjacency list)\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-02-23-img/2.png)<br/>\n\n- 각 정점에 인접한 정점들을 연결리스트로 표현\n- 각 연결 리스트들은 헤드 포인터를 가지고 있고 이 헤드 포인터들은 하나의 배열로 구성되어 있어 정점의 번호만 알면 이 번호를 배열의 인덱스로 하여 각 정점의 연결리스트에 쉽게 접근할 수 있다.\n- 정점의 수가 n개고 간선의 수가 e개인 무방향 그래프를 표시하기 위해서는 n개의 연결 리스트가 필요하고 n개의 헤드 포인터와 2e개의 노드가 필요하다.\n- 간선의 개수가 적은 희소 그래프의 표현에 적합하다.\n- 간선의 존재 여부나 정점 i의 차수를 알기 위해서는 정점 i의 연결리스트를 탐색해야 하므로 연결리스트에 있는 노드의 수만큼(정점 차수만큼)의 시간이 필요하다.\n- n개의 정점, e개의 간선을 가진 그래프의 전체 간선 수를 알아내려면 O(n+e)의 연산이 요구된다.\n\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main() {\n  int n, m;\n  int v1, v2, d, c;\n  scanf(\"%d %d\", &n, &m);\n\n  vector<pair<int, int> > graph[n+1];\n\n  for (int i=0; i<m+1; i++) {\n    scanf(\"%d %d %d %d\", &v1, &v2, &d, &c);\n    if (d == 0) { // 무방향\n      graph[v1].push_back(make_pair(v2, c));\n      graph[v2].push_back(make_pair(v1, c));\n    } else {\n      graph[v1].push_back(make_pair(v2, c));\n    }\n  }\n}\n```\n\n# 4. 그래프 탐색\n\n- 그래프에서 모든 노드를 방문하고 싶다면?\n  - DFS, BFS 중 아무거나 사용해도 상관없으나 DFS가 좀 더 간단하긴 하다.\n- 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶다면?\n  - BFS가 일반적으로 더 낫다.\n  - DFS는 경로를 찾을 수는 있겠지만 모든 노드를 탐색해야할지도 모르고 최단 경로가 아닐 수도 있다.\n\n## 1) 깊이 우선 탐색(DFS)\n\n> 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 가다가 더 이상 갈 수 없게 되면 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색을 진행하는 방법과 유사하다.\n\n- 순환 호출이나 명시적 스택을 사용한다.\n- 전위 순회를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류다.\n- 그래프 탐색의 경우는 어떤 노드를 방문했었는지 여부를 반드시 검사해야한다. 이를 검사하지 않으면 무한 루프에 빠질 위험이 있다.\n- 정점의 수가 n, 간선의 수가 e인 그래프를 깊이 우선 탐색하는 시간은? (힌트 : 모든 간선을 조사한다.)\n  - 인접리스트 : O(n+e)\n  - 인접행렬 : O(n<sup>2</sup>)\n\n**인접 행렬로 표현된 무방향 그래프 DFS**\n\n```cpp\n#include <iostream>\n#define MAX_V 20; // 정점 최대 값\nusing namespace std;\n\nint n; // 입력받은 정점의 수\n\nvoid dfs(int graph[][MAX_V], int visited[], int v) {\n  visited[v] = true;\n  printf(\"%d\", v);\n  for (int i=0; i<n+1; i++) {\n    if (graph[v][i] == 1 && !visited[i]) dfs(graph, visited, i);\n  }\n}\n```\n\n## 2) 너비 우선 탐색(BFS)\n\n- 큐를 사용한다.\n- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.\n\n**인접 행렬로 표현된 무방향 그래프 BFS**\n\n```cpp\n#include <iostream>\n#include <queue>\n#define MAX_V 20; // 정점 최대 값\nusing namespace std;\n\nint n; // 입력받은 정점의 수\n\nvoid bfs(int graph[][MAX_V], int visited[], int v) {\n  visited[v] = true;\n  queue<int> q;\n  q.push(v);\n\n  while(!q.empty()) {\n    int top = q.front();\n    q.pop();\n    printf(\"%d\", top);\n\n    for (int i=0; i<n+1; i++) {\n      if (graph[v][i] == 1 && !visited[i]) {\n        q.push(i);\n        visited[i] = true;\n      }\n    }\n  }\n\n}\n\n```\n\n## 3) 양방향 탐색\n\n- 출발지와 도착지 사이에 최단 경로를 찾을 때 사용한다.\n- 출발지, 도착지 두 노드에서 동시에 너비 우선 탐색을 수행한 뒤, 두 탐색 지점이 충돌하는 경우에 경로를 찾는 방법이다.\n- 두 탐색 알고리즘이 대략 d/2 단계(s와 t 사이의 중간 지점)에서 충돌하여 각 출발지와 도착지 노드의 방문 노드의 개수는 대략 k<sup>d/2</sup>가 된다. (k : 각 노드의 인접 노드의 개수)\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"16dcace2ef64f8366920a452156651609248244b","text":"# 백준 - 17837 새로운 게임2(C++)\n\n- Title : 백준 - 17837 새로운 게임2(C++)\n- Date : 2020-01-30\n- Category: 알고리즘 풀이\n\n## 생각의 흐름\n\n- 자료구조는 뭘 사용해야하지?\n- 체스는 구조체로 정의해서 배열로 저장해야겠고.. 보드판 각 칸마다 어떤 체스가 순서대로 있는 지를 표현해야하는 데.. 어떤 걸 사용할까?\n- 앞, 뒤로 pop, push 하고 싶으니깐 deque를 사용해보자..!\n  > 다 푼 후,.. <br/>\n  > 근데.. 다른 사람들 코드를 보니깐 vector를 사용했던 데 나중에 살펴봐야겠다..\n- 구조체 배열을 받을 때는 &를 사용한 참조변수를 사용하자! 그래야 수정도 가능하니깐!\n- A말이 위치한 체스칸의 큐에서 뒤부터 하나씩 빼야겠다. 단, A가 나올 때까지만!\n- 그 다음 뺀 거를 가지고 A말이 이동할 체스칸에 push_back을 해줘야겠지..?\n- 빨간색은 반대로 넣어줘야하니깐 pop_front, pop_back을 적절히 활용해봐야겠다..\n\n```cpp\n#include <iostream>\n#include <deque>\nusing namespace std;\n\nstruct Horse {\n int row, col, dir;\n};\n\nint N, K;\nint prow[4] = {0, 0, -1, 1}; //우,좌,상,하\nint pcol[4] = {1, -1, 0, 0};\n\nHorse horse[10];\nint color[12][12];\ndeque<int> board[12][12];\n\nvoid input() {\n scanf(\"%d %d\", &N, &K);\n\n for (int i=0; i<N; i++) {\n  for (int j=0; j<N; j++) {\n   scanf(\"%d\", &color[i][j]);\n  }\n }\n\n for (int i=0; i<K; i++) {\n  scanf(\"%d %d %d\", &horse[i].row, &horse[i].col, &horse[i].dir);\n  horse[i].row--, horse[i].col--, horse[i].dir--;\n  board[horse[i].row][horse[i].col].push_back(i);\n }\n}\n\nbool move(int k) {\n Horse &h = horse[k];\n int nextrow = h.row + prow[h.dir];\n int nextcol = h.col + pcol[h.dir];\n\n // 범위 밖 or 파란색\n if ((nextrow < 0 || nextcol < 0 || nextrow >= N || nextcol >= N) || color[nextrow][nextcol] == 2) {\n  // 방향 반대로\n  switch(h.dir) {\n   case 0:\n    h.dir = 1;\n    break;\n   case 1:\n    h.dir = 0;\n    break;\n   case 2:\n    h.dir = 3;\n    break;\n   case 3:\n    h.dir = 2;\n    break;\n   default: break;\n  }\n  nextrow = h.row + prow[h.dir];\n  nextcol = h.col + pcol[h.dir];\n\n  if ((nextrow < 0 || nextcol < 0 || nextrow >= N || nextcol >= N) || color[nextrow][nextcol] == 2)\n   return false;\n }\n\n deque<int> &q = board[h.row][h.col];\n deque<int> tmpq;\n int tmpk;\n while (!q.empty()) {\n  tmpk = q.back();\n  // k말 좌표 이동\n  horse[tmpk].row = nextrow;\n  horse[tmpk].col = nextcol;\n\n  // 원래 큐에서 이동할 말들 빼기\n  tmpq.push_front(tmpk);\n  q.pop_back();\n\n  if (tmpk == k) break;\n }\n deque<int> &nextq = board[nextrow][nextcol];\n // 다음 이동칸이 흰색\n if (color[nextrow][nextcol] == 0) {\n  while (!tmpq.empty()) {\n   nextq.push_back(tmpq.front());\n   tmpq.pop_front();\n  }\n } else if (color[nextrow][nextcol] == 1) { // 빨간(순서 반대로)\n  while (!tmpq.empty()) {\n   nextq.push_back(tmpq.back());\n   tmpq.pop_back();\n  }\n }\n if (nextq.size() >= 4) return true;\n else return false;\n}\n\nint main() {\n int ans = 0;\n int i;\n input();\n while (ans++ < 1000) {\n  for (i=0; i<K; i++) {\n   if (move(i)) break;\n  }\n  if (i < K) break;\n }\n\n if (ans > 1000) ans = -1;\n printf(\"%d\", ans);\n return 0;\n}\n```\n"}}}},"pageContext":{"id":"743834917aab9e696c3a64fdc6a0a3dd281ebb68","previousPostId":"77ee51be00a66cb386e84663fe372b319859e4f3","nextPostId":"16dcace2ef64f8366920a452156651609248244b"}},"staticQueryHashes":["2685952063","2841359383"]}