{"componentChunkName":"component---src-templates-blog-post-js","path":"/f2032027a41318246789d128d0d9c7c3692f528d","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f2032027a41318246789d128d0d9c7c3692f528d","text":"# call()과 apply()\n\n- Title : call()과 apply()\n- Date : 2018-01-08\n- Category: Javascript\n\ncall() 과 apply() 메서드를 이용하여 명시적으로 this에 바인딩할 수 있습니다.\n\n모든 함수의 부모 객체인 Function.prototype 객체의 메서드라서 모든 함수에서 호출 가능합니다.\n\n## Function.prototype.apply()\n\n```javascript\nfun.apply(thisArg, [argArray]);\n```\n\nfun 메서드를 호출할 때, fun 내부의 this를 매개변수인 thisArg로 바인딩 시킵니다.\nargArray는 fun 메서드에서 인자로 사용됩니다.  \n<span class=\"clr-grey\">argArray : 배열리터럴, Array 객체</span>\n\n## Function.prototype.call()\n\n```javascript\nfun.call(thisArg[,arg1[,arg2[,....]]])\n```\n\napply와 기능이 같으며, 배열형태가 아닌 각각의 하나의 인자형태로 값을 넘긴다는 차이점이 있습니다.\n\n# 추가 개념\n\n## 객체의 메서드를 호출할 때, 객체 메서드 내부의 this는?\n\n해당 메서드를 호출한 객체\n\n## 함수를 호출할 때, 함수 내부의 this는?\n\n전역객체에 바인딩 된다. window \\*내부함수를 호출했을 때도, 내부 this는 window!\n\n## 생성자 함수를 호출할 때, 생성자 함수 내부의 this는?\n\n생성자 함수 코드가 실행되기 전 생성되는 빈 객체  \n이 객체는 부모인 프로토타입과 연결되어있으므로 부모의 프로퍼티와 메서드를 사용할 수 있다.\n\n```javascript\nfunction Person() {\n  this.age = 0; // (1)\n  setInterval(function growUp() {\n    this.age++; // (2)\n  }, 1000);\n}\nvar p = new Person();\n```\n\n(1)의 this는 생성자 함수를 호출하면서 만들어지는 빈 객체  \n(2)의 this는 window 전역객체를 가르킨다.\n\n그래서, 위의 코드는 1초마다 나이가 1씩 증가하는 결과를 얻을 수 없다.\n\n그렇다면, (2)가 Person 생성자로 만들어진 객체로 바인딩되게 하고 싶으며 어떻게 해야할까?\n\n아래 코드와 같이 비전역 변수에 할당하여 해결할 수 있다.\n\n```javascript\nfunction Person() {\n  var that = this;\n  that.age = 0;\n\n  setInterval(function growUp() {\n    that.age++;\n  }, 1000);\n}\n```\n\nES6의 화살표 함수를 이용하면 비전역 변수를 이용하지 않고도 생성자 객체에 바인딩 시킬 수 있다.  \n화살표 함수는 자신만의 this를 생성하지 않기 때문이다!!\n\n```javascript\nfunction Person() {\n  this.age = 0;\n\n  setInterval(() => {\n    this.age++;\n  }, 1000);\n}\n```\n\n위 화살표 함수 내 this는 정확히 Person() 생성자를 통해 생성된 객체를 가리키게 된다!\n\n[출처](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98)\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"ce15b2faaa11ddc0a404c2e65bec3c53a4496c9f","text":"# [생활코딩] Javascript 입문1\n\n- Title : [생활코딩] Javascript 입문1\n- Date : 2018-01-09\n- Category: Javascript\n\n생활코딩 URL : https://opentutorials.org/course/743  \n생활코딩 강의에서 기억하고 싶었던 내용을 포스팅해보았다.\n\n# 변수의 효용을 이해하자.\n\n- 필요에 의해서 변할 수 있는 영역과 변하지 않는 영역을 구분해서 코딩해야한다.\n- 재활용 가능해진다. 유지보수 용이해진다.\n\n# 비교\n\n```javascript\nalert(1 === \"1\"); //false    데이터타입[형식]도 동일해야함.**이걸쓰자!\nalert(1 == \"1\"); //true     버그발생 가능성 높음..\n\nvar a;\nalert(a); //undefined 값이 정의되지 않음\nalert(undefined == null); //true\nalert(undefined === null); //false\nalert(true == 1); //true **숫자 1은 true로 간주, 그 외는 false로.\nalert(true === 1); //false\nalert(NaN === NaN); //false\n```\n\n## [데이터타입]\n\nundefined : 값이 정의되지 않은 상태, 프로그래머가 의도하지 않음 false로 간주  \nnull : 값이 없는 상태, 프로그래머가 의도함. false로 간주  \nNaN : 0/0 계산할 수 없음. false로 간주\n\n# 조건문\n\nif('') alert('빈문자열'); //false 빈문자열은 false/ 문자열있으면 true로 간주\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"932dabc45fc6e6a76d7adfeaaaf283051305af67","text":"---\ntitle: Koa 가이드 \ndate: 2020-01-04\ntags: koa\ncategory: nodejs\n---\n\n> 원본 [Koa user guide](https://github.com/koajs/koa/blob/master/docs/guide.md)\n\n---\n\n# 가이드\n\n이 가이드는 미들웨어 사용법과 애플리케이션 구조에 대해서 다룬다.\n예제의 미들웨어에서는 async 함수를 사용한다. 물론 commonFunction 또는 generatorFunction을 사용할 수도 있다.\n\n## 목차\n\n- [미들웨어 사용법](#미들웨어-사용법)\n- [미들웨어 표준 사용법](#미들웨어-표준-사용법)\n  - [미들웨어 옵션들](#미들웨어-옵션들)\n  - [미들웨어 이름 지정](#미들웨어-이름-지정)\n  - [koa-compose를 통해 다양한 미들웨어 조합하기](#koa-compose를-통해-다양한-미들웨어-조합하기)\n  - [미들웨어 Response](#미들웨어-Response)\n- [Async operations](#async-operations)\n- [Debugging Koa](#debugging-koa)\n\n# 미들웨어 사용법\n\n  Koa 미들웨어는 (ctx, next) 같은 파라미터를 가진 `MiddlewareFunction` 반환하는 간단한 함수다. 미들웨어가 동작할 때, 반드시 `next()` 를 통해 다음 미들웨어로 갈 수 있다. \n\n만약 Koa를 통해 전파되는 request 소요 시간을 추적하고 싶다면 다음과 같이 `X-Response-Time`  헤더에 시간을 셋팅하면 된다.\n\n```js\nasync function responseTime(ctx, next) {\n  const start = Date.now();\n  await next();\n  const ms = Date.now() - start;\n  ctx.set('X-Response-Time', `${ms}ms`);\n}\n\napp.use(responseTime);\n```\n\n프론트엔드 개발자는 `next()` 전의 코드를 \"capture\" 단계로 `next()` 후의 코드를 \"bubble\" 단계로 생각할 수 있다.  아래의 이미지는 어떻게 async 함수로 request, reponse 구현을 스택 플로우로 활용할 수 있는 지 설명해준다.\n\n![Koa middleware](/assets/images/2020-01-04-img/middleware.gif)\n\n   1. response time 생성\n   2. Await를 통해 다음 미들웨어로\n   3. 소요시간 계산을 위해 또 다른 time을 생성\n   4. Await를 통해 다음 미들웨어로\n   5. response body에 \"Hello World\" 셋팅\n   6. 소요시간 계산\n   7. 로그로 출력\n   8. 응답시간 계산\n   9. `X-Response-Time`  헤더 필드에 값 셋팅\n   10. Koa로 이동하여 response 전달 \n\n이제 우리는 Koa 미들웨어를 생성하는 방법에 대해 알아볼 것이다.\n\n## 미들웨어 표준 사용법\n\n이 섹션은 미들웨어 옵션, 디버깅 등을 위한 미들웨어 사용 방법에 대해 다룬다.\n\n### 미들웨어 옵션들\n\n공용 미들웨어를 생성할 때 옵션을 허용하여 편리하게 함수를 확장하여 미들웨어를 랩핑할 수 있다.  미들웨어에서 옵션을 허용하지 않을 수도 있는 데, 이는 좋은 표준이기도 하다.\n\n여기 `logger` 미들웨어는 커스텀을 위해 `format`을 이용하여 값을 셋팅 후 문자열로 리턴한다.\n\n```js\nfunction logger(format) {\n  format = format || ':method \":url\"';\n\n  return async function (ctx, next) {\n    const str = format\n      .replace(':method', ctx.method)\n      .replace(':url', ctx.url);\n\n    console.log(str);\n\n    await next();\n  };\n}\n\napp.use(logger());\napp.use(logger(':method :url'));\n```\n\n### 미들웨어 이름 지정\n\n미들웨어의 이름을 지정하는 것은 선택사항이나 이름을 사용하면 디버깅 목적으로 사용할 때 유용하다.\n\n```js\nfunction logger(format) {\n  return async function logger(ctx, next) {\n\n  };\n}\n```\n\n### koa-compose를 통해 다양한 미들웨어 조합하기\n\n[koa-compose](https://github.com/koajs/compose) 를 사용하면 여러 개의 미들웨어를 조립하여 하나의 미들웨어로 사용할 수 있다. 미들웨어를 재사용하거나 export할 때 유리하다. \n\n```js\nconst compose = require('koa-compose');\n\nasync function random(ctx, next) {\n  if ('/random' == ctx.path) {\n    ctx.body = Math.floor(Math.random() * 10);\n  } else {\n    await next();\n  }\n};\n\nasync function backwards(ctx, next) {\n  if ('/backwards' == ctx.path) {\n    ctx.body = 'sdrawkcab';\n  } else {\n    await next();\n  }\n}\n\nasync function pi(ctx, next) {\n  if ('/pi' == ctx.path) {\n    ctx.body = String(Math.PI);\n  } else {\n    await next();\n  }\n}\n\nconst all = compose([random, backwards, pi]);\n\napp.use(all);\n```\n\n### 미들웨어 Response\n\n미들웨어는 요청에 대한 응답을 위해 `next()`를 생략할지도 모른다. 일반적으로 `next()`는 미들웨어의 라우팅을 결정하나 다음과 같은 작업을 한다.\n예를 들어 아래의 코드는 요청에 대해 \"two\"를 응답하나 3개의 미들웨어 모두 실행된다. 3개의 미들웨어에 response를 조작할 수 있는 기회가 주어지는 것이다.\n\n```js\napp.use(async function (ctx, next) {\n  console.log('>> one');\n  await next();\n  console.log('<< one');\n});\n\napp.use(async function (ctx, next) {\n  console.log('>> two');\n  ctx.body = 'two';\n  await next();\n  console.log('<< two');\n});\n\napp.use(async function (ctx, next) {\n  console.log('>> three');\n  await next();\n  console.log('<< three');\n});\n```\n  \n  아래의 코드는 두번째 미들웨어에서 `next()`를 생략했고 response로 \"two\"를 셋팅하여 세번째 미들웨어는 무시될 것이다.\n\n```js\napp.use(async function (ctx, next) {\n  console.log('>> one');\n  await next();\n  console.log('<< one');\n});\n\napp.use(async function (ctx, next) {\n  console.log('>> two');\n  ctx.body = 'two';\n  console.log('<< two');\n});\n\napp.use(async function (ctx, next) {\n  console.log('>> three');\n  await next();\n  console.log('<< three');\n});\n```\n\n가장 마지막 미들웨어에서 `next()`를 실행하면 noop function, 아무 동작을 하지 않으며 미들웨어가 스택의 어느 곳에서나 올바르게 구성할 수 있다.\n\n## Async operations\n\nAsync 함수와 promise 기반인 Koa는 non-blocking sequential code를 허용한다. 예를 들어 이 미들웨어는 `./docs` 디렉토리에서 파일 이름들을 읽어온 후  parallel, 병렬로 각각의 마크다운 파일 형태의 내용을 읽어 body에 결과를 join 하여 셋팅한다.\n\n> non-blocking이란, 어떤 쓰레드에서 오류가 발생하거나 멈추었을 때 다른 쓰레드에게 영향을 끼치지 않도록 만드는 방법들을 말한다.\n\n> parallel, 병렬이라는 뜻처럼 데이터를 한번에 여러 개를 전송한다\n\n```js\nconst fs = require('mz/fs');\n\napp.use(async function (ctx, next) {\n  const paths = await fs.readdir('docs');\n  const files = await Promise.all(paths.map(path => fs.readFile(`docs/${path}`, 'utf8')));\n\n  ctx.type = 'markdown';\n  ctx.body = files.join('');\n});\n```\n\n## Koa 디버깅하기\n\n  Koa along with many of the libraries it's built with support the __DEBUG__ environment variable from [debug](https://github.com/visionmedia/debug) which provides simple conditional logging.\n\n  For example\n  to see all Koa-specific debugging information just pass `DEBUG=koa*` and upon boot you'll see the list of middleware used, among other things.\n\n```\n$ DEBUG=koa* node --harmony examples/simple\n  koa:application use responseTime +0ms\n  koa:application use logger +4ms\n  koa:application use contentLength +0ms\n  koa:application use notfound +0ms\n  koa:application use response +0ms\n  koa:application listen +0ms\n```\n\n  Since JavaScript does not allow defining function names at\n  runtime, you can also set a middleware's name as `._name`.\n  This is useful when you don't have control of a middleware's name.\n  For example:\n\n```js\nconst path = require('path');\nconst serve = require('koa-static');\n\nconst publicFiles = serve(path.join(__dirname, 'public'));\npublicFiles._name = 'static /public';\n\napp.use(publicFiles);\n```\n\n  Now, instead of just seeing \"serve\" when debugging, you will see:\n\n```\n  koa:application use static /public +0ms\n```\n"}}}},"pageContext":{"id":"f2032027a41318246789d128d0d9c7c3692f528d","previousPostId":"ce15b2faaa11ddc0a404c2e65bec3c53a4496c9f","nextPostId":"932dabc45fc6e6a76d7adfeaaaf283051305af67"}},"staticQueryHashes":["2841359383"]}