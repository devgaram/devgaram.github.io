{"componentChunkName":"component---src-templates-blog-post-js","path":"/d3243c845434711276363da6e3b2e4b8a276c730","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d3243c845434711276363da6e3b2e4b8a276c730","text":"# [안드로이드] RecyclerView를 사용하자\n\n- Title : [안드로이드] RecyclerView를 사용하자\n- Date : 2018-12-05\n- Category: Android\n\n[될 때까지 안드로이드]의 RecyclerView 파트를 정리한 내용입니다.\n\n어댑터 뷰의 성능을 개선한 컴포넌트로 애니메이션을 지원하고 뷰홀더 패턴을 강제한다.  \n대신 이벤트 리스너와 커서를 지원하지 않는 단점이 있다.\n\n## 어댑터 뷰의 단점\n\n1. 빠르게 스크롤 할 때 성능문제와 불필요한 지연 문제가 있다.\n2. 데이터 목록이 변경되었을 때, <code class=\"codetainer\">notifyDataSetChanged()</code> 메서드를 빈번하게 호출하여 전체 아이템을 갱신하는 데 비용이 많이 든다. 이 메서드는 항상 전체 항목을 새로 로드한다.\n\n## 리사이클러 뷰 vs 어댑터 뷰\n\n- 상속 받는 클래스 : RecyclerView.Adapter vs BaseAdapter\n- 리사이클러 뷰는 레이아웃 매니저를 지정해줘야 한다.\n- 리사이클러 뷰는 뷰홀더 패턴을 반드시 구현해야한다.\n\n## 리사이클러 뷰 관련 클래스\n\n1. RecyclerView.Adapter : 어댑터 역할\n2. RecyclerView.ViewHolder : 뷰홀더 클래스가 상속받아야 할 클래스\n3. LayoutManager : 아이템을 어떻게 배치할 것 인가\n\n   - LinearLayoutManager\n   - GridLayoutManager\n   - StaggeredGridLayoutManager\n\n4. RecyclerView.ItemAnimator : 아이템이 추가, 삭제, 재정렬 시 애니메이션 어떻게 할 것인가\n5. RecyclerView.ItemDecoration : 아이템을 세부적으로 어떻게 꾸밀 것인가\n\n## 리사이클러 통지 메서드\n\n- <code class=\"codetainer\">notifyItemInserted(int position)</code> : position 위치의 아이템이 삽입된 것을 통지\n- <code class=\"codetainer\">notifyItemRemoved(int position)</code> : position 위치의 아이템이 삭제된 것을 통지\n\n## 관련 메서드\n\n- <code class=\"codetainer\">void setHasFixedSize (boolean hasFixedSize)</code> : 각 아이템의 변화가 리사이클러 뷰의 전체 크기에 영향을 끼치지 않는다면 true를 사용한다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"21592a4a75d3f4c8d56813075597b1287f9822f2","text":"# [안드로이드] fragment를 사용하자\n\n- Title : [안드로이드] fragment를 사용하자\n- Date : 2018-12-07\n- Category: Android\n\n[될 때까지 안드로이드]의 fragment 파트를 정리한 내용입니다.\n\n[기본 프래그먼트 구현 예제](https://github.com/devgaram/androidExample/tree/master/fragmentexam).  \n[다이얼로그 프래그먼트 구현 예제](https://github.com/devgaram/androidExample/tree/master/exitdialogfragment).  \n[콜백 구현 예제](https://github.com/devgaram/androidExample/tree/master/callbackexam).\n\n여러 개의 프래그먼트를 하나의 액티비티에 조합하여 창이 여러 개인 UI를 구축할 때 사용할 수 있다.\n\n- 하나의 프래그먼트를 여러 액티비티에서 재사용할 수 있으며,동적으로 추가, 삭제, 교체가 쉽다.\n- 프래그먼트는 자체 수명 주기를 가진다.\n- 프래그먼트는 부모-자식 관계를 가질 수 있다.\n\n---\n\n# 생명주기 (소속 액티비티가 실행 중일 때)\n\n최소한 다음과 같은 수명 주기 메서드를 구현해야한다.\n\n**onCreate()**  \n프래그먼트를 생성할 때 호출되는 콜백 메서드  \n프래그먼트가 일시정지되거나 중지되었다가 재개되었을 때 유지하고자 하는 것을 초기화하는 부분\n\n**onCreateView()**  \n액티비티는 <code class=\"codetainer\">onCreate()</code> 콜백 메서드에서 <code class=\"codetainer\">setContentView()</code> 메서드를 호출하여 View 객체(레이아웃)을 가져온다.  \n프래그먼트는 <code class=\"codetainer\">onCreateView()</code> 콜백 메서드에서 LayoutInflater를 통해 레이아웃을 가져온다.\n\n**onPause()**  \n시스템이 이 메서드를 호출하는 것은 사용자가 프래그먼트를 떠난다는 첫 번째 신호.  \n현재 사용자 세션을 넘어서 지속되어야 하는 변경 사항을 저장하는 부분\n\n프래그먼트 추가  \nonAttach() -> onCreate() -> onCreateView() -> onActivityCreated() -> onStart() -> onResume()\n\n프래그먼트 소멸  \nonPause() -> onStop() -> onDestroyView() -> onDestroy() -> onDetach()\n\n# 실습\n\n## 프래그먼트의 생성자\n\n생성자를 오버로드할 수 없으며, 생성자를 통해 파라미터 전달을 금지하고 있다.  \n재생성 시에 정보를 자동으로 저장 및 복원하기 위한 설계가 이미 되어 있고 그것을 따르기 위한 제약이다.\n프래그먼트의 생성과 동시에 파라미터를 전달하는 방법은 **Bundle 객체**를 활용한다.\n\n```java\npublic class ColorFragment extends Fragment {\n\n    public ColorFragment() {\n        // Required empty public constructor\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.fragment_color, container, false);\n    }\n}\n```\n\n## 프래그먼트 매니저\n\n프래그먼트 조작을 위해 프래그먼트 매니저가 필요하다.  \n프래그먼트 매니저는 액티비티 처럼 백스택을 가지고 있음.\n\n- 액티비티 내 XML에 포함된 프래그먼트를 <code class=\"codetainer\">findFragmentById()</code> 메서드로 가져오기 또는 <code class=\"codetainer\">findFragmentByTag()</code>로 가져오기\n- 액티비티 백스택에서 프래그먼트를 <code class=\"codetainer\">popBackStack()</code>메서드로 빠져나오게 하여 액티비티의 뒤로 가기와 같은 효과를 냄 ( <code class=\"codetainer\">addToBackStack()</code> : 프래그먼트 매니저의 백스택에 프래그먼트 추가하는 메서드 )\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n      ...생략...\n        FragmentManager fragmentManager = getSupportFragmentManager();\n        ColorFragment colorFragment = (ColorFragment) fragmentManager.findFragmentById(R.id.color_fragment);\n        colorFragment.setColor(Color.BLUE);\n    }\n}\n```\n\n## 프래그먼트에서 액티비티에 접근하는 방법\n\n```java\nView listView = getActivity().findViewById(R.id.list);\n```\n\n## 프래그먼트 교체, 삭제, 추가\n\n프래그먼트를 교체하기 위해서는 <fragment<fragment>>를 <FrameLayout<FrameLayout>>과 같은 레이아웃으로 감싸줘야한다.  \n**프래그먼트 트랜지션 수행** add(), remove(), replace() 같은 메서드를 사용하고 commit()을 수행하면 트랜지션이 적용된다.\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n  ...생략....\n\n    public void change(View view) {\n        ColorFragment fragment = new ColorFragment();\n        int red = new Random().nextInt(256);\n        int green = new Random().nextInt(256);\n        int blue = new Random().nextInt(256);\n        fragment.setColor(Color.rgb(red, green, blue));\n        getSupportFragmentManager()\n                .beginTransaction()\n                .replace(R.id.container, fragment)\n                .commit();\n    }\n}\n```\n\n## 프래그먼트와 액티비티 간의 통신\n\n일반적으로 액티비티에서 프래그먼트나 다른 뷰들의 인스턴스를 가지고 있어서 이들의 메서드를 호출하는 식이다. 따라서 프래그먼트의 상태가 변했을 때 액티비티에서 이것을 알아차리려면 계속해서 프래그먼트의 상태 값을 알아내는 메서드를 호출해야한다.\n\n그러나 콜백 인터페이스를 사용하여 프래그먼트의 상태가 변할 때마다 자동으로 액티비티에게 알려줄 수 있다.\nButton의 <code class=\"codetainer\">onClick()</code> 이벤트나 액티비티의 <code class=\"codetainer\">onCreate()</code>가 대표적인 콜백 메서드이며, 호출자 입장에서는 피호출자의 변화를 감시하다가 알아채기 때문에 리스너(Listener) 라고도 불른다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"f8ebac2b78438548ddb7207724467420f65eee08","text":"# [안드로이드] 어댑터뷰를 사용해보자\n\n- Title : [안드로이드] 어댑터뷰를 사용해보자\n- Date : 2018-12-02\n- Category: Android\n\n[될때까지 안드로이드] 어댑터뷰 파트의 내용을 정리한 글입니다.\n\nListView 와 GridView\n\n- 반복되고 양이 많은 데이터를 표시하고 싶을 때\n- 이미지와 같이 메모리를 차지하는 리소스를 표시하고 싶을 때\n- 모두 AdapterView 추상클래스를 상속받아 어댑터 패턴을 사용하여 데이터를 뷰에 표시한다.\n- ScrollView의 경우 한번에 모든 컨텐츠를 로드하므로 컨텐츠가 메모리를 많이 사용할 경우 메모리 부족으로 앱이 종료될 수 있다.\n\n# AdapterView\n\n---\n\nAdapterView를 상속받은 뷰들은 화면에 보이는 내용만 로드하는 기법을 사용한다.\n\n## 1. AdapterView의 구현\n\n데이터 준비하기\n\n```java\n//MainActivity.java\nArrayList<Weather> data = new ArrayList<Weather>()\ndata.add(new Weather(\"수원\", \"25도\", \"맑음\"));\ndata.add(new Weather(\"안양\", \"22도\", \"비\"));\ndata.add(new Weather(\"부천\", \"22도\", \"구름\"));\ndata.add(new Weather(\"성남\", \"24도\", \"맑음\"));\ndata.add(new Weather(\"서울\", \"28도\", \"구름\"));\ndata.add(new Weather(\"광주\", \"30도\", \"비\"));\ndata.add(new Weather(\"부산\", \"20도\", \"비\"));\n```\n\n데이터를 뷰에 연결해 줄 어댑터를 준비한다.\n\n```java\n//MainActivity.java\nMyFirstAdapter adapter = new MyFirstAdapter(data);\n```\n\n뷰에 어댑터를 붙인다.\n\n```java\n//MainActivity.java\nListView listView = (ListView) findViewById(R.id.list_view);\nlistView.setAdapter(adapter);\n```\n\n## 2. 클릭 이벤트 구현\n\npublic static interface AdapterView.OnItemClickListener  \n<span class=\"clr-grey\">android.widget.AdapterView.OnItemClickListener : 어댑터뷰의 아이템 클릭시 호출되는 콜백 메서드를 정의한 인터페이스</span>\n\npublic abstract void onItemClick (AdapterView<?> parent, View view, int position, long id)  \n<span class=\"clr-grey\">\nparent : 클릭이 일어난 AdapterView  \nview : AdapterView 안의 클릭된 View = 클릭된 아이템 뷰  \nposition : 클릭된 아이템 뷰의 위치  \nid : 클릭된 아이템 뷰의 row ID\n</span>\n\n```java\nlistView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n  @Override\n  public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n    Toast.makeText(MainActivity.this, position + \" 번째 아이템 선택\", Toast.LENGTH_SHORT).show();\n   }\n});\n```\n\n## 3. 예제 구성\n\n1. Weather.java\n   날씨를 표현하는 모델클래스  \n   <span class=\"clr-grey\"> toString() : 모든 클래스가 가지고 있는 기본메서디로 디버깅이나 로그에서 정보 확인을 위해 toString() 메서드 재정의한다. </span>\n\n2. MyFirstAdapter.java  \n   추상클래스인 BaseAdapter를 상속받는 클래스로 추상 메서드들을 구현해야 한다.  \n   <span class=\"clr-grey\"> Note: BaseAdapter는 어댑터의 기능을 추상화해 둔 추상 클래스, 각 메서드 재정의 필요 </span>\n\n```java\n @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        /**\n         * LayoutInflater 클래스란?\n         * Activity 이외의 클래스에서 Context를 통해 XML로 정의한 레이아웃을 로드하여 View로 반환해주는 클래스\n         */\n        ViewHolder holder;\n        if (convertView == null) {\n            holder = new ViewHolder();\n            convertView = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_weather, parent, false);\n            ImageView weatherImage = (ImageView) convertView.findViewById(R.id.weather_image);\n            TextView cityText = (TextView) convertView.findViewById(R.id.city_text);\n            TextView tempText = (TextView) convertView.findViewById(R.id.temp_text);\n            holder.cityText = cityText;\n            holder.tempText = tempText;\n            holder.weatherImage = weatherImage;\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n\n        Weather weather = mData.get(position);\n        holder.cityText.setText(weather.getCity());\n        holder.tempText.setText(weather.getTemp());\n        holder.weatherImage.setImageResource(mWeatherImageMap.get(weather.getWeather()));\n        return convertView;\n    }\n    static class ViewHolder {\n        ImageView weatherImage;\n        TextView cityText;\n        TextView tempText;\n    }\n```\n\n- 핵심메서드 getView() 작성\n  - 각 아이템이 화면에 표시될 때마다 호출되며, 여기서 화면에 표시할 레이아웃과 데이터를 모두 작성해야한다.\n  - ListView의 각 아이템에 해당되는 View는 화면에 보이는 만큼만 생성되고 스크롤 시에 안쓰이는 아이템은 새로 보이는 아이템의 View로 재사용된다.  \n    <span class=\"clr-grey\"> Note: 두번째 파라미터인 convertView가 재사용 시에 이전에 생성되었던 getView()가 반환했던 View </span>\n- LayoutInflater 추상 클래스\n  - Activity 이외의 클래스에서 Context를 통해 XML로 정의한 레이아웃을 로드하여 View로 반환해주는 클래스\n  - 레이아웃 XML 파일을 View 객체로 반환한다.\n  - LayoutInflater 인스턴스 받는 법 : **Activity.getLayoutInflater()** or **Context.getSystemService(Class)**\n  - Public methods  \n    <span class=\"clr-grey\">\n    -LayoutInflater.from(parent.getContext())  \n     현재 Context로부터 LayoutInflater 인스턴스를 반환받는다._static LayoutInflater_  \n     -LayoutInflater.from(parent.getContext()).inflate(R.layout.item_weather, parent, false);  \n     inflate(int resource, ViewGroup root, boolean attachToRoot)  \n     xml파일 item_weather을 View 객체 형태로 반환한다.\n    </span>\n- ViewHolder\n  자주 사용하는 뷰를 한번 로드하면 재사용하고 표시할 내용만 교체하기 위한 패턴 - View 안에 여러 데이터를 담고 싶을 때, getTag(), setTag()를 사용한다.  \n   <span class=\"clr-grey\">android.view.View, Tag는 Object 타입이라 다양한 용도로 사용가능</span>\n"}}}},"pageContext":{"id":"d3243c845434711276363da6e3b2e4b8a276c730","previousPostId":"21592a4a75d3f4c8d56813075597b1287f9822f2","nextPostId":"f8ebac2b78438548ddb7207724467420f65eee08"}},"staticQueryHashes":["2841359383"]}