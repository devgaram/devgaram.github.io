{"componentChunkName":"component---src-templates-blog-post-js","path":"/badecf2a1d8b27736ed2d861abdb95aeffc07070","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"badecf2a1d8b27736ed2d861abdb95aeffc07070","text":"# 프로그래머스 - lv3 네트워크, lv2 짝지어 제거하기\n\n- Title : 프로그래머스 - lv3 네트워크, lv2 짝지어 제거하기\n- Date : 2019-12-30\n- Category: 알고리즘 풀이\n\n# # LV3 네트워크\n\n각 행을 순회해서 컬럼 값이 1일 때, 해당 col을 row로 하여 또 순회하는 식으로 해결했다.\n\n```javascript\nfunction solution(n, computers) {\n  var answer = 0;\n  var arr = [];\n  arr = computers.reduce((acc, cur) => {\n    acc.push(cur.includes(1));\n    return acc;\n  }, []);\n\n  for (let i = 0; i < n; i++) {\n    if (arr[i]) {\n      dfs(i);\n      answer++;\n    }\n  }\n\n  function dfs(row) {\n    if (!arr[row]) return;\n    arr[row] = false;\n    for (let i = 0; i < n; i++) {\n      if (computers[row][i] > 0) {\n        computers[row][i] = 0;\n        dfs(i);\n      }\n    }\n  }\n\n  return answer;\n}\n```\n\n# # lv2 짝지어 제거하기\n\n스택을 생각해냈으면 쉽게 해결할 수 있다.\n\n```javascript\nfunction solution(s) {\n  var stack = [];\n  stack.push(s[0]);\n  for (let i = 1; i < s.length; i++) {\n    if (stack[stack.length - 1] === s[i]) stack.pop();\n    else stack.push(s[i]);\n  }\n  return stack.length ? 0 : 1;\n}\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"68ea80dc2124e8d2e6495a2ae7232f0d565aecf7","text":"# 운영체제 - 프로세스 동기화 1\n\n- Title : 운영체제 - 프로세스 동기화 1\n- Date : 2020-01-06\n- Category: 운영체제\n\n> 1. 프로세스 동기화란?\n> 2. 임계구역이란?\n> 3. 세마포란?\n\n# 프로세스 동기화(Process Synchronization, Thread Synchronization)\n\n프로세스들이 서로 공유하는 데이터에 동시에 접근할 때 순서대로 실행하여 **일관성있는 데이터를 유지**하는 것\n\n- Independent : 프로세스1과 프로세스2가 관계가 없을 때\n- Cooperating : 다른 프로세스에게 영향을 미치거나 다른 프로세스로부터 영향을 받을 때\n- 프로세스 간 통신 : 전자 우편, 파일 전송\n- 프로세스 간 자원 공유 : 메모리 상의 자료, 데이터베이스 등\n- 실생활 예 : 명절 기차표 예약, 대학 온라인 수강신청, 실시간 주식 거래\n\n## 프로세스/쓰레드 동기화를 하려면?\n\n- 임계구역 문제 해결(틀린 답이 나오지 않도록)\n- 프로세스 실행 순서 제어(원하는 대로)\n- busy wait 등 비효율성은 제거\n\n## 동기화 도구\n\n- 세마포(Semaphores)\n- 모니터(Monitors)\n- Misc.\n\n## 은행 계좌 예시\n\n아래의 코드는 공통 변수(balance)에 대해 동시 업데이트를 수행하여 0이 아닌 잘못된 결과값이 출력된다. 이는 한번에 한 쓰레드만 업데이트하도록 하여 해결할 수 있다. -> **임계구역 문제**\n\n```java\nclass Test {\npublic static void main(String[] args) throws InterruptedException {\n  BankAccount b = new\n  BankAccount();\n  Parent p = new Parent(b);\n  Child c = new Child(b);\n  p.start();\n  c.start();\n  p.join();\n  c.join();\n  System.out.println( \"\\nbalance = \" + b.getBalance());\n  }\n}\n```\n\n```java\nclass BankAccount {\n  int balance;\n  void deposit(int amount) {\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp; // 임계구역\n  }\n  void withdraw(int amount) {\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp; // 임계구역\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n\n```java\nclass Parent extends Thread {\n  BankAccount b;\n  Parent(BankAccount b) {\n    this.b = b;\n  }\n  public void run() {\n    for (int i=0; i<100; i++)\n    b.deposit(1000);\n  }\n}\nclass Child extends Thread {\n  BankAccount b;\n  Child(BankAccount b) {\n    this.b = b;\n  }\n  public void run() {\n    for (int i=0; i<100; i++)\n    b.withdraw(1000);\n  }\n}\n```\n\n# 임계구역 문제(The Critical-Section Problem)\n\n## 임계구역(Critical Section)\n\n여러 개의 스레드로 구성된 시스템에서 각 스레드가 같이 사용하는 변수, 테이블, 파일을 바꾸는 코드 영역을 임계구역이라고 한다. 예) 은행 계좌 예시에서 balance 값을 바꾸는 코드가 임계구역이다.\n\n## 임계구역 문제 해결방법 - 아래 3가지 다 만족해야한다!\n\n- Mutual exclusion (상호배타): 오직 한 쓰레드만 진입<br/>예) Parent 스레드가 임계구역 실행 중에는 Child 스레드는 임계구역에 들어갈 수 없다.\n- Progress (진행): 진입 결정은 유한 시간 내<br/>예) 임계구역에 어떤 스레드가 먼저 진입할지에 대한 결정은 유한 시간 내에 결정되어야 한다.\n- Bounded waiting (유한대기): 어느 쓰레드라도<br/>예) 어느 스레드라도 기다리고 있으면 유한한 시간내에 임계구역에 들어갈 수 있다.\n\n# 세마포 (Semaphore)\n\n동기화 문제 해결을 위한 소프트웨어 도구로 <span class=\"clr-note\">정수형 변수 + 두 개의 동작 (P, V)</span>으로 이루어져있다.\n\n## 동작\n\n- P: Proberen (test) → **acquire()**\n- V: Verhogen (increment) → **release()**\n\n## 구조\n\n- acquire() : 임계구역 전에 호출하여 value가 조건에 맞으면 **프로세스(or 스레드)를 list(큐)에 넣는다.** 큐에 들어간 프로세스는 다른 프로세스에 의해 release()가 호출될 때까지 Block된다. 즉 임계구역을 실행할 수 없게 된다. (Block이 된다 == Ready Queue에 들어가지 못한다)\n- release() : value 조건에 맞으면 list에서 **프로세스를 꺼내서 깨운다.** 깨운다는 것은 Ready Queue(cpu 서비스 기다리는 줄)에 넣는 다는 것을 의미한다.\n\n```java\nclass Semaphore {\n  int value; // number of permits\n\n  Semaphore(int value) {\n  ... }\n  void acquire() {\n    value--;\n    if (value < 0) {\n      add this process/thread to list;\n      block;\n    }\n  }\n  void release() {\n    value++;\n    if (value <= 0) {\n      remove a process P from list;\n      wakeup P;\n    }\n  }\n}\n\n```\n\n## 세마포의 사용 - 상호 배타(Mutual exclusion)\n\nsem.value = 1로 두어 임계구역에는 프로세스 한 개만 들어갈 수 있도록 한다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2020-01-06-img/1.png)<br/>\n\n아래 코드는 은행 계좌 예시의 BankAccount 클래스를 수정한 것으로 임계구역 문제를 해결한다.\n\n```java\nimport java.util.concurrent.Semaphore;\n\nclass BankAccount {\n  int balance;\n  Semaphore sem;\n  public BankAccount () {\n    this.sem = new Semaphore(1)\n  }\n  void deposit(int amount) {\n    try {\n      sem.acquire()\n    } catch(InterruptedException) {}\n\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp;\n    sem.release()\n  }\n  void withdraw(int amount) {\n    try {\n      sem.acquire()\n    } catch(InterruptedException) {}\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp;\n    sem.release()\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n\n1. Parent 프로세스가 deposit()을 호출하면 acquire() 메소드가 실행된다. 이는 value를 0으로 만드나 조건이 false라 바로 빠져나와 임계구역을 실행한다.\n2. 문맥 전환에 의해 Child 프로세스의 witdhdraw()가 호출되면 acquire()이 호출된다. value를 -1로 만들어 조건이 true가 되어 Child 프로세스는 큐에 들어가고 Block 된다. 즉, 임계구역을 못 간다.\n3. Parent 프로세스가 임계구역 실행을 완료한 후 release()를 호출하면 큐의 프로세스 하나를 뺀다. 즉, Child 프로세스를 깨워 Ready Queue로 보낸다.\n\n## 세마포의 사용 - 프로세스 실행 순서 제어(Ordering)\n\nCPU 스케줄링 알고리즘에 관련없이 P1에 들어간 S1 코드가 P2의 S2 코드보다 먼저 실행되게 하고 싶을 때? 세마포를 사용하자!\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2020-01-06-img/2.png)<br/>\n\n항상 입금이 먼저 되게 BankAccount 클래스를 수정해보자.\n\n```java\nimport java.util.concurrent.Semaphore;\n\nclass BankAccount {\n  int balance;\n  Semaphore sem;\n  Semaphore sem2;\n  public BankAccount () {\n    this.sem = new Semaphore(1);\n    this.sem2 = new Semaphore(0)\n  }\n  void deposit(int amount) {\n    try {\n      sem.acquire()\n    } catch(InterruptedException) {}\n\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp;\n    sem.release()\n    sem2.release()\n  }\n  void withdraw(int amount) {\n    try {\n      sem2.acquire()\n      sem.acquire()\n    } catch(InterruptedException) {}\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp;\n    sem.release()\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n\n이제 입출금 교대로 되게 BankAccount 클래스를 수정해보자.\n\n```java\nimport java.util.concurrent.Semaphore;\n\nclass BankAccount {\n  int balance;\n  Semaphore sem;\n  Semaphore dsem;\n  Semaphore wsem;\n  public BankAccount () {\n    this.sem = new Semaphore(1);\n    this.dsem = new Semaphore(0);\n    this.wsem = new Semaphore(0);\n  }\n  void deposit(int amount) {\n    try {\n      sem.acquire();\n    } catch(InterruptedException) {}\n\n    int temp = balance + amount;\n    System.out.print(\"+\")\n    balance = temp;\n    sem.release();\n    wsem.release();\n    try {\n      dsem.acquire();\n    } catch(InterruptedException) {}\n\n  }\n  void withdraw(int amount) {\n    try {\n      wsem.acquire();\n      sem.acquire();\n    } catch(InterruptedException) {}\n    int temp = balance - amount;\n    System.out.print(\"-\")\n    balance = temp;\n    sem.release();\n    dsem.release();\n  }\n  int getBalance() {\n    return balance;\n  }\n}\n\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"98d190815eccc3f8e3445b39df9139a4209a3f5c","text":"# 운영체제 - 프로세스 생성과 종료 및 쓰레드\n\n- Title : 운영체제 - 프로세스 생성과 종료 및 쓰레드\n- Date : 2019-12-27\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # Process Creation(프로세스 생성)\n\n## 프로세스는 프로세스에 의해 만들어진다!\n\n부팅 후 OS가 프로세스를 만들면 그 프로세스에 자식 프로세스가 만들어지고 또 자식의 자식 프로세스가 만들어진다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-27-img/1.png)<br/>\n\n- 부모 프로세스(Parent process)\n- 자식 프로세스(Child process)\n- 형제 프로세스(Sibling process) : 부모가 같은 프로세스\n- 프로세스 트리 (process tree) = 족보, 가계도\n\n## Process Identifier (PID)\n\n프로세스의 유니크 번호로 주민등록번호와 비슷한 개념이다. 절대 PID 중복되면 안됀다. cf) PPID : 부모 프로세스의 PID\n\n## 프로세스 생성\n\n- fork() system call – 부모 프로세스 복사해서 새로운 프로그램을 만든다.\n- exec() – 새로 만들어진 프로그램의 실행파일을 메모리로 가져온다.\n\n# # Process Termination(프로세스 종료)\n\n- exit() system call - 프로세스를 종료시킨다. 해당 프로세스가 가졌던 모든 자원(메모리, 열었던 파일, 프린터같은 입출력 장치 등)을 회수해서 O/S에게 반환한다.\n\n# # 쓰레드(Thread)\n\n쓰레드란? <span class=\"clr-note\">프로그램 내부의 흐름, 맥</span>이다.\n\n```java\nclass Test {\n  public static void main(String[] args) {\n    int n = 0;\n    int m = 6;\n    System.out.println(n+m);\n    while (n < m) n++;\n    System.out.println(\"Bye\");\n  }\n```\n\n이처럼 하나의 프로그램에는 보통 맥(쓰레드)이 하나 있으나 어떤 프로그램은 맥(쓰레드)이 여러 개가 있다. 하나의 프로그램에 2개 이상의 맥이 있으면 <span class=\"clr-note\">다중 쓰레드 (Multithreads)</span>라고 한다. 맥이 빠른 시간 간격으로 스위칭되기 때문에 여러 맥이 동시에 실행되는 것처럼 보인다.(=<code class=\"codetainer\">Concurrent</code> 동시성) cf) <code class=\"codetainer\">simultaneous</code>는 진짜로 동시에 실행되는 경우를 말하며 CPU가 하나면 일어날 수 없는 일이다.\n\n## 예시\n\nWeb browser(화면 출력하는 쓰레드 + 데이터 읽어오는 쓰레드), Word processor(화면 출력하는 쓰레드 + 키보드 입력 받는 쓰레드 + 철자/문법\n오류 확인 쓰레드), 음악 연주기, 동영상 플레이어, Eclipse IDE\n\n우리가 이전 포스팅에서는 <code class=\"codetainer\">Process1 -> Process2 -> Process3...</code>로 프로세스가 스위칭된다고 했지만 사실 운영체제는 다중 스레드를 지원하고 있어서 다음과 같은 흐름을 가진다. <code class=\"codetainer\">Thread1 of Process1 -> Thread2 of Process1 -> Thread1 of Process2 -> Thread2 of Process2 -> Thread3 of Process2 .....</code>\n\n## 쓰레드 구조\n\n![process](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-27-img/2.JPG)<br/>\n\n- 프로세스의 메모리 공간 공유 (code, data)\n- 프로세스의 자원 공유 (file, i/o, …)\n- 비공유: 개별적인 PC(program counter), SP(stack pointer), registers, stack\n\n![process](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-27-img/3.JPG)<br/>\n\n**vs 프로세스** <br/>\n프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받는다. 즉, 각 프로세스는 별도의 주소 공간에서 실행되고 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다. 다른 프로세스의 자원에 접근하려면 <code class=\"codetainer\">프로세스 간의 통신(IPC, inter-process communication, 파일, 소켓, 파이프...)</code>을 사용해야 한다.\n\n# # 잠깐 컴퓨터 구조 지식을 채워보자.\n\n## Register(레지스터)\n\nCPU 내부에서 처리할 명령어나 연산의 중간 결과값 등을 일시적으로 기억하는 임시 기억장소다.\n\n- 데이터 레지스터(data register) : CPU가 처리하는 데이터를 임시로 저장\n- <code class=\"codetainer\">주소 레지스터(address register)</code> : 기억장치를 액세스할 주소를 저장하며 포인터(Pointer)라고도 한다. 스택 포인터(SP, Stack Pointer), 베이스 포인터(BP, Base Pointer), 인덱스 포인터(IX, Index Pointer)가 있다.\n- 범용 레지스터(GPR) :주소 레지스터 혹은 데이터 레지스터로 사용될 수 있는 레지스터\n\n## PC\n\n프로그램 카운터(Program counter, PC)는 마이크로프로세서(중앙 처리 장치) 내부에 있는 레지스터 중의 하나로서, 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정한다. 때문에 명령어 포인터라고도 한다.\n\n## 버스\n\nCPU, 메모리, I/O 장치 등과 상호 필요한 정보를 교환하기 위해 연결된 공동의 전송선이다.\n"}}}},"pageContext":{"id":"badecf2a1d8b27736ed2d861abdb95aeffc07070","previousPostId":"68ea80dc2124e8d2e6495a2ae7232f0d565aecf7","nextPostId":"98d190815eccc3f8e3445b39df9139a4209a3f5c"}},"staticQueryHashes":["2685952063","2841359383"]}