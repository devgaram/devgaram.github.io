{"componentChunkName":"component---src-templates-blog-post-js","path":"/badecf2a1d8b27736ed2d861abdb95aeffc07070","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"badecf2a1d8b27736ed2d861abdb95aeffc07070","text":"# 프로그래머스 - lv3 네트워크, lv2 짝지어 제거하기\n\n- Title : 프로그래머스 - lv3 네트워크, lv2 짝지어 제거하기\n- Date : 2019-12-30\n- Category: 알고리즘 풀이\n\n# # LV3 네트워크\n\n각 행을 순회해서 컬럼 값이 1일 때, 해당 col을 row로 하여 또 순회하는 식으로 해결했다.\n\n```javascript\nfunction solution(n, computers) {\n  var answer = 0;\n  var arr = [];\n  arr = computers.reduce((acc, cur) => {\n    acc.push(cur.includes(1));\n    return acc;\n  }, []);\n\n  for (let i = 0; i < n; i++) {\n    if (arr[i]) {\n      dfs(i);\n      answer++;\n    }\n  }\n\n  function dfs(row) {\n    if (!arr[row]) return;\n    arr[row] = false;\n    for (let i = 0; i < n; i++) {\n      if (computers[row][i] > 0) {\n        computers[row][i] = 0;\n        dfs(i);\n      }\n    }\n  }\n\n  return answer;\n}\n```\n\n# # lv2 짝지어 제거하기\n\n스택을 생각해냈으면 쉽게 해결할 수 있다.\n\n```javascript\nfunction solution(s) {\n  var stack = [];\n  stack.push(s[0]);\n  for (let i = 1; i < s.length; i++) {\n    if (stack[stack.length - 1] === s[i]) stack.pop();\n    else stack.push(s[i]);\n  }\n  return stack.length ? 0 : 1;\n}\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"050c203f0de4fcd23578d6b6bc29d88531fc4775","text":"# 알고리즘 개념 잡자 - 트리\n\n- Title : 알고리즘 개념 잡자 - 트리\n- Date : 2020-01-03\n- Category: Algorithm\n\n> 참고 서적<br/> > [코딩 인터뷰 완전분석](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=115116545) 트리와 그래프<br/> > [C언어로 쉽게 풀어쓴 자료구조](http://www.yes24.com/Product/Goods/69750539) 제 7장 트리, 제 8장 우선순위 큐\n\n# 1. 트리(Tree)\n\n- 트리는 노드(node)와 간선(edge)로 이루어진 자료구조이다.\n- 트리는 하나의 루트 노드를 가진다.\n- 루트 노드는 0개 이상의 자식 노드를 가진다.\n- 그 자식 노드 또한 0개 이상의 자식 노드를 가진다.\n- 그 자식의 자식 노드 또한..\n- 노드들은 특정 순서대로 나열될 수도 있고 없을 수도 있다.\n- 각 노드는 어떤 자료형으로도 표현이 가능하다.\n- 각 노드는 부모 노드로의 연결이 있을 수도 있고 없을 수도 있다.\n\n## 용어 정리\n\n- 트리에는 **사이클(cycle)**이 존재할 수 없다.\n- 자식이 없는 노드는 **말단 노드(leaf node)**라고 부른다.\n- **차수(degree)**는 자식 노드의 개수로 자식 노드가 3개면 그 노드의 차수는 3이다. 트리의 차수는 트리가 가지고 있는 노드의 차수 중에서 가장 큰 차수이다.\n- **레벨(level)**은 트리의 각 층에 번호를 매긴 것으로 루트의 레벨은 1이 되고 한 층씩 내려갈수록 1씩 증가한다\n- 트리의 **높이(height)**는 트리가 가진 최대 레벨이다.\n\n예시) 노드 클래스\n\n```java\nclass Node {\n  public String name;\n  public Node[] children;\n}\n```\n\n예시) 트리 클래스\n\n```java\nclass Tree {\n  public Node root;\n}\n```\n\n## 이진 트리(Binary tree)와 이진 탐색 트리(Binary search tree)\n\n- 이진트리\n  - 이진 트리의 노드는 최대 2개까지의 자식 노드가 존재할 수 있고 모든 노드의 차수는 2 이하가 된다.\n  - n개의 노드를 가진 이진 트리는 n-1개의 간선을 가진다. 루트 노드를 제외한 노드들은 부모와 정확히 하나의 간선으로 이어져있기 때문이다.\n  - 높이가 h인 이진 트리는 최소 h개 노드를 가지고 최대 2<sup>h</sup>-1 노드를 가진다.\n  - 레벨 i에서 노드의 개수는 2<sup>i-1</sup> 다.\n  - n개의 노드를 가진 이진 트리의 최대 높이는 n이며 최소 높이는 log<sub>2</sub>(n+1) 이다.\n- 이진 탐색 트리\n  - 모든 노드 n은 <span class=\"clr-note\">모든 왼쪽 자식들 <= n < 모든 오른쪽 자식들</span> 속성을 만족한다.\n  - 이진 탐색 트리의 탐색, 삽입, 삭제 연산의 시간 복잡도는 트리의 높이를 h라고 했을 때 O(h)가 된다.\n  - n개의 노드를 가진 균형 잡힌 이진 트리의 높이는 log<sub>2</sub>n 이므로 평균적인 시간 복잡도는 O(log<sub>2</sub>n)\n  - 한쪽으로 치우친 이진 트리의 경우 트리의 높이가 노드의 개수 n과 같게 되어 시간복잡도는 선형 탐색과 같이 O(n)이 된다.\n\n## 이진 트리 표현 방법\n\n**1. 배열 이용** <br/><br/>\n![배열 이용](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-03-img/1.png)<br/>\n\n- 주로 포화 이진 트리나 완전 이진 트리의 경우에 많이 쓰인다.\n- 높이가 k인 완전 이진 트리로 가정하여 배열의 크기를 최대 노드 개수인 2<sup>k</sup>-1 로 할당한 다음 완전 이진 트리의 번호대로 노드를 저장한다.\n- 편한 계산을 위해 인덱스는 1부터 시작한다.\n- 오른쪽 그림처럼 일반 이진 트리의 경우 공간 낭비가 크다.\n\n> 부모 & 자식 노드 찾는 법 <br/><br/>\n> 현재 노드 i를 기준으로, <br/>\n> 부모 노드의 인덱스 = **i/2** <br/>\n> 왼쪽 자식 노드의 인덱스 = **i\\*2** <br/>\n> 오른쪽 자식 노드의 인덱스 = **i\\*2 + 1** <br/>\n\n<br/>\n\n**2. 연결리스트 이용** <br/><br/>\n\n- 노드가 자바에서는 클래스, C에서는 구조체로 표현되고 각 노드가 포인터를 가지고 있어서 이 포인터를 이용하여 노드와 노드를 연결하는 방법이다.\n- 하나의 노드가 왼쪽 자식 노드, 오른쪽 자식 노드를 필드로 가진다.\n\n## 트리가 '균형' 트리인지 아닌지 확인하는 방법\n\n<span class=\"clr-note\">O(log N)</span> 시간에 insert와 find를 할 수 있는 정도로 균형이 잘 잡혀있는 지 확인하면 된다. 꼭 완전 이진 트리처럼 완벽하게 균형 잡혀 있을 필요는 없다.\n\n> 예) 레드-블랙 트리와 AVL 트리\n\n## 이진 트리의 종류\n\n- 완전 이진 트리(complete binary tree) : 트리의 모든 높이에서 노드가 꽉 차 있다. 마지막 단계(level)은 꽉 차 있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져야 한다.\n- 전 이진 트리(full binary tree) : 자식노드가 0개 또는 2개인 경우다.\n- 포화 이진 트리(perfect binary tree) : 전 이진 트리면서 완전 이진 트리인 경우다. 모든 말단 노드는 같은 레벨에 있으며 마지막 레벨에서 노드의 개수가 최대가 되어야 한다. 노드의 개수는 정확히 2<sup>k-1</sup>(k는 트리의 레벨)\n\n## 이진 트리 순회 방법\n\n**중위 순회(in-order traversal)**는 <span class=\"clr-note\">왼쪽 가지(branch) - 현재 노드 - 오른쪽 가지</span> 순서로 노드를 방문하고 출력하는 방법이다.\n\n> 이진 탐색 트리를 이 방법으로 순회한다면? <span class=\"is-has-danger\">오름차순</span>으로 방문!\n\n```java\nvoid inOrderTraversal(TreeNode node) {\n  if (node != null) {\n    inOrderTraversal(node.left);\n    visit(node);\n    inOrderTraversal(node.right);\n  }\n}\n```\n\n<br/>\n\n**전위 순회(pre-order traversal)**는 <span class=\"clr-note\">현재 노드 - 왼쪽 가지(branch) - 오른쪽 가지</span> 순서로 노드를 방문하고 출력하는 방법이다.\n\n> 가장 먼저 방문할 노드는? 루트 노드!\n\n```java\nvoid preOrderTraversal(TreeNode node) {\n  if (node != null) {\n    visit(node);\n    preOrderTraversal(node.left);\n    preOrderTraversal(node.right);\n  }\n}\n```\n\n<br/>\n\n**후위 순회(post-order traversal)**는 <span class=\"clr-note\">왼쪽 가지(branch) - 오른쪽 가지 - 현재 노드</span> 순서로 노드를 방문하고 출력하는 방법이다. 예) 현재 디렉토리 용량 계산\n\n> 맨 마지막에 방문할 노드는? 루트 노드!\n\n```java\nvoid postOrderTraversal(TreeNode node) {\n  if (node != null) {\n    postOrderTraversal(node.left);\n    postOrderTraversal(node.right);\n    visit(node);\n  }\n}\n```\n\n<br/>\n\n**레벨 순회(level traversal)**는 각 노드를 레벨 순으로 순회하는 방법이다. 레벨 1에서 시작하며 동일한 레벨의 경우에는 왼쪽에서 오른쪽으로 순으로 방문한다.\n\n> 중위, 전위, 후위는 스택을 사용하며 레벨 순회는 **큐**를 이용한다.\n\n## 이진 트리 순회의 응용\n\n**수식 트리(expression tree)**를 처리하는 데 사용\n<br/>\n\n![수식 트리 예제](https://raw.githubusercontent.com/devgaram/TIL/master/Algorithm/images/2020-01-03-img/2.png)<br/>\n\n- 루트 노드는 연산자이고 서브 트리가 피연산자이므로 서브 트리를 계산하면 전체 수식을 계산할 수 있다.\n- 위 표에 나와있듯이 가장 적합한 순회 방식은 **후위 순회**다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"98d190815eccc3f8e3445b39df9139a4209a3f5c","text":"# 운영체제 - 프로세스 생성과 종료 및 쓰레드\n\n- Title : 운영체제 - 프로세스 생성과 종료 및 쓰레드\n- Date : 2019-12-27\n- Category: 운영체제\n\n경성대학교 양희재 교수님 강의를 듣고 정리했습니다.\n\n# # Process Creation(프로세스 생성)\n\n## 프로세스는 프로세스에 의해 만들어진다!\n\n부팅 후 OS가 프로세스를 만들면 그 프로세스에 자식 프로세스가 만들어지고 또 자식의 자식 프로세스가 만들어진다.\n\n![process tree](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-27-img/1.png)<br/>\n\n- 부모 프로세스(Parent process)\n- 자식 프로세스(Child process)\n- 형제 프로세스(Sibling process) : 부모가 같은 프로세스\n- 프로세스 트리 (process tree) = 족보, 가계도\n\n## Process Identifier (PID)\n\n프로세스의 유니크 번호로 주민등록번호와 비슷한 개념이다. 절대 PID 중복되면 안됀다. cf) PPID : 부모 프로세스의 PID\n\n## 프로세스 생성\n\n- fork() system call – 부모 프로세스 복사해서 새로운 프로그램을 만든다.\n- exec() – 새로 만들어진 프로그램의 실행파일을 메모리로 가져온다.\n\n# # Process Termination(프로세스 종료)\n\n- exit() system call - 프로세스를 종료시킨다. 해당 프로세스가 가졌던 모든 자원(메모리, 열었던 파일, 프린터같은 입출력 장치 등)을 회수해서 O/S에게 반환한다.\n\n# # 쓰레드(Thread)\n\n쓰레드란? <span class=\"clr-note\">프로그램 내부의 흐름, 맥</span>이다.\n\n```java\nclass Test {\n  public static void main(String[] args) {\n    int n = 0;\n    int m = 6;\n    System.out.println(n+m);\n    while (n < m) n++;\n    System.out.println(\"Bye\");\n  }\n```\n\n이처럼 하나의 프로그램에는 보통 맥(쓰레드)이 하나 있으나 어떤 프로그램은 맥(쓰레드)이 여러 개가 있다. 하나의 프로그램에 2개 이상의 맥이 있으면 <span class=\"clr-note\">다중 쓰레드 (Multithreads)</span>라고 한다. 맥이 빠른 시간 간격으로 스위칭되기 때문에 여러 맥이 동시에 실행되는 것처럼 보인다.(=<code class=\"codetainer\">Concurrent</code> 동시성) cf) <code class=\"codetainer\">simultaneous</code>는 진짜로 동시에 실행되는 경우를 말하며 CPU가 하나면 일어날 수 없는 일이다.\n\n## 예시\n\nWeb browser(화면 출력하는 쓰레드 + 데이터 읽어오는 쓰레드), Word processor(화면 출력하는 쓰레드 + 키보드 입력 받는 쓰레드 + 철자/문법\n오류 확인 쓰레드), 음악 연주기, 동영상 플레이어, Eclipse IDE\n\n우리가 이전 포스팅에서는 <code class=\"codetainer\">Process1 -> Process2 -> Process3...</code>로 프로세스가 스위칭된다고 했지만 사실 운영체제는 다중 스레드를 지원하고 있어서 다음과 같은 흐름을 가진다. <code class=\"codetainer\">Thread1 of Process1 -> Thread2 of Process1 -> Thread1 of Process2 -> Thread2 of Process2 -> Thread3 of Process2 .....</code>\n\n## 쓰레드 구조\n\n![process](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-27-img/2.JPG)<br/>\n\n- 프로세스의 메모리 공간 공유 (code, data)\n- 프로세스의 자원 공유 (file, i/o, …)\n- 비공유: 개별적인 PC(program counter), SP(stack pointer), registers, stack\n\n![process](https://raw.githubusercontent.com/devgaram/TIL/master/OperatingSystem/images/2019-12-27-img/3.JPG)<br/>\n\n**vs 프로세스** <br/>\n프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받는다. 즉, 각 프로세스는 별도의 주소 공간에서 실행되고 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다. 다른 프로세스의 자원에 접근하려면 <code class=\"codetainer\">프로세스 간의 통신(IPC, inter-process communication, 파일, 소켓, 파이프...)</code>을 사용해야 한다.\n\n# # 잠깐 컴퓨터 구조 지식을 채워보자.\n\n## Register(레지스터)\n\nCPU 내부에서 처리할 명령어나 연산의 중간 결과값 등을 일시적으로 기억하는 임시 기억장소다.\n\n- 데이터 레지스터(data register) : CPU가 처리하는 데이터를 임시로 저장\n- <code class=\"codetainer\">주소 레지스터(address register)</code> : 기억장치를 액세스할 주소를 저장하며 포인터(Pointer)라고도 한다. 스택 포인터(SP, Stack Pointer), 베이스 포인터(BP, Base Pointer), 인덱스 포인터(IX, Index Pointer)가 있다.\n- 범용 레지스터(GPR) :주소 레지스터 혹은 데이터 레지스터로 사용될 수 있는 레지스터\n\n## PC\n\n프로그램 카운터(Program counter, PC)는 마이크로프로세서(중앙 처리 장치) 내부에 있는 레지스터 중의 하나로서, 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정한다. 때문에 명령어 포인터라고도 한다.\n\n## 버스\n\nCPU, 메모리, I/O 장치 등과 상호 필요한 정보를 교환하기 위해 연결된 공동의 전송선이다.\n"}}}},"pageContext":{"id":"badecf2a1d8b27736ed2d861abdb95aeffc07070","previousPostId":"050c203f0de4fcd23578d6b6bc29d88531fc4775","nextPostId":"98d190815eccc3f8e3445b39df9139a4209a3f5c"}},"staticQueryHashes":["2685952063","2841359383"]}