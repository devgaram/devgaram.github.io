{"componentChunkName":"component---src-templates-blog-post-js","path":"/146f5eb0b2e672cd66e3c67c69e36f8cac38be23","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"146f5eb0b2e672cd66e3c67c69e36f8cac38be23","text":"# [Vue] 슬롯(Slots)\n\n- Title : [Vue] 슬롯(Slots)\n- Date : 2020-03-09\n- Category: Vue\n\n## Why?\n\n요즘 vue 프로젝트를 하면서 Vuetify 공식 문서를 매일 같이 들락날락 하고 있다. 크롬 탭 한켠에 켜놓고 Vuetify 죠아..🤩하며 잘 쓰고 있던 중 낯선 예제가 눈에 밟혔다. 바로 아래의 `<v-menu>` 컴포넌트의 예시 코드다.\n\n```ts\n    <v-menu offset-y>\n    \t<template v-slot:activator=\"{ on }\">\n    \t  <v-btn\n    \t    color=\"primary\"\n          dark\n          v-on=\"on\"\n    \t   >\n    \t     Dropdown\n    \t\t </v-btn>\n       </template>\n       <v-list>\n         <v-list-item\n           v-for=\"(item, index) in items\"\n           :key=\"index\"\n           @click=\"\"\n         >\n           <v-list-item-title>{{ item.title }}</v-list-item-title>\n         </v-list-item>\n       </v-list>\n     </v-menu>\n```\n\n**`<template v-slot:activator=\"{ on }>`** 음.. slot이 컴포넌트 렌더링할 때 베이스 컴포넌트의 `<slot>` 에 부모 컴포넌트가 들어가는 거 였는 데...? 근데 예제에서 어떻게 리스트를 보였다 숨겼다 하는 거지? 라는 생각이 들었고 지식의 짧음을 깨달아 곧장 Vue 공식 문서를 방문했다.\n\n[슬롯(Slots) - Vue.js](https://kr.vuejs.org/v2/guide/components-slots.html)\n\n## 슬롯?\n\n### A 컴포넌트 안에 B(컴포넌트, 텍스트, HTML 템플릿..)를 넣고 싶을 때\n\n예시로 페이지마다 쓰이는 레이아웃(헤더, 푸터) 컴포넌트에 페이지마다 달라지는 컨텐츠 컴포넌트를 넣고 싶다고 하자.\n\n레이아웃(Layout) 컴포넌트는 아래와 같다.\n\n```ts\n<template>\n  <Header />\n  <main>\n    <slot></slot>\n  </main>\n  <Footer />\n</template>\n```\n\n이제 콘텐츠(Content) 컴포넌트를 Layout 컴포넌트의 `<slot></slot>` 부분에 넣어보자.\n\n콘텐츠(Content) 컴포넌트는 아래와 같다.\n\n```ts\n<template>\n  <Layout>\n    <div>매번 변경되는 컨텐츠들..</div>\n    <Shop />\n  </Layout>\n</template>\n```\n\n만약 레이아웃 컴포넌트에 `<slot>` 이 없으면 위 예제의 `<Layout>` 요소 안에 있는 내용은 무시된다.\n\n### 음 근데 A컴포넌트 안에 여러 `<slot>`을 만들고 싶은데?\n\n당근 가능하다. 위 예제에서 컨텐츠뿐만 아니라 헤더와 푸터도 `<slot>` 요소로 받을 수 있게 바꿔보자\n\n```ts\n<template>\n  <slot name=\"header\"></slot>\n  <main>\n    <slot></slot>\n  </main>\n  <slot name=\"footer\"></slot>\n</template>\n```\n\n자세히 살펴보면 `<slot>`이 name 속성을 가지고 있다. `<main>`안의 `<slot>`은 name이 지정되지 않았는 데 이때는 암묵적으로 \"default\" 이름을 갖는다.\n\n자 이제 레이아웃 컴포넌트에 헤더, 푸터 컴포넌트와 콘텐츠 내용을 전달해보자.\n\n```ts\n    <template>\n    \t<Layout>\n    \t\t<template v-slot:header><Header /></template>\n    \t\t<div>매번 변경되는 컨텐츠들..</div>\n    \t\t<Shop />\n    \t\t<template v-slot:footer><Footer/></template>\n    \t</Layout>\n    </template>\n```\n\nname 속성이 있는 슬롯에 내용을 전달하려면 `<template>`에 `v-slot` 디렉티브를 쓰고 속성에 앞에서 지정한 name을 넣으면 된다. 이제 `<template>` 요소들의 모든 내용들은 적절한 슬롯에 전달된다. `<template>`에 싸여있지 않은 내용들은 default 슬롯으로 간주하여 이름 없는 `<slot>`요소에 전달된다. v-slot:default로 명시적으로 표시할 수도 있는 데 아래 예제로 확인해보자. 아래 예제는 바로 위 예제와 동일하다.\n\n```ts\n    <template>\n    \t<Layout>\n    \t\t<template v-slot:header><Header /></template>\n    \t\t<template v-slot:default>\n    \t\t\t<div>매번 변경되는 컨텐츠들..</div>\n    \t\t\t<Shop />\n    \t\t</template>\n    \t\t<template v-slot:footer><Footer/></template>\n    \t</Layout>\n    </template>\n```\n\nv-slot만 `<template>` 태그에 추가할 수 있다는 점! 기억하기.\n\n### 슬롯에 전달될 내용이 없을 때 디폴트로 어떤 내용을 표시하고 싶으면?\n\n버튼 텍스트를 `<slot>` 요소로 전달 받으려면 아래와 같이 만들어야한다. 컴포넌트의 이름은 SubmitBtn으로 하자.\n\n```ts\n    <template>\n    \t<v-btn type=\"submit\" :color=\"color\">\n    \t\t<slot></slot>\n    \t</v-btn>\n    </template>\n```\n\n아래와 같이 `<slot>`을 \"저장\" 텍스트로 대체해보자\n\n```ts\n<template>\n  <SubmitBtn color=\"grey\">저장</SubmitBtn>\n</template>\n```\n\n근데 `<SubmitBtn>`안에 아무 것도 안적어도 `<slot>`요소가 \"submit\"으로 대체되게 하고 싶다면? SubmitBtn 컴포넌트를 아래와 같이 수정하자.\n\n```ts\n    <template>\n    \t<v-btn type=\"submit\" :color=\"color\">\n    \t\t<slot>submit</slot>\n    \t</v-btn>\n    </template>\n```\n\n이제 아무 내용이 없으면 submit이 렌더링 된다.\n\n```ts\n<template>\n  <SubmitBtn></SubmitBtn>\n</template>\n```\n\n위 코드의 렌더링 결과는 아래와 같다.\n\n```ts\n<v-btn type=\"submit\">submit</v-btn>\n```\n\n### 자. 여기까지 배운 상태에서 v-menu 예제를 다시 살펴보자.\n\n```ts\n    <v-menu offset-y>\n    \t<template v-slot:activator=\"{ on }\">\n    \t  <v-btn\n    \t    color=\"primary\"\n          dark\n          v-on=\"on\"\n    \t   >\n    \t     Dropdown\n    \t\t </v-btn>\n       </template>\n       <v-list>\n         <v-list-item\n           v-for=\"(item, index) in items\"\n           :key=\"index\"\n           @click=\"\"\n         >\n           <v-list-item-title>{{ item.title }}</v-list-item-title>\n         </v-list-item>\n       </v-list>\n     </v-menu>\n```\n\n이정도 해석은 가능할거다. `<v-menu>` 컴포넌트에 `<slot name=\"activator\"></slot>`이 존재하겠구나. 그래서 `<v-btn>` 요소는 \"activator\" 슬롯에 대체되고 `<template>`로 싸여있지않은 `<v-list>` 컴포넌트는 `<slot></slot>` 즉, 이름 없는 \"default\" 슬롯에 전달되겠네!\n\n그래도 여전히 의문이 남아있다. activator=\"{ on }\" 의 의미는 뭐지? `<v-btn>` 요소의 v-on 디렉티브에 on이 전달되는 데? 무슨 의미일까? 계속 슬롯에 대해 알아보자\n\n잠시 컴파일 범위를 짚고 넘어가보자.\n\n> 부모 템플릿 안에 있는 것은 부모 컴포넌트의 범위에 컴파일되고 자식 템플릿 안에 있는 것들은 자식 컴포넌트의 범위에 컴파일된다.\n\n무슨 의미인지 예제로 이해해보자. 우선 자식 컴포넌트를 살펴보자. 베이스 컴포넌트라고 이해해도 좋다. 일부러 아직 `<slot>` 요소를 넣지 않았다. 이 컴포넌트는 props로 items를 전달받고 v-for 디렉티브로 리스트 렌더링을 수행한다. 이 템플릿은 이 컴포넌트의 범위에서 컴파일된다. 즉, items는 이 컴포넌트 범위에 있으므로 `{{ item.name }}` 데이터 옵션이 정상적으로 'a', b', 'c'로 렌더링된다는 의미다.\n\n```ts\n    <template>\n    \t<ul>\n    \t\t<li v-for=\"item in items\" :key=\"item.name\">\n    \t\t\t{{ item.name }}\n    \t\t</li>\n    \t</ul>\n    </template>\n    <script>\n    export default {\n    \tprops: ['items']\n    }\n    /*\n    \titems = [\n    \t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t{ name: 'c', soldout: true, bestten: false  }\n    \t]\n    */\n    </script>\n```\n\n만약 어떤 컴포넌트에서는 soldout 이 true면 \"Sold Out a\" 이런식으로 렌더링하고 싶고 또 다른 컴포넌트에서는 bestten이 true인 아이템만 렌더링하고 싶다면? 물론 또 다른 props를 전달받아서 구분 값으로 사용하여 렌더링하는 방법도 있긴 하다. 하지만 item 속성에 따른 렌더링 방식에 더 다양해진다면 재사용성이 떨어질 것이다. 그럴 때 슬롯을 사용하면된다.\n\n하지만 부모 컴포넌트에서는 베이스 컴포넌트의 데이터를 사용할 수가 없다. items를 넘기므로 items야 물론 접근할 수 있다. 하지만 베이스 컴포넌트에서 렌더링되는 item에 접근할 수가 없는 거다. 컴파일 범위가 다르니 당연한 얘기다. 그럼 어떻게 해야할까? 바로 슬롯스코프를 사용하면 된다.\n\n```ts\n    <template>\n    \t<ul>\n    \t\t<li v-for=\"item in items\" :key=\"item.name\">\n    \t\t\t<slot name=\"item\" :item=\"item\">\n    \t\t\t\t{{ item.name }}\n    \t\t\t</slot>\n    \t\t</li>\n    \t</ul>\n    </template>\n    <script>\n    export default {\n    \tprops: ['items']\n    }\n    /*\n    \titems = [\n    \t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t{ name: 'c', soldout: true, bestten: false  }\n    \t]\n    */\n    </script>\n```\n\n위 코드의 `<slot name=\"item\" :item=\"item\">`에 주목해보자. 이렇게 item 속성으로 item 값을 내보냈다. 이렇게 `<slot>` 요소에 연결된 속성을 슬롯 속성(slot props)라고 한다. 이제 이 베이스 컴포넌트를 사용하는 부모 컴포넌트는 item에 접근할 수 있다. 아래는 베이스 컴포넌트를 사용하여 Sold Out 표시를 해주는 컴포넌트다. `<template v-slot:item=\"{ item }\">` 템플릿 v-slot에 슬롯 속성인 item을 쓰면 된다. 아래처럼 item의 slodout 속성에 접근할 수 있게 되었다.\n\n```ts\n    <template>\n    \t<ItemList v-bind:items=\"items\">\n    \t  <template v-slot:item=\"{ item }\">\n    \t    <span v-if=\"item.soldout\">Sold Out</span>\n    \t    {{ item.name }}\n    \t  </template>\n    \t</ItemList>\n    </template>\n    <script>\n    export default {\n    \tdata() {\n    \t\treturn {\n    \t\t\titems: [\n    \t\t\t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t\t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t\t\t{ name: 'c', soldout: true, bestten: false  }\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n    </script>\n```\n\n마찬가지로 bestten이 true인 경우에만 렌더링하는 컴포넌트에 사용할 수 있다.\n\n```ts\n    <template>\n    \t<ItemList v-bind:items=\"items\">\n    \t  <template v-slot:item=\"{ item }\">\n    \t    <span v-if=\"item.bestten\">{{ item.name }}</span>\n    \t  </template>\n    \t</ItemList>\n    </template>\n    <script>\n    export default {\n    \tdata() {\n    \t\treturn {\n    \t\t\titems: [\n    \t\t\t\t{ name: 'a', soldout: true, bestten: false },\n    \t\t\t\t{ name: 'b', soldout: false, bestten: true},\n    \t\t\t\t{ name: 'c', soldout: true, bestten: false  }\n    \t\t\t]\n    \t\t}\n    \t}\n    }\n    </script>\n```\n\n사실 v-slot:item=\"{ item }\" 은 v-slot:item=\"slotProps\" 와 같은 데 ES6의 구조분해를 이용하여 { item } 처럼 사용한 거다.\n\n휴 거의 다했다. 이제 v-menu를 다시 살펴보자\n\n이제 v-menu 컴포넌트의 on(slotProps)를 부모 컴포넌트에서 사용할 수 있게 했구나. 라는 것이 이해될 것이다. 아마 v-menu에서 on은 이벤트 핸들러로 부모 컴포넌트에서 v-on 요소에 on을 연결하면 해당 컴포넌트가 클릭되면 default 슬롯이 보이도록 개발이 되어있을 것이다.\n\n```ts\n    <v-menu offset-y>\n    \t<template v-slot:activator=\"{ on }\">\n    \t  <v-btn\n    \t    color=\"primary\"\n          dark\n          v-on=\"on\"\n    \t   >\n    \t     Dropdown\n    \t\t </v-btn>\n       </template>\n       <v-list>\n         <v-list-item\n           v-for=\"(item, index) in items\"\n           :key=\"index\"\n           @click=\"\"\n         >\n           <v-list-item-title>{{ item.title }}</v-list-item-title>\n         </v-list-item>\n       </v-list>\n     </v-menu>\n```\n\n슬롯 정리 끝!\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e1d99f9a899dc585ce4b9625b8729cc326c3da77","text":"# Pattern Searching - Naive algorithm\n\n- Title : Pattern Searching - Naive algorithm\n- Date : 2020-03-10\n- Category: Algorithm\n\n## Naive algorithm\n\n문자열 인덱스 0부터 패턴 문자열은 하나씩 비교해가는 방법. 가장 직관적이면서 순수(?)하다.\n\n```cpp\n    #include <iostream>\n    #include <cstring>\n    using namespace std;\n\n    void search(char* pat, char* txt) {\n    \tint M = strlen(pat);\n    \tint N = strlen(txt);\n\n    \tfor (int i=0; i<=N-M; i++) {\n    \t\tint j;\n    \t\tfor (j=0; j<M; j++) {\n    \t\t\tif (txt[i + j] != pat[j]) break;\n    \t\t}\n    \t\tif (j == M)\n    \t\t\tcout << \"Pattern found at index \" << i << endl;\n    \t}\n    }\n    int main() {\n    \tchar txt[] = \"AABAACAADAABAABA\";\n    \tchar pat[] = \"AABA\";\n    \tsearch(pat, txt);\n    \treturn 0;\n    }\n```\n\n## 시간 복잡도\n\n### 최선의 시간 복잡도\n\n- txt[] = \"AABCCAADDEE\"\n- pat[] = \"FAA\"\n\n패턴의 첫번째 문자 'F'가 일치하는 경우가 없어서 `O(n)`의 시간 복잡도를 가진다. n: 탐색 문자열의 길이\n\n### 최악의 시간 복잡도\n\n- txt[] = \"AAAAAAAAAAAAAAAAAA\"\n- pat[] = \"AAAAB\"\n\n패턴의 마지막 문자 'B'만 다를 경우 `O(m*(n-m+1))`의 시간 복잡도를 가진다. m: 패턴 문자열의 길이, n: 탐색 문자열의 길이\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"eb4eae48978a7e276ad569a852c70fbe692ea9ad","text":"# [타입스크립트] 변수 선언과 타입\n\n- Title : [타입스크립트] 변수 선언과 타입\n- Date : 2020-03-08\n- Category: Typescript\n\n## 1. 변수 선언\n\n**var**\n\n- 호이스팅\n- 함수 레벨 스코프\n\n**let**\n\n- 변수를 초기화하기 전에는 변수에 접근할 수 없게 호이스팅 방지\n- 같은 블록 내에서 같은 이름의 변수 중복 선언 불가\n- 블록 레벨 스코프\n\n**const**\n\n- 호이스팅 안함\n- 블록 레벨 스코프\n- 변수를 상수로 선언할 때 사용(재할당되지 않는 읽기 전용 변수)\n- 객체로 초기화하는 경우 값 자체를 재할당할 수는 없으나 속성값의 변경은 허용\n\n> 호이스팅 - 선언한 변수가 스코프의 최상위로 끌어올림 되는 현상\n\n## 2. 타입 검사\n\n**정적 타입 검사**\n\n- 컴파일 타임에 타입 검사\n- 타입 검사하는 데 시간은 들지만 안정성 보장\n- 자바, C++\n\n**동적 타입 검사**\n\n- 실행 시간에 타입 검사 수행\n- 동적 타이핑 수행\n  - 동적 타이핑 : 값을 변수에 할당할 때 타입이 정해지는 것\n- 자바스크립트\n\n**점진적 타입 검사**\n\n- 컴파일 시간에 타입 검사를 수행\n- 타입 선언 생략 허용\n  - 생략시 암시적 형변환 발생\n  - 암시적 형변환 : 컴파일러가 알아서 데이터 타입 변환\n- 여러 타입을 결합해 새로운 타입을 정의하는 것 허용\n- 타입스크립트, 파이썬\n\n## 3. 타입 계층도\n\n- 타입스크립트는 자바스크립트에서 지원하는 내장 타입을 제공하며 크게 기본 타입, 객체 타입, 함수 타입이 있다.\n\n![200308/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Typescript/images/2020-03-08-img/Untitled.png)\n\n## 4. Primitive(기본) 타입\n\n### 1) string, number, boolean 타입\n\n```ts\n// string\nlet name: string = \"rami\"; // 큰 따옴표 사용 권장\nlet sentence: string = `안녕하세요 ${name}입니다.`;\n\n// number\nlet decimal: number = 6;\nlet hex: number = 0xf00d;\nlet binary: number = 0b1010;\nlet octal: number = 0o744;\n\n// boolean\nlet isShow: boolean = false;\n```\n\n### 2) enum 열거 타입\n\n- numberic 값 집합에 친숙한 이름을 부여하는 방법\n- 기본적으로 멤버 번호는 0부터 시작\n- 수동으로 값을 변경할 수도 있음\n\n```ts\nenum Color {\n  Red,\n  Green,\n  Blue\n}\nlet c: Color = Color.Green;\nconsole.log(c); // 1\nconsole.log(typeof Color); // object\n\n// 0대신 1로 시작할 수 있게 --> 1, 2, 3\nenum Color {\n  Red = 1,\n  Green,\n  Blue\n}\nlet c: Color = Color.Green;\n\n// 열거 형 모든 값 수동 설정\nenum Color {\n  Red = 1,\n  Green = 2,\n  Blue = 4\n}\nlet c: Color = Color.Green;\n\n// 2가 Color enum의 어떤 값과 매핑되는 지 모를 때 이름을 찾을 수 있음\nenum Color {\n  Red = 1,\n  Green,\n  Blue\n}\nlet colorName: string = Color[2];\nconsolo.log(colorName); // Green\n```\n\n**const enum**\n\n- 일반 열거형과 달리 컴파일하는 동안 완전히 제거됨\n\n```ts\n// typescript\nenum WeekDay {\n  Mon = 1,\n  Tue,\n  Wed,\n  Thu\n}\nconsole.log(WeekDay.Mon); // 1\nconsole.log(WeekDay[\"Mon\"]); // 1\nconsole.log(WeekDay[WeekDay.Mon]); // Mon\nlet day = WeekDay;\n// enum 객체의 키는 속성의 인덱스, 속성의 이름이 된다.\n// 따라서 객체에 할당되는 속성의 수는 enum 객체의 속성 개수보다 2배 많다.\nconsole.log(day); // {1: \"Mon\", 2: \"Tue\", 3: \"Wed\", 4: \"Thu\", Mon: 1, Tue: 2, Wed: 3, Thu: 4}\n\n// 컴파일 후 ES5\n\"use strict\";\nvar WeekDay;\n(function(WeekDay) {\n  WeekDay[(WeekDay[\"Mon\"] = 1)] = \"Mon\";\n  WeekDay[(WeekDay[\"Tue\"] = 2)] = \"Tue\";\n  WeekDay[(WeekDay[\"Wed\"] = 3)] = \"Wed\";\n  WeekDay[(WeekDay[\"Thu\"] = 4)] = \"Thu\";\n})(WeekDay || (WeekDay = {}));\n```\n\n```ts\n// typescript\nconst enum WeekDay {\n  Mon = 1,\n  Tue,\n  Wed,\n  Thu\n}\nconsole.log(WeekDay.Mon); // 1\nconsole.log(WeekDay[\"Mon\"]); // 1\nconsole.log(WeekDay[WeekDay.Mon]); // 에러, 문자열 리터럴을 이용해서만 접근 가능\nlet day = WeekDay; // 에러, 속성 또는 인덱스 표현식으로만 가능\n// 컴파일 후 ES5\n\"use strict\";\n```\n\n**기타 enum**\n\n```ts\n// 초기값으로 문자열 할당 가능\nenum WeekDay {\n  Mon = \"MON\",\n  Tue = \"TUE\",\n  Wed = \"WED\",\n  Thu = \"TUE\"\n}\nconsole.log(WeekDay.Mon); // MON\nconsole.log(WeekDay[\"Mon\"]); // MON\n// 리버스 매핑 적용 안됨\n// 문자열 할당하면 속성 값으로 속성 이름 알 수 없음\nconsole.log(WeekDay[WeekDay.Mon]); // 에러,\n\n// 문자열 또는 숫자 섞어서 가능\nenum WeekDay {\n  Mon = \"MON\",\n  Tue = 1,\n  Wed = \"WED\",\n  Thu = \"TUE\"\n}\n\n// boolean, 표현식 불가능\nenum WeekDay {\n  Mon = \"MON\",\n  Tue = 1,\n  Wed = true,\n  Thu = \"TUE\"\n}\nenum WeekDay {\n  Mon = \"MON\",\n  Tue = 1,\n  Wed = 1 + 2,\n  Thu = \"TUE\"\n}\n```\n\n### 3) symbol 타입\n\n- Symbol 생성자를 호출하여 생성\n- 불변 고유\n- 심벌 객체는 호출될 때마다 새로운 심벌 객체를 만듬\n- 객체 리터럴의 속성 키로 사용할 수 있음\n\n```ts\nlet hello = Symbol(\"key\");\nlet hello2 = Symbol(\"key\");\nconsole.log(hello === hello2); // false\nconsole.log(hello, hello2); // Symbol(key) Symbol(key)\nconsole.log(typeof hello); // symbol\n\nlet uniqueKey = Symbol();\nlet obj = {\n  [uniqueKey]: 1234,\n  title: \"hi\"\n};\nconsole.log(obj.uniqueKey); // undefined\nconsole.log(obj.title); // hi\nconsole.log(obj); // {title: \"hi\", Symbol(): 1234}\n```\n\n### 4) string literal 타입\n\n```ts\n// 사용자 정의 타입에 정의한 문자열만 할당 받을 수 있음\ntype EventType = \"keyup\" | \"mouseover\";\n```\n\n## 5. Object(객체) 타입\n\n### 1) Array(배열) 타입\n\n- 타입스크립트에서 배열 타입은 배열 타입과 제네릭 배열 타입으로 나뉜다\n\n```ts\nlet arr: string[] = [\"a\", \"b\", \"c\"];\nlet arr2: Array<string> = [\"a\", \"b\", \"c\"];\n```\n\n**배열 타입**\n\n- 요소 타입으로 string, boolean, number와 같은 자바스크립트 내장 타입뿐 아니라 클래스나 인터페이스도 올 수 있음\n\n```ts\nlet items: number[] = [1, 2, 3];\nlet fruits: string[] = [];\nfruits.push(\"banana\");\nfruits.push(\"apple\");\n\n// any 타입 지정하면 어떤 타입이든 배열의 요소로 추가 가능\nlet myVar: any[] = [1, \"hi\", true];\n\n// 유니언 타입\nlet myVar: (number | string | boolean)[] = [1, \"hi\", true];\n```\n\n**제네릭 배열**\n\n- Array<T> 형태로 선언 (T: 타입)\n- 제네릭 타입 인수로 사용된 타입은 컴파일 시점에 타입을 검사함\n\n```ts\nlet num: Array<number> = [1, 2, 3];\nlet num: Array<number | string> = [1, \"hello\"];\nlet num2: typeof num = [1, \"hello\"]; // 타입 쿼리로 num 변수의 타입을 참조\n\n// 배열요소로 익명 함수 받으려면\nlet nums: Array<() => string> = [() => \"one\", () => \"two\"];\nconsole.log(nums[0]()); // one 출력\n\n// 배열 선언 부분과 요소 추가하는 부분 분리\nlet num3: Array<number> = new Array<number>();\nnum3.push(1);\nnum3.push(2);\nnum4.push(3);\n```\n\n타입스크립트에서 배열 타입이든 제네릭 타입이든 컴파일 시 타입 검사를 위해 필요하며 컴파일 후(ES5)에는 타입이 제거된 배열만 남는다.\n\n### 2) Tuple(튜플) 타입\n\n- 배열 요소가 n개로 정해질 때 각 요소별로 타입을 지정함\n\n```ts\nlet x: [string, number];\nx = [\"tuple\", 100]; // 성공\nx = [10, \"tuple\"]; // 에러\nconsole.log(typeof x, typeof x[0], typeof x[1]); // object string number\nconsole.log(x[0].substring(1)); // uple\nconsole.log(x[1].substring(1)); // 에러\nx[3] = \"world\"; // 에러 - [string, number] 타입에서 3번째 속성이 없어서\n```\n\nFunction, 생성자, Class, Interface는 추후 정리\n\n## 6. Union 타입\n\n2개 이상의 타입을 하나의 타입으로 정의\n\n```ts\nlet x: string | number;\n```\n\n## 7. Intersection 타입\n\n두 타입을 합쳐 하나로 만들 수 있는 타입\n\n```ts\ninterface Cat {\n  leg: number;\n}\ninterface Bird {\n  wing: number;\n}\nlet birdCat: Cat & Bird = { leg: 4, wing: 2 };\n```\n\n## 8. Void 타입\n\n- 빈 값을 나타내는 타입\n- 함수의 반환값이 없을 때\n- null이나 undefined만 할당 가능\n  - void 타입이 null, undefined의 상위 타입이기 때문\n\n```ts\n// 반환값이 없는 함수\nfunction say(): void {\n  alert(\"hello!\");\n}\n// 반환값은 void이지만 실제로는 undefined가 할당됨\nlet mySay: void = say();\n\n// 변수에 undefined나 null 할당 -> 비추\nlet unusable: void = undefined;\nlet unusable; // 위 코드와 같은 의미\nlet unusable = null; // 쓰지 말자\n```\n\n> 변수를 선언할 때 값을 할당하지 않았음을 나타내기 위해 선언한 변수에 null을 할당하는 것은 권장하지 않음\n\n- null이나 undefined를 할당하면 컴파일러 오류가 발생하도록 tsconfig.json에 아래와 같이 설정한다.\n\n```ts\n    {\n    \t\"compilerOptions\": {\n    \t\t\"strictNullChecks\": true\n    \t}\n    }\n```\n\n## 9. null과 undefined 타입\n\n- 둘다 모든 타입의 하위타입\n- undefined는 선언은 됐지만 값이 할당되지 않은 것\n- null은 값은 할당됐지만 값이 빈 객체로 초기화되는 것\n\n```ts\nlet person = { name: \"happy\" };\nperson = null;\nconsole.log(typeof person); // object\n\n// undefined vs null\nlet testUndefined;\nconsole.log(testUndefined, typeof testUndefined); // undefined 'undefined'\n\nlet testUndefined2: undefined = undefined;\nconsole.log(testUndefined2, typeof testUndefined2); // undefined 'undefined'\n\nlet testNull: null = null;\nconsole.log(testNull, typeof testNull); // null 'object'\n\n// 비교\nconsole.log(undefined === null); // false\nconsole.log(undefined == null); // true\nconsole.log(undefined == undefined); // true\n```\n\n## 10. Any 타입\n\n- 제약이 없는 타입으로 어떤 타입의 값도 받아들일 수 있음\n- 최소한의 정적 타입 검사만 수행\n- 외부라이브러리의 연산 결과를 받는 것과 같이 타입 결과를 예측할 수 없을 때\n- 배열 값의 타입이 다양해서 한 가지 타입으로 고정할 수 없을 때\n\n```ts\nlet basket: any = 10;\nbasket = true;\nbasket = \"banana\";\nconsole.log(basket);\n\nlet vList: any[] = [1, false, \"happy\"];\nconsole.log(vList[0]);\n```\n\n### 1) **최소한의 정적 타입 검사...?**\n\n- any 타입으로 선언된 변수는 최소한의 정적 타입 검사만 수행\n\n아래 예를 보면 any 타입으로 선언한 경우, 존재하지않는 함수를 호출할 때 컴파일 에러는 안나지만 런타임 에러가 난다. 속성의 유무를 런타임 시에 검사하나보다..\n\n```ts\nlet number = 50;\nlet number2: any = 50;\n\nconsole.log(number.toFixed(2)); // 50.00\nconsole.log(number2.toFixed(2)); // 50.00\n\nnumber.notExistMethod(); // 컴파일 타임에 에러\nnumber2.notExistMethod(); // 컴파일 에러는 안나지만 런타임 에러\n```\n\n### 2) object 타입과의 차이...?\n\nobject도 any 처럼 타입 구분 없이 값을 할당할 수 있는 특성이 있다. 하지만 속성 유무를 검사하는 시간이 다름. any는 런타임 시에 검사, object는 컴파일 시간에 속성 유무 검사\n\n```ts\nlet number2: Object = 50;\n// 변수에 할당된 타입이 number인지 string인지 몰라서 컴파일 에러 뱉음\nnumber2.toFixed(1); // property 'toFixed' does not exist on type 'Object'\n```\n\n### 3) 비교\n\n```ts\nlet number1 = 50;\nlet number2: any = 50;\nlet number3: Object = 50;\nconsole.log(typeof number1); // number\nconsole.log(typeof number2); // number\nconsole.log(typeof number3); // number\nconsole.log(number1.toFixed(2)); // 50.00\nconsole.log(number2.toFixed(2)); // 50.00\nconsole.log(number3.toFixed(2)); // 컴파일 에러, Object에 tofixed가 없음\n```\n\n### 4) noImplicitAny 옵션\n\n타입을 생략하면 명시적으로 any 타입이 된다. any 타입임을 추론할 수는 있지만, 명시적으로 any 타입임을 선언하는 것이 더 명확하므로 any 타입을 강제하는 게 좋다. 이는 tsconfig.json 파일에서 noImplicitAny 속성을 true로 하면 된다.\n"}}}},"pageContext":{"id":"146f5eb0b2e672cd66e3c67c69e36f8cac38be23","previousPostId":"e1d99f9a899dc585ce4b9625b8729cc326c3da77","nextPostId":"eb4eae48978a7e276ad569a852c70fbe692ea9ad"}},"staticQueryHashes":["2685952063","2841359383"]}