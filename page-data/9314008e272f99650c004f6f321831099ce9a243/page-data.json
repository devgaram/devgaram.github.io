{"componentChunkName":"component---src-templates-blog-post-js","path":"/9314008e272f99650c004f6f321831099ce9a243","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"9314008e272f99650c004f6f321831099ce9a243","text":"# Arrow function\n\nDate: Jun 14, 2020\n\n- Title : Arrow function\n- Date : 2020-06-14\n- Category : Javascript\n\n# 화살표 함수\n\nES6에 익명 함수를 간단하게 표현할 수 있는 화살표 표현식이 추가되었다.\n\n## 기존 익명 함수 vs 화살표 함수\n\n콜백 함수로 실행될 때 기존의 익명 함수는 글로벌 컨텍스트에 접근 하였으나, 함수 화살표 표현식은 콜백 함수를 할당한 당시의 컨텍스트를 그대로 활용한다. \n\n```javascript\nvar name = 'global';\nfunction Person() {\n\tthis.name = 'garam';\n\n\tsetTimeout(() => alert(`my name is ${this.name}`), 100); //garam\n\tsetTimeout(function() {\n\t\talert(`Global name is ${this.name}`); // global\n\t}, 100);\n}\n\nlet person = new Person();\n```\n\n화살표 함수는 함수 선언 시 this가 바인딩 할 객체가 **정적**으로 결정된다. 즉 일반 함수와 달리 화살표 함수는 항상 **상위 스코프의 this**를 가리킨다. 이를 `Lexical this`라고 한다.\n\n> 자바 스크립트는 함수 호출 시 this가 바인딩 할 객체가 **동적**으로 결정된다. 함수 선언 시 this에 바인딩 할 객체가 정적으로 결정되는 것이 아니라 **함수를 호출할 때 함수가 어떻게 호출 되었는지에 따라 this가 바인딩할 객체를 동적**으로 결정한다.\n\n```javascript\nconst test = {\n  name: 'test object',\n  createAnonFunction: function() {\n    return function() {\n      console.log(this.name);\n      console.log(arguments);\n    };\n  },\n\n  createArrowFunction: function() {\n    return () => {\n      console.log(this.name);\n      console.log(arguments);\n    };\n  }\n};\n\nconst anon = test.createAnonFunction('hello', 'world'); \n// undefined\n// {}\nconst arrow = test.createArrowFunction('hello', 'world');\n// test object\n// { '0': 'hello', '1': 'world' }\n```\n\n기존 익명 함수는 함수가 호출 되었을 때의 컨텍스트를 가진다. 즉 `test.createAnonFunction`이 글로벌 컨텍스트에서 호출 되었기에 `this.name`과 `arguments` 객체를 얻을 수 없다. \n\n## 화살표 함수 언제 쓰지 말아야 할까?\n\n### 객체의 메소드를 정의할 때\n\n```javascript\nconst calculate = {\n  array: [1, 2, 3],\n  sum: () => {\n    console.log(this === window); // => true\n    return this.array.reduce((result, item) => result + item);\n  }\n};\nconsole.log(this === window); // => true\n// Throws \"TypeError: Cannot read property 'reduce' of undefined\"\ncalculate.sum();\n```\n\n메소드로 정의한 화살표 함수 내부의 this는 메소드를 소유한 객체를 가리키지 않고 상위 컨텍스트인 `window`를 가리킨다. 아래와 같이 사용 해야 한다.\n\n```javascript\nconst calculate = {  \n  array: [1, 2, 3],\n  sum() {\n    console.log(this === calculate); // => true\n    return this.array.reduce((result, item) => result + item);\n  }\n};\ncalculate.sum(); // => 6\n```\n\n### 프로토타입 방식으로 객체 메소드 정의할 때\n\n```javascript\nfunction MyCat(name) {\n  this.catName = name;\n}\nMyCat.prototype.sayCatName = () => {\n  console.log(this === window); // => true\n  return this.catName;\n};\nconst cat = new MyCat('Mew');\ncat.sayCatName(); // => undefined\n```\n\n```javascript\nfunction MyCat(name) {\n  this.catName = name;\n}\nMyCat.prototype.sayCatName = function() {\n  console.log(this === cat); // => true\n  return this.catName;\n};\nconst cat = new MyCat('Mew');\ncat.sayCatName(); // => 'Mew'\n```\n\n### 이벤트 리스너 콜백함수\n\n```javascript\nconst button = document.getElementById('myButton');\nbutton.addEventListener('click', () => {\n  console.log(this === window); // => true\n  this.innerHTML = 'Clicked button';\n});\n```\n\n`this`는 글로벌 컨텍스트에 바인딩 된다. 클릭 이벤트가 발생하면 브라우저는 버튼 컨텍스트와 함께 핸들러 함수를 실행 시킨다. 화살표 표현식으로 정의된 함수의 경우는 정적으로 `this`가 바인딩 되기 때문에 `this`가 동적으로 변경되는 이벤트 콜백 함수로 적절하지 않다.\n\n```javascript\nconst button = document.getElementById('myButton');\nbutton.addEventListener('click', function() {\n  console.log(this === button); // => true\n  this.innerHTML = 'Clicked button';\n});\n```\n\n기존 익명 함수는 타켓 엘리먼트에 의존하여 this를 바꾸는 것을 허용한다.\n\n### 생성자 함수\n\n모든 객체는 자신의 `prototype`으로 부터 `constructor` 속성을 상속하기 때문에 `prototype` 속성을 가지고 있어야 한다. 하지만 화살표 표현식으로 정의된 함수는 `prototype` 속성이 없어서 생성자 함수로 사용될 수 없다.\n\n```javascript\nconst Foo = () => {};\n\n// 화살표 함수는 prototype 프로퍼티가 없다\nconsole.log(Foo.hasOwnProperty('prototype')); // false\n\nconst foo = new Foo(); // TypeError: Foo is not a constructor\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"1a0d75577712c0855f91cf05f5e12d0107fd92c5","text":"# Javascript module\n\nDate: Jun 20, 2020\n\n- Title : Javascript module\n- Date : 2020-06-20\n- Category : Javascript\n\n# ES6 module 등장 배경\n\n클라이언트 사이드 자바스크립트는 파일을 여러 개로 분리하여 `script` 태그로 로드 하여도 분리된 자바스크립트 파일들이 결국 하나의 자바스크립트 파일 내에 있는 것처럼 **하나의 전역 객체를 공유**한다. \n\n이런 상황을 해결하고자`CommonJS`와 `AMD` 가 등장했고 자바스크립트의 모듈화는 크게 `CommonJS`와 `AMD` 진영으로 나뉘게 되었다. 브라우저에서 모듈을 사용하기 위해서는 `CommonJS` 또는 `AMD`를 구현한 모듈 로더 라이브러리를 사용해야 했다.\n\n이러한 상황에서 ES6는 클라이언트 사이드 자바스크립트에서도 동작하는 모듈 기능을 추가하였다.  `<script>` 태그에 `type=\"module\"` 요소를 추가하면 로드 된 자바스크립트 파일은 모듈로서 동작하여 **모듈 스코프**를 갖는다. 추가적으로 ES6는 모듈의 파일 확장자를 `mjs`로 설정 하기를  권장하고 있다.\n\n```bash\n<script type=\"module\" src=\"main.mjs\"></script>\n```\n\n하지만 IE를 포함한 구형 브라우저의 경우는 ES6 모듈을 지원하지 않아서 사용하더라도 트랜스 파일링이나 번들링이 필요하다. 이러한 이유로 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 웹팩, 바벨 같은 모듈 기반 시스템을 사용한다.\n\n# Module\n\n- ES6 모듈은 명시적으로 `use strict` 를 쓰지 않아도 엄격 모드로 코드가 실행된다.\n- `import`와 `export` 문은 모듈 내에서만 사용할 수 있다. HTML에서 모듈을 사용하려면 아래와 같이 `<script>` 요소에 `type=\"module\"` 을 포함시켜야 한다.\n- 모듈 스크립트를 불러올 때 자동으로 `defer`로 설정된다.\n\n    > 브라우저는 `script` 태그를 만나면 우선 해당 스크립트를 받아 해석하고 실행할 때까지 웹 문서의 HTML 코드 파싱 작업을 잠시 미룬다. 따라서 용량이 큰 스크립트를 문서 해석 초기에 만나게 되면 해당 페이지를 불러오는 속도가 지체된다. 이러한 병목 현상을 막기 위해 `script` 태그의 `async`와 `defer`속성을 사용한다. `script`가 문서를 직접 만지고 조작하거나 서로 간 로딩 순서가 중요할 때에는 `defer` 속성을 쓰고, 그렇지 않다면 `async`속성을 써서 웹 페이지 로딩 속도를 줄일 수 있다.\n\n    ![Untitled](https://user-images.githubusercontent.com/34448538/85366790-01836700-b563-11ea-8163-c324bce13a66.png)\n\n## 실습\n\n### export\n\n```jsx\n// square.js\n\n// ...randowSquare 정의\n\nexport default randomSquare;\n\nexport const name = 'square';\n\nexport function draw(ctx, length, x, y, color) {\n  ctx.fillStyle = color;\n  ctx.fillRect(x, y, length, length);\n\n  return {\n    length: length,\n    x: x,\n    y: y,\n    color: color\n  };\n}\n```\n\n### import\n\n```jsx\n// main.js\nimport randomSquare, { name, draw } from './modules/square.js';\n```\n\n### default export 이름 변경\n\n```jsx\nimport {default as randomSquare} from './modules/square.js';\n```\n\n### named export 이름 변경\n\n```jsx\n// inside module.js\nexport {\n  function1 as newFunctionName,\n  function2 as anotherNewFunctionName\n};\n\n// inside main.js\nimport { newFunctionName, anotherNewFunctionName } from './modules/module.js';\n```\n\n```jsx\n// inside module.js\nexport { function1, function2 };\n\n// inside main.js\nimport { function1 as newFunctionName,\n         function2 as anotherNewFunctionName } from './modules/module.js';\n```\n\n참고\n\n[Module | PoiemaWeb](https://poiemaweb.com/es6-module)\n\n[script 태그의 async와 defer 속성](https://appletree.or.kr/blog/web-development/javascript/script-%ED%83%9C%EA%B7%B8%EC%9D%98-async%EC%99%80-defer-%EC%86%8D%EC%84%B1/)\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"3c7c4a385e5202b5904a3a48543da5209ff30efa","text":"# Strict Mode\n\nDate: Jun 13, 2020\n\n- Title : Strict Mode\n- Date : 2020-06-13\n- Category : Javascript\n\n# Strict mode\n\n- Javscript ES5 이후로 권장하는 코딩 스타일 중 하나는 `Strict mode`를 사용하는 것이다.\n- Javascript 언어의 문법을 보다 엄격히 적용하여 기존에는 **무시 되던 오류를 발생**시킬 가능성이 높거나 Javascript **엔진의 최적화 작업에 문제**를 일으킬 수 있는 코드에 대해 **명시적인 에러**를 발생시킨다.\n- Strict mode는 ES5에 정의되어 있으며 브라우저가 Strict mode를 지원하지 않아도 실행하는 데 전혀 무관하니 Strict mode로 설정해서 개발하는 것이 좋다.\n- Strict mode를 지원하지 않는 IE9 이전 버전에서는 문자열로 무시되고 일반 모드로 실행된다.\n\n전역 strict mode 사용 방법(전역에 적용하는 것은 피하자!)\n\n```javascript\n\"use strict\";\n```\n\n파일 상단에 키워드를 넣으면 전체 소스 파일에 대해서 엄격 모드로 실행된다.\n\n함수 내부에서 strict mode 사용 방법\n\n```javascript\n(function() {\n\t\"use strict\";\n}());\n```\n\n즉시 실행 함수로 스크립트 전체를 감싸서 스코프를 구분하고 즉시 실행 함수의 선두에 strict mode를 적용한다.\n\n## 예시\n\nvar, const, let 없이 변수를 사용할 때 레퍼런스 오류 발생\n\n```javascript\n(function(){\n\t\"use strict\";\n\tx = 1;\n\tconsole.log(x); // Uncaught ReferenceError: x is not defined\n}());\n```\n\n변수나 함수를 삭제하려고 하면 문법 오류 발생\n\n```javascript\n(function(){\n\t\"use strict\";\n\tlet x = 1;\n\tfunction fun() {}\n\n\tdelete x;\n\tdelete fun;\n\t// SyntaxError: Delete of an unqualified identifier in strict mode.\n\n}());\n```\n\n중복되는 파라미터명이 있을 때 문법 오류 발생\n\n```javascript\n(function(win, doc, doc){\n\t\"use strict\";\n\tconsole.log(doc); // SyntaxError: Duplicate parameter name not allowed in this context\n}(window, document));\n```\n\nargument를 설정하려고 하면 문법 오류 발생\n\n```javascript\n(function(win, doc, doc){\n\t\"use strict\";\n\targuments = [1, 2, 3];\n\tconsole.log(arguments); // SyntaxError: Unexpected eval or arguments in strict mode\n}(window, document));\n```\n"}}}},"pageContext":{"id":"9314008e272f99650c004f6f321831099ce9a243","previousPostId":"1a0d75577712c0855f91cf05f5e12d0107fd92c5","nextPostId":"3c7c4a385e5202b5904a3a48543da5209ff30efa"}},"staticQueryHashes":["2685952063","2841359383"]}