{"componentChunkName":"component---src-templates-blog-post-js","path":"/47fd52255ef30bd58a17b3696a2a9869befb8488","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"47fd52255ef30bd58a17b3696a2a9869befb8488","text":"# 프로그래머스 다음 큰 숫자 Javascript\n\n- Title : 프로그래머스 다음 큰 숫자 Javascript\n- Date : 2019-11-29\n- Category: 알고리즘 풀이\n\n# 문제 설명\n\n자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다.\n\n- 조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다.\n- 조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다. \\*조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다.\n\n예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다.\n\n자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요.\n\n# 내 풀이\n\n2진수 n의 1 비트 갯수와 같은 비트수를 가지는 숫자를 n+1부터 반복을 돌려서 찾으면 된다.\n\n```javascript\nfunction solution(n) {\n  let nBit = getBitCount(n);\n  while (true) {\n    if (getBitCount(++n) === nBit) break;\n  }\n\n  function getBitCount(number) {\n    let bitCount = 0;\n    while (number > 0) {\n      if (number & (1 === 1)) bitCount++;\n      number = number >>> 1;\n    }\n    return bitCount;\n  }\n\n  return n;\n}\n```\n\n# 다른 사람 풀이\n\n풀고 다른 사람의 풀이를 보니 아이디어는 비슷했으나 비트 수를 세는 방법이 다양했다.\n\n1. String.prototype.match() 메서드와 정규 표현식 이용하기\n\n```javascript\nfunction solution(n) {\n  // console.log(n.toString(2).match(/1/g)) : [ '1', '1', '1', '1' ] 배열 형태로 반환\n  let nBit = n.toString(2).match(/1/g).length;\n  while (true) if ((++n).toString(2).match(/1/g).length === nBit) return n;\n}\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"67bc7c019b3bd9c9383545a07d1976ba5bc817a9","text":"# 자바스크립트의 실행 컨텍스트\n\n- Title : 자바스크립트의 실행 컨텍스트\n- Date : 2019-12-09\n- Category: Javascript\n\n인사이드 자바스크립트를 정리하며 작성한 포스팅입니다.  \n이 포스팅은 실행 컨텍스트의 개념과 생성 과정에 대해 정리한 내용이며 실행 컨텍스트 이해를 위한 필수 개념인 스코프 체인과 this 바인딩에 대해서는 추후 정리할 예정입니다.\n\n# 실행 컨텍스트란?\n\n콜 스택에 쌓이는 각각의 정보들이 하나의 실행 컨텍스트라고 생각하며 아래의 문구를 읽어보자.\n\n- ECMAScript는 **실행 가능한 코드를 형상화하고 구분하는 추상적인 개념**으로 정의한다.\n- **실행 가능한 자바스크립트 코드 블록이 실행되는 환경**으로 코드 블록 안에는 변수, 객체, 실행 가능한 코드가 들어있다.\n- 스택의 TOP에 위치하는 실행 컨텍스트가 **현재 실행되는 컨텍스트**다.\n- 현재 실행되는 컨텍스트와 관련 없는 코드 블록이 실행되면 새로운 실행 컨텍스트가 생성되어 스택에 쌓이고 제어권이 생성된 컨텍스트로 이동한다.\n\n그렇다면 실행 컨텍스트가 형성되는 경우는 언제일까?  \nECMAScript에서 실행 컨텍스트가 형성되는 경우를 다음과 같이 규정하고 있다.\n\n- 전역 코드\n- eval() 함수로 실행되는 코드\n- **함수 안의 코드를 실행하는 경우** (대부분의 경우)\n\n# 실행 컨텍스트 생성 과정\n\n자바스크립트에서 함수를 실행하여 실행 컨텍스트를 생성하면 자바스크립트 엔진은 다음 순서대로 작업을 실행한다.\n\n## 1. 활성 객체 생성\n\n실행 컨텍스트가 생성되면 엔진은 이 컨텍스트가 접근 할 수 있는 활성 객체를 생성하며 활성 객체에 앞으로 사용할 매개변수, 사용자 정의 변수 및 객체를 저장한다.\n\n## 2. arguments 객체 생성\n\n2단계에서는 arguments 객체를 생성하며 앞서 만들어진 활성 객체는 이 arguments 객체를 참조한다.\n\n잠깐 arguments 객체에 대해 알아보고 넘어가자\n\n```javascript\nfunction func(arg1, arg2) {\n  console.log(arg1, arg2);\n}\n\nfunc(); // undefined undefined\nfunc(1); // 1 undefined\nfunc(1, 2); // 1 2\nfunc(1, 2, 3); // 1 2\n```\n\n자바스크립트에서는 위 예제와 같이 함수 형식에 맞춰 인자 값을 넘겨주지 않아도 에러가 발생하지 않는다. 넘겨지지 않은 인자에는 **undefined**값이 할당되고, 초과된 인수는 무시된다.\n\n이러한 자바스크립트 특성 때문에 함수 코드를 작성할 때, 런타임 시에 호출된 인자의 개수를 확인하고 이에 따라 동작을 다르게 해줘야 할 경우가 있는 데, 이를 가능케 하는 게 바로 **arguments 객체**다.\n\n자바스크립트에서는 함수를 호출할 때 인수들과 함께 암묵적으로 arguments 객체가 함수 내부로 전달되며 arguments 객체에 넘긴 인자들이 배열형태로 저장된다. 단, 실제 배열이 아닌 **유사 배열 객체**다. 유사 배열 객체는 length 프로퍼티가 있어서 배열과 유사하게 동작하지만, 배열 메서드를 사용할 경우 에러가 발생한다.\n\n만약 arguments 객체에서 배열 메서드를 사용하고 싶다면 명시적으로 this를 바인딩 하면 된다.\ncall과 apply 메서드를 이용하여 this를 바인딩 할 수 있고, ES6 부터는 Arrays.from() 메서드와 전개 연산자를 사용할 수 있다.\n\n```javascript\nvar args = Array.prototype.slice.apply(arguments); // Array.prototype.slice() 메서드를 호출한다. 단, this는 arguments 객체로 바인딩한다.\n\n// ES6 이후\nvar args = Array.from(arguments);\nvar args = [...arguments];\n```\n\n## 3. 스코프 정보 생성\n\n현재 컨텍스트의 유효 범위를 나타내는 **스코프 정보**를 생성한다.  \n스코프 정보는 현재 실행 중인 실행 컨텍스트 안에서 **연결 리스트**와 유사한 형식으로 만들어진다.  \n현재 컨텍스트에서 특정 변수에 접근해야 할 경우, 이 리스트를 사용하며 현재 컨텍스트의 변수뿐 아니라 상위 실행 컨텍스트의 변수도 접근이 가능하다. 이 리스트에서 변수를 찾지 못하면 정의되지 않은 변수로 판단하여 에러를 검출한다. 이 때, 활성 객체는 리스트의 맨 앞에 추가된다.\n\n스코프 체인이 어떻게 만들어지는 지는 추후에 포스팅할 예정이다.\n\n## 4. 변수 생성\n\n실행 컨텍스트 내부에서 사용되는 **지역 변수**의 생성이 이루어진다. 여기서 생성되는 변수는 변수 객체에 저장되며 변수 객체는 앞서 생성한 활성 객체다.\n\n- 지역 변수나 내부 함수를 메모리에 생성하고 지역 변수에는undefined를 할당한다.\n- 인자를 생성하고 값을 할당한다. 인자값이 넘겨지지 않았다면 undefined를 할당한다.\n- 메모리에 생성할 뿐, **초기화**는 이루어지지 않는다.\n\n## 5. this 바인딩\n\n함수 호출 패턴에 따라 this는 다른 객체를 참조(바인딩)하며, this가 참조하는 객체가 없으면 전역 객체를 참조한다. this 함수 호출 패턴은 중요한 개념이므로 추후에 포스팅할 예정이다.\n\n## 6. 코드 실행\n\n코드 블록의 여러 가지 표현식이 실행되면서 변수의 초기화 및 연산, 또 다른 함수 실행 등이 이루어진다.\n\n**참고**  \n전역 실행 컨텍스트는 일반적인 실행 컨텍스트와 약간 다르다.\n\n- arguments 객체가 없다.\n- 스코프 체인은 전역 객체 하나만을 포함한다.\n- 전역 코드가 실행될 때 생성되는 컨텍스트다.\n- 전역 실행 컨텍스트의 **변수 객체는 전역 객체(window)다.** 따라서 전역적으로 선언된 함수와 변수는 전역 객체의 프로퍼티가 된다.\n\n```javascript\nvar a = 10;\nconsole.log(window.a); // 10\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"0b7c34714ce4c87957b97c6cb4a503aa70efdaf6","text":"# 백준 설탕배달 Java\n\n- Title : 백준 설탕배달 Java\n- Date : 2019-12-09\n- Category: 알고리즘 풀이\n\n# 문제 설명\n\n상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.\n\n상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.\n\n상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.\n\n**입력**  \n첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)\n\n**출력**  \n상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.\n\n# 내 풀이\n\n최소 개수의 봉지를 구해야해서 5킬로그램 봉지부터 계산한다.\n\n```java\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tSystem.out.println(Solution(N));\n\t}\n\n\tpublic static int Solution(int N) {\n\t\tint c = N / 5;\n\t\tint r = N % 5;\n\t\twhile (c >= 0 && r > 0) {\n\t\t\tif (r % 3 == 0) {\n\t\t\t\tc += r/3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc--;\n\t\t\tr += 5;\n\t\t}\n\t\tif (c < 0) return -1;\n\t\treturn c;\n\t}\n}\n```\n"}}}},"pageContext":{"id":"47fd52255ef30bd58a17b3696a2a9869befb8488","previousPostId":"67bc7c019b3bd9c9383545a07d1976ba5bc817a9","nextPostId":"0b7c34714ce4c87957b97c6cb4a503aa70efdaf6"}},"staticQueryHashes":["2841359383"]}