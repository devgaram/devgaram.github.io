{"componentChunkName":"component---src-templates-blog-post-js","path":"/e8be63527de9580685e34fc4299ba081b8713fe7","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e8be63527de9580685e34fc4299ba081b8713fe7","text":"# [생활코딩] javascript 객체지향2\n\n- Title : [생활코딩] javascript 객체지향2\n- Date : 2018-01-13\n- Category: Javascript\n\n생활코딩 객체지향 파트 중 상속과 프로토타입에 대한 내용을 정리했습니다.\n\n# 1. 상속\n\n상속을 하기 위한 준비 작업\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.name = null;\nPerson.prototype.introduce = function() {\n  return \"My name is\" + this.name;\n};\n\nvar p1 = new Person(\"egoing\");\ndocument.write(p1.introduce()); //My name is egoing\n```\n\n객체의 프로퍼티 정의 방법은 생성자를 이용하는 것과 프로토타입을 이용하는 것이 있다.  \nPerson 객체에는 prototype이라는 속성이 있는 데 그 안에는 어떤 객체가 있다.  \n.name을 통해 그 객체에 값을 줄 수 있다.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.name = null;\nPerson.prototype.introduce = function() {\n  return \"My name is\" + this.name;\n};\nfunction Programmer(name) {\n  this.name = name;\n}\nfunction Designer(name) {\n  this.name = name;\n}\n\n/**상속방법**/\nDesigner.prototype = new Person();\nDesigner.prototype.design = function() {\n  return \"beautiful!\";\n};\nProgrammer.prototype = new Person();\nProgrammer.prototype.coding = function() {\n  return \"hello world!\";\n};\n\nvar p1 = new Programmer(\"egoing\");\ndocument.write(p1.introduce() + \"\"); //My name is egoing이 출력됨\ndocument.write(p1.coding() + \"\"); //hello world!\n\nvar p2 = new Desiner(\"leezche\");\ndocument.write(p2.design() + \"\"); //beautiful!\n```\n\nProgrammer에는 introduce 속성이 정의되어 있지않은데 어떻게 사용할 수 있었을까?  \nPerson의 introduce를 상속받았기 때문이다.\n\n객체를 생성할 때, 자바스크립트는 생성자 함수가 prototype라는 프로퍼티를 갖고 있는 지 확인한다.  \n그리고 생성자 함수에 들어있는 객체와 똑같은 객체를 만들어서 생성자의 결과로 리턴을 해준다.\n\nname과 introduce라는 프로퍼티가 prototype이라는 객체가 가지고 있다.  \n즉, prototype이라는 객체를 리턴한다?  \n그래서 Programmer의 prototype이라는 프로퍼티에 저장된다.\n\n<span class=\"clr-note\">\n*생성자의 prototype에 상속받을 객체를 new 한다.    \n*Programmer.prototype = new Person()\n</span>\n\n기본적으로 가지고있는 property를 가진 객체를 생성하기 위해서 객체 리터럴 대신, new라는 키워드를 사용한다.\n\n# 2. prototype\n\n```javascript\nfunction Ultra() {}\nUltra.prototype.ultraProp = true;\n\nfunction Super() {}\nSuper.prototype = new Ultra();\n\nfunction sub() {}\nSub.prototype = new Super();\n\nvar o = new Sub();\nconsole.log(o.ultraProp); //true출력됨.\n\n//1)\no.ultraProp = 1;\nconsole.log(o.ultraProp); //1\n```\n\no.ultraProp o라는 객체가 ultraProp를 가지고 있는지 찾는다. 그래서 1이 출력됨.\n\n```javascript\nfunction Ultra() {}\nUltra.prototype.ultraProp = true;\n\nfunction Super() {}\nSuper.prototype = new Ultra();\n\nfunction sub() {}\nSub.prototype = new Super();\nSub.prototype.ultraProp = 2;\n\nvar o = new Sub();\nconsole.log(o.ultraProp); //2가 출력됨\n```\n\no객체에 ultraProp 프로퍼티를 찾는다. 없으면 o라는 객체의 생성자를 알아 낸후, 이 생성자의 프로토타입 객체를 뒤져서 그 객체의 propery에 ultraProp가 있는 지 찾는다.\n\n```javascript\nfunction Ultra() {}\nUltra.prototype.ultraProp = true;\n\nfunction Super() {}\nSuper.prototype = new Ultra();\n\nfunction sub() {}\nvar s = new Super();\ns.ultraProp = 3;\nSub.prototype = s;\n\nvar o = new Sub();\nconsole.log(o.ultraProp); //3이 출력됨\n```\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"803f4d7096343a90d391862bb2f929d76497a8e8","text":"# [생활코딩] javascript 객체지향1\n\n- Title : [생활코딩] javascript 객체지향1\n- Date : 2018-01-13\n- Category: Javascript\n\n생활코딩 객체지향에 대한 내용을 정리했습니다.\n\n객체(object)는 연관되어 있는 것(변수, 메소드)들을 그룹화한 것, 각 그룹화된 것은 독립성을 가지는 부품이 된다.\n\n# 1. 객체의 생성 방법\n\nthis는 함수가 속해있는 객체인 person을 가리킨다.\n\n```javascript\nvar person = {};\nperson.name = \"egoing\";\nperson.introduce = function() {\n  return \"My name is\" + this.name;\n};\ndocument.write(person.introduce());\n```\n\n```javascript\nvar person = {\n  name: \"egoing\",\n  introduce: function() {\n    return \"My name is\" + this.name;\n  }\n};\n```\n\n# 2. 생성자와 new\n\n생성자는 객체를 만드는 역할을 하는 함수.\n\n```javascript\nfunction Person() {}\nvar p0 = Person(); //undefined\nvar p = new Person(); //Person{} 비어있는 객체\n```\n\nnew Person()  \nPerson() 함수가 객체의 참조자가 될 수 있다.\n\n자바는 클래스 안에 생성자가 있고, 클래스의 객체를 만든다.  \n자바스크립트에서는 생성자가 함수일 뿐, 어디에 속해있지 않다.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n  this.introduce = function() {\n    return \"My name is \" + this.name;\n  };\n}\n\nvar p1 = new Person(\"egoing\");\nvar p2 = new Person(\"leezche\");\n\ndocument.write(p1.introduce()); //My name is egoing\ndocument.write(p2.introduce()); //My name is leezche\n```\n\n생성자 Person이라는 함수를 정의했다.  \nPerson 앞에 new가 존재하기 때문에 함수가 아닌 생성자가 된다.  \n생성자 함수가 하는 일은 객체의 초기화이며, 객체가 가지고 있는 정보, 객체가 할 수 있는 일을 정의하게 된다.  \n덕분에 코드의 재사용성이 높아진다.\n\n# 3. 함수와 this\n\n전역변수와 전역함수는 모두 window라는 전역객체의 속성과 메소드다.  \n<span class=\"clr-grey\">node.js에서 전역객체는 global이다.</span>\n\n## 1) 메소드와 this\n\nthis는 함수를 어떻게 호출하느냐에 따라 this를 가리키는 대상이 달라진다.\n\n전역함수의 this는 window와 같다.\n\n```javascript\nfunction func() {\n  if (window === this) {\n    console.log(\"window === this\");\n  }\n}\nfunc(); //window === this\n```\n\n객체의 소속인 메소드의 this는 그 객체를 가르킨다.\n\n```javascript\nvar o = {\n  func: function() {\n    if (o === this) {\n      document.write(\"o === this\");\n    }\n  }\n};\no.func(); //o===this\n```\n\n## 2) 생성자와 this\n\n```javascript\nvar funcThis = null;\nfunction Func() {\n  funcThis = this;\n}\n\nvar o1 = Func();\nif (funcThis === window) {\n  document.write(\"window\");\n}\n\nvar o2 = new Func();\nif (funcThis === o2) {\n  document.write(\"o2 </br>\");\n}\n// window, o2 둘다 출력됨.\n```\n\nFunc를 생성자로 사용되면 this는 객체를 가리키고, 함수로 사용되면 this는 window는 가리킨다.\n\n## 3) 객체로서 함수\n\n```javascript\nfunction sum(x, y) {\n  return x + y;\n}\nvar sum2 = new Function(\"x\", \"y\", \"return x+y\");\n```\n\nsum이라는 함수는 sum이라는 객체를 만든 것이다.  \n<span class=\"clr-grey\">\nfunction sum(){} 함수 리터럴  \nvar o ={} 객체리터럴  \nvar a = [0,1,2] 배열 리터럴  \n편리하게 값을 만들 수 있는 문법적인 체계를 리터럴이라고 한다.\n</span>\n\n## 4) apply와 this\n\n```javascript\nvar o = {};\nvar p = {};\n\nfunction func() {\n  switch (this) {\n    case o:\n      document.write(\"o\");\n      break;\n    case p:\n      document.write(\"p\");\n      break;\n    case window:\n      document.write(\"window\");\n      break;\n  }\n}\n\nfunc(); //window\nfunc.apply(o); //o\nfunc.apply(p); //p\n```\n\n자바스크립트의 this는 변화무쌍하다.\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"c29af323a257c5fcf1c5044662e2eb8af4c2b08d","text":"# [생활코딩] Javascript 입문3\n\n- Title : [생활코딩] Javascript 입문3\n- Date : 2018-01-11\n- Category: Javascript\n\n생활코딩 javscript 과정 중 정규표현식 내용을 정리했습니다.\n\n# 정규표현식(Regular Expression)\n\n- 문자열에서 특정 문자를 찾을 때 사용 .. \\* 나중에 생활코딩 정규표현식 강의도 듣기!! & 전화번호 때 사용했던 경험 넣기\n- 컴파일 -> 실행 단계로 이뤄진다.\n- 컴파일 : 찾고 싶은 패턴을 만듬.\n- 실행 : 문자열에서 패턴을 추출.\n\n## 정규표현식 객체를 만드는 방법\n\n1. var pattern = /a/\n2. var pattern = new RegExp('a');\n\n## 패턴 추출\n\n1. pattern.exec('abcdef') // [\"a\"]; a배열 추출\n2. pattern.exec('bcdefg') // null a가 없어서.\n3. pattern.test('abcdef') // true\n4. pattern.test('bcdefg') // false\n\n## 문자열 객체의 메소드에서 정규표현식 사용하기\n\nString.match()  \nString.replace()\n\n```javascript\n\"abcdef\".match(pattern); // [\"a\"]\n\"bcdefg\".match(pattern); // null\n\"abcdef\".replace(pattern, \"A\"); // Abcdef\n```\n\n## 옵션\n\ni 대소문자 구분 안함\n\n```javascript\nvar oi = /a/i;\n\"Abcdef\".match(oi); //[\"A\"]\n```\n\ng 검색된 모든 결과 리턴\n\n```\nvar og = /a/g;\n\"abcdea\".match(og);    //[\"a\",\"a\"]\n```\n\n## 치환\n\n```\nvar pattern = /(\\w+)\\s(\\w+)/;    //()는 그룹, \\s는 공백, +는 1개이상, \\w는 문자(0-9,a-z,A-Z)\nvar str = \"coding everybody\";\nvar result = str.replace(pattern, \"$2, $1\");    //$N는 N번째 그룹.\nconsole.log(result);\n```\n"}}}},"pageContext":{"id":"e8be63527de9580685e34fc4299ba081b8713fe7","previousPostId":"803f4d7096343a90d391862bb2f929d76497a8e8","nextPostId":"c29af323a257c5fcf1c5044662e2eb8af4c2b08d"}},"staticQueryHashes":["2841359383"]}