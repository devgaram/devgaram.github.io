{"componentChunkName":"component---src-templates-blog-post-js","path":"/46f1163ddd6eee6183debd713845d84759157be4","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"46f1163ddd6eee6183debd713845d84759157be4","text":"# 운영체제 - 교착상태\n\n- Title : 운영체제 - 교착상태\n- Date : 2020-03-29\n- Category : 운영체제\n\n# 시스템 모델(System Model)\n\n시스템은 경쟁하는 프로세스들 사이에 분배되어야 할 유한한 자원들로 구성되며 여러 프로세스들은 해당 자원을 점유하기 위해 서로 경쟁 구도에 놓여있다. 프로세스가 자원을 사용하기 위해서는 반드시 사용하기 전에 요청을 해야 하고 사용 후에는 반드시 방출해야한다. 정상적인 작동 모드에서 프로세스는 다음의 순서로만 자원을 사용할 수 있다.\n\n1. 요청(Request) : 자원을 요청한다. 다른 프로세스가 사용 중이라서 자원를 받을 수 없다면 대기한다.\n2. 사용(Use) : 프로세스는 자원에 대해 작업 수행한다.\n3. 방출(Release) : 자원을 다 사용했으면 자원을 방출한다.\n\n# 교착상태(Deadlocks)\n\n둘 이상의 프로세스들이 자원(CPU, 메모리, 파일, 프린터 등..)을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상을 말한다. 교착 상태에서 프로세스들은 결코 실행을 끝낼 수 없으며, 시스템 자원이 묶여 있어서 다른 작업을 시작하는 것도 불가능하다.\n\n# 교착상태 필요조건\n\n교착 상태는 아래 4가지 조건이 **모두 만족**되야 발생할 수 있다.\n\n## 1. 상호배제(mutual exclusion)\n\n여러 프로세스 중 하나만 임계 구역에 진입할 수 있을 때 즉, 자원을 동시에 공유하지 못할 때\n\n## 2. 점유하며 대기(hold-and-height)\n\n최소 하나의 자원을 점유한 채, 현재 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 대기 중일 때\n\n## 3. 비선점(no-preemption)\n\n자원들을 선점할 수 없어야 한다. 즉, OS가 작동 중인 프로세스를 임의로 중단시킬 수 없을 때\n\n## 4. 순환대기(circular-wait)\n\n프로세스가 순환적으로 서로를 기다릴 때\n\n# 자원 할당 그래프(Resource Allocation Graph)\n\n자원과 프로세스의 관계를 그래프로 도식화한 **자원 할당 그래프**를 통해 데드락 유무를 파악할 수 있다. 자원 할당 그래프란 시스템 내 모든 활성 프로세스의 집합인 P와 모든 자원의 집합인 R로 정점의 집합 V를 구성한다. 이 그래프에서 P로부터 R로 뻣어나가는 간선은 특정 프로세스가 해당 자원을 요청하고 기다리는 것을 표시하며 자원 R에서 P로 뻣어나가는 간선은 할당 간선으로 해당 자원이 해당 프로세스에 할당되어있음을 나타낸다. 이러한 **자원 할당 그래프에 사이클이 있다면 데드락 위험이 있다는 의미가 된다.** 사이클이 있다고 무조건 데드락이 발생하는 것은 아니지만, 사이클이 없으면 절대로 데드락이 발생하지 않는다. 가능성이라고 얘기하는 이유는 자원이 하나의 인스턴스가 아닌 여러 개의 인스턴스를 가질 수도 있기 때문이다. 만약 자원이 여러 개의 인스턴스를 가질 수 있어서 여러 프로세스에게 자원을 제공한다면 교착 상태가 일어나지 않게 된다.\n\n# 교착상태 처리 방법\n\n## 1. 교착 상태 방지(Deadlock Prevention)\n\n교착상태 4가지 필요조건 중 하나를 만족시키지 않음으로서 교착 상태가 발생하는 것을 방지할 수 있다.\n\n### 상호배타 (Mutual exclusion)\n\n읽기 전용 파일은 여러 프로세스가 공유할 수 있게 하여 상호 배타를 깰 수가 있다. 하지만 대부분의 컴퓨터 자원들은 임계 구역 문제를 해결하기위해 상호 배타를 만족해야만 한다. 상호 배타를 깨는 건 현실적으로 불가능한 일이다.\n\n### 보유 및 대기 (Hold and wait)\n\n프로세스가 실행되기 전에 필요한 모든 자원을 요청하여 할당받도록 하는 거다. 이렇게 하면 프로세스가 다른 자원을 요청하여 할당받을 때까지 대기하는 일이 없고 모든 자원을 가지고 프로세스를 시작하기 때문에 대기하는 일이 발생하지 않는다. 하지만 많은 자원들이 할당된 후 오랫동안 사용되지 않기 때문에 자원 활용률이 떨어지는 단점이 있고 **기아 문제**가 발생할 수 있다. 식사하는 철학자를 예를 들면 젓가락을 동시에 두개를 집게 하고 하나만 집을 수 있다면 아예 못 집게 하는 방법이다. 또는 프로세스가 자원을 점유하지 않을 때만 자원을 요청할 수 있도록 하는 방법도 있다.\n\n### 비선점 (No Preemption)\n\n자원을 점유하고 있는 프로세스가 다른 자원를 요청했을 때 즉시 리자원를 사용할 수 없다면 점유하고 있던 자원을 방출(release)한다.\n\n### 순환 대기 (Circular wait)\n\n모든 자원 유형들에게 전체적인 순서를 부여하여 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 강제하는 것이다. 이를 통해 모든 자원들은 먼저 할당되는 순서가 정해져 있기 때문에 교착상태가 일어날 수 없다. 즉, 자원의 타입에 따라 프로세스마다 일대일 함수로 순서를 지정해준다. 식사하는 철학자 같은 경우는 아이디를 부여하여 홀수번은 오른쪽 왼쪽, 짝수번은 왼쪽 오른쪽 순서로 집도록 하였다. 역시 자원 활용률을 떨어트린다.\n\n## 2. 교착 상태 회피(Deadlock Avoidance)\n\n여기서는 교착 상태를 자원 요청에 대해 운영체제가 잘못 할당한 것으로 정의한다. 운영체제는 리소스 매니저, 리소스 allocator라고 불리듯이 자원을 프로세스에게 골고루 나눠주는 역할을 한다. 즉, **운영체제의 프로세스 관리 부서가 자원을 잘 못 나눠줘서 교착상태가 발생했다고 보는 것**이다. 은행 파산으로 비유할 수 있다. \n\n이러한 교착 상태는 어떤 프로세스가 요청을 할 때 미래에 대한 분석을 통해 자원 요청을 늦추는 방법으로 피할 수 있다. 시스템이 unsafe 상태가 되지 않도록 해야 하며 만약 unsafe 상태면 최대한 빨리 safe 상태로 복구한다. 데드락 가능성은 자원 할당 그래프를 구현해 파악하며 리소스 타입이 여러 개면 Banker's algorithm을 사용한다.\n\n> 안전 상태란 이러한 교착 상태 알고리즘을 설계함에 있어 각 유효 자원의 최대 개수까지 어떤 순서로 요청을 하더라도 교착상태를 야기하지 않고 모두 할당을 잘 해줄 수 있음 을 뜻한다.\n\n### Banker's Alogorithm\n\n교착상태 회피 알고리즘으로 프로세스가 리소스를 요청할때마다 수행되며, 이 자원을 할당하면 미래에 교착상태가 발생할지를 시뮬레이션한다.\n\n## 3. 교착 상태 검출 및 복구\n\n교착 상태가 일어나는 것을 허용하며 자원을 마음껏 나눠준다. 어쩌다가 교착상태가 일어나면 이를 회복하는 방법이다. 검출을 위한 오버헤드가 크다. 복구를 위해 프로세스 일부를 강제 종료하거나 자원을 선점하여 일부 프로세스에게 할당한다. 복구를 위해 주기적으로 현재 상태를 기억해둬야하며 데드락이 일어나지 않은 상태로 다시 돌아가야 한다.\n\n### 복구 1. 프로세스를 종료시키는 방법\n\n- 교착 상태 프로세스를 모두 중지\n    - 다시 처음부터 계산해야한다.\n- 교착 상태가 제거될 때까지 한 프로세스씩 중지하는 방법\n    - 각 프로세스가 중지될 때마다 아직도 교착 상태에 있는 지 매번 살펴봐야 하기 때문에 상당한 오버헤드를 유발한다.\n\n**어떤 프로세스를 종료시킬까?**\n\n- 프로세스의 중요도\n- 프로세스가 얼마나 오래 실행됐는가\n- 얼마나 많을 자원을 사용했는가\n- 프로세스가 작업을 마치기 위해 얼마나 많은 리소스가 필요한가\n- 프로세스가 종료되기 위해 얼마나 많은 리소스가 필요한가\n- 프로세스가 batch인가 interactive한가?\n\n### 복구 2. 자원 선점 방법\n\n교착 상태가 깨어질 때까지 프로세스로부터 자원을 계속적으로 선점해 다른 프로세스에게 주는 방법이다.\n\n**고려사항**\n\n- 희생자 선택(selection of a victim)\n    - 어떤 자원과 어느 프로세스가 선점될 것인가 를 고민\n- 롤백(rollback)\n    - 만약 특정 프로세스의 자원을 강제로 방출하고 선점시켰다면, 그 프로세스를 어떻게 처리 할 것인가에 대한 고민이다. 보통 가장 안전한 방법은 프로세스를 중지시키고 재시작하는 것 즉, 롤백하는 것이다.\n- 기아 상태(starvation)\n    - 특정 프로세스의 자원을 강제 방출시켜 선점을 시켜주게 되면 그 프로세스는 계속해서 희생자로 선택될 확률이 높고 이경우 그 프로세스는 영원히 실행이 완료되지 못하는 기아상태에 빠질 수 있다. 프로세스가 한정된 시간에만 희생자로 선정된다는 것을 반드시 보장 해야 한다.\n\n## 4. 교착 상태 무시\n\n실제 잘 안일어나니깐 그냥 무시하고..교착상태를 처리하는 것을 응용 개발자의 몫으로 맡기는 것.\n\n참고\n\n[운영체제 | 교착상태(deadlock)란 무엇인가?](https://frontalnh.github.io/2018/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-deadlock-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/)"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d40dfa460c3404882d4c862ecddb0374d3a40df0","text":"# 자바스크립트 동작 방식 - 스레드 큐와 setTimeout()\n\nDate: Mar 31, 2020\n\n- Title : 자바스크립트 동작 방식 - 스레드 큐와 setTimeout()\n- Date : 2020-03-31\n- Category : Javascript\n\n# WHY?\n\n자바스크립트가 단일 스레드 환경에서 돌아간다는 것은 대부분의 사람들이 알고 있을 것이다. 하지만 어떻게 동작하는 지는 모르는 사람이 있다.. ~~바로..나처럼..?~~ 그런 이유로 자바스크립트가 어떻게 돌아가는 지 낱낱이 파헤쳐 봐야지!\n\n# 스레드 큐(태스크 큐)\n\n스레드 큐는 단일 스레드 환경에서 어떠한 순서로 함수나 기능을 수행할지 결정하는 목록으로 FIFO(First-In First-Out)의 정책을 가진다. 스레드 큐 덕분에 지연이 발생하더라도 들어온 순서대로 요청을 처리할 수 있다. \n\n> ✨ 여기서 말하는 지연이란? 자바스크립트는 사용자와 상호작용하는 이벤트 기반 언어라, 비동기로 동작하거나 현재 소스가 실행 중에 사용자의 입력이 들어오면 지연이 발생할 수 있다.\n\n# setTimeOut() 파헤치기\n\n🎉아래 코드에서 `buttonAddItem.onclick`, `divItems.appendChild()`, `inputCloneItem.focus()` 가 스레드 큐에 어떤 순서로 들어갈지 생각해보자.\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n      </head>\n      <body>\n        <button id=\"addItem\">Add New Input</button>\n        <div id=\"items\"></div>\n        <script>\n          (function() {\n            const divItems = document.getElementById(\"items\"),\n              buttonAddItem = document.getElementById(\"addItem\"),\n              inputItem = document.createElement(\"input\");\n            buttonAddItem.onclick = () => {\n              const inputCloneItem = inputItem.cloneNode(true);\n              inputCloneItem.value = \"Give me focus\";\n    \n              divItems.appendChild(inputCloneItem);\n              setTimeout(() => {\n                inputCloneItem.focus();\n              }, 0);\n            };\n          }());\n        </script>\n      </body>\n    </html>\n\n`setTimeout()` 함수의 두번째 파라미타를 0으로 했으니깐 버튼을 클릭하면 `divItems.appendChild(inputCloneItem)` 보다 `inputCloneItem.focus()` 가 먼저 들어가있을거라고 생각했다면...? 땡땡!!😂😂 정답은 아래와 같다. `setTimeout()` 함수를 0초 후에 호출되도록 설정하면 호출하자마자 실행되는 것이 아니라 UI 업데이트가 이루어지고 나서 호출된다. 즉, setTimeout() 함수는 특정 시간이 되면 콜백 함수를 호출하도록 실행 큐 뒤에 해당 함수를 넣는 거지 함수 자체를 호출한다는 의미가 아니다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled.png)\n\n🎉 다음 예제를 통해 `setTimeout()` 함수와 단일 스레드 환경을 명확하게 이해해보자. 방금 예제와 비슷하지만 `setTimeout()`은 버튼이 클릭되고 2초 뒤에 콜백함수로 호출하도록 했고 `sleep()` 함수를 추가해서 10초동안 while 문이 돌아가게 했다. 자, 그럼 `setTimeout()`의 콜백함수는 언제 실행될까?\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n      </head>\n      <body>\n        <button id=\"addItem\">Add New Input</button>\n        <div id=\"items\"></div>\n        <script>\n          (function() {\n            const divItems = document.getElementById(\"items\"),\n              buttonAddItem = document.getElementById(\"addItem\"),\n              inputItem = document.createElement(\"input\"),\n              divLog = document.getElementById(\"log\");\n            buttonAddItem.onclick = () => {\n              const inputCloneItem = inputItem.cloneNode(true),\n                    waitSeconds = 10;\n              \n              inputCloneItem.value = \"Give me focus\";\n    \n              divItems.appendChild(inputCloneItem);\n    \n              console.log(\"Execute setTimeout at: \\t\" + Date.now());\n              setTimeout(() => {\n                inputCloneItem.focus();\n                console.log(\"Execute setTimeout at: \\t\" + Date.now());\n              }, 2000);\n    \n              sleep(waitSeconds * 1000);\n            };\n    \n            function sleep(waitSeconds) {\n              const waitUntil = Date.now() + waitSeconds;\n              while (Date.now() < waitUntil);\n            }\n          }());\n        </script>\n      </body>\n    </html>\n\n아래의 실행결과를 보면 setTimeout() 안의 콜백함수는 2초 뒤에 실행되지않고 10초 뒤에 실행된다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%201.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%201.png)\n\nsetTimeout()의 콜백함수는 버튼 클릭 2초 후 스레드 큐에 등록되지만 버튼 클릭 핸들러 내 sleep() 함수가 다 실행되어야 순서대로 처리되기 때문에 10초보다 뒤에 실행된다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%202.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%202.png)\n\n🎉 위 예제에서 버튼 클릭 시 setTimeout() 함수를 두번 호출하도록 코드를 수정해보고 실행이 어떤식으로 되는 지 알아보자.\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n      </head>\n      <body>\n        <button id=\"addItem\">Add New Input</button>\n        <div id=\"items\"></div>\n        <script>\n          (function() {\n            const divItems = document.getElementById(\"items\"),\n              buttonAddItem = document.getElementById(\"addItem\"),\n              inputItem = document.createElement(\"input\"),\n              divLog = document.getElementById(\"log\");\n            buttonAddItem.onclick = () => {\n              const inputCloneItem = inputItem.cloneNode(true),\n                    waitSeconds = 10;\n              \n              inputCloneItem.value = \"Give me focus\";\n    \n              divItems.appendChild(inputCloneItem);\n    \n              console.log(\"onclick function invoked at: \\t\" + Date.now());\n              setTimeout(() => {\n                console.log(\"1st Execute setTimeout at: \\t\" + Date.now());\n                sleep(waitSeconds * 1000);\n              }, 2000);\n              setTimeout(() => {\n                inputCloneItem.focus();\n                console.log(\"2 Execute setTimeout at: \\t\" + Date.now());\n              }, 2000);\n    \n              sleep(waitSeconds * 1000);\n            };\n    \n            function sleep(waitSeconds) {\n              const waitUntil = Date.now() + waitSeconds;\n              while (Date.now() < waitUntil);\n            }\n          }());\n        </script>\n      </body>\n    </html>\n\n클릭 이벤트가 발생하면 setTimeout() 함수의 콜백 이벤트를 등록하고 2초 뒤에는 등록한 2개의 setTimeout() 함수가 호출된다(스레드 큐에 콜백함수가 들어간다) 이때 스레드 큐에서는 10초간 sleep()을 수행하기때문이 sleep()이 끝나고 UI 업데이트가 이루어진 후 첫번째 콜백이 실행된다. 콜백 안에 또 sleep()이 있어서 10초 뒤에 두번째 콜백이 수행된다. 즉, 두번째 setTimeout 콜백은 20초 뒤에나 실행된다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%203.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%203.png)\n\n스레드 큐는 아래와 같다.\n\n![https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%204.png](https://raw.githubusercontent.com/devgaram/TIL/master/Javascript/images/2020-03-31-img/Untitled%204.png)\n\n# 결론\n\nsetTimeout() 뿐만 아니라 모든 XMLHttpRequest나 다른 콜백 이벤트가 발생했다고 해서 바로바로 현재의 스레드에 인터럽트를 걸고 실행하는 것이 아니라, **현재 실행하고 있는 스레드 큐가 끝나고 자신의 차리가 와야 실행된다**. 즉, 처리가 오래 걸리는 자바스크립트 함수가 있을 때는 호출이 이루어져야 하는 시간이 되어도 그 함수의 처리가 끝날 때까지 스레드 큐에서 대기한다."}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"cc4c2ba350ff2dcd7d43ee1ce312d69f9c1991b8","text":"# 백준 문제 - 문자열 처리\n\n- Title : [백준] 문자열 처리\n- Date : 2020-03-27\n- Category : 알고리즘 문제 풀기\n\n# Why?\n\nC++ 로 문자열 문제를 풀 때 입출력, 파싱 등 부분에서 막힌다는 생각이 들어서 연습겸 문자열 관련 문제만 풀어보았다. 난이도는 브론즈 정도?\n\n## 11654 아스키 코드\n\n알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하세요.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tchar c;\n    \tcin >> c;\n    \tcout << (int) c;\n    \treturn 0;\n    }\n\n> 'A' 는 65, 'a' 는 97\n\n## 1152 단어의 개수\n\n영어 대소문자와 띄어쓰기만으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \tint ans = 0;\n    \tgetline(cin, str);\n    \tcin.ignore();\n    \t\n    \tfor (int i=0; i<str.size(); i++) {\n    \t\tif (str[i] == ' ') ans++;\n    \t}\n    \t\n    \tif (str[str.size()-1] == ' ') ans--;\n    \tif (str[0] != ' ') ans++;\n    \t\n    \tcout << ans;\n    \treturn 0;\n    }\n\n> 문자열을 공백으로 파싱해야할 때\n\n    #include <iostream>\n    #include <vector>\n    #include <sstream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \t\n    \tgetline(cin, str);\n    \tcin.ignore();\n    \t\n    \tstring buf;\n    \tstringstream ss(str);\n    \tvector<string> tokens;\n    \t\n    \twhile (ss >> buf) {\n    \t\ttokens.push_back(buf);\n    \t}\n    \t\n    \tcout << tokens.size();\t\n    \t\n    \treturn 0;\n    }\n\n> `getline(cin, str)` 로 공백을 포함한 문자열을 입력받을 수 있다. 단, `\\n` 을 포함하지않으므로 버퍼에서 `\\n` 을 제거하기 위해 `cin.ignore()` 을 해야한다.\n\n## 10809 알파벳 찾기\n\n알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tstring str;\n    \tcin >> str;\n    \tint ans[26];\n    \tfill(&ans[0], &ans[26], -1);\n    \t\n    \tfor (int i=str.size()-1; i>=0; i--) {\n    \t\tint c = (int) str[i];\n    \t\tans[c - 97] = i;\n    \t}\n    \t\n    \tfor (int i=0; i<26; i++) {\n    \t\tcout << ans[i] << ' ';\n    \t}\n    \t\n    \treturn 0;\n    }\n\n## 1157 단어공부\n\n알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.\n\n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n    \tchar str[1000000];\n    \tint cnt[26] = {0};\n    \tint idx = 0, max = 0, maxi = 0;\n    \t\n    \tscanf(\"%s\", str);\n    \t\n    \tfor (int i=0; str[i]; i++) {\n    \t\tif (str[i] < 97) idx = str[i] - 65;\n    \t\telse idx = str[i] - 97;\n    \t\t\n    \t\tcnt[idx]++;\n    \t\tif (cnt[idx] > max) {\n    \t\t\tmax = cnt[idx];\n    \t\t\tmaxi = idx;\n    \t\t} else if (cnt[idx] == max) {\n    \t\t\tmaxi = -1;\n    \t\t}\n    \t}\n    \t\n    \tprintf(\"%c\", maxi == -1 ? '?' : maxi + 65);\n    \t\n    \treturn 0;\n    }\n\n## 2908 상수\n\n상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다. 두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오.\n\n### strcmp로 문자열 비교\n\n    #include <iostream>\n    #include <string.h>\n    using namespace std;\n    \n    int main() {\n    \tchar a[4], b[4];\n    \tscanf(\"%s %s\", a, b);\n    \t\n    \tswap(a[2], a[0]);\n    \tswap(b[2], b[0]);\n    \t\n    \tif (strcmp(a, b) < 0) printf(\"%s\", b);\n    \telse printf(\"%s\", a);\n    \t\n    \treturn 0;\n    }\n\n### atoi로 char * → int로 변경 후 비교\n\n    #include <iostream>\n    #include <string>\n    using namespace std;\n    \n    int main() {\n    \tchar a[4], b[4];\n    \tscanf(\"%s %s\", a, b);\n    \t\n    \tswap(a[2], a[0]);\n    \tswap(b[2], b[0]);\n    \t\n    \tint na = atoi(a);\n    \tint nb = atoi(b);\n    \t\n    \tif (na > nb) printf(\"%d\", na);\n    \telse printf(\"%d\", nb);\n    \t\n    \treturn 0;\n    }\n\n- a, b 값을.. 3으로 했을 때 입력을 제대로 못 받는 문제 생김 ㅜ_ㅜ\n    - c의 문자열은 `\\0` 을 기준으로 구분한다. 문자열의 끝에 있는 `\\0` 이 어떤 식으로든 없어지게 된다면 그 뒤에 `\\0` 이 나타날 때까지 진행하게 된다\n    - 123 456 일 때, a, b 크기를 3으로 하면 a에는 \"123\"이 들어간다. 그럼 `\\0` 은 b[0]에 들어갔을 거다. 이 상태로 456을 입력받으면 b[0]에 4가 쓰여진다. 마찬가지로 b의  `\\0` 도 메모리 어딘가에 들어가게된다.\n    - 즉, a 출력시 123456이 나오는 이유는 123을 입력받을 때 `\\0` 을 받지 못해 456까지 입력받게 되서다."}}}},"pageContext":{"id":"46f1163ddd6eee6183debd713845d84759157be4","previousPostId":"d40dfa460c3404882d4c862ecddb0374d3a40df0","nextPostId":"cc4c2ba350ff2dcd7d43ee1ce312d69f9c1991b8"}},"staticQueryHashes":["2685952063","2841359383"]}