{"componentChunkName":"component---src-templates-blog-post-js","path":"/03e73fed3a9d0eacb1704fefb89e8300da18fa23","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"03e73fed3a9d0eacb1704fefb89e8300da18fa23","text":"# 부트스트랩의 sr-only 클래스가 하는 일\n\n- Title : 부트스트랩의 sr-only 클래스가 하는 일\n- Date : 2020-05-18\n- Category : 프론트\n\n이 글은 그저 기억하기 위한 용도로 작성했으니 참고바랍니다.\n\n부트스트랩은 `sr-only` 클래스를 사용하여 원하는 요소를 화면상에서는 사라지게 하는 동시에 웹 접근성을 높인다. 장애를 가진 사람은 스크린 리더기나 점자 타자기와 같은 보조 기구를 통해 웹을 인식하기 때문에 웹 접근성은 신경써야 할 요소 중 하나다. 간단하게 `<img>` 태그의 alt 요소에 이미지를 파악할 수 있는 텍스트를 작성하는 것만으로도 웹 접근성을 높일 수 있다. \n\n나는 체크박스(`<input type=\"checkbox>`)를 커스텀하면서 `sr-only` 를 접하게 되었다. *아마 사수가 아니었으면 웹 접근성을 신경쓰지도 않았을 텐데 덕분에 팁을 얻었다.*  작업에 대해 자세히 말하자면 체크박스를 슬라이드 토글 형태로 커스텀하는 것이었다. 작업 순서는 아래와 같다. 체크 박스에 `sr-only` 클래스를 적용하여 체크 박스를 사라지게 만들기 → `<label><div class=\"circle\"></label>` 로 style 만들기 → 체크박스 `:checked` 일 때 토글 효과 주기\n\n부트스트랩의 `sr-only` 는 다음과 같이 작성되어있다. 이를 이용하여 체크박스를 화면에서 지우면 된다.\n\n```css\n.sr-only {\n\tposition: absolute;\n\toverflow: hidden;\n\twidth: 1px;\n\theight: 1px;\n\tpadding: 0;\n\tmargin: -1px;\n\tborder: 0;\n\tclip: rect(0,0,0,0);\n}\n```\n\n `clip` 속성은 요소의 일부분만 보이게 하고 싶을 때 사용한다. 단, 요소의 `position`이 `absolute` 또는 `fixed`로 적용되어 있어야 작동된다. `sr-only` 에서 `clip` 요소는 `rect(0,0,0,0)` 으로 선언되어있는 데 이는 요소를 노출 시키지 않겠다는 의미다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"925c932c741ff2a153eedb35c2a39a5860255566","text":"# 자바스크립트의 iterable, iterator 프로토콜과 generator\n\n- Title : 자바스크립트의 iterable, iterator 프로토콜과 generator\n- Date : 2020-05-23\n- Category : Javascript\n\n# iterable 프로토콜\n\n- iterable 프로토콜은 반복 가능한 객체를 정의하는 방법(규약)으로 `for..of` 를 통해 value를 반복할 수 있다.\n- 반복 가능한 내장 객체로 `Array`, `Map`, `Set`, `String` 등이 있으며 객체는`[Symbol.iterator]` 속성 키를 가진다. *이 객체 들의 프로토타입 객체들이 `@@iterator` 메소드를 가지기 때문에 반복이 가능하다.*\n- `Promise.all(iterable)`, `Array.from()` 도 iterable을 허용한다.\n- 반복 가능한 객체를 만들고 싶다면 객체의 `[Symbol.iterator]` 속성에 `@@iterator` 메소드를 구현 하면 된다. 이 메소드는 iterator 프로토콜을 따르며 인수 없이 호출 되고 iterator 객체를 반환한다.\n\n반복 가능한 객체(iterable)는 `for-of` , `spread operator`, `yield*`, `구조 분해 할당`에 함께 사용된다.\n\n```java\nfor(let value of ['a', 'b', 'c']){\n    console.log(value)\n}\n// \"a\"\n// \"b\"\n// \"c\"\n\n[...'abc'] // [\"a\", \"b\", \"c\"]\n\nfunction* gen(){\n  yield* ['a', 'b', 'c']\n}\n\ngen().next() // { value:\"a\", done:false }\n\n[a, b, c] = new Set(['a', 'b', 'c'])\na // \"a\"\n```\n\nString은 반복 가능한 내장 객체로 `[Symbol.iterator]` 속성에 `@@iterator` 메소드가 있다.\n\n```java\nconst someString = \"hi\";\ntypeof someString[Symbol.iterator]; // function\nconst iterator = someString[Symbol.iterator](); // StringIterator {}\niterator + \"\" // [Object String Iterator]\n\niterator.next(); // { value: \"h\", done: false }\niterator.next(); // { value: \"i\", done: false }\niterator.next(); // { value: undefined, done: true }\n\n[...someString] // [ \"h\", \"i\" ]\n```\n\n반면에 일반 객체는 `@@iterator` 없어서 `undefined` 값을 반환한다. *물론 정의가 가능하다.*\n\n```java\nconst testObject = new Object();\ntypeof testObject[Symbol.iterator] // undefined\n```\n\n# iterator 프로토콜\n\n- 반복 가능한 객체의 value들을 시퀀스(어떠한 일련의 순서)대로 처리하는 방법(규약)이다.\n\n### iterator 객체 구현 규칙\n\n- `next()` 메소드가 있어야 한다. 이 메소드는 `done`, `value` 속성을 가진 객체를 반환한다.\n    - `done`(boolean): iterator가 마지막 반복 작업을 끝내면 true, 작업이 남아 있으면 false다. *done이 true이면 반환되는 객체의 value 프로퍼티의 값은 undefined다.*\n    - `value`: iterator에서 반환되는 값으로 done이 true면 생략될 수 있다.\n\n아래 코드는 문자를 하나씩 반환하는 String의 `@@iterator` 메소드를  \"bye\" 만 반환하고 끝내도록 재 정의한 예제다.\n\n```java\nconst someString = new String(\"hi\");\n\nsomeString[Symbol.iteraror] = function() {\n\treturn { // iterator 객체를 리턴\n\t\tnext: function() {\n\t\t\tif (this._first) {\n\t\t\t\tthis._first = false;\n\t\t\t\treturn { value: \"bye\", done: false };\n\t\t\t} else {\n\t\t\t\treturn { done: true };\n\t\t\t}\n\t\t},\n\t\t_first: true\n\t};\n};\n```\n\n# Generator\n\n## Generator 함수\n\n- 실행이 연속적이지 않는 작업을 iterator 처럼 사용할 수 있게 해준다.\n- `function*` 키워드를 통해 선언되는 Generator 함수는 호출 되어도 즉시 실행되지 않고, 대신 함수를 위한 Iterator 객체(Generator 객체)가 반환됩니다\n- `next()` 메소드를 호출하면 Generator 함수가 실행되어 `yield` 문을 만날 때까지 진행하고, 해당 yield가 반환하는 객체를 리턴 한다.  반환하는 객체는 yield문이 반환할 값(yielded value)을 나타내는 `value` 속성과, Generator 함수 안의 모든 yield 문의 실행 여부를 표시하는 boolean 타입의 `done` 속성을 갖는다.\n\n> `yield*`: 다른 generator 또는 iterable 객체에 yield를 위임할 때 쓰이며 `yield [iterable 객체를 반환하는 표현식]` 방식으로 사용한다.\n\n## Generator 객체\n\n- generator function에서 반환된 값으로 iterator, iterable 프로토콜을 준수한다.\n- `Generator.prototype.next()`: `yield` 표현을 통해 yield된 값을 반환\n- `Generator.prototype.return()`: 주어진 값을 반환하고 Generator 종료\n- `Generator.prototype.throw()`:  Generator의 실행을 재개시키고 Generator 함수의 실행 문맥 속으로 error를 주입하며 done, value 프로퍼티를 가진 객체를 반환한다.\n\n```java\nfunction* gen() {\n\twhile(true) {\n\t\ttry {\n\t\t  yield 1;\n\t\t  yield 2;\n\t\t  yield 3;\n\t\t} catch(e) {\n\t\t\tconsole.log('Error caught!');\n\t\t}\n\t}\n}\n\nvar g = gen(); // \"Generator { }\"\n\ng.next();        // { value: 1, done: false }\ng.throw(new Error(\"Something went wrong\"));\n// \"Error caught!\"\n// { value: 1, done: false }\ng.return(\"foo\"); // { value: \"foo\", done: true }\ng.next();        // { value: undefined, done: true }\n```\n\n반복 가능한 객체를 만들기 위해 `[Symbol.iterator]` 속성에 Generator 객체를 아래와 같이 정의할 수 있다.\n\n```java\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n[...myIterable]; // [1, 2, 3]\n```\n\n무한 iterable 객체 만드는 방법\n\n```java\nfunction* idMaker(){\n    var index = 0;\n    while(true)\n        yield index++;\n}\n\nvar gen = idMaker(); // \"Generator { }\"\n\nconsole.log(gen.next().value); // 0\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d828d76a01fdf156e30e5cff57c159e3cbf5c5f0","text":"# git rebase\n\nDate: Apr 27, 2020\n\n- Title : git rebase\n- Date : 2020-04-27\n- Category : Git\n\n## git rebase 하기\n\n```bash\ngit checkout develop\n\ngit fetch origin develop\n\ngit checkout feature\n\ngit rebase origin/develop\n\n// conflict 발생 시 충돌 해결 후\ngit add <수정된 파일 이름>\n\ngit rebase --continue\n```\n\n- git fetch origin develop을 하면 로컬의 origin/develop 에 원격저장소 develop의 최신 커밋들이 싱크된다. 그래서 rebase 대상이 develop이 아니라 origin/develop 이다.\n- 충돌 해결 후 파일을 commit 이 아니라 **꼭 add만 해야 한다.**\n\n## git rebase 취소\n\n이미 remote 까지 push 했을 때 rebase 취소하는 방법\n\n```bash\ngit reflog <브랜치명>\n\n// 돌아가고 싶은 커밋 확인\ngit reset --hard <128e6d4>\n\ngit push -f origin <브랜치명>\n```\n\n## 생각하기\n\n### `git rebase origin/develop` 과 `git rebase develop` 의 차이점\n\n### `git fetch origin develop` 과 `git pull origin develop` 의 차이점\n\npull 은 내부적으로 `fetch + merge` 를 실행한 것과 같다. 즉 pull 을 실행하면 원격 저장소의 내용을 가져오고(fetch) 병합작업(merge)를 수행하게 된다. 만약 단순히 원격 저장소의 내용을 확인만 하고 로컬 데이터와 병합은 하고 싶지 않다면 fetch를 수행하면 된다. fetch를 하게되면 최신 커밋들은 로컬에 `FETCH_HEAD` 라는 이름으로 가져오게 된다. 이 상태에서 원격 저장소의 내용을 로컬 저장소에 통합하고 싶다면 `FETCH_HEAD` 브랜치를 merge 하거나 pull 하면 된다.\n"}}}},"pageContext":{"id":"03e73fed3a9d0eacb1704fefb89e8300da18fa23","previousPostId":"925c932c741ff2a153eedb35c2a39a5860255566","nextPostId":"d828d76a01fdf156e30e5cff57c159e3cbf5c5f0"}},"staticQueryHashes":["2685952063","2841359383"]}