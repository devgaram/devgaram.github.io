{"componentChunkName":"component---src-templates-blog-post-js","path":"/92b42dd986f3a755361f0a2640d33d0bb9c70fd3","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"92b42dd986f3a755361f0a2640d33d0bb9c70fd3","text":"# [안드로이드] 안드로이드 LiveData 대해 알아보자\n\n- Title : [안드로이드] 안드로이드 LiveData 대해 알아보자\n- Date : 2019-01-09\n- Category: Android\n\nLiveData 클래스를 통해 데이터 변경을 감지해보자.\n\n[안드로이드 개발문서-LiveData](https://developer.android.com/topic/libraries/architecture/livedata#java).\n\n# LiveData는 LifecycleOwner의 라이프사이클을 알고있다.\n\nLiveData 객체는 <code class=\"codetainer\">observe()</code> 메서드를 통해 <code class=\"codetainer\">LifecycleOwner</code>와 <code class=\"codetainer\">Observer</code>객체를 페어로 등록한다.  \nObserver 객체는 페어인 LifecycleOwner가 활성상태(<code class=\"codetainer\">STARTED</code> 또는 <code class=\"codetainer\">RESUMED</code>)일 때, 데이터 변화을 관측할 수 있다.\n반대로, LiveData 객체는 LifecycleOwner가 비활성 상태면 LiveData의 변화를 Observer에게 전달하지 않으며, LifecycleOwner가 <code class=\"codetainer\">DESTROYED</code> 상태라면 자동으로 제거된다.\n이러한 LiveData의 라이프사이클의 인지는 메모리 누수에 대한 걱정을 덜어주며, UI 컴포넌트(액티비티, 프래그먼트)를 사용할 때 유용하다.  \n<span class=\"clr-grey\">**Note:** LifecycleOwner의 비활성 상태 예시) 액티비티가 백 스택에 올라가있을 때 </span>\n\n# LiveData 사용시 이점\n\n<span class=\"li-icon\">일반적인 Observable과 달리, LifecycleOwner가 활성 상태일 때, LiveData의 변화를 Observer 객체에 전달함</span>\n<span class=\"li-icon\">충돌방지 : 액티비티가 백스택(비활성)에 있을 때, LiveData의 변화 이벤트를 Observer에게 전달하지 않음</span>\n<span class=\"li-icon\">메모리누수방지 : <code class=\"codetainer\">DESTROYED</code> 시, LiveData 제거</span>\n<span class=\"li-icon\">생명주기 수동으로 관리할 필요 없음</span>\n<span class=\"li-icon\">항상 최신 데이터 유지 가능 : 액티비티가 다시 활성상태로 돌아온 즉시 최신 데이터를 받는다.</span>\n<span class=\"li-icon\">환경변화(예,화면회전)로 UI 컴포넌트 재생성 시, 즉시 최신 데이터를 받는다.</span>\n<span class=\"li-icon\">LiveData를 상속받아 앱에서 자원 공유 가능</span>\n\n# LiveData 사용하기\n\n[예제로 바로가기](/android/android-mvvm/#LiveData).\n\n## 1. LiveData 객체 생성하기\n\nLiveData는 보통 <code class=\"codetainer\">Collections</code> 인터페이스를 구현한 클래스(List, Map, Set)를 사용하며, <code class=\"codetainer\">ViewMoodel</code> 객체 안에 저장된다.\n\n```java\npublic class NameViewModel extends ViewModel {\n  // String 타입의 LiveData 생성\n  private MutableLiveData<String> mCurrentName;\n\n    public MutableLiveData<String> getCurrentName() {\n        if (mCurrentName == null) {\n            mCurrentName = new MutableLiveData<String>();\n        }\n        return mCurrentName;\n    }\n\n// ..생략\n}\n```\n\n## 2. LiveData 객체 관찰하기\n\n<code class=\"codetainer\">onCreate()</code> 메서드에서 LiveData 관찰을 시작하는 것이 좋다.\n<span class=\"li-icon\"><code class=\"codetainer\">onResume()</code> 메서드에서 사용 시 중복 호출이 발생된다.</span>\n<span class=\"li-icon\"><code class=\"codetainer\">STARTED</code> 상태가 되자마자 LiveData 객체의 최신 데이터를 받을 수 있다.</span>\n\n```java\npublic class NameActivity extends AppCompatActivity {\n\n    private NameViewModel mModel;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        // ..생략\n\n        // ViewModel 얻기\n        mModel = ViewModelProviders.of(this).get(NameViewModel.class);\n\n\n        // 옵저버 생성\n        final Observer<String> nameObserver = new Observer<String>() {\n            @Override\n            public void onChanged(@Nullable final String newName) {\n                // Update the UI, in this case, a TextView.\n                mNameTextView.setText(newName);\n            }\n        };\n\n        // LiveData 관찰 시작\n        mModel.getCurrentName().observe(this, nameObserver);\n    }\n}\n```\n\n## 3. LiveData 객체 업데이트하기\n\nLiveData는 데이터를 업데이트 하는 publid 메서드를 가지고 있지 않으므로, LiveData를 상속받은 <code class=\"codetainer\">MutableLiveData</code>를 사용해야한다.\n<code class=\"codetainer\">MutableLiveData</code>는 <code class=\"codetainer\">public setValue(T)</code>와 <code class=\"codetainer\">public postValue(T)</code> 메서드를 가지고 있어서 이를 통해 데이터를 변경할 수 있다.\n\n```java\nmButton.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        String anotherName = \"John Doe\";\n        mModel.getCurrentName().setValue(anotherName);\n    }\n});\n```\n\n<code class=\"codetainer\">setValue(T)</code>와 <code class=\"codetainer\">postValue(T)</code>는 호출 시 Observer의 <code class=\"codetainer\">onChanged()</code> 메서드가 호출되어 UI가 업데이트 된다.\n"}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"57a9a023880800c47fc8fb09eb9ea97232df6cad","text":"# [Drawable 리소스] LayerDrawable과 ShapeDrawable을 이용해 둥근모서리와 그림자 있는 배경 만들기.\n\n- Title : [Drawable 리소스] LayerDrawable과 ShapeDrawable을 이용해 둥근모서리와 그림자 있는 배경 만들기.\n- Date : 2019-01-16\n- Category: Android\n\nLayerDrawable과 ShapeDrawable을 이용해 둥근모서리+그림자+투명배경이 있는 디자인을 다른 XML 리소스의 background로 적용하는 방법입니다.\n\n[안드로이드 개발문서-Drawable 바로가기](https://developer.android.com/guide/topics/resources/drawable-resource?hl=ko)\n\n## 드로어블(Drawable) 리소스\n\n앱 화면에 그리고 싶은 것을 XML 파일로 미리 정의할 수 있으며, <code class=\"codetainer\">getDrawable(int)</code>와 같은 API를 사용하여 가져오거나\n<code class=\"codetainer\">android:drawable</code> 및 <code class=\"codetainer\">android:icon</code>과 같은 속성을 사용하여 다른 XML 리소스에 적용할 수 있다.  \n<span class=\"clr-grey\">**Example)** android:background=\"@drawable/custom_layer_resource\"</span>\n\n# LayerDrawable\n\n각 `<item>` 요소는 순서대로 그려지므로, 맨 마지막 `<item>`이 맨 위에 보이게 된다.\n\n<span class=\"li-nonicon\">위치 : res/drawable/filename.xml</span>\n<span class=\"li-nonicon\">Java 리소스 참조 : R.drawable.filename</span>\n<span class=\"li-nonicon\">XML 리소스 참조 : @[package:]drawable/filename</span>\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list\n    xmlns:android=\"http://schemas.android.com/apk/res/android\" ><!-- XML 네임스페이스 정의 필수 -->\n    <item\n        android:drawable=\"@[package:]drawable/drawable_resource\"\n        android:id=\"@[+][package:]id/resource_name\"\n        android:top=\"dimension\"\n        android:right=\"dimension\"\n        android:bottom=\"dimension\"\n        android:left=\"dimension\" />\n</layer-list>\n```\n\n<span class=\"li-icon\"><code class=\"codetainer\">android:top=\"dimension\"</code> top에서 dimension 값만큼 padding</span>\n\n# ShapeDrawable\n\n<span class=\"li-nonicon\">위치 : res/drawable/filename.xml</span>\n<span class=\"li-nonicon\">Java 리소스 참조 : R.drawable.filename</span>\n<span class=\"li-nonicon\">XML 리소스 참조 : @[package:]drawable/filename</span>\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<shape\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:shape=[\"rectangle\" | \"oval\" | \"line\" | \"ring\"] >\n    <corners\n        android:radius=\"integer\"\n        android:topLeftRadius=\"integer\"\n        android:topRightRadius=\"integer\"\n        android:bottomLeftRadius=\"integer\"\n        android:bottomRightRadius=\"integer\" />\n    <gradient\n        android:angle=\"integer\"\n        android:centerX=\"float\"\n        android:centerY=\"float\"\n        android:centerColor=\"integer\"\n        android:endColor=\"color\"\n        android:gradientRadius=\"integer\"\n        android:startColor=\"color\"\n        android:type=[\"linear\" | \"radial\" | \"sweep\"]\n        android:useLevel=[\"true\" | \"false\"] />\n    <padding\n        android:left=\"integer\"\n        android:top=\"integer\"\n        android:right=\"integer\"\n        android:bottom=\"integer\" />\n    <size\n        android:width=\"integer\"\n        android:height=\"integer\" />\n    <solid\n        android:color=\"color\" />\n    <stroke\n        android:width=\"integer\"\n        android:color=\"color\"\n        android:dashWidth=\"integer\"\n        android:dashGap=\"integer\" />\n</shape>\n```\n\n<span class=\"li-icon\"><code class=\"codetainer\">corners : </code>둥근모서리</span>\n<span class=\"li-icon\"><code class=\"codetainer\">gradient : </code>그라데이션 색상</span>\n<span class=\"li-icon\"><code class=\"codetainer\">padding : </code>shape가 아닌 view 요소에 적용할 패딩</span>\n<span class=\"li-icon\"><code class=\"codetainer\">size : </code>shape 크기</span>\n<span class=\"li-icon\"><code class=\"codetainer\">solid : </code>채우기 색상</span>\n<span class=\"li-icon\"><code class=\"codetainer\">stroke : </code>선 속성</span>\n\n# 실전예제\n\n1. 둥근모서리+그림자+투명배경 드로어블 생성하기\n\nres/drawable/round_border.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\" >\n    <item>\n        <shape android:shape=\"rectangle\" >\n            <solid android:color=\"@android:color/darker_gray\" />\n        </shape>\n    </item>\n    <item\n        android:bottom=\"-2dp\"\n        android:left=\"2dp\"\n        android:right=\"2dp\"\n        android:top=\"2dp\">\n        <shape android:shape=\"rectangle\" >\n            <stroke\n                android:width=\"0.75dp\"\n                android:color=\"#f5f5f5\" />\n            <corners\n                android:topLeftRadius=\"10dp\"\n                android:topRightRadius=\"10dp\"/>\n            <solid android:color=\"#3cffffff\" />\n        </shape>\n    </item>\n</layer-list>\n```\n\n2. round_border를 LinearLayout의 배경으로 적용하기\n\n```xml\n<LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"10dp\"\n        android:background=\"@drawable/round_border\">\n</LinearLayout>\n```\n"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"9aacac8dd60a2171340862343e0ee39877fa3df9","text":"# [안드로이드] 안드로이드 MVVM에 대해 알아보자1\n\n- Title : [안드로이드] 안드로이드 MVVM에 대해 알아보자1\n- Date : 2019-01-07\n- Category: Android\n\nCoding in Flow의 Room + ViewModel + LiveData + RecyclerView (MVVM) 튜토리얼을 정리했습니다.\n\n# 파일 구성\n\n- MainActivity.java\n- Note.java\n- NoteAdapter.java\n- NoteDao.interface\n- NoteDatabase.java\n- NoteRepository.java\n- NoteViewModel.java\n\n# MVVM - VIEW와 VIEWMODEL\n\n<span class=\"li-icon\">MainActivity.class : 앱의 시작점으로 RecyclerView 설정 및 ViewModel 생성하는 부분 </span>\n<span class=\"li-icon\">NoteViewModel.class : UI 컴포넌트와 UI 데이터의 분리</span>\n<span class=\"li-icon\">NoteAdapter.class : 리사이클러뷰 어댑터</span>\n<span class=\"li-icon\">NoteRepository.class : 저장소, 도메인과 모델 사이의 중간체 역할?</span>\n\n## 1. 리사이클러뷰 구현\n\n```java\nRecyclerView recyclerView = findViewById(R.id.recycler_view);\nrecyclerView.setLayoutManager(new LinearLayoutManager(this));   // 1)\nrecyclerView.setHasFixedSize(true); // 2)\n\nfinal NoteAdapter adapter = new NoteAdapter();  // 3)\nrecyclerView.setAdapter(adapter);   // 3-1)\n```\n\n1. LayoutManager 클래스, 아이템을 어떻게 배치할 것인가를 결정한다.  \n   <span class=\"clr-grey\">LinearLayoutManager 클래스 : 가로/세로 형태로 아이템을 배열한다.</span>\n\n2. 각 아이템의 변화가 리사이클러 뷰의 전체 크기에 영향을 끼치지 않는다면 true를 사용한다.\n\n3. 데이터를 리사이클러뷰에 연결해 줄 어댑터 객체 생성\n\n3-1) 3)에서 생성한 어댑터 객체를 리사이클러뷰에 붙인다.\n\n<span id=\"viewModel\"></span>\n\n## 2. ViewModel과 LiveData\n\n[뷰모델 개념 익히러가기](/android/android-viewModel/).\n\n```java\nnoteViewModel = ViewModelProviders.of(this).get(NoteViewModel.class);\n```\n\n**ViewModel 객체 요청**  \n보통 ViewModel 생성 요청은 <code class=\"codetainer\">onCreate()</code> 메서드에서 이루어지며, **ViewModelProvider 클래스**를 통해서 ViewModel 객체를 생성한다.\nViewModelProviders 클래스의 <code class=\"codetainer\">of(this)</code> 를 통해 this(UI 컨트롤러) 스코프를 가진 ViewModelProvider 인스턴스가 반환된다.\n리턴된 ViewModelProvider 객체의 메서드 <code class=\"codetainer\">get(NoteViewModel.class)</code> 를 통해 NoteViewModel 인스턴스가 생성된다.\n\n<span class=\"clr-grey\">**NOTE:** get()은 이미 ViewModel 객체가 생성되었을 경우, 그 객체를 리턴한다. </span>\n\n<span id=\"LiveData\"></span>\n**LiveData 사용**  \n[LiveData 개념 익히러가기](/android/android-LiveData/).\n\nnoteViewModel.java\n\n```java\npublic class NoteViewModel extends AndroidViewModel {\n    // ...생략\n    private LiveData<List<Note>> allNotes;\n\n    public NoteViewModel(@NonNull Application application) {\n        super(application);\n        repository = new NoteRepository(application);\n        allNotes = repository.getAllNotes();\n    }\n\n    // ...생략\n    public LiveData<List<Note>> getAllNotes() {\n        return allNotes;\n    }\n}\n```\n\nLiveData는 보통 ViewModel 내에서 함께 쓰인다.\n\nMainActivity.java\n\n```java\nnoteViewModel.getAllNotes().observe(this, new Observer<List<Note>>() {  // 1) LifeCycleOwner, Observer\n    @Override\n    public void onChanged(@Nullable List<Note> notes) { // 2)\n        // update RecyclerView\n        // Toast.makeText(MainActivity.this, \"onchanged\", Toast.LENGTH_SHORT).show();\n        adapter.setNotes(notes);\n    }\n});\n```\n\n1. <code class=\"codetainer\">noteViewModel.getAllNotes()</code>를 통해 LiveData를 리턴받고 <code class=\"codetainer\">observe()</code> 메서드를 통해 Observer를 붙여 감지를 시작한다.\n   <span class=\"clr-grey\">보통 Observer는 프래그먼트나 액티비티 같은 UI 컨트롤러에서 만든다.</span>  \n   <span class=\"clr-note\">LiveData의 data가 변경될 때 LifeCycleOwner가 활성화 되어있는 한 등록된 모든 Observer들 에게 이벤트를 보낸다.</span>\n\n2. Observer는 <code class=\"codetainer\">onChanged()</code> 메서드를 반드시 오버라이드해야하며, <code class=\"codetainer\">onChanged()</code> 메서드에서 UI 업데이트를 한다.\n\n# MVVM - MODEL\n\n<span class=\"li-icon\">NoteDatabase.class</span>\n<span class=\"li-icon\">NoteDao.interface</span>\n<span class=\"li-icon\">Note.class</span>\n\nRoom은 SQLite 추상계층을 감싸고 있으며, 쉽게 데이터베이스에 접근하여 SQLite를 자유롭게 사용할 수 있다. Room에는 세가지 주요한 컴포넌트가 있다.\n\n## 1. Database (NoteDatabase.class)\n\n데이터베이스 홀더를 포함하고, 관계형 데이터베이스에 접근할 수 있는 액세스 포인트를 제공한다.\n\n```java\n@Database(entities = {Note.class}, version = 1, exportSchema = false)   // 1)\npublic abstract class NoteDatabase extends RoomDatabase {\n\n    private static NoteDatabase instance;\n\n    public abstract NoteDao noteDao();  // 3)\n\n    public static synchronized NoteDatabase getInstance(Context context) {\n        if (instance == null) {\n            instance = Room.databaseBuilder(context.getApplicationContext(),    // 4)\n                    NoteDatabase.class, \"note_database\")\n                    .fallbackToDestructiveMigration()\n                    .addCallback(roomCallback)\n                    .build();\n        }\n        return instance;\n    }\n    // ..생략\n}\n```\n\n1. @Database 애노테이션을 클래스에 달아야하며, 데이터베이스와 관련된 Entity들은 애노테이션 인자값으로 포함해야한다.\n2. RoomDatabase를 상속한 abstract class여야 한다.\n3. abstract method 포함해야하는데, 이 메소드에는 인자가 0개이고 reture되는 클래스가 @Dao 애노테이션을 달고 있어야한다.\n4. 런타임때에는 Room.databaseBuilder() 또는 Room.inMemoryDatabaseBuilder()를 통해 Database의 객체를 얻어 낼 수 있다.\n\n<span class=\"clr-grey\">**Note:** RoomDatabase 객체를 인스턴스화 하는 비용은 매우 크므로 인스턴스를 얻는 작업을 싱글톤패턴으로 만드는 게 좋다.</span>\n\n```java\n@Database(entities = {Note.class}, version = 1, exportSchema = false)   // 1)\npublic abstract class NoteDatabase extends RoomDatabase {\n    private static NoteDatabase instance;\n    public abstract NoteDao noteDao();\n    // ..생략\n\n    private static RoomDatabase.Callback roomCallback = new RoomDatabase.Callback() {\n\n        // 데이터베이스가 처음 생성될 때 호출됨, 모든 테이블이 생성된 후 호출됨.\n        @Override\n        public void onCreate(@NonNull SupportSQLiteDatabase db) {\n            super.onCreate(db);\n            new PopulateDbAsyncTask(instance).execute(); // AsyncTask 실행\n        }\n    };\n\n    private static class PopulateDbAsyncTask extends AsyncTask<Void, Void, Void> {\n        private NoteDao noteDao;\n\n        private PopulateDbAsyncTask(NoteDatabase db) {\n            noteDao = db.noteDao();\n        }\n\n        @Override\n        protected Void doInBackground(Void... voids) {\n            noteDao.insert(new Note(\"Title 1\", \"Description 1\", 1));\n            noteDao.insert(new Note(\"Title 2\", \"Description 2\", 2));\n            noteDao.insert(new Note(\"Title 3\", \"Description 3\", 3));\n\n            return null;\n        }\n    }\n}\n```\n\n**AsyncTask클래스**  \n비즈니스 로직과 UI 컴포넌트 조작이 동시에 일어나야 할 때 유용하며, 비교적 오래 걸리지 않는 작업에 적합하다. 또한, task 캔슬이 용이하다.\n\nAsyncTask <Params, Progress, Result> 제너릭 타입\n<span class=\"li-icon\">Params: doInBackground 파라미타 타입이며, execute 메소드의 인자 값이 된다.</span>\n<span class=\"li-icon\">Progress: doInBakcgroud 작업 시 진행 단위의 타입으로 onProgressUpdate 파라미터의 타입이다.</span>\n<span class=\"li-icon\">doInBackground 리턴값으로 onPostExecute 파라미터 타입이다.</span>\n\n<span class=\"clr-grey\">**제네릭스(Generics):** 객체 생성시 타입을 선언하므로 캐스팅할 필요가 없으며, 다른 타입을 할당할 경우 컴파일 단계에서 예외처리가 된다. <T>는 객체(Object) 타입이다.</span>\n\n## 2. Entity (Note.class)\n\nEntity를 사용하여 데이터 구조를 정의하고, 데이터베이스 테이블을 표현한다.\n\n```java\n@Entity(tableName = \"note_table\")   // tableName 속성 : 테이블명을 Note로 사용하고 싶지 않을 때\npublic class Note {\n\n    @PrimaryKey(autoGenerate = true)    // 기본키 정의 필수\n    private int id;\n    @ColumnInfo(name = \"Notetitle\") // name 속성 : 필드명을 다르게 지정하고 싶을 때\n    private String title;\n    private String description;\n    private int priority;\n    @Ignore // 데이터베이스에서 칼럼으로 생성되기를 원치 않을 때\n    Bitmap picture;\n\n    public Note(String title, String description, int priority) {\n        this.title = title;\n        this.description = description;\n        this.priority = priority;\n    }\n\n    // ..생략 (반드시, getter setter 필요)\n}\n```\n\n## 3. DAO (NoteDao.interface)\n\n데이터베이스의 데이터에 접근하기 위해서는 DAO가 필요하다. 직접적인 쿼리를 작성하는 대신 DAO 클래스를 사용하여 데이터베이스에 추상적으로 접근한다. <span class=\"clr-note\">DAO는 interface나 abstract class가 되야한다.</span>\n\n```java\n@Dao\npublic interface NoteDao {\n\n    @Insert\n    void insert(Note note);\n\n    @Update\n    void update(Note note);\n\n    @Delete\n    void delete(Note note);\n\n    @Query(\"DELETE FROM note_table\")\n    void deleteAllNotes();\n\n    @Query(\"SELECT * FROM note_table ORDER BY priority DESC\")\n    LiveData<List<Note>> getAllNotes();\n}\n```\n"}}}},"pageContext":{"id":"92b42dd986f3a755361f0a2640d33d0bb9c70fd3","previousPostId":"57a9a023880800c47fc8fb09eb9ea97232df6cad","nextPostId":"9aacac8dd60a2171340862343e0ee39877fa3df9"}},"staticQueryHashes":["2685952063","2841359383"]}