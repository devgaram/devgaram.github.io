{"componentChunkName":"component---src-templates-blog-post-js","path":"/26d7550b6695cd1acf2bd2bbf374a7a509c021f5","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"26d7550b6695cd1acf2bd2bbf374a7a509c021f5","text":"# Flux 패턴\n\n- Title : Flux와 MVC\n- Date : 2020-12-07\n- Category : 프론트\n\n## 페이스북은 Flux 패턴을 왜 만들었을까?\n\n페이스북은 기존의 MVC 패턴이 프로젝트 규모가 커질수록 빠른 속도로 복잡해진다고 결론 내렸다. 프로젝트의 구조가 복잡하면 **코드 예측이 어려워**지고, **새로운 개발자가 적응하는 데 많은 시간**이 필요해지고, **테스트가 어려워**진다. MVC 패턴은 아래 그림처럼 모델-뷰가 양방향 통신이 가능하다. 이는 두 개 이상의 모델을 순차적으로 업데이트 하는 기능을 구현할 때 모델 간의 의존성을 높이는 문제를 만들고 종종 데이터 흐름을 꼬이게 한다.\n\n> 예시) 유저가 뷰에서 액션(키보드, 마우스 등)을 하여 컨트롤러에게 명령이 전달되면 컨트롤러는 A모델을 업데이트 하고 B모델도 업데이트 한다. B 모델의 업데이트가 또 다른 C뷰에 영향을 끼치고 C뷰는 컨트롤러를 거쳐 D모델의 상태를 변경시킬 수 있다. **양방향 통신은 이러한 연쇄적인 트리거를 만들어 낼 수 있다.**\n\n![Flux%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%20aad6e4d02e6a4aa8a650a32ae0d2c9d1/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Front/images/2020-12-07-img/Untitled.png)\n\n## Flux 패턴이란?\n\nFlux에서는 항상 데이터가 **단방향**으로 흐른다. 언제나 디스패쳐 → 스토어 → 뷰 → 액션 → 디스패쳐 .. 로 흐른다.\n데이터를 뷰에서 직접 수정할 수 없고 반드시 액션을 통해서만 수정이 일어나기 때문에 양방향보다 **데이터의 흐름을 예측하기 쉬워진다**. \n\n![Flux%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%20aad6e4d02e6a4aa8a650a32ae0d2c9d1/Untitled%201.png](https://raw.githubusercontent.com/devgaram/TIL/master/Front/images/2020-12-07-img/Untitled%201.png)\n\n![Flux%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%20aad6e4d02e6a4aa8a650a32ae0d2c9d1/Untitled%202.png](https://raw.githubusercontent.com/devgaram/TIL/master/Front/images/2020-12-07-img/Untitled%202.png)\n\n## Flux 패턴의 구성요소\n\n### **단일** **Dispatcher**\n\n모든 데이터 흐름을 관리하는 **허브(교통정리)** 역할을 한다. 액션 생성자가 새로운 액션을 디스패처에게 알려주면 디스패처는 스토어에게 제공받은 콜백 함수를 실행하여 액션을 스토어에게 전달한다. 애플리케이션 규모가 커지게 되면 디스패처의 역할이 더욱 중요해진다. 바로 스토어 간의 의존성을 특정적인 순서로 콜백을 실행하는 것으로 관리하기 때문이다. 스토어는 다른 스토어의 업데이트가 끝날 때까지 기다릴 수 있고 끝나는 순서에 따라 스스로 갱신된다.\n\n### **Stores**\n\n스토어는 애플리케이션의 상태와 로직을 가지고 있다. 스토어는 단순히 ORM 스타일의 객체 컬렉션(DB 레코드)을 관리하는 것을 넘어 개별적인 도메인에서 상태를 관리한다. 스토어는 자신을 디스패처에 등록하고 콜백을 제공한다. 콜백은 액션 타입을 파라미터로 받고 `switch`문을 사용하여 액션 타입에 따라 스토어 내부 메소드에 연결될 수 있는 적절한 훅을 제공한다. \n\n### **Views와 Controller-Views**\n\n**컨트롤러-뷰란?**\n\n뷰들의 최상위 레이어로 스토어의 데이터를 자식 뷰에게 전달하는 역할을 한다.\n\n1. 스토어가 상태가 변경되었다고 이벤트를 보내면 컨트롤러-뷰는 스토어의 `public getter` 메소드를 통해 필요한 데이터를 요청한다.\n2. `setState()` 또는 `forceUpdate()`를 호출한다.\n3. 2번 호출은 자동으로 `render()` 와 하위 모든 자식 뷰의 `render()` 메소드를 실행시킨다.\n\n컨트롤러-뷰가 전체 스토어 상태를 단일 객체로 만들어 하위 뷰들에 전달하는 덕분에 자식 뷰들은 데이터에 따라 UI를 렌더링하는 순수 함수로 유지될 수 있다. \n\n**레이어 중간에 컨트롤러-뷰를 추가할 때 고려해야할 점**\n\n때로는 레이어 중간에 컨트롤러-뷰를 넣어 특정 도메인과 관계된 뷰들을 감싸서 독립적으로 만들 수 있다.(일종의 캡슐화) 이 때 데이터의 흐름의 **단순함**을 유지해야 한다. 캡슐화 된 단순한 컴포넌트와 여러 방향으로 흐르는 데이터의 복잡도의 균형을 잘 판단해서 컨트롤러-뷰를 만들어야 한다. 자칫하면 다른 컨트롤러-뷰에 의해 리액트`render()` 메소드가 반복적으로 실행되어 디버깅을 어렵게 할 수 있다.\n\n참고\n\n[https://taegon.kim/archives/5288](https://taegon.kim/archives/5288)\n\n[https://haruair.github.io/flux/docs/overview.html#content](https://haruair.github.io/flux/docs/overview.html#content)"}}},"previous":{"repository":{"post":null}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"c09ede76adcb853a1a1204f48d2da94febede56e","text":"# CSS Media Query\n\n- Title : CSS Media Query\n- Date : 2020-09-19\n- Category : 프론트\n\n\n단말기의 유형(출력물 vs 화면)과 어떤 특성이나 수치(화면 해상도, 뷰포트 너비 등)에 따라 웹 사이트나 앱의 스타일을 수정할 때 유용하다.\n\n## 기본 구문\n\n```css\n//\n@media media-type and (media-feature-rule) {\n  /* CSS rules go here */\n}\n```\n\n### media-type\n\n선택사항으로 기본값은 all\n\n- `all`\n- `print` 인쇄 결과물 및 출력 미리보기 화면에 표시 중인 문서\n- `screen` 화면\n- `speech` 음성 장치\n\n### 논리 연산자\n\n- `and`\n- `not` 쿼리가 거짓일때만 참을 반환\n- `only` 전체 쿼리가 일치할 때만 스타일 적용\n- `,(쉼표)` or 연산자처럼 동작 하나만 true면 true\n\n## 예제\n\n### 고밀도 디스플레이를 위한 이미지 다루는 방법\n\n고밀도 디스플레이 기기가 늘어나면서 웹에서도 고 해상도 이미지의 수요가 생겼다. \n\n`resolution` 은 고밀도 디스플레이를 위해 고안된 css문법으로, IE9를 포함한 브라우저 대부분이 지원합니다. 문법은 (min/max)-resolution: 값으로 사용되며, 기본 단위는 dppx입니다.\n* 출력 장치의 픽셀 밀도\n* 오페라미니와 IE는 dppx를 지원하지 않기 때문에 적당한 dpi 사용\n* safari는 min/max-device-pixel-ratio 문법만 지원\n\n```css\n@mixin hidpi() {\n  @media (-webkit-min-device-pixel-ratio: 1.5), (min-resolution: 144dpi) {\n    @content;\n  }\n}\n\n// 사용\n@include hidpi {\n\tbackground-image: url(고해상도 이미지2x.png\");\n}\n```\n\n[https://blog.hanlee.io/2018/high-density-display-and-images/](https://blog.hanlee.io/2018/high-density-display-and-images/)\n\n### 부트스트랩에서 미디어쿼리 어떻게 사용할까?\n\n```css\n@include media-breakpoint-up(sm) { ... }\n@include media-breakpoint-up(md) { ... }\n@include media-breakpoint-up(lg) { ... }\n@include media-breakpoint-up(xl) { ... }\n\n// 사용\n@include media-breakpoint-up(sm) {\n  .custom-class {\n    display: block;\n  }\n}\n\n@mixin media-breakpoint-up($name, $breakpoints: $grid-breakpoints) {\n  $min: breakpoint-min($name, $breakpoints);\n  @if $min {\n    @media (min-width: $min) {\n      @content;\n    }\n  } @else {\n    @content;\n  }\n}\n\n\t@media (min-width: 576px) { ... }\n\t\n\t// Medium devices (tablets, 768px and up)\n\t@media (min-width: 768px) { ... }\n\t\n\t// Large devices (desktops, 992px and up)\n\t@media (min-width: 992px) { ... }\n\t\n\t// Extra large devices (large desktops, 1200px and up)\n\t@media (min-width: 1200px) { ... }\n\n```"}}}},"pageContext":{"id":"26d7550b6695cd1acf2bd2bbf374a7a509c021f5","previousPostId":null,"nextPostId":"c09ede76adcb853a1a1204f48d2da94febede56e"}},"staticQueryHashes":["2841359383"]}