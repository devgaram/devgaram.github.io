{"componentChunkName":"component---src-templates-blog-post-js","path":"/e1d231567cddc9de8b345729cc86853dff9718ce","result":{"data":{"site":{"siteMetadata":{"title":"보노보노의 평화로운 개발 이야기"}},"current":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"e1d231567cddc9de8b345729cc86853dff9718ce","text":"# DOM API\n\n- Title : DOM API\n- Date : 2020-09-05\n- Category : 프론트\n\n# DOM(Document Object Model)\n\n- 문서 객체 모델은 HTML 또는 XML과 상호작용을 위한 일종의 API\n- 브라우저에 로드 되며 DOM tree 형태로 문서를 만듬 (노드로 트리를 구성, element, text string, coment)\n- 스크립트 또는 프로그래밍 언어를 웹 페이지에서 사용할 수 있게 연결 시킴\n- 자바 스크립트를 이용해 DOM을 수정할 수 있음\n- 웹 페이지를 객체 지향적으로 표현한 것\n- Dom Tree: 트리 구조 형태의 노드들이 문서를 만듬\n\n    ![DOM%20API%2045dcb9dfa98b4ca7969268d9de5e8451/Untitled.png](https://raw.githubusercontent.com/devgaram/TIL/master/Front/images/2020-09-05-img/Untitled.png)\n\n    ![DOM%20API%2045dcb9dfa98b4ca7969268d9de5e8451/Untitled%201.png](https://raw.githubusercontent.com/devgaram/TIL/master/Front/images/2020-09-05-img/Untitled1.png)\n\n    예시)\n\n    HTMLElement ← HTMLMediaElement ← HMLTAudioElement ← <audio>\n\n    HTMLElement ← HTMLMediaElement ← HMLTVideoElement ← <video>\n\n# DOM API\n\n[Web API](https://developer.mozilla.org/ko/docs/Web/API)\n\n- DOM의 각 노드와 상호작용을 위한 인터페이스\n- 노드 생성, 이동, 수정\n- 노드에 이벤트 리스너 추가\n- 폼 데이터 조작\n- `<canvas>`, `2D 이미지`와 상호작용\n- media 관리 `<audio>` `<video>`\n- 웹페이지 컨텐츠 `드래그 앤 드랍`\n- 브라우저의 세션 기록에 접근 `History API`\n- `Web Components`, `Web Storage`, `Web Workers`, `WebSocket`, and `Server-sent events`."}}},"previous":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"c09ede76adcb853a1a1204f48d2da94febede56e","text":"# CSS Media Query\n\n- Title : CSS Media Query\n- Date : 2020-09-19\n- Category : 프론트\n\n\n단말기의 유형(출력물 vs 화면)과 어떤 특성이나 수치(화면 해상도, 뷰포트 너비 등)에 따라 웹 사이트나 앱의 스타일을 수정할 때 유용하다.\n\n## 기본 구문\n\n```css\n//\n@media media-type and (media-feature-rule) {\n  /* CSS rules go here */\n}\n```\n\n### media-type\n\n선택사항으로 기본값은 all\n\n- `all`\n- `print` 인쇄 결과물 및 출력 미리보기 화면에 표시 중인 문서\n- `screen` 화면\n- `speech` 음성 장치\n\n### 논리 연산자\n\n- `and`\n- `not` 쿼리가 거짓일때만 참을 반환\n- `only` 전체 쿼리가 일치할 때만 스타일 적용\n- `,(쉼표)` or 연산자처럼 동작 하나만 true면 true\n\n## 예제\n\n### 고밀도 디스플레이를 위한 이미지 다루는 방법\n\n고밀도 디스플레이 기기가 늘어나면서 웹에서도 고 해상도 이미지의 수요가 생겼다. \n\n`resolution` 은 고밀도 디스플레이를 위해 고안된 css문법으로, IE9를 포함한 브라우저 대부분이 지원합니다. 문법은 (min/max)-resolution: 값으로 사용되며, 기본 단위는 dppx입니다.\n* 출력 장치의 픽셀 밀도\n* 오페라미니와 IE는 dppx를 지원하지 않기 때문에 적당한 dpi 사용\n* safari는 min/max-device-pixel-ratio 문법만 지원\n\n```css\n@mixin hidpi() {\n  @media (-webkit-min-device-pixel-ratio: 1.5), (min-resolution: 144dpi) {\n    @content;\n  }\n}\n\n// 사용\n@include hidpi {\n\tbackground-image: url(고해상도 이미지2x.png\");\n}\n```\n\n[https://blog.hanlee.io/2018/high-density-display-and-images/](https://blog.hanlee.io/2018/high-density-display-and-images/)\n\n### 부트스트랩에서 미디어쿼리 어떻게 사용할까?\n\n```css\n@include media-breakpoint-up(sm) { ... }\n@include media-breakpoint-up(md) { ... }\n@include media-breakpoint-up(lg) { ... }\n@include media-breakpoint-up(xl) { ... }\n\n// 사용\n@include media-breakpoint-up(sm) {\n  .custom-class {\n    display: block;\n  }\n}\n\n@mixin media-breakpoint-up($name, $breakpoints: $grid-breakpoints) {\n  $min: breakpoint-min($name, $breakpoints);\n  @if $min {\n    @media (min-width: $min) {\n      @content;\n    }\n  } @else {\n    @content;\n  }\n}\n\n\t@media (min-width: 576px) { ... }\n\t\n\t// Medium devices (tablets, 768px and up)\n\t@media (min-width: 768px) { ... }\n\t\n\t// Large devices (desktops, 992px and up)\n\t@media (min-width: 992px) { ... }\n\t\n\t// Extra large devices (large desktops, 1200px and up)\n\t@media (min-width: 1200px) { ... }\n\n```"}}},"next":{"repository":{"post":{"__typename":"GitHub_Blob","oid":"d91ddb038b5151998966588eea19cf150c69cd32","text":"# 함수 컴포넌트에서 ref를 사용하려면?\n\n- Title : 함수 컴포넌트에서 ref를 사용하려면?\n- Date : 2020-09-02\n- Category: React\n\n# Key Point 💥\n\n부모 컴포넌트에서 `useRef` 훅으로 생성한 ref를 자식 컴포넌트에 전달하고 싶다면? **forwardRef**를 사용하자!\n함수 컴포넌트에는 인스턴스가 없기 때문에 함수 컴포넌트에 ref 어트리뷰트를 사용할 수 없다.\n\n함수 컴포넌트에 ref를 사용할 수 있게 하려면!\n\n- [forwardRef](https://ko.reactjs.org/docs/forwarding-refs.html) 또는 forwardRef + [useImperativeHandle](https://ko.reactjs.org/docs/hooks-reference.html#useimperativehandle) 를 사용\n- 클래스 컴포넌트로 변경\n\n단, DOM 엘리먼트나 클래스 컴포넌트의 인스턴스에 접근하기 위해 `ref` ****어트리뷰트를 함수 컴포넌트에서 사용할 수 있다.\n\n# 삽질기 ⛏️\n\n현재의 Copy 컴포넌트에서 Overlay의 target 속성이 Copy 컴포넌트 내부에서 useRef로 생성한 ref 값을 전달한다. 내가 구현하고 싶었던 건 부모 컴포넌트에서 ref를 받아서 부모 컴포넌트의 특정 DOM 위에 overlay를 보여주는 거다. 부모 컴포넌트에서 useRef로 만든 값을 props로 전달했지만 Copy 자체가 동작하지 않았다. 휴 계속 삽질을 했지만 답은 공식 문서에 있었다. 문서를 열심히 읽자!! 😆\n\n수정 전 Copy.jsx\n\n```jsx\nimport React, { useState, useEffect, useRef } from 'react';\nimport { CopyToClipboard } from 'react-copy-to-clipboard';\nimport { Overlay, Tooltip } from 'react-bootstrap';\n\nconst Copy = ({ children, text, placement, copiedMsg }) => {\n  const [isShowCopied, setIsShowCopied] = useState(false);\n  const target = useRef(null);\n\n  useEffect(() => {\n    if (!isShowCopied) return;\n\n    setTimeout(() => {\n      setIsShowCopied(false);\n    }, 2000);\n  }, [isShowCopied]);\n\n  return (\n    <>\n      <CopyToClipboard\n        text={text}\n        onCopy={() => {\n          setIsShowCopied(true);\n        }}\n      >\n        {React.cloneElement(children, { ref: target })}\n      </CopyToClipboard>\n      <Overlay target={target.current} show={isShowCopied} placement={placement}>\n        <Tooltip>{copiedMsg}</Tooltip>\n      </Overlay>\n    </>\n  );\n};\n\nexport default Copy;\n```\n\n수정 후 Copy.jsx\n\n```jsx\nimport React, { useState, useEffect, useRef, forwardRef } from 'react';\nimport { CopyToClipboard } from 'react-copy-to-clipboard';\nimport { Overlay, Tooltip } from 'react-bootstrap';\n\nconst Copy = forwardRef(({ children, text, placement, copiedMsg }, ref) => {\n  const [isShowCopied, setIsShowCopied] = useState(false);\n  const target = useRef(null);\n\n  useEffect(() => {\n    if (!isShowCopied) return;\n\n    setTimeout(() => {\n      setIsShowCopied(false);\n    }, 2000);\n  }, [isShowCopied]);\n\n  return (\n    <>\n      <CopyToClipboard\n        text={text}\n        onCopy={() => {\n          setIsShowCopied(true);\n        }}\n      >\n        {React.cloneElement(children, { ref: target })}\n      </CopyToClipboard>\n      <Overlay target={(ref && ref.current) || target.current} show={isShowCopied} placement={placement}>\n        <Tooltip>{copiedMsg}</Tooltip>\n      </Overlay>\n    </>\n  );\n});\n\nexport default Copy;\n```"}}}},"pageContext":{"id":"e1d231567cddc9de8b345729cc86853dff9718ce","previousPostId":"c09ede76adcb853a1a1204f48d2da94febede56e","nextPostId":"d91ddb038b5151998966588eea19cf150c69cd32"}},"staticQueryHashes":["2685952063","2841359383"]}